# --- T2-COPYRIGHT-NOTE-BEGIN ---
# T2 SDE: package/*/pulseaudio/hotfix-alsa-ucm.patch
# Copyright (C) 2024 The T2 SDE Project
# 
# This Copyright note is generated by scripts/Create-CopyPatch,
# more information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License version 2 as used by the T2 SDE.
# --- T2-COPYRIGHT-NOTE-END ---

--- pulseaudio-17.0/src/modules/alsa/alsa-ucm.c.vanilla
+++ pulseaudio-17.0/src/modules/alsa/alsa-ucm.c
@@ -624,6 +624,11 @@
     char *devstatus;
     long status = 0;
 
+    if (!ucm->active_verb) {
+        pa_log_error("Failed to get status for UCM device %s: no UCM verb set", dev_name);
+        return -1;
+    }
+
     devstatus = pa_sprintf_malloc("_devstatus/%s", dev_name);
     if (snd_use_case_geti(ucm->ucm_mgr, devstatus, &status) < 0) {
         pa_log_debug("Failed to get status for UCM device %s", dev_name);
@@ -637,6 +642,11 @@
 static int ucm_device_disable(pa_alsa_ucm_config *ucm, pa_alsa_ucm_device *dev) {
     const char *dev_name = pa_proplist_gets(dev->proplist, PA_ALSA_PROP_UCM_NAME);
 
+    if (!ucm->active_verb) {
+        pa_log_error("Failed to disable UCM device %s: no UCM verb set", dev_name);
+        return -1;
+    }
+
     /* If any of dev's conflicting devices is enabled, trying to disable
      * dev gives an error despite the fact that it's already disabled.
      * Check that dev is enabled to avoid this error. */
@@ -657,6 +667,11 @@
 static int ucm_device_enable(pa_alsa_ucm_config *ucm, pa_alsa_ucm_device *dev) {
     const char *dev_name = pa_proplist_gets(dev->proplist, PA_ALSA_PROP_UCM_NAME);
 
+    if (!ucm->active_verb) {
+        pa_log_error("Failed to enable UCM device %s: no UCM verb set", dev_name);
+        return -1;
+    }
+
     /* We don't need to enable devices that are already enabled */
     if (ucm_device_status(ucm, dev) > 0) {
         pa_log_debug("UCM device %s is already enabled", dev_name);
@@ -707,6 +722,11 @@
     char *modstatus;
     long status = 0;
 
+    if (!ucm->active_verb) {
+        pa_log_error("Failed to get status for UCM modifier %s: no UCM verb set", mod_name);
+        return -1;
+    }
+
     modstatus = pa_sprintf_malloc("_modstatus/%s", mod_name);
     if (snd_use_case_geti(ucm->ucm_mgr, modstatus, &status) < 0) {
         pa_log_debug("Failed to get status for UCM modifier %s", mod_name);
@@ -720,6 +740,11 @@
 static int ucm_modifier_disable(pa_alsa_ucm_config *ucm, pa_alsa_ucm_modifier *mod) {
     const char *mod_name = pa_proplist_gets(mod->proplist, PA_ALSA_PROP_UCM_NAME);
 
+    if (!ucm->active_verb) {
+        pa_log_error("Failed to disable UCM modifier %s: no UCM verb set", mod_name);
+        return -1;
+    }
+
     /* We don't need to disable modifiers that are already disabled */
     if (ucm_modifier_status(ucm, mod) == 0) {
         pa_log_debug("UCM modifier %s is already disabled", mod_name);
@@ -738,6 +763,11 @@
 static int ucm_modifier_enable(pa_alsa_ucm_config *ucm, pa_alsa_ucm_modifier *mod) {
     const char *mod_name = pa_proplist_gets(mod->proplist, PA_ALSA_PROP_UCM_NAME);
 
+    if (!ucm->active_verb) {
+        pa_log_error("Failed to disable UCM modifier %s: no UCM verb set", mod_name);
+        return -1;
+    }
+
     /* We don't need to enable modifiers that are already enabled */
     if (ucm_modifier_status(ucm, mod) > 0) {
         pa_log_debug("UCM modifier %s is already enabled", mod_name);
@@ -1551,6 +1581,7 @@
     pa_alsa_ucm_config *ucm;
     pa_alsa_ucm_device *dev;
     pa_alsa_ucm_port_data *data;
+    const char *dev_name, *ucm_dev_name;
 
     pa_assert(context && context->ucm);
 
@@ -1558,8 +1589,18 @@
     pa_assert(ucm->ucm_mgr);
 
     data = PA_DEVICE_PORT_DATA(port);
-    dev = context->ucm_device;
-    pa_assert(dev == data->device);
+    dev = data->device;
+    pa_assert(dev);
+
+    if (context->ucm_device) {
+        dev_name = pa_proplist_gets(dev->proplist, PA_ALSA_PROP_UCM_NAME);
+        ucm_dev_name = pa_proplist_gets(context->ucm_device->proplist, PA_ALSA_PROP_UCM_NAME);
+        if (!pa_streq(dev_name, ucm_dev_name)) {
+            pa_log_error("Failed to set port %s with wrong UCM context: %s", dev_name, ucm_dev_name);
+            return -1;
+        }
+    }
+
 
     return ucm_device_enable(ucm, dev);
 }
