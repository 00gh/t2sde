# --- T2-COPYRIGHT-NOTE-BEGIN ---
# T2 SDE: package/*/dosfstools/f414e322da17c628a69ef61409b06b8f03e5a17c.patch
# Copyright (C) 2022 The T2 SDE Project
# 
# This Copyright note is generated by scripts/Create-CopyPatch,
# more information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License version 2 as used by the T2 SDE.
# --- T2-COPYRIGHT-NOTE-END ---

From f414e322da17c628a69ef61409b06b8f03e5a17c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali.rohar@gmail.com>
Date: Sat, 12 Jun 2021 15:00:14 +0200
Subject: [PATCH] mkfs.fat: Fix upper limit for CHS overflow in MBR

Maximal head value in MBR CHS is 255. But due to bug in MS-DOS which cause
system crash when head value in MBR CHS is 255, it is common to use only
maximal head value 254.

Head value in MBR CHS is zero indexed. So number of disk heads (stored in
FAT boot sector) is maximal head value in MBR CHS + 1.

So fix upper limit for number of heads to 255 which can be still
represented in MBR CHS without MS-DOS crash.
---
 src/mkfs.fat.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/mkfs.fat.c b/src/mkfs.fat.c
index 0ad4eff..37fc8ff 100644
--- a/src/mkfs.fat.c
+++ b/src/mkfs.fat.c
@@ -1095,7 +1095,7 @@ static void setup_tables(void)
         partition[3] = 0;
 
         /* Partition type */
-        if (le16toh(bs.heads) > 254 || le16toh(bs.secs_track) > 63) { /* CHS values are out of range for MBR, use LBA */
+        if (le16toh(bs.heads) > 255 || le16toh(bs.secs_track) > 63) { /* CHS values are out of range for MBR, use LBA */
             if (size_fat != 32)
                 partition[4] = 0x0E; /* BIG FAT16 (LBA) */
             else
@@ -1112,7 +1112,7 @@ static void setup_tables(void)
             partition[4] = 0x0C; /* FAT32 (LBA) */
 
         /* CHS address of the last sector */
-        if (le16toh(bs.heads) > 254 || le16toh(bs.secs_track) > 63 || num_sectors >= le16toh(bs.secs_track) * le16toh(bs.heads) * 1024) {
+        if (le16toh(bs.heads) > 255 || le16toh(bs.secs_track) > 63 || num_sectors >= le16toh(bs.secs_track) * le16toh(bs.heads) * 1024) {
             /* If CHS address is too large use tuple (1023, 254, 63) */
             partition[5] = 254;
             partition[6] = 255;
