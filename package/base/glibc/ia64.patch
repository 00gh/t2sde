# --- T2-COPYRIGHT-NOTE-BEGIN ---
# T2 SDE: package/*/glibc/ia64.patch
# Copyright (C) 2024 The T2 SDE Project
# 
# This Copyright note is generated by scripts/Create-CopyPatch,
# more information can be found in the files COPYING and README.
# 
# This patch file is dual-licensed. It is available under the license the
# patched project is licensed under, as long as it is an OpenSource license
# as defined at http://www.opensource.org/ (e.g. BSD, X11) or under the terms
# of the GNU General Public License version 2 as used by the T2 SDE.
# --- T2-COPYRIGHT-NOTE-END ---

--- b/NEWS
+++ a/NEWS
@@ -80,8 +80,6 @@
   of GNU libc are advised to check whether their build processes can be
   simplified.
 
-* The ia64*-*-linux-gnu configurations are no longer supported.
-
 Changes to build and runtime requirements:
 
 * Building on LoongArch requires at a minimum binutils 2.41 for vector
--- b/README
+++ a/README
@@ -30,6 +30,7 @@
 	hppa-*-linux-gnu
 	i[4567]86-*-linux-gnu
 	x86_64-*-linux-gnu	Can build either x86_64 or x32
+	ia64-*-linux-gnu
 	loongarch64-*-linux-gnu Hardware floating point, LE only.
 	m68k-*-linux-gnu
 	microblaze*-*-linux-gnu
--- b/conform/data/signal.h-data
+++ a/conform/data/signal.h-data
@@ -24,7 +24,8 @@
 
 type ucontext_t
 element ucontext_t {ucontext_t*} uc_link
+// Bug 21634: uc_sigmask has wrong type.
+xfail[ia64-linux]-element ucontext_t sigset_t uc_sigmask
-element ucontext_t sigset_t uc_sigmask
 element ucontext_t stack_t uc_stack
 // Bug 21635: uc_mcontext has wrong type.
 xfail[powerpc32-linux]-element ucontext_t mcontext_t uc_mcontext
@@ -137,7 +138,8 @@
 type ucontext_t
 
 element ucontext_t {ucontext_t*} uc_link
+// Bug 21634: uc_sigmask has wrong type.
+xfail[ia64-linux]-element ucontext_t sigset_t uc_sigmask
-element ucontext_t sigset_t uc_sigmask
 element ucontext_t stack_t uc_stack
 // Bug 21635: uc_mcontext has wrong type.
 xfail[powerpc32-linux]-element ucontext_t mcontext_t uc_mcontext
--- b/conform/data/ucontext.h-data
+++ a/conform/data/ucontext.h-data
@@ -4,7 +4,8 @@
 type ucontext_t
 
 element ucontext_t {ucontext_t*} uc_link
+// Bug 21634: uc_sigmask has wrong type.
+xfail[ia64-linux]-element ucontext_t sigset_t uc_sigmask
-element ucontext_t sigset_t uc_sigmask
 element ucontext_t stack_t uc_stack
 // Bug 21635: uc_mcontext has wrong type.
 xfail[powerpc32-linux]-element ucontext_t mcontext_t uc_mcontext
--- b/elf/cache.c
+++ a/elf/cache.c
@@ -179,6 +179,9 @@
     case FLAG_SPARC_LIB64:
       fputs (",64bit", stdout);
       break;
+    case FLAG_IA64_LIB64:
+      fputs (",IA-64", stdout);
+      break;
     case FLAG_X8664_LIB64:
       fputs (",x86-64", stdout);
       break;
--- b/gmon/tst-sprofil.c
+++ a/gmon/tst-sprofil.c
@@ -34,6 +34,7 @@
     0x00010000		/* Linux elf32/sparc */
 #if __WORDSIZE > 32
     ,
+    0x4000000000000000,	/* Linux elf64/ia64 */
     0x0000000120000000,	/* Linux elf64/alpha */
     0x4000000000001000,	/* elf64/hppa */
     0x0000000100000000	/* Linux elf64/sparc */
--- b/manual/install.texi
+++ a/manual/install.texi
@@ -669,6 +669,8 @@
 
 If you are installing @theglibc{} on @gnulinuxsystems{}, you need to have
 the header files from a 3.2 or newer kernel around for reference.
+(For the ia64 architecture, you need version 3.2.18 or newer because this
+is the first version with support for the @code{accept4} system call.)
 These headers must be installed using @samp{make headers_install}; the
 headers present in the kernel source directory are not suitable for
 direct use by @theglibc{}.  You do not need to use that kernel, just have
--- b/manual/math.texi
+++ a/manual/math.texi
@@ -69,7 +69,7 @@
 provided for @code{_Float32}, @code{_Float64} and @code{_Float32x} on
 all platforms.
 It is also provided for @code{_Float128} and @code{_Float64x} on
+powerpc64le (PowerPC 64-bits little-endian), x86_64, x86, ia64,
-powerpc64le (PowerPC 64-bits little-endian), x86_64, x86,
 aarch64, alpha, loongarch, mips64, riscv, s390 and sparc.
 
 @menu
--- b/math/libm-test-support.h
+++ a/math/libm-test-support.h
@@ -128,7 +128,7 @@
 /* On some architectures, glibc can be built with compilers that do
    not have suitable built-in functions for setting the payload of a
    _Float128 NaN.  */
+#if ((defined __x86_64__ || defined __i386__ || defined __ia64__)	\
-#if ((defined __x86_64__ || defined __i386__)	\
      && !__GNUC_PREREQ (7, 0))
 # define XFAIL_FLOAT128_PAYLOAD (TEST_COND_binary128 ? XFAIL_TEST : 0)
 #else
--- b/nptl/allocatestack.c
+++ a/nptl/allocatestack.c
@@ -150,7 +150,9 @@
 guard_position (void *mem, size_t size, size_t guardsize, struct pthread *pd,
 		size_t pagesize_m1)
 {
+#ifdef NEED_SEPARATE_REGISTER_STACK
+  return mem + (((size - guardsize) / 2) & ~pagesize_m1);
+#elif _STACK_GROWS_DOWN
-#if _STACK_GROWS_DOWN
   return mem;
 #elif _STACK_GROWS_UP
   return (char *) (((uintptr_t) pd - guardsize) & ~pagesize_m1);
@@ -164,7 +166,7 @@
 		  const int prot)
 {
   char *guardend = guard + guardsize;
+#if _STACK_GROWS_DOWN && !defined(NEED_SEPARATE_REGISTER_STACK)
-#if _STACK_GROWS_DOWN
   /* As defined at guard_position, for architectures with downward stack
      the guard page is always at start of the allocated area.  */
   if (__mprotect (guardend, size - guardsize, prot) != 0)
@@ -187,7 +189,7 @@
 {
   uintptr_t sp = (uintptr_t) CURRENT_STACK_FRAME;
   size_t pagesize_m1 = __getpagesize () - 1;
+#if _STACK_GROWS_DOWN && !defined(NEED_SEPARATE_REGISTER_STACK)
-#if _STACK_GROWS_DOWN
   size_t freesize = (sp - (uintptr_t) mem) & ~pagesize_m1;
   assert (freesize < size);
   if (freesize > PTHREAD_STACK_MIN)
@@ -508,7 +510,19 @@
 	{
 	  /* The old guard area is too large.  */
 
+#ifdef NEED_SEPARATE_REGISTER_STACK
+	  char *guard = mem + (((size - guardsize) / 2) & ~pagesize_m1);
+	  char *oldguard = mem + (((size - pd->guardsize) / 2) & ~pagesize_m1);
+
+	  if (oldguard < guard
+	      && __mprotect (oldguard, guard - oldguard, prot) != 0)
+	    goto mprot_error;
+
+	  if (__mprotect (guard + guardsize,
+			oldguard + pd->guardsize - guard - guardsize,
+			prot) != 0)
+	    goto mprot_error;
+#elif _STACK_GROWS_DOWN
-#if _STACK_GROWS_DOWN
 	  if (__mprotect ((char *) mem + guardsize, pd->guardsize - guardsize,
 			prot) != 0)
 	    goto mprot_error;
@@ -585,7 +599,7 @@
 static void
 name_stack_maps (struct pthread *pd, bool set)
 {
+#if _STACK_GROWS_DOWN && !defined(NEED_SEPARATE_REGISTER_STACK)
-#if _STACK_GROWS_DOWN
   void *stack = pd->stackblock + pd->guardsize;
 #else
   void *stack = pd->stackblock;
--- b/nptl/perf.c
+++ a/nptl/perf.c
@@ -708,6 +708,8 @@
   ({ unsigned int _hi, _lo; \
      asm volatile ("rdtsc" : "=a" (_lo), "=d" (_hi)); \
      (Var) = ((unsigned long long int) _hi << 32) | _lo; })
+#elif defined __ia64__
+#define HP_TIMING_NOW(Var)	__asm__ __volatile__ ("mov %0=ar.itc" : "=r" (Var) : : "memory")
 #else
 #error "HP_TIMING_NOW missing"
 #endif
--- b/scripts/build-many-glibcs.py
+++ a/scripts/build-many-glibcs.py
@@ -234,6 +234,10 @@
                         os_name='linux-gnu')
         self.add_config(arch='i686',
                         os_name='gnu')
+        self.add_config(arch='ia64',
+                        os_name='linux-gnu',
+                        first_gcc_cfg=['--with-system-libunwind'],
+                        binutils_cfg=['--enable-obsolete'])
         self.add_config(arch='loongarch64',
                         os_name='linux-gnu',
                         variant='lp64d',
@@ -1296,6 +1300,7 @@
                 'i586': 'x86',
                 'i686': 'x86',
                 'i786': 'x86',
+                'ia64': 'ia64',
                 'loongarch64': 'loongarch',
                 'm68k': 'm68k',
                 'microblaze': 'microblaze',
--- b/support/xclone.c
+++ a/support/xclone.c
@@ -27,11 +27,18 @@
 {
   pid_t r = -1;
 
+# ifdef __ia64__
+  extern int __clone2 (int (*fn) (void *arg), void *stack, size_t stack_size,
+		       int flags, void *arg, ...);
+  r = __clone2 (fn, stack, stack_size, flags, arg, /* ptid */ NULL,
+		/* tls */ NULL, /* ctid  */ NULL);
+# else
+#  if _STACK_GROWS_DOWN
-# if _STACK_GROWS_DOWN
   r = clone (fn, stack + stack_size, flags, arg, /* ptid */ NULL,
 	     /* tls */ NULL, /* ctid */  NULL);
+#  elif _STACK_GROWS_UP
-# elif _STACK_GROWS_UP
   r = clone (fn, stack, flags, arg, /* ptid */ NULL, /* tls */ NULL, NULL);
+#  endif
 # endif
 
   if (r < 0)
--- b/sysdeps/generic/ldconfig.h
+++ a/sysdeps/generic/ldconfig.h
@@ -30,6 +30,7 @@
 #define FLAG_ELF_LIBC6			0x0003
 #define FLAG_REQUIRED_MASK		0xff00
 #define FLAG_SPARC_LIB64		0x0100
+#define FLAG_IA64_LIB64			0x0200
 #define FLAG_X8664_LIB64		0x0300
 #define FLAG_S390_LIB64			0x0400
 #define FLAG_POWERPC_LIB64		0x0500
--- b/sysdeps/generic/unwind-dw2.c
+++ a/sysdeps/generic/unwind-dw2.c
@@ -224,6 +224,7 @@
     return NULL;
 }
 
+#ifndef __ia64__
 _Unwind_Ptr
 _Unwind_GetDataRelBase (struct _Unwind_Context *context)
 {
@@ -235,6 +236,7 @@
 {
   return (_Unwind_Ptr) context->bases.tbase;
 }
+#endif
 
 /* Extract any interesting information from the CIE for the translation
    unit F belongs to.  Return a pointer to the byte after the augmentation,
--- b/sysdeps/generic/unwind.h
+++ a/sysdeps/generic/unwind.h
@@ -33,7 +33,11 @@
    inefficient for 32-bit and smaller machines.  */
 typedef unsigned _Unwind_Word __attribute__((__mode__(__unwind_word__)));
 typedef signed _Unwind_Sword __attribute__((__mode__(__unwind_word__)));
+#if defined(__ia64__) && defined(__hpux__)
+typedef unsigned _Unwind_Ptr __attribute__((__mode__(__word__)));
+#else
 typedef unsigned _Unwind_Ptr __attribute__((__mode__(__pointer__)));
+#endif
 typedef unsigned _Unwind_Internal_Ptr __attribute__((__mode__(__pointer__)));
 
 /* @@@ The IA-64 ABI uses a 64-bit word to identify the producer and
@@ -186,8 +190,29 @@
    and data-relative addressing in the LDSA.  In order to stay link
    compatible with the standard ABI for IA-64, we inline these.  */
 
+#ifdef __ia64__
+#include <stdlib.h>
+
+static inline _Unwind_Ptr
+_Unwind_GetDataRelBase (struct _Unwind_Context *_C)
+{
+  /* The GP is stored in R1.  */
+  return _Unwind_GetGR (_C, 1);
+}
+
+static inline _Unwind_Ptr
+_Unwind_GetTextRelBase (struct _Unwind_Context *_C)
+{
+  abort ();
+  return 0;
+}
+
+/* @@@ Retrieve the Backing Store Pointer of the given context.  */
+extern _Unwind_Word _Unwind_GetBSP (struct _Unwind_Context *);
+#else
 extern _Unwind_Ptr _Unwind_GetDataRelBase (struct _Unwind_Context *);
 extern _Unwind_Ptr _Unwind_GetTextRelBase (struct _Unwind_Context *);
+#endif
 
 /* @@@ Given an address, return the entry point of the function that
    contains it.  */
--- /dev/null
+++ a/sysdeps/ia64/Implies
@@ -0,0 +1,6 @@
+wordsize-64
+# ia64 uses IEEE 754 floating point.
+ieee754/float128
+ieee754/ldbl-96
+ieee754/dbl-64
+ieee754/flt-32
--- /dev/null
+++ a/sysdeps/ia64/Makeconfig
@@ -0,0 +1,4 @@
+# ia64 does not provide crtbeginT.o, so use crtbegin.o.
++prectorT = $(+prector)
+
+float64x-alias-fcts = yes
--- /dev/null
+++ a/sysdeps/ia64/Makefile
@@ -0,0 +1,25 @@
+# The ia64 `long double' is a distinct type we support.
+long-double-fcts = yes
+
+ifeq ($(subdir),math)
+# sqrtf128 requires soft-fp.
+CPPFLAGS += -I../soft-fp
+endif
+
+ifeq ($(subdir),gmon)
+sysdep_routines += _mcount
+endif
+
+ifeq ($(subdir), csu)
+CPPFLAGS-start.S = -D__ASSEMBLY__
+
+ifeq (yes,$(build-shared))
+# Compatibility
+sysdep_routines += ia64libgcc
+shared-only-routines += ia64libgcc
+endif
+endif
+
+ifeq ($(subdir),elf)
+sysdep-dl-routines += dl-symaddr dl-fptr
+endif
--- /dev/null
+++ a/sysdeps/ia64/Versions
@@ -0,0 +1,21 @@
+ld {
+  GLIBC_PRIVATE {
+    # ia64 specific functions in the dynamic linker, but used by libc.so.
+    _dl_symbol_address; _dl_lookup_address;
+    _dl_function_address;
+  }
+}
+libc {
+  GLIBC_2.2 {
+    # Functions from libgcc.
+    __divtf3; __divdf3; __divsf3; __divdi3; __moddi3; __udivdi3; __umoddi3;
+    __multi3;
+  }
+}
+libm {
+  GLIBC_2.1 {
+    # A generic bug got this omitted from other configurations' version
+    # sets, but we always had it.
+    exp2l;
+  }
+}
--- /dev/null
+++ a/sysdeps/ia64/_mcount.S
@@ -0,0 +1,90 @@
+/* Machine-specific calling sequence for `mcount' profiling function.  ia64
+   Copyright (C) 2000-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Assembly stub to invoke _mcount().  Compiler generated code calls
+   this stub before executing a function's prologue and without saving
+   any registers.  It is therefore necessary to preserve the input
+   registers as they may contain function arguments.  To work
+   correctly with frame-less functions, it is also necessary to
+   preserve the return pointer (b0 aka rp).
+
+   State upon entering _mcount:
+
+    r8  address of return value structure (used only when called
+	function returns a large structure)
+    r15 static link (used only for nested functions)
+    in0 ar.pfs to restore before returning to the function that
+	called _mcount
+    in1 gp value to restore before returning to the function that
+	called _mcount
+    in2 return address in the function that invoked the caller
+	of _mcount (frompc)
+    in3	address of the global-offset table entry that holds the
+	profile count dword allocated by the compiler; to get
+	the address of this dword, use "ld8 in2=[in2]; this
+	dword can be used in any way by _mcount (including
+	not at all, as is the case with the current implementation)
+    b0	address to return to after _mcount is done
+*/
+
+#include <sysdep.h>
+
+#undef ret
+
+LEAF(_mcount)
+	.prologue ASM_UNW_PRLG_RP|ASM_UNW_PRLG_PFS, ASM_UNW_PRLG_GRSAVE(4)
+	alloc loc1 = ar.pfs, 4, 4, 3, 0
+	mov loc0 = rp
+	.body
+	mov loc2 = r8	// gcc uses r8 to pass pointer to return structure
+	;;
+	mov loc3 = r15	// gcc uses r15 to pass the static link to nested functions
+	mov out0 = in2
+	mov out1 = rp
+	br.call.sptk.few rp = __mcount
+	;;
+.here:
+{
+	.mii
+	mov gp = in1
+	mov r2 = ip
+	mov ar.pfs = loc1
+}
+	;;
+	adds r2 = _mcount_ret_helper - .here, r2
+	mov b7 = loc0
+	mov rp = in2
+	;;
+	mov r3 = in0
+	mov r8 = loc2
+	mov r15 = loc3
+	mov b6 = r2
+	br.ret.sptk.few b6
+END(_mcount)
+
+LOCAL_LEAF(_mcount_ret_helper)
+	.prologue
+	.altrp b7
+	.save ar.pfs, r3
+	.body
+	alloc r2 = ar.pfs, 0, 0, 8, 0
+	mov ar.pfs = r3
+	br b7
+END(_mcount_ret_helper)
+
+weak_alias (_mcount, mcount)
--- /dev/null
+++ a/sysdeps/ia64/abort-instr.h
@@ -0,0 +1,3 @@
+/* An instruction which should crash any program is `break 0' which triggers
+   SIGILL.  */
+#define ABORT_INSTRUCTION asm ("break 0")
--- /dev/null
+++ a/sysdeps/ia64/atomic-machine.h
@@ -0,0 +1,96 @@
+/* Copyright (C) 2003-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <ia64intrin.h>
+
+#define __HAVE_64B_ATOMICS 1
+#define USE_ATOMIC_COMPILER_BUILTINS 0
+
+/* XXX Is this actually correct?  */
+#define ATOMIC_EXCHANGE_USES_CAS 0
+
+
+#define __arch_compare_and_exchange_bool_8_acq(mem, newval, oldval) \
+  (abort (), 0)
+
+#define __arch_compare_and_exchange_bool_16_acq(mem, newval, oldval) \
+  (abort (), 0)
+
+#define __arch_compare_and_exchange_bool_32_acq(mem, newval, oldval) \
+  (!__sync_bool_compare_and_swap ((mem), (int) (long) (oldval), \
+				  (int) (long) (newval)))
+
+#define __arch_compare_and_exchange_bool_64_acq(mem, newval, oldval) \
+  (!__sync_bool_compare_and_swap ((mem), (long) (oldval), \
+				  (long) (newval)))
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval) \
+  (abort (), (__typeof (*mem)) 0)
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval) \
+  (abort (), (__typeof (*mem)) 0)
+
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval) \
+  __sync_val_compare_and_swap ((mem), (int) (long) (oldval), \
+			       (int) (long) (newval))
+
+#define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  __sync_val_compare_and_swap ((mem), (long) (oldval), (long) (newval))
+
+/* Atomically store newval and return the old value.  */
+#define atomic_exchange_acq(mem, value) \
+  __sync_lock_test_and_set (mem, value)
+
+#define atomic_exchange_rel(mem, value) \
+  (__sync_synchronize (), __sync_lock_test_and_set (mem, value))
+
+#define atomic_exchange_and_add(mem, value) \
+  __sync_fetch_and_add ((mem), (value))
+
+#define atomic_decrement_if_positive(mem) \
+  ({ __typeof (*mem) __oldval, __val;					      \
+     __typeof (mem) __memp = (mem);					      \
+									      \
+     __val = (*__memp);							      \
+     do									      \
+       {								      \
+	 __oldval = __val;						      \
+	 if (__builtin_expect (__val <= 0, 0))				      \
+	   break;							      \
+	 __val = atomic_compare_and_exchange_val_acq (__memp,	__oldval - 1, \
+						      __oldval);	      \
+       }								      \
+     while (__builtin_expect (__val != __oldval, 0));			      \
+     __oldval; })
+
+#define atomic_bit_test_set(mem, bit) \
+  ({ __typeof (*mem) __oldval, __val;					      \
+     __typeof (mem) __memp = (mem);					      \
+     __typeof (*mem) __mask = ((__typeof (*mem)) 1 << (bit));		      \
+									      \
+     __val = (*__memp);							      \
+     do									      \
+       {								      \
+	 __oldval = __val;						      \
+	 __val = atomic_compare_and_exchange_val_acq (__memp,		      \
+						      __oldval | __mask,      \
+						      __oldval);	      \
+       }								      \
+     while (__builtin_expect (__val != __oldval, 0));			      \
+     __oldval & __mask; })
+
+#define atomic_full_barrier() __sync_synchronize ()
--- /dev/null
+++ a/sysdeps/ia64/bits/endianness.h
@@ -0,0 +1,11 @@
+#ifndef _BITS_ENDIANNESS_H
+#define _BITS_ENDIANNESS_H 1
+
+#ifndef _BITS_ENDIAN_H
+# error "Never use <bits/endianness.h> directly; include <endian.h> instead."
+#endif
+
+/* IA64 is little-endian.  */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+#endif /* bits/endianness.h */
--- /dev/null
+++ a/sysdeps/ia64/bits/fenv.h
@@ -0,0 +1,104 @@
+/* Copyright (C) 1999-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+
+/* Define bits representing the exception.  We use the bit positions of
+   the appropriate bits in the FPSR...  (Tahoe EAS 2.4 5-4)*/
+
+enum
+  {
+    FE_INEXACT =
+#define FE_INEXACT	(1 << 5)
+      FE_INEXACT,
+
+    FE_UNDERFLOW =
+#define FE_UNDERFLOW	(1 << 4)
+      FE_UNDERFLOW,
+
+    FE_OVERFLOW =
+#define FE_OVERFLOW	(1 << 3)
+      FE_OVERFLOW,
+
+    FE_DIVBYZERO =
+#define FE_DIVBYZERO	(1 << 2)
+      FE_DIVBYZERO,
+
+    FE_UNNORMAL =
+#define FE_UNNORMAL	(1 << 1)
+      FE_UNNORMAL,
+
+    FE_INVALID =
+#define FE_INVALID	(1 << 0)
+      FE_INVALID,
+
+    FE_ALL_EXCEPT =
+#define FE_ALL_EXCEPT	(FE_INEXACT | FE_UNDERFLOW | FE_OVERFLOW | FE_DIVBYZERO | FE_UNNORMAL | FE_INVALID)
+      FE_ALL_EXCEPT
+  };
+
+
+enum
+  {
+    FE_TOWARDZERO =
+#define FE_TOWARDZERO	3
+      FE_TOWARDZERO,
+
+    FE_UPWARD =
+#define FE_UPWARD	2
+      FE_UPWARD,
+
+    FE_DOWNWARD =
+#define FE_DOWNWARD	1
+      FE_DOWNWARD,
+
+    FE_TONEAREST =
+#define FE_TONEAREST	0
+      FE_TONEAREST,
+  };
+
+
+/* Type representing exception flags.  */
+typedef unsigned long int fexcept_t;
+
+/* Type representing floating-point environment.  */
+typedef unsigned long int fenv_t;
+
+/* If the default argument is used we use this value.  */
+#define FE_DFL_ENV	((const fenv_t *) 0xc009804c0270033fUL)
+
+#ifdef __USE_GNU
+/* Floating-point environment where only FE_UNNORMAL is masked since this
+   exception is not generally supported by glibc.  */
+# define FE_NOMASK_ENV	((const fenv_t *) 0xc009804c02700302UL)
+
+/* Floating-point environment with (processor-dependent) non-IEEE
+   floating point.  In this case, turning on flush-to-zero mode for
+   s0, s2, and s3.  */
+# define FE_NONIEEE_ENV ((const fenv_t *) 0xc009a04d0270037fUL)
+#endif
+
+#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)
+/* Type representing floating-point control modes.  */
+typedef unsigned long int femode_t;
+
+/* Default floating-point control modes.  */
+# define FE_DFL_MODE	((const femode_t *) 0xc009804c0270033fUL)
+#endif
--- /dev/null
+++ a/sysdeps/ia64/bits/floatn.h
@@ -0,0 +1,119 @@
+/* Macros to control TS 18661-3 glibc features on ia64.
+   Copyright (C) 2017-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_FLOATN_H
+#define _BITS_FLOATN_H
+
+#include <features.h>
+
+/* Defined to 1 if the current compiler invocation provides a
+   floating-point type with the IEEE 754 binary128 format, and this
+   glibc includes corresponding *f128 interfaces for it.  The required
+   libgcc support was added some time after the basic compiler
+   support.  */
+#if __GNUC_PREREQ (4, 4)
+# define __HAVE_FLOAT128 1
+#else
+# define __HAVE_FLOAT128 0
+#endif
+
+/* Defined to 1 if __HAVE_FLOAT128 is 1 and the type is ABI-distinct
+   from the default float, double and long double types in this glibc.  */
+#if __HAVE_FLOAT128
+# define __HAVE_DISTINCT_FLOAT128 1
+#else
+# define __HAVE_DISTINCT_FLOAT128 0
+#endif
+
+/* Defined to 1 if the current compiler invocation provides a
+   floating-point type with the right format for _Float64x, and this
+   glibc includes corresponding *f64x interfaces for it.  */
+#define __HAVE_FLOAT64X 1
+
+/* Defined to 1 if __HAVE_FLOAT64X is 1 and _Float64x has the format
+   of long double.  Otherwise, if __HAVE_FLOAT64X is 1, _Float64x has
+   the format of _Float128, which must be different from that of long
+   double.  */
+#define __HAVE_FLOAT64X_LONG_DOUBLE 1
+
+#ifndef __ASSEMBLER__
+
+/* Defined to concatenate the literal suffix to be used with _Float128
+   types, if __HAVE_FLOAT128 is 1. */
+# if __HAVE_FLOAT128
+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))
+/* The literal suffix f128 exists only since GCC 7.0.  */
+#   define __f128(x) x##q
+#  else
+#   define __f128(x) x##f128
+#  endif
+# endif
+
+/* Defined to a complex binary128 type if __HAVE_FLOAT128 is 1.  */
+# if __HAVE_FLOAT128
+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))
+/* Add a typedef for older GCC compilers which don't natively support
+   _Complex _Float128.  */
+typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
+#   define __CFLOAT128 __cfloat128
+#  else
+#   define __CFLOAT128 _Complex _Float128
+#  endif
+# endif
+
+/* The remaining of this file provides support for older compilers.  */
+# if __HAVE_FLOAT128
+
+/* The type _Float128 exists only since GCC 7.0.  */
+#  if !__GNUC_PREREQ (7, 0) || (defined __cplusplus && !__GNUC_PREREQ (13, 0))
+typedef __float128 _Float128;
+#  endif
+
+/* __builtin_huge_valf128 doesn't exist before GCC 7.0.  */
+#  if !__GNUC_PREREQ (7, 0)
+#   define __builtin_huge_valf128() ((_Float128) __builtin_huge_val ())
+#  endif
+
+/* Older GCC has only a subset of built-in functions for _Float128 on
+   ia64, and __builtin_infq is not usable in static initializers.
+   Converting a narrower sNaN to _Float128 produces a quiet NaN, so
+   attempts to use _Float128 sNaNs will not work properly with older
+   compilers.  */
+#  if !__GNUC_PREREQ (7, 0)
+#   define __builtin_copysignf128 __builtin_copysignq
+#   define __builtin_fabsf128 __builtin_fabsq
+#   define __builtin_inff128() ((_Float128) __builtin_inf ())
+#   define __builtin_nanf128(x) ((_Float128) __builtin_nan (x))
+#   define __builtin_nansf128(x) ((_Float128) __builtin_nans (x))
+#  endif
+
+/* In math/math.h, __MATH_TG will expand signbit to __builtin_signbit*,
+   e.g.: __builtin_signbitf128, before GCC 6.  However, there has never
+   been a __builtin_signbitf128 in GCC and the type-generic builtin is
+   only available since GCC 6.  */
+#  if !__GNUC_PREREQ (6, 0)
+#   define __builtin_signbitf128 __signbitf128
+#  endif
+
+# endif
+
+#endif /* !__ASSEMBLER__.  */
+
+#include <bits/floatn-common.h>
+
+#endif /* _BITS_FLOATN_H */
--- /dev/null
+++ a/sysdeps/ia64/bits/fp-logb.h
@@ -0,0 +1,24 @@
+/* Define __FP_LOGB0_IS_MIN and __FP_LOGBNAN_IS_MIN.  IA64 version.
+   Copyright (C) 2016-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/fp-logb.h> directly; include <math.h> instead."
+#endif
+
+#define __FP_LOGB0_IS_MIN	1
+#define __FP_LOGBNAN_IS_MIN	0
--- /dev/null
+++ a/sysdeps/ia64/bits/link.h
@@ -0,0 +1,62 @@
+/* Copyright (C) 2005-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef	_LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+/* Registers for entry into PLT on ia64.  */
+typedef struct La_ia64_regs
+{
+  uint64_t lr_r8;
+  uint64_t lr_r9;
+  uint64_t lr_r10;
+  uint64_t lr_r11;
+  uint64_t lr_gr [8];
+  long double lr_fr [8];
+  uint64_t lr_unat;
+  uint64_t lr_sp;
+} La_ia64_regs;
+
+/* Return values for calls from PLT on ia64.  */
+typedef struct La_ia64_retval
+{
+  uint64_t lrv_r8;
+  uint64_t lrv_r9;
+  uint64_t lrv_r10;
+  uint64_t lrv_r11;
+  long double lr_fr [8];
+} La_ia64_retval;
+
+
+__BEGIN_DECLS
+
+extern Elf64_Addr la_ia64_gnu_pltenter (Elf64_Sym *__sym, unsigned int __ndx,
+					uintptr_t *__refcook,
+					uintptr_t *__defcook,
+					La_ia64_regs *__regs,
+					unsigned int *__flags,
+					const char *__symname,
+					long int *__framesizep);
+extern unsigned int la_ia64_gnu_pltexit (Elf64_Sym *__sym, unsigned int __ndx,
+					 uintptr_t *__refcook,
+					 uintptr_t *__defcook,
+					 const La_ia64_regs *__inregs,
+					 La_ia64_retval *__outregs,
+					 const char *__symname);
+
+__END_DECLS
--- /dev/null
+++ a/sysdeps/ia64/bzero.c
@@ -0,0 +1,3 @@
+/* ia64 does not export __bzero symbol.  */
+#define __bzero bzero
+#include <string/bzero.c>
--- /dev/null
+++ a/sysdeps/ia64/configure
@@ -0,0 +1,9 @@
+# This file is generated from configure.ac by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/ia64.
+
+# PIE builds fail on binutils 2.37 and earlier, see:
+# https://sourceware.org/bugzilla/show_bug.cgi?id=28672
+printf "%s\n" "#define PIE_UNSUPPORTED 1" >>confdefs.h
+
+# work around problem with autoconf and empty lines at the end of files
+
--- /dev/null
+++ a/sysdeps/ia64/configure.ac
@@ -0,0 +1,7 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/ia64.
+
+# PIE builds fail on binutils 2.37 and earlier, see:
+# https://sourceware.org/bugzilla/show_bug.cgi?id=28672
+AC_DEFINE(PIE_UNSUPPORTED)
+# work around problem with autoconf and empty lines at the end of files
--- /dev/null
+++ a/sysdeps/ia64/crti.S
@@ -0,0 +1,162 @@
+/* Special .init and .fini section support for IA64.
+   Copyright (C) 2000-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* crti.S puts a function prologue at the beginning of the .init and
+   .fini sections and defines global symbols for those addresses, so
+   they can be called as functions.  The symbols _init and _fini are
+   magic and cause the linker to emit DT_INIT and DT_FINI.  */
+
+#include <libc-symbols.h>
+#include <sysdep.h>
+#undef ret
+
+#ifndef PREINIT_FUNCTION
+# define PREINIT_FUNCTION __gmon_start__
+#endif
+
+#ifndef PREINIT_FUNCTION_WEAK
+# define PREINIT_FUNCTION_WEAK 1
+#endif
+
+#if PREINIT_FUNCTION_WEAK
+	weak_extern (PREINIT_FUNCTION)
+#else
+	.hidden PREINIT_FUNCTION
+#endif
+
+/* If we have working .init_array support, we want to keep the .init
+   section empty (apart from the mandatory prologue/epilogue.  This
+   ensures that the default unwind conventions (return-pointer in b0,
+   frame state in ar.pfs, etc.)  will do the Right Thing.  To ensure
+   an empty .init section, we register gmon_initializer() via the
+   .init_array.
+
+    --davidm 02/10/29 */
+
+#if PREINIT_FUNCTION_WEAK
+/* This blob of assembly code is one simple C function:
+
+static void
+__attribute__ ((used))
+gmon_initializer (void)
+{
+  extern void weak_function __gmon_start__ (void);
+
+  if (__gmon_start__)
+    (*__gmon_start__)();
+}
+ */
+	.text
+	.align 64
+	.proc gmon_initializer#
+gmon_initializer:
+	.prologue 12, 32
+	.mmi
+	.save ar.pfs, r33
+	alloc r33 = ar.pfs, 0, 3, 0, 0
+	addl r14 = @ltoff(@fptr(PREINIT_FUNCTION#)), gp
+	.save rp, r32
+	mov r32 = b0
+	.mmi
+	mov r34 = r1
+	.body
+	;;
+	ld8 r14 = [r14]
+	nop 0
+	;;
+	.mib
+	cmp.eq p6, p7 = 0, r14
+	nop 0
+	(p6) br.cond.spnt .L1
+	;;
+	.mib
+	nop 0
+	nop 0
+	br.call.sptk.many b0 = PREINIT_FUNCTION#
+	;;
+	.mmi
+	mov r1 = r34
+	nop 0
+	nop 0
+.L1:
+	.mii
+	nop 0
+	mov ar.pfs = r33
+	nop 0
+	;;
+	.mib
+	nop 0
+	mov b0 = r32
+	br.ret.sptk.many b0
+	.endp gmon_initializer#
+# undef PREINIT_FUNCTION
+# define PREINIT_FUNCTION gmon_initializer
+#endif
+	.section .init_array, "aw"
+	data8 @fptr(PREINIT_FUNCTION)
+
+	.section .init,"ax",@progbits
+	.global _init#
+	.hidden	_init#
+	.proc _init#
+_init:
+	.prologue
+	.save ar.pfs, r34
+	alloc r34 = ar.pfs, 0, 3, 0, 0
+	.vframe r32
+	mov r32 = r12
+	.save rp, r33
+	mov r33 = b0
+	.body
+	adds r12 = -16, r12
+	;;		/* see gmon_initializer() above */
+	.endp _init#
+
+	.section .fini,"ax",@progbits
+	.global _fini#
+	.hidden	_fini#
+	.proc _fini#
+_fini:
+	.prologue
+	.save ar.pfs, r34
+	alloc r34 = ar.pfs, 0, 3, 0, 0
+	.vframe r32
+	mov r32 = r12
+	.save rp, r33
+	mov r33 = b0
+	.body
+	adds r12 = -16, r12
+	;;
+	.endp _fini#
--- /dev/null
+++ a/sysdeps/ia64/crtn.S
@@ -0,0 +1,69 @@
+/* Special .init and .fini section support for ARM.
+   Copyright (C) 2000-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#undef ret
+
+/* crtn.S puts function epilogues in the .init and .fini sections
+   corresponding to the prologues in crti.S. */
+
+	.section .init,"ax",@progbits
+	.proc _init#
+_init:
+	.prologue
+	.save ar.pfs, r34
+	.vframe r32
+	.save rp, r33
+	.body
+	.regstk 0,2,0,0
+	mov r12 = r32
+	mov ar.pfs = r34
+	mov b0 = r33
+	br.ret.sptk.many b0
+	.endp _init#
+
+	.section .fini,"ax",@progbits
+	.proc _fini#
+_fini:
+	.prologue
+	.save ar.pfs, r34
+	.vframe r32
+	.save rp, r33
+	.body
+	mov r12 = r32
+	mov ar.pfs = r34
+	mov b0 = r33
+	br.ret.sptk.many b0
+	.endp _fini#
--- /dev/null
+++ a/sysdeps/ia64/dl-dtprocnum.h
@@ -0,0 +1,21 @@
+/* Configuration of lookup functions.  IA-64 version.
+   Copyright (C) 2000-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Number of extra dynamic section entries for this architecture.  By
+   default there are none.  */
+#define DT_THISPROCNUM	DT_IA_64_NUM
--- /dev/null
+++ a/sysdeps/ia64/dl-fptr.h
@@ -0,0 +1,45 @@
+/* Function descriptors.  IA64 version.
+   Copyright (C) 2003-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef dl_ia64_fptr_h
+#define dl_ia64_fptr_h 1
+
+#include <ia64intrin.h>
+#include <sysdeps/generic/dl-fptr.h>
+
+#define COMPARE_AND_SWAP(ptr, old, new)	\
+  __sync_bool_compare_and_swap (ptr, old, new)
+
+/* There are currently 123 dynamic symbols in ld.so.
+   ELF_MACHINE_BOOT_FPTR_TABLE_LEN needs to be at least that big.  */
+#define ELF_MACHINE_BOOT_FPTR_TABLE_LEN	200
+
+#define ELF_MACHINE_LOAD_ADDRESS(var, symbol)	\
+  asm ("movl %0 = @gprel (" #symbol ");; add %0 = %0, gp" : "=&r" (var));
+
+/* We don't have a gcc helper to extract the plabel info.  */
+#define ELF_PTR_TO_FDESC(ptr) \
+  ({ union { \
+       void *_ptr; \
+       struct fdesc *_fdesc; \
+     } _u; \
+     _u._ptr = ptr; \
+     _u._fdesc; \
+  })
+
+#endif /* !dl_ia64_fptr_h */
--- /dev/null
+++ a/sysdeps/ia64/dl-lookupcfg.h
@@ -0,0 +1,79 @@
+/* Configuration of lookup functions.
+   Copyright (C) 2000-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define ELF_FUNCTION_PTR_IS_SPECIAL
+#define DL_UNMAP_IS_SPECIAL
+
+#include <dl-fptr.h>
+
+/* We do not support copy relocations for IA-64.  */
+#define DL_NO_COPY_RELOCS
+
+/* Forward declaration.  */
+struct link_map;
+
+extern void *_dl_symbol_address (struct link_map *map, const Elf64_Sym *ref);
+rtld_hidden_proto (_dl_symbol_address)
+
+#define DL_SYMBOL_ADDRESS(map, ref) _dl_symbol_address(map, ref)
+
+extern Elf64_Addr _dl_lookup_address (const void *address);
+
+#define DL_LOOKUP_ADDRESS(addr) _dl_lookup_address (addr)
+
+extern void attribute_hidden _dl_unmap (struct link_map *map);
+
+#define DL_UNMAP(map) _dl_unmap (map)
+
+#define DL_DT_FUNCTION_ADDRESS(map, start, attr, addr)			\
+  attr volatile unsigned long int fptr[2];					\
+  fptr[0] = (unsigned long int) (start);					\
+  fptr[1] = (map)->l_info[DT_PLTGOT]->d_un.d_ptr;			\
+  addr = (ElfW(Addr)) fptr;						\
+
+#define DL_CALL_DT_INIT(map, start, argc, argv, env)	\
+{							\
+  ElfW(Addr) addr;					\
+  DL_DT_FUNCTION_ADDRESS(map, start, , addr)		\
+  dl_init_t init = (dl_init_t) addr; 			\
+  init (argc, argv, env);				\
+}
+
+#define DL_CALL_DT_FINI(map, start)		\
+{						\
+  ElfW(Addr) addr;				\
+  DL_DT_FUNCTION_ADDRESS(map, start, , addr)	\
+  fini_t fini = (fini_t) addr;			\
+  fini ();					\
+}
+
+/* The type of the return value of fixup/profile_fixup.  */
+#define DL_FIXUP_VALUE_TYPE struct fdesc
+/* Construct a value of type DL_FIXUP_VALUE_TYPE from a code address
+   and a link map.  */
+#define DL_FIXUP_MAKE_VALUE(map, addr) \
+  ((struct fdesc) { (addr), (map)->l_info[DT_PLTGOT]->d_un.d_ptr })
+/* Extract the code address from a value of type DL_FIXUP_MAKE_VALUE.
+ */
+#define DL_FIXUP_VALUE_CODE_ADDR(value) (value).ip
+
+#define DL_FIXUP_VALUE_ADDR(value) ((uintptr_t) &(value))
+#define DL_FIXUP_ADDR_VALUE(addr) (*(struct fdesc *) (addr))
+#define DL_FIXUP_BINDNOW_ADDR_VALUE(addr) (addr)
+#define DL_FIXUP_BINDNOW_RELOC(l, reloc, value, new_value, st_value, lazy) \
+  (*value) = *(struct fdesc *) (st_value)
--- /dev/null
+++ a/sysdeps/ia64/dl-machine.h
@@ -0,0 +1,460 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  IA-64 version.
+   Copyright (C) 1995-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef dl_machine_h
+#define dl_machine_h 1
+
+#define ELF_MACHINE_NAME "ia64"
+
+#include <assert.h>
+#include <string.h>
+#include <link.h>
+#include <errno.h>
+#include <dl-fptr.h>
+#include <tls.h>
+#include <dl-static-tls.h>
+#include <dl-machine-rel.h>
+
+/* Translate a processor specific dynamic tag to the index
+   in l_info array.  */
+#define DT_IA_64(x) (DT_IA_64_##x - DT_LOPROC + DT_NUM)
+
+static inline void __attribute__ ((always_inline))
+__ia64_init_bootstrap_fdesc_table (struct link_map *map)
+{
+  Elf64_Addr *boot_table;
+
+  /* careful: this will be called before got has been relocated... */
+  asm (";; addl %0 = @gprel (_dl_boot_fptr_table), gp" : "=r"(boot_table));
+
+  map->l_mach.fptr_table_len = ELF_MACHINE_BOOT_FPTR_TABLE_LEN;
+  map->l_mach.fptr_table = boot_table;
+}
+
+#define ELF_MACHINE_BEFORE_RTLD_RELOC(map, dynamic_info)		\
+	__ia64_init_bootstrap_fdesc_table (map);
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute__ ((unused))
+elf_machine_matches_host (const Elf64_Ehdr *ehdr)
+{
+  return ehdr->e_machine == EM_IA_64;
+}
+
+
+/* Return the link-time address of _DYNAMIC.  */
+static inline Elf64_Addr __attribute__ ((unused, const))
+elf_machine_dynamic (void)
+{
+  Elf64_Addr *p;
+
+  __asm__ (
+	".section .sdata\n"
+	"	.type __dynamic_ltv#, @object\n"
+	"	.size __dynamic_ltv#, 8\n"
+	"__dynamic_ltv:\n"
+	"	data8	@ltv(_DYNAMIC#)\n"
+	".previous\n"
+	"	addl	%0 = @gprel(__dynamic_ltv#), gp ;;"
+	: "=r" (p));
+
+  return *p;
+}
+
+
+/* Return the run-time load address of the shared object.  */
+static inline Elf64_Addr __attribute__ ((unused))
+elf_machine_load_address (void)
+{
+  Elf64_Addr ip;
+  int *p;
+
+  __asm__ (
+	"1:	mov %0 = ip\n"
+	".section .sdata\n"
+	"2:	data4	@ltv(1b)\n"
+	"       .align 8\n"
+	".previous\n"
+	"	addl	%1 = @gprel(2b), gp ;;"
+	: "=r" (ip), "=r" (p));
+
+  return ip - (Elf64_Addr) *p;
+}
+
+/* Set up the loaded object described by L so its unrelocated PLT
+   entries will jump to the on-demand fixup code in dl-runtime.c.  */
+
+static inline int __attribute__ ((unused, always_inline))
+elf_machine_runtime_setup (struct link_map *l, struct r_scope_elem *scope[],
+			   int lazy, int profile)
+{
+  extern void _dl_runtime_resolve (void);
+  extern void _dl_runtime_profile (void);
+
+  if (lazy)
+    {
+      register Elf64_Addr gp __asm__ ("gp");
+      Elf64_Addr *reserve, doit;
+
+      /*
+       * Careful with the typecast here or it will try to add l-l_addr
+       * pointer elements
+       */
+      reserve = ((Elf64_Addr *)
+		 (l->l_info[DT_IA_64 (PLT_RESERVE)]->d_un.d_ptr + l->l_addr));
+      /* Identify this shared object.  */
+      reserve[0] = (Elf64_Addr) l;
+
+      /* This function will be called to perform the relocation.  */
+#ifdef SHARED
+      if (__glibc_unlikely (profile))
+	{
+	  if (GLRO(dl_profile) != NULL
+	      && _dl_name_match_p (GLRO(dl_profile), l))
+	    {
+	      /* This is the object we are looking for.  Say that we really
+		 want profiling and the timers are started.  */
+	      GL(dl_profile_map) = l;
+	    }
+	  doit = (Elf64_Addr) ELF_PTR_TO_FDESC (&_dl_runtime_profile)->ip;
+	}
+      else
+#endif
+	{
+	  doit = (Elf64_Addr) ELF_PTR_TO_FDESC (&_dl_runtime_resolve)->ip;
+	}
+
+      reserve[1] = doit;
+      reserve[2] = gp;
+    }
+
+  return lazy;
+}
+
+/* Names of the architecture-specific auditing callback functions.  */
+#define ARCH_LA_PLTENTER ia64_gnu_pltenter
+#define ARCH_LA_PLTEXIT ia64_gnu_pltexit
+
+/* Undo the adds out0 = 16, sp below to get at the value we want in
+   __libc_stack_end.  */
+#define DL_STACK_END(cookie) \
+  ((void *) (((long) (cookie)) - 16))
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.  */
+
+#define RTLD_START asm (						      \
+".text\n"								      \
+"	.global _start#\n"						      \
+"	.proc _start#\n"						      \
+"_start:\n"								      \
+"0:	{ .mii\n"							      \
+"	  .prologue\n"							      \
+"	  .save rp, r0\n"						      \
+"	  .body\n"							      \
+"	  .prologue\n"							      \
+"	  .save ar.pfs, r32\n"						      \
+"	  alloc loc0 = ar.pfs, 0, 3, 4, 0\n"				      \
+"	  .body\n"							      \
+"	  mov r2 = ip\n"						      \
+"	  addl r3 = @gprel(0b), r0\n"					      \
+"	  ;;\n"								      \
+"	}\n"								      \
+"	{ .mlx\n"							      \
+"	  /* Calculate the GP, and save a copy in loc1.  */\n"		      \
+"	  sub gp = r2, r3\n"						      \
+"	  movl r8 = 0x9804c0270033f\n"					      \
+"	  ;;\n"								      \
+"	}\n"								      \
+"	{ .mii\n"							      \
+"	  mov ar.fpsr = r8\n"						      \
+"	  sub loc1 = r2, r3\n"						      \
+"	  /* _dl_start wants a pointer to the pointer to the arg block and\n" \
+"	     the arg block starts with an integer, thus the magic 16. */\n"   \
+"	  adds out0 = 16, sp\n"						      \
+"	}\n"								      \
+"	{ .bbb\n"							      \
+"	  br.call.sptk.many b0 = _dl_start#\n"				      \
+"	  ;;\n"								      \
+"	}\n"								      \
+"	.endp _start#\n"						      \
+"	/* FALLTHRU */\n"						      \
+"	.global _dl_start_user#\n"					      \
+"	.proc _dl_start_user#\n"					      \
+"_dl_start_user:\n"							      \
+"	 .prologue\n"							      \
+"	 .save rp, r0\n"						      \
+"	  .body\n"							      \
+"	 .prologue\n"							      \
+"	 .save ar.pfs, r32\n"						      \
+"	 .body\n"							      \
+"	{ .mii\n"							      \
+"	  /* Save the pointer to the user entry point fptr in loc2.  */\n"    \
+"	  mov loc2 = ret0\n"						      \
+"	  addl r2 = @ltoff(_dl_argc), gp\n"				      \
+"	  ;;\n"								      \
+"	}\n"								      \
+"	{ .mii\n"							      \
+"	  ld8 out1 = [r2]	/* Get the _dl_argc address.  */\n"	      \
+"	  addl r3 = @ltoff(_dl_argv), gp\n"				      \
+"	  ;;\n"								      \
+"	}\n"								      \
+"	{ .mmi\n"							      \
+"	  ld8 out2 = [r3]	/* Get the _dl_argv address.  */\n"	      \
+"	  ld8 out1 = [out1]	/* Get the adjusted _dl_argc.  */\n"	      \
+"	  addl r2 = @gprel(_rtld_local), gp\n"				      \
+"	  ;;\n"								      \
+"	}\n"								      \
+"	{ .mmi\n"							      \
+"	  sxt4 out3 = out1	/* envp = argv + argc + 1  */\n" 	      \
+"	  ;;\n"								      \
+"	}\n"								      \
+"	{ .mmi\n"							      \
+"	  adds out3 = 1, out3\n"					      \
+"	  ;;\n"								      \
+"	}\n"								      \
+"	{ .mmi\n"							      \
+"	  ld8 out2 = [out2]	/* Get the adjusted _dl_argv.  */\n"	      \
+"	  shladd out3 = out3, 3, r0\n"					      \
+"	  ;;\n"								      \
+"	}\n"								      \
+"	{ .mmb\n"							      \
+"	  add out3 = out3, out2\n"					      \
+"	  ld8 out0 = [r2]	/* Get the linkmap. */\n"		      \
+"	  br.call.sptk.many b0 = _dl_init#\n"				      \
+"	}\n"								      \
+"	/* Pass our finalizer function to the user,\n"			      \
+"	   and jump to the user's entry point.  */\n"			      \
+"	{ .mmi\n"							      \
+"	  ld8 r3 = [loc2], 8\n"						      \
+"	  mov b0 = r0\n"						      \
+"	}\n"								      \
+"	{ .mmi\n"							      \
+"	  addl ret0 = @ltoff(@fptr(_dl_fini#)), gp\n"			      \
+"	  ;;\n"								      \
+"	  mov b6 = r3\n"						      \
+"	}\n"								      \
+"	{ .mmi\n"							      \
+"	  ld8 ret0 = [ret0]\n"						      \
+"	  ld8 gp = [loc2]\n"						      \
+"	  mov ar.pfs = loc0\n"						      \
+"	  ;;\n"								      \
+"	}\n"								      \
+"	{ .mfb\n"							      \
+"	  br.sptk.many b6\n"						      \
+"	  ;;\n"								      \
+"	}\n"								      \
+"	.endp _dl_start_user#\n"					      \
+".previous\n");
+
+
+#ifndef RTLD_START_SPECIAL_INIT
+#define RTLD_START_SPECIAL_INIT /* nothing */
+#endif
+
+/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry or TLS
+   variable, so undefined references should not be allowed to define the
+   value.
+   ELF_RTYPE_CLASS_COPY iff TYPE should not be allowed to resolve to one
+   of the main executable's symbols, as for a COPY reloc, which we don't
+   use.  */
+/* ??? Ignore *MSB for now.  */
+#define elf_machine_type_class(type) \
+  (((type) == R_IA64_IPLTLSB || (type) == R_IA64_DTPMOD64LSB		      \
+    || (type) == R_IA64_DTPREL64LSB || (type) == R_IA64_TPREL64LSB)	      \
+   * ELF_RTYPE_CLASS_PLT)
+
+/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.  */
+#define ELF_MACHINE_JMP_SLOT	 R_IA64_IPLTLSB
+
+/* Return the address of the entry point. */
+#define ELF_MACHINE_START_ADDRESS(map, start)			\
+({								\
+	ElfW(Addr) addr;					\
+	DL_DT_FUNCTION_ADDRESS(map, start, static, addr)	\
+	addr;							\
+})
+
+/* Fixup a PLT entry to bounce directly to the function at VALUE.  */
+static inline struct fdesc __attribute__ ((always_inline))
+elf_machine_fixup_plt (struct link_map *l, lookup_t t,
+		       const ElfW(Sym) *refsym, const ElfW(Sym) *sym,
+		       const Elf64_Rela *reloc,
+		       Elf64_Addr *reloc_addr, struct fdesc value)
+{
+  /* l is the link_map for the caller, t is the link_map for the object
+   * being called */
+  /* got has already been relocated in elf_get_dynamic_info() */
+  reloc_addr[1] = value.gp;
+  /* we need a "release" here to ensure that the gp is visible before
+     the code entry point is updated: */
+  ((volatile Elf64_Addr *) reloc_addr)[0] = value.ip;
+  return value;
+}
+
+/* Return the final value of a plt relocation.  */
+static inline struct fdesc
+elf_machine_plt_value (struct link_map *map, const Elf64_Rela *reloc,
+		       struct fdesc value)
+{
+  /* No need to handle rel vs rela since IA64 is rela only */
+  return (struct fdesc) { value.ip + reloc->r_addend, value.gp };
+}
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE_MAP
+
+#define R_IA64_TYPE(R)	 ((R) & -8)
+#define R_IA64_FORMAT(R) ((R) & 7)
+
+#define R_IA64_FORMAT_32MSB	4
+#define R_IA64_FORMAT_32LSB	5
+#define R_IA64_FORMAT_64MSB	6
+#define R_IA64_FORMAT_64LSB	7
+
+
+/* Perform the relocation specified by RELOC and SYM (which is fully
+   resolved).  MAP is the object containing the reloc.  */
+static inline void
+__attribute ((always_inline))
+elf_machine_rela (struct link_map *map, struct r_scope_elem *scope[],
+		  const Elf64_Rela *reloc,
+		  const Elf64_Sym *sym,
+		  const struct r_found_version *version,
+		  void *const reloc_addr_arg,
+		  int skip_ifunc)
+{
+  Elf64_Addr *const reloc_addr = reloc_addr_arg;
+  const unsigned long int r_type = ELF64_R_TYPE (reloc->r_info);
+  Elf64_Addr value;
+
+  /* We cannot use a switch here because we cannot locate the switch
+     jump table until we've self-relocated.  */
+
+#if !defined RTLD_BOOTSTRAP
+  if (__builtin_expect (R_IA64_TYPE (r_type) == R_IA64_TYPE (R_IA64_REL64LSB),
+			0))
+    {
+      assert (ELF64_R_TYPE (reloc->r_info) == R_IA64_REL64LSB);
+      value = *reloc_addr + map->l_addr;
+    }
+  else
+#endif
+    if (__builtin_expect (r_type == R_IA64_NONE, 0))
+      return;
+  else
+    {
+      struct link_map *sym_map = RESOLVE_MAP (map, scope, &sym, version,
+					      r_type);
+
+      /* RESOLVE_MAP() will return NULL if it fail to locate the symbol.  */
+      if (sym_map != NULL)
+	{
+	  value = SYMBOL_ADDRESS (sym_map, sym, true) + reloc->r_addend;
+
+	  if (R_IA64_TYPE (r_type) == R_IA64_TYPE (R_IA64_DIR64LSB))
+	    ;/* No adjustment.  */
+	  else if (r_type == R_IA64_IPLTLSB)
+	    {
+	      elf_machine_fixup_plt (NULL, NULL, NULL, NULL, reloc, reloc_addr,
+				     DL_FIXUP_MAKE_VALUE (sym_map, value));
+	      return;
+	    }
+	  else if (R_IA64_TYPE (r_type) == R_IA64_TYPE (R_IA64_FPTR64LSB))
+	    value = _dl_make_fptr (sym_map, sym, value);
+	  else if (R_IA64_TYPE (r_type) == R_IA64_TYPE (R_IA64_PCREL64LSB))
+	    value -= (Elf64_Addr) reloc_addr & -16;
+	  else if (R_IA64_TYPE (r_type) == R_IA64_TYPE (R_IA64_DTPMOD64LSB))
+#ifdef RTLD_BOOTSTRAP
+	    /* During startup the dynamic linker is always index 1.  */
+	    value = 1;
+#else
+	    /* Get the information from the link map returned by the
+	       resolv function.  */
+	    value = sym_map->l_tls_modid;
+	  else if (R_IA64_TYPE (r_type) == R_IA64_TYPE (R_IA64_DTPREL64LSB))
+	    value -= sym_map->l_addr;
+#endif
+	  else if (R_IA64_TYPE (r_type) == R_IA64_TYPE (R_IA64_TPREL64LSB))
+	    {
+#ifndef RTLD_BOOTSTRAP
+	      CHECK_STATIC_TLS (map, sym_map);
+#endif
+	      value += sym_map->l_tls_offset - sym_map->l_addr;
+	    }
+	  else
+	    _dl_reloc_bad_type (map, r_type, 0);
+	}
+      else
+	value = 0;
+    }
+
+  /* ??? Ignore MSB and Instruction format for now.  */
+  if (R_IA64_FORMAT (r_type) == R_IA64_FORMAT_64LSB)
+    *reloc_addr = value;
+  else if (R_IA64_FORMAT (r_type) == R_IA64_FORMAT_32LSB)
+    *(int *) reloc_addr = value;
+  else if (r_type == R_IA64_IPLTLSB)
+    {
+      reloc_addr[0] = 0;
+      reloc_addr[1] = 0;
+    }
+  else
+    _dl_reloc_bad_type (map, r_type, 0);
+}
+
+/* Let do-rel.h know that on IA-64 if l_addr is 0, all RELATIVE relocs
+   can be skipped.  */
+#define ELF_MACHINE_REL_RELATIVE 1
+
+static inline void
+__attribute ((always_inline))
+elf_machine_rela_relative (Elf64_Addr l_addr, const Elf64_Rela *reloc,
+			   void *const reloc_addr_arg)
+{
+  Elf64_Addr *const reloc_addr = reloc_addr_arg;
+  /* ??? Ignore MSB and Instruction format for now.  */
+  assert (ELF64_R_TYPE (reloc->r_info) == R_IA64_REL64LSB);
+
+  *reloc_addr += l_addr;
+}
+
+/* Perform a RELATIVE reloc on the .got entry that transfers to the .plt.  */
+static inline void
+__attribute ((always_inline))
+elf_machine_lazy_rel (struct link_map *map, struct r_scope_elem *scope[],
+		      Elf64_Addr l_addr, const Elf64_Rela *reloc,
+		      int skip_ifunc)
+{
+  Elf64_Addr *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned long int r_type = ELF64_R_TYPE (reloc->r_info);
+
+  if (r_type == R_IA64_IPLTLSB)
+    {
+      reloc_addr[0] += l_addr;
+      reloc_addr[1] += l_addr;
+    }
+  else if (r_type == R_IA64_NONE)
+    return;
+  else
+    _dl_reloc_bad_type (map, r_type, 1);
+}
+
+#endif /* RESOLVE_MAP */
--- /dev/null
+++ a/sysdeps/ia64/dl-tls.h
@@ -0,0 +1,30 @@
+/* Thread-local storage handling in the ELF dynamic linker.  IA-64 version.
+   Copyright (C) 2002-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+
+/* On IA-64 the __tls_get_addr function take the module ID and the
+   offset as parameters.  */
+#define GET_ADDR_ARGS		size_t tls_ia64_m, size_t tls_ia64_offset
+#define GET_ADDR_PARAM		tls_ia64_m, tls_ia64_offset
+#define GET_ADDR_MODULE		tls_ia64_m
+#define GET_ADDR_OFFSET		tls_ia64_offset
+
+/* We have no tls_index type.  */
+#define DONT_USE_TLS_INDEX	1
+
+extern void *__tls_get_addr (size_t m, size_t offset);
--- /dev/null
+++ a/sysdeps/ia64/dl-trampoline.S
@@ -0,0 +1,538 @@
+/* PLT trampolines.  ia64 version.
+   Copyright (C) 2005-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#undef ret
+
+/*
+   This code is used in dl-runtime.c to call the `_dl_fixup' function
+   and then redirect to the address it returns. `_dl_fixup()' takes two
+   arguments, however _dl_profile_fixup() takes five.
+
+   The ABI specifies that we will never see more than 8 input
+   registers to a function call, thus it is safe to simply allocate
+   those, and simpler than playing stack games.  */
+
+/* Used to save and restore 8 incoming fp registers */
+#define RESOLVE_FRAME_SIZE (16*8)
+
+ENTRY(_dl_runtime_resolve)
+	{ .mmi
+	  .prologue
+	  .save ar.pfs, r40
+	  alloc loc0 = ar.pfs, 8, 6, 2, 0
+	  /* Use the 16 byte scratch area. r2 will start at f8 and
+	     r3 will start at f9.  */
+	  adds r2 = -(RESOLVE_FRAME_SIZE - 16), r12
+	  adds r3 = -(RESOLVE_FRAME_SIZE - 32), r12
+	}
+	{ .mii
+	  .fframe RESOLVE_FRAME_SIZE
+	  adds r12 = -RESOLVE_FRAME_SIZE, r12
+	  .save rp, loc1
+	  mov loc1 = b0
+	  .body
+	  mov loc2 = r8		/* preserve struct value register */
+	  ;;
+	}
+	{ .mii
+	  mov loc3 = r9		/* preserve language specific register */
+	  mov loc4 = r10	/* preserve language specific register */
+	  mov loc5 = r11	/* preserve language specific register */
+	}
+	{ .mmi
+	  stf.spill [r2] = f8, 32
+	  stf.spill [r3] = f9, 32
+	  mov out0 = r16
+	  ;;
+	}
+	{ .mmi
+	  stf.spill [r2] = f10, 32
+	  stf.spill [r3] = f11, 32
+	  shl out1 = r15, 4
+	  ;;
+	}
+	{ .mmi
+	  stf.spill [r2] = f12, 32
+	  stf.spill [r3] = f13, 32
+	  /* Relocation record is 24 byte. */
+	  shladd out1 = r15, 3, out1
+	  ;;
+	}
+	{ .mmb
+	  stf.spill [r2] = f14
+	  stf.spill [r3] = f15
+	  br.call.sptk.many b0 = _dl_fixup
+	}
+	{ .mii
+	  /* Skip the 16byte scratch area.  */
+	  adds r2 = 16, r12
+	  adds r3 = 32, r12
+	  mov b6 = ret0
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f8 = [r2], 32
+	  ldf.fill f9 = [r3], 32
+	  mov b0 = loc1
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f10 = [r2], 32
+	  ldf.fill f11 = [r3], 32
+	  mov gp = ret1
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f12 = [r2], 32
+	  ldf.fill f13 = [r3], 32
+	  mov ar.pfs = loc0
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f14 = [r2], 32
+	  ldf.fill f15 = [r3], 32
+	  .restore sp		/* pop the unwind frame state */
+	  adds r12 = RESOLVE_FRAME_SIZE, r12
+	  ;;
+	}
+	{ .mii
+	  mov r9 = loc3		/* restore language specific register */
+	  mov r10 = loc4	/* restore language specific register */
+	  mov r11 = loc5	/* restore language specific register */
+	}
+	{ .mii
+	  mov r8 = loc2		/* restore struct value register */
+	  ;;
+	}
+	/* An alloc is needed for the break system call to work.
+	   We don't care about the old value of the pfs register.  */
+	{ .mmb
+	  .prologue
+	  .body
+	  alloc r2 = ar.pfs, 0, 0, 8, 0
+	  br.sptk.many b6
+	  ;;
+	}
+END(_dl_runtime_resolve)
+
+
+/* The fourth argument to _dl_profile_fixup and the third one to
+   _dl_audit_pltexit are a pointer to La_ia64_regs:
+
+   8byte r8
+   8byte r9
+   8byte r10
+   8byte r11
+   8byte in0
+   8byte in1
+   8byte in2
+   8byte in3
+   8byte in4
+   8byte in5
+   8byte in6
+   8byte in7
+   16byte f8
+   16byte f9
+   16byte f10
+   16byte f11
+   16byte f12
+   16byte f13
+   16byte f14
+   16byte f15
+   8byte ar.unat
+   8byte sp
+
+   The fifth argument to _dl_profile_fixup is a pointer to long int.
+   The fourth argument to _dl_audit_pltexit is a pointer to
+   La_ia64_retval:
+
+   8byte r8
+   8byte r9
+   8byte r10
+   8byte r11
+   16byte f8
+   16byte f9
+   16byte f10
+   16byte f11
+   16byte f12
+   16byte f13
+   16byte f14
+   16byte f15
+
+  Since stack has to be 16 byte aligned, the stack allocation is in
+  16byte increment. Before calling _dl_profile_fixup, the stack will
+  look like
+
+  psp	new frame_size
+  +16	La_ia64_regs
+  sp	scratch
+
+ */
+
+#define PLTENTER_FRAME_SIZE (4*8 + 8*8 + 8*16 + 2*8 + 16)
+#define PLTEXIT_FRAME_SIZE (PLTENTER_FRAME_SIZE + 4*8 + 8*16)
+
+#if !defined PROF && defined SHARED
+ENTRY(_dl_runtime_profile)
+	{ .mii
+	  .prologue
+	  .save ar.pfs, r40
+	  alloc loc0 = ar.pfs, 8, 12, 8, 0
+	  .vframe loc10
+	  mov loc10 = r12
+	  .save rp, loc1
+	  mov loc1 = b0
+	}
+	{ .mii
+	  .save ar.unat, r17
+	  mov r17 = ar.unat
+	  .save ar.lc, loc6
+	  mov loc6 = ar.lc
+	  mov loc11 = gp
+	}
+	{ .mii
+	  .body
+	  /* There is a 16 byte scratch area. r2 will start at r8 and
+	     r3 will start at r9 for La_ia64_regs.  */
+	  adds r2 = -(PLTENTER_FRAME_SIZE - 16), r12
+	  adds r3 = -(PLTENTER_FRAME_SIZE - 24), r12
+	  adds r12 = -PLTENTER_FRAME_SIZE, r12
+	  ;;
+	}
+	{ .mmi
+	  st8 [r2] = r8, 16;
+	  st8 [r3] = r9, 16;
+	  mov out2 = b0		/* needed by _dl_fixup_profile */
+	  ;;
+	}
+	{ .mmi
+	  st8 [r2] = r10, 16;
+	  st8 [r3] = r11, 16;
+	  adds out3 = 16, r12	/* pointer to La_ia64_regs */
+	  ;;
+	}
+	{ .mmi
+	  .mem.offset 0, 0
+	  st8.spill [r2] = in0, 16
+	  .mem.offset 8, 0
+	  st8.spill [r3] = in1, 16
+	  mov out4 = loc10	/* pointer to new frame size  */
+	  ;;
+	}
+	{ .mmi
+	  .mem.offset 0, 0
+	  st8.spill [r2] = in2, 16
+	  .mem.offset 8, 0
+	  st8.spill [r3] = in3, 16
+	  mov loc2 = r8		/* preserve struct value register */
+	  ;;
+	}
+	{ .mmi
+	  .mem.offset 0, 0
+	  st8.spill [r2] = in4, 16
+	  .mem.offset 8, 0
+	  st8.spill [r3] = in5, 16
+	  mov loc3 = r9		/* preserve language specific register */
+	  ;;
+	}
+	{ .mmi
+	  .mem.offset 0, 0
+	  st8 [r2] = in6, 16
+	  .mem.offset 8, 0
+	  st8 [r3] = in7, 24	/* adjust for f9 */
+	  mov loc4 = r10	/* preserve language specific register */
+	  ;;
+	}
+	{ .mii
+	  mov r18 = ar.unat	/* save it in La_ia64_regs */
+	  mov loc7 = out3	/* save it for _dl_audit_pltexit */
+	  mov loc5 = r11	/* preserve language specific register */
+	}
+	{ .mmi
+	  stf.spill [r2] = f8, 32
+	  stf.spill [r3] = f9, 32
+	  mov out0 = r16	/* needed by _dl_fixup_profile */
+	  ;;
+	}
+	{ .mii
+	  mov ar.unat = r17	/* restore it for function call */
+	  mov loc8 = r16	/* save it for _dl_audit_pltexit */
+	  nop.i 0x0
+	}
+	{ .mmi
+	  stf.spill [r2] = f10, 32
+	  stf.spill [r3] = f11, 32
+	  shl out1 = r15, 4
+	  ;;
+	}
+	{ .mmi
+	  stf.spill [r2] = f12, 32
+	  stf.spill [r3] = f13, 32
+	  /* Relocation record is 24 byte. */
+	  shladd out1 = r15, 3, out1
+	  ;;
+	}
+	{ .mmi
+	  stf.spill [r2] = f14, 32
+	  stf.spill [r3] = f15, 24
+	  mov loc9 = out1	/* save it for _dl_audit_pltexit */
+	  ;;
+	}
+	{ .mmb
+	  st8 [r2] = r18	/* store ar.unat */
+	  st8 [r3] = loc10	/* store sp */
+	  br.call.sptk.many b0 = _dl_profile_fixup
+	}
+	{ .mii
+	  /* Skip the 16byte scratch area, 4 language specific GRs and
+	     8 incoming GRs to restore incoming fp registers.  */
+	  adds r2 = (4*8 + 8*8 + 16), r12
+	  adds r3 = (4*8 + 8*8 + 32), r12
+	  mov b6 = ret0
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f8 = [r2], 32
+	  ldf.fill f9 = [r3], 32
+	  mov gp = ret1
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f10 = [r2], 32
+	  ldf.fill f11 = [r3], 32
+	  mov r8 = loc2		/* restore struct value register */
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f12 = [r2], 32
+	  ldf.fill f13 = [r3], 32
+	  mov r9 = loc3		/* restore language specific register */
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f14 = [r2], 32
+	  ldf.fill f15 = [r3], 32
+	  mov r10 = loc4	/* restore language specific register */
+	  ;;
+	}
+	{ .mii
+	  ld8 r15 = [loc10]	/* load the new frame size */
+	  mov r11 = loc5	/* restore language specific register */
+	  ;;
+	  cmp.eq p6, p7 = -1, r15
+	  ;;
+	}
+	{ .mii
+(p7)	  cmp.eq p8, p9 = 0, r15
+(p6)	  mov b0 = loc1
+(p6)	  mov ar.lc = loc6
+	}
+	{ .mib
+	  nop.m 0x0
+(p6)	  mov ar.pfs = loc0
+(p6)	  br.cond.dptk.many .Lresolved
+	  ;;
+	}
+
+	/* At this point, the stack looks like
+
+	  +psp	free
+	  +16	La_ia64_regs
+	  sp	scratch
+
+	  We need to keep the current stack and call the resolved
+	  function by copying the r15 byte from sp + PLTENTER_FRAME_SIZE
+	  + 16 (scratch area) to sp + 16 (scratch area). Since stack
+	  has to be 16byte aligned, we around r15 up to 16byte.  */
+
+	{ .mbb
+(p9)	  adds r15 = 15, r15
+(p8)	  br.cond.dptk.many .Lno_new_frame
+	  nop.b 0x0
+	  ;;
+	}
+	{ .mmi
+	  and r15 = -16, r15
+	  ;;
+	  /* We don't copy the 16byte scratch area. Prepare r16/r17 as
+	     destination.  */
+	  sub r16 = r12, r15
+	  sub r17 = r12, r15
+	  ;;
+	}
+	{ .mii
+	  adds r16 = 16, r16
+	  adds r17 = 24, r17
+	  sub r12 = r12, r15		/* Adjust stack  */
+	  ;;
+	}
+	{ .mii
+	  nop.m 0x0
+	  shr r15 = r15, 4
+	  ;;
+	  adds r15 = -1, r15
+	  ;;
+	}
+	{ .mii
+	  /* Skip the 16byte scratch area. Prepare r2/r3 as source.  */
+	  adds r2 = 16, loc10
+	  adds r3 = 24, loc10
+	  mov ar.lc = r15
+	  ;;
+	}
+.Lcopy:
+	{ .mmi
+	  ld8 r18 = [r2], 16
+	  ld8 r19 = [r3], 16
+	  nop.i 0x0
+	  ;;
+	}
+	{ .mmb
+	  st8 [r16] = r18, 16
+	  st8 [r17] = r19, 16
+	  br.cloop.sptk.few .Lcopy
+	}
+.Lno_new_frame:
+	{ .mii
+	  mov out0 = in0
+	  mov out1 = in1
+	  mov out2 = in2
+	}
+	{ .mii
+	  mov out3 = in3
+	  mov out4 = in4
+	  mov out5 = in5
+	}
+	{ .mib
+	  mov out6 = in6
+	  mov out7 = in7
+	  /* Call the resolved function  */
+	  br.call.sptk.many b0 = b6
+	}
+	{ .mii
+	  /* Prepare stack for _dl_audit_pltexit. Loc10 has the original
+	     stack pointer.  */
+	  adds r12 = -PLTEXIT_FRAME_SIZE, loc10
+	  adds r2 = -(PLTEXIT_FRAME_SIZE - 16), loc10
+	  adds r3 = -(PLTEXIT_FRAME_SIZE - 24), loc10
+	  ;;
+	}
+	{ .mmi
+	  /* Load all possible return values into buffer.  */
+	  st8 [r2] = r8, 16
+	  st8 [r3] = r9, 16
+	  mov out0 = loc8
+	  ;;
+	}
+	{ .mmi
+	  st8 [r2] = r10, 16
+	  st8 [r3] = r11, 24
+	  mov out1 = loc9
+	  ;;
+	}
+	{ .mmi
+	  stf.spill [r2] = f8, 32
+	  stf.spill [r3] = f9, 32
+	  mov out2 = loc7		/* Pointer to La_ia64_regs */
+	  ;;
+	}
+	{ .mmi
+	  stf.spill [r2] = f10, 32
+	  stf.spill [r3] = f11, 32
+	  adds out3 = 16, r12		/* Pointer to La_ia64_retval */
+	  ;;
+	}
+	{ .mmi
+	  stf.spill [r2] = f12, 32
+	  stf.spill [r3] = f13, 32
+	  /* We need to restore gp for _dl_audit_pltexit. */
+	  mov gp = loc11
+	  ;;
+	}
+	{ .mmb
+	  stf.spill [r2] = f14
+	  stf.spill [r3] = f15
+	  br.call.sptk.many b0 = _dl_audit_pltexit
+	}
+	{ .mmi
+	  /* Load all the non-floating and floating return values. Skip
+	     the 16byte scratch area.  */
+	  adds r2 = 16, r12
+	  adds r3 = 24, r12
+	  nop.i 0x0
+	  ;;
+	}
+	{ .mmi
+	  ld8 r8 = [r2], 16
+	  ld8 r9 = [r3], 16
+	  nop.i 0x0
+	  ;;
+	}
+	{ .mmi
+	  ld8 r10 = [r2], 16
+	  ld8 r11 = [r3], 24
+	  nop.i 0x0
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f8 = [r2], 32
+	  ldf.fill f9 = [r3], 32
+	  mov ar.lc = loc6
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f10 = [r2], 32
+	  ldf.fill f11 = [r3], 32
+	  mov ar.pfs = loc0
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f12 = [r2], 32
+	  ldf.fill f13 = [r3], 32
+	  mov b0 = loc1
+	  ;;
+	}
+	{ .mmi
+	  ldf.fill f14 = [r2]
+	  ldf.fill f15 = [r3]
+	  /* We know that the previous stack pointer, loc10, isn't 0.
+	     We use it to reload p7.  */
+	  cmp.ne p7, p0 = 0, loc10
+	  ;;
+	}
+.Lresolved:
+	{ .mmb
+	  .restore sp
+	  mov r12 = loc10
+(p7)	  br.ret.sptk.many b0
+	  ;;
+	}
+	/* An alloc is needed for the break system call to work. We
+	   don't care about the old value of the pfs register. After
+	   this alloc, we can't use any rotating registers. Otherwise
+	   assembler won't be happy. This has to be at the end.  */
+	{ .mmb
+	  .prologue
+	  .body
+	  alloc r2 = ar.pfs, 0, 0, 8, 0
+	  br.sptk.many b6
+	  ;;
+	}
+END(_dl_runtime_profile)
+#endif
--- /dev/null
+++ a/sysdeps/ia64/elf-initfini.h
@@ -0,0 +1,20 @@
+/* Determine DT_INIT/DT_FINI support in the dynamic loader.  IA64 version.
+   Copyright (C) 2020-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Enable DT_INIT/DT_FINI support.  */
+#define ELF_INITFINI 1
--- /dev/null
+++ a/sysdeps/ia64/entry.h
@@ -0,0 +1,8 @@
+#include <link.h>
+#include <dl-fptr.h>
+
+extern void _start (void);
+
+/* The function's entry point is stored in the first word of the
+   function descriptor (plabel) of _start().  */
+#define ENTRY_POINT ELF_PTR_TO_FDESC (_start)->ip
--- /dev/null
+++ a/sysdeps/ia64/float128-abi.h
@@ -0,0 +1,3 @@
+/* ABI version for _Float128 ABI introduction.  */
+#define FLOAT128_VERSION GLIBC_2.26
+#define FLOAT128_VERSION_M GLIBC_2_26
--- /dev/null
+++ a/sysdeps/ia64/fpu/Makefile
@@ -0,0 +1,34 @@
+ifeq ($(subdir),math)
+#
+# Some files which need to go both into libc and libm have external
+# dependencies which need to be resolved differently for libc
+# vs. libm.  For example, inside libc, __libm_error_support needs to
+# resolve to HIDDEN_JUMPTARGET(__libm_error_support) whereas within
+# libm it always resolves to __libm_error_support.  Such files need to
+# be compiled twice.  Fortunately, math/Makefile already has logic to
+# support this: if a file starts with "s_", make will automatically
+# generate a matching file whose name starts with "m_" which simply
+# includes the corresponding "s_" file.
+#
+duplicated-routines = s_libm_ldexp s_libm_ldexpf s_libm_ldexpl \
+		      s_libm_scalbn s_libm_scalbnf s_libm_scalbnl
+
+libm-sysdep_routines += s_erfc s_erfcf s_erfcl \
+			s_matherrf s_matherrl libm_reduce \
+			libm_error \
+			libm_frexp libm_frexpf libm_frexpl \
+			libm_sincos libm_sincosf libm_sincosl \
+			libm_sincos_large \
+			libm_lgamma libm_lgammaf libm_lgammal \
+			libm_scalblnf \
+			$(duplicated-routines:s_%=m_%)
+
+sysdep_routines += libc_libm_error libm_frexp libm_frexpf libm_frexpl \
+		   $(duplicated-routines)
+
+sysdep-CPPFLAGS += -include libm-symbols.h \
+	-D__POSIX__ -Dopensource \
+	-D_LIB_VERSIONIMF=_LIB_VERSION \
+	-DSIZE_INT_32 -DSIZE_LONG_INT_64 -DSIZE_LONG_LONG_INT_64 \
+	-DSIZE_LONG_64 -DIA64
+endif
--- /dev/null
+++ a/sysdeps/ia64/fpu/README
@@ -0,0 +1,50 @@
+  ----------------------------------------------------------
+  Notes on how to update libm based on Intel's libm releases
+  ----------------------------------------------------------
+
+This source code in this directory is currently based on Intel libm
+v2.1 as available from:
+
+  http://www.intel.com/software/products/opensource/libraries/num.htm
+
+To ease importing, fix some bugs, and simplify integration into libc,
+it is also necessary to apply the patch at:
+
+  ftp://ftp.hpl.hp.com/pub/linux-ia64/intel-libm-041228.diff.gz
+
+The expectation is that Intel will integrate most if not all of these
+changes into future releases of libm, so this patching step can
+hopefully be omitted in the future.
+
+Once the patched libm sources are extracted in a directory $LIBM, they
+can be imported into the libc source tree at $LIBC with the following
+step:
+
+	$ cd $LIBC/src/sysdep/ia64/fpu
+	$ ./import_intel_libm $LIBM
+
+This should produce a number of "Importing..." messages, without
+showing any errors.
+
+At this point, you should be able to build glibc in the usual fashion.
+We assume you do this in directory $OBJ.  Once the build has
+completed, run "make check" to verify that all (math) checks succeed.
+If these checks succeed, you should also run the following commands to
+verify that the new libm doesn't pollute the name-space and has proper
+size-info for the data objects:
+
+	$ cd $LIBC/src/sysdep/ia64/fpu
+	$ import_check $OBJ/math/
+
+There should be no (unexpected) errors reported by this script.
+
+As an optional step, you may also want to confirm that the new libm
+exports the exact same global symbols as the old one.
+
+If you want to see the changes introduced by the "import_intel_libm"
+script, you can run the commands:
+
+	$ cd $LIBC/src/sysdep/ia64/fpu
+	$ import_diffs
+
+That's it.
--- /dev/null
+++ a/sysdeps/ia64/fpu/Versions
@@ -0,0 +1,10 @@
+libc {
+  GLIBC_PRIVATE {
+    __libm_frexp_4; __libm_frexp_4f; __libm_frexp_4l; __libm_error_support;
+  }
+}
+libm {
+  GLIBC_2.2.3 {
+    matherrf; matherrl;
+  }
+}
--- /dev/null
+++ a/sysdeps/ia64/fpu/branred.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/doasin.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/dosincos.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_acos.S
@@ -0,0 +1,878 @@
+.file "acos.s"
+
+
+// Copyright (c) 2000 - 2003 Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 08/17/00 New and much faster algorithm.
+// 08/30/00 Avoided bank conflicts on loads, shortened |x|=1 and x=0 paths,
+//          fixed mfb split issue stalls.
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 08/02/02 New and much faster algorithm II
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+
+// Description
+//=========================================
+// The acos function computes the principal value of the arc cosine of x.
+// acos(0) returns Pi/2, acos(1) returns 0, acos(-1) returns Pi.
+// A domain error occurs for arguments not in the range [-1,+1].
+//
+// The acos function returns the arc cosine in the range [0, Pi] radians.
+//
+// There are 8 paths:
+// 1. x = +/-0.0
+//    Return acos(x) = Pi/2 + x
+//
+// 2. 0.0 < |x| < 0.625
+//    Return acos(x) = Pi/2 - x - x^3 *PolA(x^2)
+//    where PolA(x^2) = A3 + A5*x^2 + A7*x^4 +...+ A35*x^32
+//
+// 3. 0.625 <=|x| < 1.0
+//    Return acos(x) = Pi/2 - asin(x) =
+//                   = Pi/2 - sign(x) * ( Pi/2 - sqrt(R) * PolB(R))
+//    Where R = 1 - |x|,
+//          PolB(R) = B0 + B1*R + B2*R^2 +...+B12*R^12
+//
+//    sqrt(R) is approximated using the following sequence:
+//        y0 = (1 + eps)/sqrt(R) - initial approximation by frsqrta,
+//             |eps| < 2^(-8)
+//        Then 3 iterations are used to refine the result:
+//        H0 = 0.5*y0
+//        S0 = R*y0
+//
+//        d0 = 0.5 - H0*S0
+//        H1 = H0 + d0*H0
+//        S1 = S0 + d0*S0
+//
+//        d1 = 0.5 - H1*S1
+//        H2 = H1 + d0*H1
+//        S2 = S1 + d0*S1
+//
+//        d2 = 0.5 - H2*S2
+//        S3 = S3 + d2*S3
+//
+//        S3 approximates sqrt(R) with enough accuracy for this algorithm
+//
+//    So, the result should be reconstracted as follows:
+//    acos(x) = Pi/2 - sign(x) * (Pi/2 - S3*PolB(R))
+//
+//    But for optimization purposes the reconstruction step is slightly
+//    changed:
+//    acos(x) = Cpi + sign(x)*PolB(R)*S2 - sign(x)*d2*S2*PolB(R)
+//        where Cpi = 0 if x > 0 and Cpi = Pi if x < 0
+//
+// 4. |x| = 1.0
+//    Return acos(1.0) = 0.0, acos(-1.0) = Pi
+//
+// 5. 1.0 < |x| <= +INF
+//    A domain error occurs for arguments not in the range [-1,+1]
+//
+// 6. x = [S,Q]NaN
+//    Return acos(x) = QNaN
+//
+// 7. x is denormal
+//    Return acos(x) = Pi/2 - x,
+//
+// 8. x is unnormal
+//    Normalize input in f8 and return to the very beginning of the function
+//
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input, output
+// f6, f7, f9 -> f15, f32 -> f64
+
+// General registers used:
+// r3, r21 -> r31, r32 -> r38
+
+// Predicate registers used:
+// p0, p6 -> p14
+
+//
+// Assembly macros
+//=========================================
+// integer registers used
+// scratch
+rTblAddr                      = r3
+
+rPiBy2Ptr                     = r21
+rTmpPtr3                      = r22
+rDenoBound                    = r23
+rOne                          = r24
+rAbsXBits                     = r25
+rHalf                         = r26
+r0625                         = r27
+rSign                         = r28
+rXBits                        = r29
+rTmpPtr2                      = r30
+rTmpPtr1                      = r31
+
+// stacked
+GR_SAVE_PFS                   = r32
+GR_SAVE_B0                    = r33
+GR_SAVE_GP                    = r34
+GR_Parameter_X                = r35
+GR_Parameter_Y                = r36
+GR_Parameter_RESULT           = r37
+GR_Parameter_TAG              = r38
+
+// floating point registers used
+FR_X                          = f10
+FR_Y                          = f1
+FR_RESULT                     = f8
+
+
+// scratch
+fXSqr                         = f6
+fXCube                        = f7
+fXQuadr                       = f9
+f1pX                          = f10
+f1mX                          = f11
+f1pXRcp                       = f12
+f1mXRcp                       = f13
+fH                            = f14
+fS                            = f15
+// stacked
+fA3                           = f32
+fB1                           = f32
+fA5                           = f33
+fB2                           = f33
+fA7                           = f34
+fPiBy2                        = f34
+fA9                           = f35
+fA11                          = f36
+fB10                          = f35
+fB11                          = f36
+fA13                          = f37
+fA15                          = f38
+fB4                           = f37
+fB5                           = f38
+fA17                          = f39
+fA19                          = f40
+fB6                           = f39
+fB7                           = f40
+fA21                          = f41
+fA23                          = f42
+fB3                           = f41
+fB8                           = f42
+fA25                          = f43
+fA27                          = f44
+fB9                           = f43
+fB12                          = f44
+fA29                          = f45
+fA31                          = f46
+fA33                          = f47
+fA35                          = f48
+fBaseP                        = f49
+fB0                           = f50
+fSignedS                      = f51
+fD                            = f52
+fHalf                         = f53
+fR                            = f54
+fCloseTo1Pol                  = f55
+fSignX                        = f56
+fDenoBound                    = f57
+fNormX                        = f58
+fX8                           = f59
+fRSqr                         = f60
+fRQuadr                       = f61
+fR8                           = f62
+fX16                          = f63
+fCpi                          = f64
+
+// Data tables
+//==============================================================
+RODATA
+.align 16
+LOCAL_OBJECT_START(acos_base_range_table)
+// Ai: Polynomial coefficients for the acos(x), |x| < .625000
+// Bi: Polynomial coefficients for the acos(x), |x| > .625000
+data8 0xBFDAAB56C01AE468 //A29
+data8 0x3FE1C470B76A5B2B //A31
+data8 0xBFDC5FF82A0C4205 //A33
+data8 0x3FC71FD88BFE93F0 //A35
+data8 0xB504F333F9DE6487, 0x00003FFF //B0
+data8 0xAAAAAAAAAAAAFC18, 0x00003FFC //A3
+data8 0x3F9F1C71BC4A7823 //A9
+data8 0x3F96E8BBAAB216B2 //A11
+data8 0x3F91C4CA1F9F8A98 //A13
+data8 0x3F8C9DDCEDEBE7A6 //A15
+data8 0x3F877784442B1516 //A17
+data8 0x3F859C0491802BA2 //A19
+data8 0x9999999998C88B8F, 0x00003FFB //A5
+data8 0x3F6BD7A9A660BF5E //A21
+data8 0x3F9FC1659340419D //A23
+data8 0xB6DB6DB798149BDF, 0x00003FFA //A7
+data8 0xBFB3EF18964D3ED3 //A25
+data8 0x3FCD285315542CF2 //A27
+data8 0xF15BEEEFF7D2966A, 0x00003FFB //B1
+data8 0x3EF0DDA376D10FB3 //B10
+data8 0xBEB83CAFE05EBAC9 //B11
+data8 0x3F65FFB67B513644 //B4
+data8 0x3F5032FBB86A4501 //B5
+data8 0x3F392162276C7CBA //B6
+data8 0x3F2435949FD98BDF //B7
+data8 0xD93923D7FA08341C, 0x00003FF9 //B2
+data8 0x3F802995B6D90BDB //B3
+data8 0x3F10DF86B341A63F //B8
+data8 0xC90FDAA22168C235, 0x00003FFF // Pi/2
+data8 0x3EFA3EBD6B0ECB9D //B9
+data8 0x3EDE18BA080E9098 //B12
+LOCAL_OBJECT_END(acos_base_range_table)
+
+.section .text
+GLOBAL_LIBM_ENTRY(acos)
+acos_unnormal_back:
+{ .mfi
+      getf.d             rXBits = f8 // grab bits of input value
+      // set p12 = 1 if x is a NaN, denormal, or zero
+      fclass.m           p12, p0 = f8, 0xcf
+      adds               rSign = 1, r0
+}
+{ .mfi
+      addl               rTblAddr = @ltoff(acos_base_range_table),gp
+      // 1 - x = 1 - |x| for positive x
+      fms.s1             f1mX = f1, f1, f8
+      addl               rHalf = 0xFFFE, r0 // exponent of 1/2
+}
+;;
+{ .mfi
+      addl               r0625 = 0x3FE4, r0 // high 16 bits of 0.625
+      // set p8 = 1 if x < 0
+      fcmp.lt.s1         p8, p9 = f8, f0
+      shl                rSign = rSign, 63 // sign bit
+}
+{ .mfi
+      // point to the beginning of the table
+      ld8                rTblAddr = [rTblAddr]
+      // 1 + x = 1 - |x| for negative x
+      fma.s1             f1pX = f1, f1, f8
+      adds               rOne = 0x3FF, r0
+}
+;;
+{ .mfi
+      andcm              rAbsXBits = rXBits, rSign // bits of |x|
+      fmerge.s           fSignX = f8, f1 // signum(x)
+      shl                r0625 = r0625, 48 // bits of DP representation of 0.625
+}
+{ .mfb
+      setf.exp           fHalf = rHalf // load A2 to FP reg
+      fma.s1             fXSqr = f8, f8, f0 // x^2
+      // branch on special path if x is a NaN, denormal, or zero
+(p12) br.cond.spnt       acos_special
+}
+;;
+{ .mfi
+      adds               rPiBy2Ptr = 272, rTblAddr
+      nop.f              0
+      shl                rOne = rOne, 52 // bits of 1.0
+}
+{ .mfi
+      adds               rTmpPtr1 = 16, rTblAddr
+      nop.f              0
+      // set p6 = 1 if |x| < 0.625
+      cmp.lt             p6, p7 = rAbsXBits, r0625
+}
+;;
+{ .mfi
+      ldfpd              fA29, fA31 = [rTblAddr] // A29, fA31
+      // 1 - x = 1 - |x| for positive x
+(p9)  fms.s1             fR = f1, f1, f8
+      // point to coefficient of "near 1" polynomial
+(p7)  adds               rTmpPtr2 = 176, rTblAddr
+}
+{ .mfi
+      ldfpd              fA33, fA35 = [rTmpPtr1], 16 // A33, fA35
+      // 1 + x = 1 - |x| for negative x
+(p8)  fma.s1             fR = f1, f1, f8
+(p6)  adds               rTmpPtr2 = 48, rTblAddr
+}
+;;
+{ .mfi
+      ldfe               fB0 = [rTmpPtr1], 16 // B0
+      nop.f              0
+      nop.i              0
+}
+{ .mib
+      adds               rTmpPtr3 = 16, rTmpPtr2
+      // set p10 = 1 if |x| = 1.0
+      cmp.eq             p10, p0 = rAbsXBits, rOne
+      // branch on special path for |x| = 1.0
+(p10) br.cond.spnt       acos_abs_1
+}
+;;
+{ .mfi
+      ldfe               fA3 = [rTmpPtr2], 48 // A3 or B1
+      nop.f              0
+      adds               rTmpPtr1 = 64, rTmpPtr3
+}
+{ .mib
+      ldfpd              fA9, fA11 = [rTmpPtr3], 16 // A9, A11 or B10, B11
+      // set p11 = 1 if |x| > 1.0
+      cmp.gt             p11, p0 = rAbsXBits, rOne
+      // branch on special path for |x| > 1.0
+(p11) br.cond.spnt       acos_abs_gt_1
+}
+;;
+{ .mfi
+      ldfpd              fA17, fA19 = [rTmpPtr2], 16 // A17, A19 or B6, B7
+      // initial approximation of 1 / sqrt(1 - x)
+      frsqrta.s1         f1mXRcp, p0 = f1mX
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA13, fA15 = [rTmpPtr3] // A13, A15 or B4, B5
+      fma.s1             fXCube = fXSqr, f8, f0 // x^3
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fA5 = [rTmpPtr2], 48 // A5 or B2
+      // initial approximation of 1 / sqrt(1 + x)
+      frsqrta.s1         f1pXRcp, p0 = f1pX
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA21, fA23 = [rTmpPtr1], 16 // A21, A23 or B3, B8
+      fma.s1             fXQuadr = fXSqr, fXSqr, f0 // x^4
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fA7 = [rTmpPtr1] // A7 or Pi/2
+      fma.s1             fRSqr = fR, fR, f0 // R^2
+      nop.i              0
+}
+{ .mfb
+      ldfpd              fA25, fA27 = [rTmpPtr2] // A25, A27 or B9, B12
+      nop.f              0
+(p6)  br.cond.spnt       acos_base_range;
+}
+;;
+
+{ .mfi
+      nop.m              0
+(p9)  fma.s1             fH = fHalf, f1mXRcp, f0 // H0 for x > 0
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+(p9)  fma.s1             fS = f1mX, f1mXRcp, f0  // S0 for x > 0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+(p8)  fma.s1             fH = fHalf, f1pXRcp, f0 // H0 for x < 0
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+(p8)  fma.s1             fS = f1pX, f1pXRcp, f0  // S0 for x > 0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRQuadr = fRSqr, fRSqr, f0 // R^4
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB11 = fB11, fR, fB10
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB1 = fB1, fR, fB0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB5 = fB5, fR, fB4
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB7 = fB7, fR, fB6
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB3 = fB3, fR, fB2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fnma.s1            fD = fH, fS, fHalf // d0 = 1/2 - H0*S0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fR8 = fRQuadr, fRQuadr, f0 // R^4
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB9 = fB9, fR, fB8
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fB12 = fB12, fRSqr, fB11
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fma.s1             fB7 = fB7, fRSqr, fB5
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fB3 = fB3, fRSqr, fB1
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fH = fH, fD, fH // H1 = H0 + H0*d0
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fS = fS, fD, fS // S1 = S0 + S0*d0
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+(p9)  fma.s1             fCpi = f1, f0, f0 // Cpi = 0 if x > 0
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+(p8)  fma.s1             fCpi = fPiBy2, f1, fPiBy2 // Cpi = Pi if x < 0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB12 = fB12, fRSqr, fB9
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB7 = fB7, fRQuadr, fB3
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fnma.s1            fD = fH, fS, fHalf // d1 = 1/2 - H1*S1
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fnma.s1            fSignedS = fSignX, fS, f0 // -signum(x)*S1
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fCloseTo1Pol = fB12, fR8, fB7
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fH = fH, fD, fH // H2 = H1 + H1*d1
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fS = fS, fD, fS // S2 = S1 + S1*d1
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // -signum(x)* S2 = -signum(x)*(S1 + S1*d1)
+      fma.s1             fSignedS = fSignedS, fD, fSignedS
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fnma.s1            fD = fH, fS, fHalf // d2 = 1/2 - H2*S2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // Cpi + signum(x)*PolB*S2
+      fnma.s1            fCpi = fSignedS, fCloseTo1Pol, fCpi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // signum(x)*PolB * S2
+      fnma.s1            fCloseTo1Pol = fSignedS, fCloseTo1Pol, f0
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      // final result for 0.625 <= |x| < 1
+      fma.d.s0           f8 = fCloseTo1Pol, fD, fCpi
+      // exit here for  0.625 <= |x| < 1
+      br.ret.sptk        b0
+}
+;;
+
+
+// here if |x| < 0.625
+.align 32
+acos_base_range:
+{ .mfi
+      ldfe               fCpi = [rPiBy2Ptr] // Pi/2
+      fma.s1             fA33 = fA33, fXSqr, fA31
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA15 = fA15, fXSqr, fA13
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA29 = fA29, fXSqr, fA27
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA25 = fA25, fXSqr, fA23
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA21 = fA21, fXSqr, fA19
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA9 = fA9, fXSqr, fA7
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA5 = fA5, fXSqr, fA3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA35 = fA35, fXQuadr, fA33
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA17 = fA17, fXQuadr, fA15
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fX8 = fXQuadr, fXQuadr, f0 // x^8
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA25 = fA25, fXQuadr, fA21
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA9 = fA9, fXQuadr, fA5
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fCpi = fCpi, f1, f8 // Pi/2 - x
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA35 = fA35, fXQuadr, fA29
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA17 = fA17, fXSqr, fA11
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fX16 = fX8, fX8, f0 // x^16
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA35 = fA35, fX8, fA25
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA17 = fA17, fX8, fA9
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fBaseP = fA35, fX16, fA17
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      // final result for |x| < 0.625
+      fnma.d.s0           f8 = fBaseP, fXCube, fCpi
+      // exit here for |x| < 0.625 path
+      br.ret.sptk        b0
+}
+;;
+
+// here if |x| = 1
+// acos(1) = 0
+// acos(-1) = Pi
+.align 32
+acos_abs_1:
+{ .mfi
+      ldfe               fPiBy2 = [rPiBy2Ptr] // Pi/2
+      nop.f              0
+      nop.i              0
+}
+;;
+.pred.rel "mutex", p8, p9
+{ .mfi
+      nop.m              0
+      // result for x = 1.0
+(p9)  fma.d.s0           f8 = f1, f0, f0 // 0.0
+      nop.i              0
+}
+{.mfb
+      nop.m              0
+      // result for x = -1.0
+(p8)  fma.d.s0           f8 = fPiBy2, f1, fPiBy2 // Pi
+      // exit here for |x| = 1.0
+      br.ret.sptk        b0
+}
+;;
+
+// here if x is a NaN, denormal, or zero
+.align 32
+acos_special:
+{ .mfi
+      // point to Pi/2
+      adds               rPiBy2Ptr = 272, rTblAddr
+      // set p12 = 1 if x is a NaN
+      fclass.m           p12, p0 = f8, 0xc3
+      nop.i              0
+}
+{ .mlx
+      nop.m              0
+      // smallest positive DP normalized number
+      movl               rDenoBound = 0x0010000000000000
+}
+;;
+{ .mfi
+      ldfe               fPiBy2 = [rPiBy2Ptr] // Pi/2
+      // set p13 = 1 if x = 0.0
+      fclass.m           p13, p0 = f8, 0x07
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fnorm.s1           fNormX = f8
+      nop.i              0
+}
+;;
+{ .mfb
+      // load smallest normal to FP reg
+      setf.d             fDenoBound = rDenoBound
+      // answer if x is a NaN
+(p12) fma.d.s0           f8 = f8,f1,f0
+      // exit here if x is a NaN
+(p12) br.ret.spnt        b0
+}
+;;
+{ .mfi
+      nop.m              0
+      // absolute value of normalized x
+      fmerge.s           fNormX = f1, fNormX
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      // final result for x = 0
+(p13) fma.d.s0           f8 = fPiBy2, f1, f8
+      // exit here if x = 0.0
+(p13) br.ret.spnt        b0
+}
+;;
+// if we still here then x is denormal or unnormal
+{ .mfi
+      nop.m              0
+      // set p14 = 1 if normalized x is greater than or
+      // equal to the smallest denormalized value
+      // So, if p14 is set to 1 it means that we deal with
+      // unnormal rather than with "true" denormal
+      fcmp.ge.s1         p14, p0 = fNormX, fDenoBound
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+(p14) fcmp.eq.s0         p6, p0 = f8, f0      // Set D flag if x unnormal
+      nop.i              0
+}
+{ .mfb
+      nop.m              0
+      // normalize unnormal input
+(p14) fnorm.s1           f8 = f8
+      // return to the main path
+(p14) br.cond.sptk       acos_unnormal_back
+}
+;;
+// if we still here it means that input is "true" denormal
+{ .mfb
+      nop.m              0
+      // final result if x is denormal
+      fms.d.s0           f8 = fPiBy2, f1, f8 // Pi/2 - x
+      // exit here if x is denormal
+      br.ret.sptk        b0
+}
+;;
+
+// here if |x| > 1.0
+// error handler should be called
+.align 32
+acos_abs_gt_1:
+{ .mfi
+      alloc              r32 = ar.pfs, 0, 3, 4, 0 // get some registers
+      fmerge.s           FR_X = f8,f8
+      nop.i              0
+}
+{ .mfb
+      mov                GR_Parameter_TAG = 58 // error code
+      frcpa.s0           FR_RESULT, p0 = f0,f0
+      // call error handler routine
+      br.cond.sptk       __libm_error_region
+}
+;;
+GLOBAL_LIBM_END(acos)
+libm_alias_double_other (acos, acos)
+
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfd [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfd [GR_Parameter_X] = FR_X                  // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = FR_RESULT             // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#         // Call error handling function
+};;
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_acosf.S
@@ -0,0 +1,694 @@
+.file "acosf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 06/28/00 Improved speed
+// 06/31/00 Changed register allocation because of some duplicate macros
+//          moved nan exit bundle up to gain a cycle.
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 08/17/00 Changed predicate register macro-usage to direct predicate
+//          names due to an assembler bug.
+// 10/17/00 Improved speed of x=0 and x=1 paths, set D flag if x denormal.
+// 03/13/01 Corrected sign of imm1 value in dep instruction.
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+// 04/17/03 Moved mutex after label
+
+
+// Description
+//=========================================
+// The acosf function computes the principle value of the arc sine of x.
+// A domain error occurs for arguments not in the range [-1,+1].
+
+// The acosf function returns the arc cosine in the range [0, +pi] radians.
+// acos(1) returns +0
+// acos(x) returns a Nan and raises the invalid exception for |x| >1
+
+// |x| <= sqrt(2)/2. get Ax and Bx
+
+// poly_p1 = x p1
+// poly_p3 = x2 p4 + p3
+// poly_p1 = x2 (poly_p1) + x  = x2(x p1) + x
+// poly_p2 = x2( poly_p3) + p2 = x2(x2 p4 + p3) + p2
+
+// poly_Ax = x5(x2( poly_p3) + p2) + x2(x p1) + x
+//         = x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x
+
+// poly_p7 = x2 p8 + p7
+// poly_p5 = x2 p6 + p5
+
+// poly_p7 = x4 p9 + (x2 p8 + p7)
+// poly_Bx = x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5
+
+// sinf1 = x11(x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5) + x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x
+//       = x19 p9 + x17 p8 + x15 p7 x13 p6 + x11 p5 + x9 p4 + x7 p3 + x5 p2 + x3 p1 + x
+// answer1 = pi/2 - sinf1
+
+
+
+// |x| >  sqrt(2)/2
+
+// Get z = sqrt(1-x2)
+
+// Get polynomial in t = 1-x2
+
+// t2      = t t
+// t4      = t2 t2
+
+// poly_p4 = t p5 + p4
+// poly_p1 = t p1 + 1
+
+// poly_p6 = t p7 + p6
+// poly_p2 = t p3 + p2
+
+// poly_p8 = t p9 + p8
+
+// poly_p4 = t2 poly_p6 + poly_p4
+//         = t2 (t p7 + p6) + (t p5 + p4)
+
+// poly_p2 = t2 poly_p2 + poly_p1
+//         = t2 (t p3 + p2) + (t p1 + 1)
+
+// poly_p4 = t4 poly_p8 + poly_p4
+//         = t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4))
+
+// P(t)    = poly_p2 + t4 poly_p8
+//         = t2 (t p3 + p2) + (t p1 + 1) + t4 (t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4)))
+//         = t3 p3 + t2 p2 + t p1 + 1 + t9 p9 + t8 p8 + t7 p7 + t6 p6 + t5 p5 + t4 p4
+
+
+//  answer2 = sign(x) z P(t)       if x>0
+//          = sign(x) z P(t) + pi  if x<0
+
+
+//
+// Assembly macros
+//=========================================
+
+// predicate registers
+//acosf_pred_LEsqrt2by2            = p7
+//acosf_pred_GTsqrt2by2            = p8
+
+// integer registers
+ACOSF_Addr1                      = r33
+ACOSF_Addr2                      = r34
+ACOSF_GR_1by2                    = r35
+
+ACOSF_GR_3by2                    = r36
+ACOSF_GR_5by2                    = r37
+
+GR_SAVE_B0                    = r38
+GR_SAVE_PFS                   = r39
+GR_SAVE_GP                    = r40
+
+GR_Parameter_X                = r41
+GR_Parameter_Y                = r42
+GR_Parameter_RESULT           = r43
+GR_Parameter_TAG              = r44
+
+// floating point registers
+
+acosf_y                          = f32
+acosf_abs_x                      = f33
+acosf_x2                         = f34
+acosf_sgn_x                      = f35
+
+acosf_1by2                       = f36
+acosf_3by2                       = f37
+acosf_5by2                       = f38
+acosf_coeff_P3                   = f39
+acosf_coeff_P8                   = f40
+
+acosf_coeff_P1                   = f41
+acosf_coeff_P4                   = f42
+acosf_coeff_P5                   = f43
+acosf_coeff_P2                   = f44
+acosf_coeff_P7                   = f45
+
+acosf_coeff_P6                   = f46
+acosf_coeff_P9                   = f47
+acosf_x2                         = f48
+acosf_x3                         = f49
+acosf_x4                         = f50
+
+acosf_x8                         = f51
+acosf_x5                         = f52
+acosf_const_piby2                = f53
+acosf_const_sqrt2by2             = f54
+acosf_x11                        = f55
+
+acosf_poly_p1                    = f56
+acosf_poly_p3                    = f57
+acosf_sinf1                      = f58
+acosf_poly_p2                    = f59
+acosf_poly_Ax                    = f60
+
+acosf_poly_p7                    = f61
+acosf_poly_p5                    = f62
+acosf_sgnx_t4                    = f63
+acosf_poly_Bx                    = f64
+acosf_t                          = f65
+
+acosf_yby2                       = f66
+acosf_B                          = f67
+acosf_B2                         = f68
+acosf_Az                         = f69
+acosf_dz                         = f70
+
+acosf_Sz                         = f71
+acosf_d2z                        = f72
+acosf_Fz                         = f73
+acosf_z                          = f74
+acosf_sgnx_z                     = f75
+
+acosf_t2                         = f76
+acosf_2poly_p4                   = f77
+acosf_2poly_p6                   = f78
+acosf_2poly_p1                   = f79
+acosf_2poly_p2                   = f80
+
+acosf_2poly_p8                   = f81
+acosf_t4                         = f82
+acosf_Pt                         = f83
+acosf_sgnx_2poly_p2              = f84
+acosf_sgn_x_piby2                = f85
+
+acosf_poly_p7a                   = f86
+acosf_2poly_p4a                  = f87
+acosf_2poly_p4b                  = f88
+acosf_2poly_p2a                  = f89
+acosf_poly_p1a                   = f90
+
+
+
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(acosf_coeff_1_table)
+data8 0x3FC5555607DCF816 // P1
+data8 0x3F9CF81AD9BAB2C6 // P4
+data8 0x3FC59E0975074DF3 // P7
+data8 0xBFA6F4CC2780AA1D // P6
+data8 0x3FC2DD45292E93CB // P9
+data8 0x3fe6a09e667f3bcd // sqrt(2)/2
+LOCAL_OBJECT_END(acosf_coeff_1_table)
+
+LOCAL_OBJECT_START(acosf_coeff_2_table)
+data8 0x3FA6F108E31EFBA6 // P3
+data8 0xBFCA31BF175D82A0 // P8
+data8 0x3FA30C0337F6418B // P5
+data8 0x3FB332C9266CB1F9 // P2
+data8 0x3ff921fb54442d18 // pi_by_2
+LOCAL_OBJECT_END(acosf_coeff_2_table)
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(acosf)
+
+// Load the addresses of the two tables.
+// Then, load the coefficients and other constants.
+
+{     .mfi
+     alloc      r32            = ar.pfs,1,8,4,0
+     fnma.s1   acosf_t        =    f8,f8,f1
+     dep.z ACOSF_GR_1by2 =    0x3f,24,8    // 0x3f000000
+}
+{     .mfi
+     addl ACOSF_Addr1    =    @ltoff(acosf_coeff_1_table),gp
+     fma.s1    acosf_x2       =    f8,f8,f0
+     addl      ACOSF_Addr2    =    @ltoff(acosf_coeff_2_table),gp ;;
+}
+
+
+{     .mfi
+     ld8       ACOSF_Addr1    =    [ACOSF_Addr1]
+     fmerge.s  acosf_abs_x    =    f1,f8
+     dep ACOSF_GR_3by2 =    -1,r0,22,8     // 0x3fc00000
+}
+{     .mlx
+     nop.m                      999
+     movl      ACOSF_GR_5by2  =    0x40200000;;
+}
+
+
+
+{     .mfi
+     setf.s    acosf_1by2     =    ACOSF_GR_1by2
+     fmerge.s  acosf_sgn_x    =    f8,f1
+     nop.i                      999
+}
+{     .mfi
+     ld8       ACOSF_Addr2    =    [ACOSF_Addr2]
+     nop.f 0
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     setf.s    acosf_5by2     =    ACOSF_GR_5by2
+     fcmp.lt.s1 p11,p12 = f8,f0
+     nop.i                      999;;
+}
+
+{ .mmf
+     ldfpd     acosf_coeff_P1,acosf_coeff_P4 =    [ACOSF_Addr1],16
+     setf.s    acosf_3by2     =    ACOSF_GR_3by2
+     fclass.m.unc p8,p0      = f8, 0xc3 ;;	//@qnan | @snan
+}
+
+
+{     .mfi
+     ldfpd     acosf_coeff_P7,acosf_coeff_P6 =    [ACOSF_Addr1],16
+     fma.s1    acosf_t2                      =    acosf_t,acosf_t,f0
+     nop.i                                     999
+}
+{     .mfi
+     ldfpd     acosf_coeff_P3,acosf_coeff_P8 =    [ACOSF_Addr2],16
+     fma.s1    acosf_x4                      =    acosf_x2,acosf_x2,f0
+     nop.i                                     999;;
+}
+
+
+{     .mfi
+     ldfpd     acosf_coeff_P9,acosf_const_sqrt2by2     =    [ACOSF_Addr1]
+     fclass.m.unc p10,p0      = f8, 0x07	//@zero
+     nop.i                                     999
+}
+{     .mfi
+     ldfpd     acosf_coeff_P5,acosf_coeff_P2 =    [ACOSF_Addr2],16
+     fma.s1    acosf_x3  =    f8,acosf_x2,f0
+     nop.i                                     999;;
+}
+
+
+{     .mfi
+     ldfd      acosf_const_piby2   =    [ACOSF_Addr2]
+     frsqrta.s1     acosf_B,p0                   =    acosf_t
+     nop.i                                               999
+}
+{     .mfb
+     nop.m                                               999
+(p8) fma.s.s0 f8                = f8,f1,f0
+(p8) br.ret.spnt   b0 ;;  // Exit if x=nan
+}
+
+
+{     .mfb
+     nop.m                 999
+     fcmp.eq.s1 p6,p0 = acosf_abs_x,f1
+(p10) br.cond.spnt  ACOSF_ZERO ;;     // Branch if x=0
+}
+
+{     .mfi
+     nop.m                 999
+     fcmp.gt.s1 p9,p0 = acosf_abs_x,f1
+     nop.i                 999;;
+}
+
+{     .mfi
+     nop.m                 999
+     fma.s1    acosf_x8  =    acosf_x4,acosf_x4,f0
+     nop.i                 999
+}
+{     .mfb
+     nop.m                      999
+     fma.s1    acosf_t4  =    acosf_t2,acosf_t2,f0
+(p6) br.cond.spnt  ACOSF_ABS_ONE ;;     // Branch if |x|=1
+}
+
+{     .mfi
+     nop.m                 999
+     fma.s1    acosf_x5  =    acosf_x2,acosf_x3,f0
+     nop.i                 999
+}
+{     .mfb
+(p9) mov            GR_Parameter_TAG = 59
+     fma.s1    acosf_yby2     =    acosf_t,acosf_1by2,f0
+(p9) br.cond.spnt  __libm_error_region ;;    // Branch if |x|>1
+}
+
+
+{     .mfi
+     nop.m                 999
+     fma.s1    acosf_Az  =    acosf_t,acosf_B,f0
+     nop.i                 999
+}
+{     .mfi
+     nop.m                 999
+     fma.s1    acosf_B2  =    acosf_B,acosf_B,f0
+     nop.i                 999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_poly_p1  =    f8,acosf_coeff_P1,f0
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_2poly_p1 =    acosf_coeff_P1,acosf_t,f1
+     nop.i                      999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_poly_p3  =    acosf_coeff_P4,acosf_x2,acosf_coeff_P3
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_2poly_p6 =    acosf_coeff_P7,acosf_t,acosf_coeff_P6
+     nop.i                      999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_poly_p7  =    acosf_x2,acosf_coeff_P8,acosf_coeff_P7
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_2poly_p2 =    acosf_coeff_P3,acosf_t,acosf_coeff_P2
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_poly_p5  =    acosf_x2,acosf_coeff_P6,acosf_coeff_P5
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_2poly_p4 =    acosf_coeff_P5,acosf_t,acosf_coeff_P4
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                 999
+     fma.s1    acosf_x11 =    acosf_x8,acosf_x3,f0
+     nop.i                 999
+}
+{     .mfi
+     nop.m                 999
+     fnma.s1   acosf_dz  =    acosf_B2,acosf_yby2,acosf_1by2
+     nop.i                 999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_poly_p1a =    acosf_x2,acosf_poly_p1,f8
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_2poly_p8 =    acosf_coeff_P9,acosf_t,acosf_coeff_P8
+     nop.i                      999;;
+}
+
+
+// Get the absolute value of x and determine the region in which x lies
+
+{     .mfi
+     nop.m                      999
+     fcmp.le.s1     p7,p8 = acosf_abs_x,acosf_const_sqrt2by2
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_poly_p2  =    acosf_x2,acosf_poly_p3,acosf_coeff_P2
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_poly_p7a =    acosf_x4,acosf_coeff_P9,acosf_poly_p7
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    acosf_2poly_p2a =    acosf_2poly_p2,acosf_t2,acosf_2poly_p1
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                                                         999
+(p8) fma.s1    acosf_sgnx_t4  =    acosf_sgn_x,acosf_t4,f0
+     nop.i                                                         999
+}
+{     .mfi
+     nop.m                      999
+(p8) fma.s1    acosf_2poly_p4a =    acosf_2poly_p6,acosf_t2,acosf_2poly_p4
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                 999
+(p8) fma.s1    acosf_Sz  =    acosf_5by2,acosf_dz,acosf_3by2
+     nop.i                 999
+}
+{     .mfi
+     nop.m                 999
+(p8) fma.s1    acosf_d2z =    acosf_dz,acosf_dz,f0
+     nop.i                 999;;
+}
+
+
+{     .mfi
+     nop.m                           999
+(p8) fnma.d.s1   acosf_sgn_x_piby2 =    acosf_sgn_x,acosf_const_piby2,acosf_const_piby2
+     nop.i                           999
+}
+{     .mfi
+     nop.m                      999
+(p7) fma.s1    acosf_poly_Ax  =    acosf_x5,acosf_poly_p2,acosf_poly_p1a
+     nop.i                 999;;
+}
+
+{     .mfi
+     nop.m                      999
+(p7) fma.s1    acosf_poly_Bx  =    acosf_x4,acosf_poly_p7a,acosf_poly_p5
+     nop.i                      999
+}
+{     .mfi
+     nop.m                           999
+(p8) fma.s1    acosf_sgnx_2poly_p2 =    acosf_sgn_x,acosf_2poly_p2a,f0
+     nop.i                           999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fcmp.eq.s0 p6,p0 = f8,f0      // Only purpose is to set D if x denormal
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+(p8) fma.s1    acosf_2poly_p4b =    acosf_2poly_p8,acosf_t4,acosf_2poly_p4a
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+(p8) fma.s1    acosf_Fz  =    acosf_d2z,acosf_Sz,acosf_dz
+     nop.i                 999;;
+}
+
+
+{     .mfi
+     nop.m                 999
+(p8) fma.d.s1  acosf_Pt  =    acosf_2poly_p4b,acosf_sgnx_t4,acosf_sgnx_2poly_p2
+     nop.i                 999;;
+}
+
+{     .mfi
+     nop.m                 999
+(p8) fma.d.s1  acosf_z   =    acosf_Az,acosf_Fz,acosf_Az
+     nop.i                 999 ;;
+}
+
+{     .mfi
+     nop.m                      999
+(p7) fma.d.s1  acosf_sinf1    =    acosf_x11,acosf_poly_Bx,acosf_poly_Ax
+     nop.i                      999;;
+}
+
+.pred.rel "mutex",p8,p7    //acosf_pred_GTsqrt2by2,acosf_pred_LEsqrt2by2
+{     .mfi
+      nop.m            999
+(p8)  fma.s.s0     f8   =    acosf_z,acosf_Pt,acosf_sgn_x_piby2
+      nop.i            999
+}
+
+{     .mfb
+      nop.m            999
+(p7)  fms.s.s0     f8   =    acosf_const_piby2,f1,acosf_sinf1
+      br.ret.sptk b0 ;;
+}
+
+ACOSF_ZERO:
+// Here if x=0
+{     .mfb
+      nop.m                 999
+      fma.s.s0    f8 =    acosf_const_piby2,f1,f0  // acosf(0)=pi/2
+      br.ret.sptk b0 ;;
+}
+
+
+ACOSF_ABS_ONE:
+.pred.rel "mutex",p11,p12
+// Here if |x|=1
+{     .mfi
+      nop.m                 999
+(p11) fma.s.s0    f8 =    acosf_const_piby2,f1,acosf_const_piby2 // acosf(-1)=pi
+      nop.i                 999
+}
+{     .mfb
+      nop.m                 999
+(p12) fma.s.s0    f8 =    f1,f0,f0 // acosf(1)=0
+      br.ret.sptk b0 ;;
+}
+
+GLOBAL_LIBM_END(acosf)
+libm_alias_float_other (acos, acos)
+
+
+// Stack operations when calling error support.
+//       (1)               (2)
+//   sp   -> +          psp -> +
+//           |                 |
+//           |                 | <- GR_Y
+//           |                 |
+//           | <-GR_Y      Y2->|
+//           |                 |
+//           |                 | <- GR_X
+//           |                 |
+//  sp-64 -> +          sp ->  +
+//    save ar.pfs          save b0
+//    save gp
+
+
+// Stack operations when calling error support.
+//     (3) (call)              (4)
+//  psp -> +                   sp -> +
+//         |                         |
+//    R3 ->| <- GR_RESULT            | -> f8
+//         |                         |
+//    Y2 ->| <- GR_Y                 |
+//         |                         |
+//    X1 ->|                         |
+//         |                         |
+//  sp ->  +                         +
+//                              restore gp
+//                              restore ar.pfs
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+                nop.f 999
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfs [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+
+.body
+{ .mfi
+        nop.m 0
+        frcpa.s0 f9,p0 = f0,f0
+        nop.i 0
+};;
+
+{ .mib
+        stfs [GR_Parameter_X] = f8            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfs [GR_Parameter_Y] = f9           // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+
+{ .mmi
+        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_acosh.S
@@ -0,0 +1,1202 @@
+.file "acosh.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// ==============================================================
+// History
+// ==============================================================
+// 03/23/01 Initial version
+// 04/19/01 Improved speed of the paths #1,2,3,4,5
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+// 05/14/03 Improved performance, set denormal flag for unorms >= 1.0
+// 03/31/05 Reformatted delimiters between data tables
+//
+// API
+// ==============================================================
+// double acosh(double)
+//
+// Overview of operation
+// ==============================================================
+//
+// There are 7 paths:
+// 1. x = 1.0
+//    Return acosh(x) = 0.0
+// 2. 1.0 < x < 1.000499725341796875(0x3FF0020C00000000)
+//    Return acosh(x) = sqrt(x-1) * Pol4(x), where Pol4(x) =
+//      (((x*C4 + C3)*(x-1) + C2)*(x-1) + C1)*(x-1) + C0
+
+// 3. 1.000499725341796875(0x3FF0020C00000000) <= x < 2^63
+//    Return acosh(x) = log(x + sqrt(x^2 -1.0))
+//    To compute x + sqrt(x^2 -1.0) modified Newton Raphson method is used
+//      (3 iterations)
+//    Algorithm description for log function see below.
+//
+// 4. 2^63 <= x < +INF
+//    Return acosh(x) = log(2*x)
+//    Algorithm description for log function see below.
+//
+// 5. x = +INF
+//    Return acosh(x) = +INF
+//
+// 6. x = [S,Q]NaN
+//    Return acosh(x) = QNaN
+//
+// 7. x < 1.0
+//    It's domain error. Error handler with tag = 136 is called
+//
+//==============================================================
+// Algorithm Description for log(x) function
+// Below we are using the fact that inequality x - 1.0 > 2^(-6) is always
+//   true for this acosh implementation
+//
+// Consider  x = 2^N 1.f1 f2 f3 f4...f63
+// Log(x) = log(frcpa(x) x/frcpa(x))
+//        = log(1/frcpa(x)) + log(frcpa(x) x)
+//        = -log(frcpa(x)) + log(frcpa(x) x)
+//
+// frcpa(x)       = 2^-N frcpa((1.f1 f2 ... f63)
+//
+// -log(frcpa(x)) = -log(C)
+//                = -log(2^-N) - log(frcpa(1.f1 f2 ... f63))
+//
+// -log(frcpa(x)) = -log(C)
+//                = +Nlog2 - log(frcpa(1.f1 f2 ... f63))
+//
+// -log(frcpa(x)) = -log(C)
+//                = +Nlog2 + log(frcpa(1.f1 f2 ... f63))
+//
+// Log(x) = log(1/frcpa(x)) + log(frcpa(x) x)
+//
+// Log(x) =  +Nlog2 + log(1./frcpa(1.f1 f2 ... f63)) + log(frcpa(x) x)
+// Log(x) =  +Nlog2 - log(/frcpa(1.f1 f2 ... f63))   + log(frcpa(x) x)
+// Log(x) =  +Nlog2 + T                              + log(frcpa(x) x)
+//
+// Log(x) =  +Nlog2 + T                     + log(C x)
+//
+// Cx = 1 + r
+//
+// Log(x) =  +Nlog2 + T  + log(1+r)
+// Log(x) =  +Nlog2 + T  + Series( r - r^2/2 + r^3/3 - r^4/4 ....)
+//
+// 1.f1 f2 ... f8 has 256 entries.
+// They are 1 + k/2^8, k = 0 ... 255
+// These 256 values are the table entries.
+//
+// Implementation
+//==============================================================
+// C = frcpa(x)
+// r = C * x - 1
+//
+// Form rseries = r + P1*r^2 + P2*r^3 + P3*r^4 + P4*r^5 + P5*r^6
+//
+// x = f * 2*n where f is 1.f_1f_2f_3....f_63
+// Nfloat = float(n)  where n is the true unbiased exponent
+// pre-index = f_1f_2....f_8
+// index = pre_index * 16
+// get the dxt table entry at index + offset = T
+//
+// result = (T + Nfloat * log(2)) + rseries
+//
+// The T table is calculated as follows
+// Form x_k = 1 + k/2^8 where k goes from 0... 255
+//      y_k = frcpa(x_k)
+//      log(1/y_k)  in quad and round to double-extended
+//
+
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input
+// f9 -> f15,  f32 -> f65
+
+// General registers used:
+// r14 -> r27, r32 -> r39
+
+// Predicate registers used:
+// p6 -> p15
+
+// p6 to filter out case when x = [Q,S]NaN
+// p7,p8 to filter out case when x < 1.0
+// p10 to select path #1
+// p11 to filter out case when x = +INF
+// p12 used in the frcpa
+// p13 to select path #4
+// p14,p15 to select path #2
+
+// Assembly macros
+//==============================================================
+log_GR_exp_17_ones    = r14
+log_GR_signexp_f8     = r15
+log_table_address2    = r16
+log_GR_exp_16_ones    = r17
+log_GR_exp_f8         = r18
+log_GR_true_exp_f8    = r19
+log_GR_significand_f8 = r20
+log_GR_index          = r21
+log_GR_comp2          = r22
+acosh_GR_f8           = r23
+log_GR_comp           = r24
+acosh_GR_f8_sig       = r25
+log_table_address3    = r26
+NR_table_address      = r27
+
+GR_SAVE_B0            = r33
+GR_SAVE_GP            = r34
+GR_SAVE_PFS           = r35
+
+GR_Parameter_X        = r36
+GR_Parameter_Y        = r37
+GR_Parameter_RESULT   = r38
+acosh_GR_tag          = r39
+
+//==============================================================
+log_y            = f9
+NR1              = f10
+NR2              = f11
+log_y_rs         = f12
+log_y_rs_iter    = f13
+log_y_rs_iter1   = f14
+log_NORM_f8      = f15
+acosh_comp       = f32
+log_w            = f34
+log_P5           = f35
+log_P4           = f36
+log_P3           = f37
+log_P2           = f38
+log_P1           = f39
+log_C0           = f40
+log_C1           = f41
+log_C2           = f42
+log2             = f43
+acosh_w_rs       = f44
+log_C            = f45
+log_arg          = f46
+acosh_w_iter1    = f47
+acosh_w_iter2    = f48
+log_int_Nfloat   = f49
+log_r            = f50
+log_rsq          = f51
+log_rp_p4        = f52
+log_rp_p32       = f53
+log_rcube        = f54
+log_rp_p10       = f55
+log_rp_p2        = f56
+log_Nfloat       = f57
+log_T            = f58
+log_r2P_r        = f59
+log_T_plus_Nlog2 = f60
+acosh_w_sqrt     = f61
+acosh_w_1        = f62
+log_C3           = f63
+log_C4           = f64
+log_arg_early    = f65
+
+
+// Data tables
+//==============================================================
+
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(log_table_1)
+data8 0x3FF0020C49BA5E35 // 1.0005
+data8 0xBFC5555DA7212371 // P5
+data8 0x3FC999A19EEF5826 // P4
+data8 0xBFCFFFFFFFFEF009 // P3
+data8 0x3FD555555554ECB2 // P2
+data8 0xBFE0000000000000 // P1 = -0.5
+//
+data8 0xb17217f7d1cf79ac, 0x00003ffe  // log2
+LOCAL_OBJECT_END(log_table_1)
+
+LOCAL_OBJECT_START(log_table_2)
+data8 0x3FE0000000000000 // 0.5
+data8 0x4008000000000000 // 3.0
+//
+data8 0xAFE8F9203939CCF8, 0x00003FF6 // C4 3FF6AFE8F9203939CCF8
+data8 0xAD46EB6AE752D809, 0x0000BFF8 // C3 BFF8AD46EB6AE752D809
+data8 0xD93923D7F53F3627, 0x00003FF9 // C2 3FF9D93923D7F53F3627
+data8 0xF15BEEEFF7D32D36, 0x0000BFFB // C1 BFFBF15BEEEFF7D32D36
+data8 0xB504F333F9DE6484, 0x00003FFF // C0 3FFFB504F333F9DE6484
+LOCAL_OBJECT_END(log_table_2)
+
+
+LOCAL_OBJECT_START(log_table_3)
+data8 0x80200aaeac44ef38 , 0x00003ff6 //   log(1/frcpa(1+  0/2^-8))
+//
+data8 0xc09090a2c35aa070 , 0x00003ff7 //   log(1/frcpa(1+  1/2^-8))
+data8 0xa0c94fcb41977c75 , 0x00003ff8 //   log(1/frcpa(1+  2/2^-8))
+data8 0xe18b9c263af83301 , 0x00003ff8 //   log(1/frcpa(1+  3/2^-8))
+data8 0x8d35c8d6399c30ea , 0x00003ff9 //   log(1/frcpa(1+  4/2^-8))
+data8 0xadd4d2ecd601cbb8 , 0x00003ff9 //   log(1/frcpa(1+  5/2^-8))
+//
+data8 0xce95403a192f9f01 , 0x00003ff9 //   log(1/frcpa(1+  6/2^-8))
+data8 0xeb59392cbcc01096 , 0x00003ff9 //   log(1/frcpa(1+  7/2^-8))
+data8 0x862c7d0cefd54c5d , 0x00003ffa //   log(1/frcpa(1+  8/2^-8))
+data8 0x94aa63c65e70d499 , 0x00003ffa //   log(1/frcpa(1+  9/2^-8))
+data8 0xa54a696d4b62b382 , 0x00003ffa //   log(1/frcpa(1+ 10/2^-8))
+//
+data8 0xb3e4a796a5dac208 , 0x00003ffa //   log(1/frcpa(1+ 11/2^-8))
+data8 0xc28c45b1878340a9 , 0x00003ffa //   log(1/frcpa(1+ 12/2^-8))
+data8 0xd35c55f39d7a6235 , 0x00003ffa //   log(1/frcpa(1+ 13/2^-8))
+data8 0xe220f037b954f1f5 , 0x00003ffa //   log(1/frcpa(1+ 14/2^-8))
+data8 0xf0f3389b036834f3 , 0x00003ffa //   log(1/frcpa(1+ 15/2^-8))
+//
+data8 0xffd3488d5c980465 , 0x00003ffa //   log(1/frcpa(1+ 16/2^-8))
+data8 0x87609ce2ed300490 , 0x00003ffb //   log(1/frcpa(1+ 17/2^-8))
+data8 0x8ede9321e8c85927 , 0x00003ffb //   log(1/frcpa(1+ 18/2^-8))
+data8 0x96639427f2f8e2f4 , 0x00003ffb //   log(1/frcpa(1+ 19/2^-8))
+data8 0x9defad3e8f73217b , 0x00003ffb //   log(1/frcpa(1+ 20/2^-8))
+//
+data8 0xa582ebd50097029c , 0x00003ffb //   log(1/frcpa(1+ 21/2^-8))
+data8 0xac06dbe75ab80fee , 0x00003ffb //   log(1/frcpa(1+ 22/2^-8))
+data8 0xb3a78449b2d3ccca , 0x00003ffb //   log(1/frcpa(1+ 23/2^-8))
+data8 0xbb4f79635ab46bb2 , 0x00003ffb //   log(1/frcpa(1+ 24/2^-8))
+data8 0xc2fec93a83523f3f , 0x00003ffb //   log(1/frcpa(1+ 25/2^-8))
+//
+data8 0xc99af2eaca4c4571 , 0x00003ffb //   log(1/frcpa(1+ 26/2^-8))
+data8 0xd1581106472fa653 , 0x00003ffb //   log(1/frcpa(1+ 27/2^-8))
+data8 0xd8002560d4355f2e , 0x00003ffb //   log(1/frcpa(1+ 28/2^-8))
+data8 0xdfcb43b4fe508632 , 0x00003ffb //   log(1/frcpa(1+ 29/2^-8))
+data8 0xe67f6dff709d4119 , 0x00003ffb //   log(1/frcpa(1+ 30/2^-8))
+//
+data8 0xed393b1c22351280 , 0x00003ffb //   log(1/frcpa(1+ 31/2^-8))
+data8 0xf5192bff087bcc35 , 0x00003ffb //   log(1/frcpa(1+ 32/2^-8))
+data8 0xfbdf4ff6dfef2fa3 , 0x00003ffb //   log(1/frcpa(1+ 33/2^-8))
+data8 0x81559a97f92f9cc7 , 0x00003ffc //   log(1/frcpa(1+ 34/2^-8))
+data8 0x84be72bce90266e8 , 0x00003ffc //   log(1/frcpa(1+ 35/2^-8))
+//
+data8 0x88bc74113f23def2 , 0x00003ffc //   log(1/frcpa(1+ 36/2^-8))
+data8 0x8c2ba3edf6799d11 , 0x00003ffc //   log(1/frcpa(1+ 37/2^-8))
+data8 0x8f9dc92f92ea08b1 , 0x00003ffc //   log(1/frcpa(1+ 38/2^-8))
+data8 0x9312e8f36efab5a7 , 0x00003ffc //   log(1/frcpa(1+ 39/2^-8))
+data8 0x968b08643409ceb6 , 0x00003ffc //   log(1/frcpa(1+ 40/2^-8))
+//
+data8 0x9a062cba08a1708c , 0x00003ffc //   log(1/frcpa(1+ 41/2^-8))
+data8 0x9d845b3abf95485c , 0x00003ffc //   log(1/frcpa(1+ 42/2^-8))
+data8 0xa06fd841bc001bb4 , 0x00003ffc //   log(1/frcpa(1+ 43/2^-8))
+data8 0xa3f3a74652fbe0db , 0x00003ffc //   log(1/frcpa(1+ 44/2^-8))
+data8 0xa77a8fb2336f20f5 , 0x00003ffc //   log(1/frcpa(1+ 45/2^-8))
+//
+data8 0xab0497015d28b0a0 , 0x00003ffc //   log(1/frcpa(1+ 46/2^-8))
+data8 0xae91c2be6ba6a615 , 0x00003ffc //   log(1/frcpa(1+ 47/2^-8))
+data8 0xb189d1b99aebb20b , 0x00003ffc //   log(1/frcpa(1+ 48/2^-8))
+data8 0xb51cced5de9c1b2c , 0x00003ffc //   log(1/frcpa(1+ 49/2^-8))
+data8 0xb819bee9e720d42f , 0x00003ffc //   log(1/frcpa(1+ 50/2^-8))
+//
+data8 0xbbb2a0947b093a5d , 0x00003ffc //   log(1/frcpa(1+ 51/2^-8))
+data8 0xbf4ec1505811684a , 0x00003ffc //   log(1/frcpa(1+ 52/2^-8))
+data8 0xc2535bacfa8975ff , 0x00003ffc //   log(1/frcpa(1+ 53/2^-8))
+data8 0xc55a3eafad187eb8 , 0x00003ffc //   log(1/frcpa(1+ 54/2^-8))
+data8 0xc8ff2484b2c0da74 , 0x00003ffc //   log(1/frcpa(1+ 55/2^-8))
+//
+data8 0xcc0b1a008d53ab76 , 0x00003ffc //   log(1/frcpa(1+ 56/2^-8))
+data8 0xcfb6203844b3209b , 0x00003ffc //   log(1/frcpa(1+ 57/2^-8))
+data8 0xd2c73949a47a19f5 , 0x00003ffc //   log(1/frcpa(1+ 58/2^-8))
+data8 0xd5daae18b49d6695 , 0x00003ffc //   log(1/frcpa(1+ 59/2^-8))
+data8 0xd8f08248cf7e8019 , 0x00003ffc //   log(1/frcpa(1+ 60/2^-8))
+//
+data8 0xdca7749f1b3e540e , 0x00003ffc //   log(1/frcpa(1+ 61/2^-8))
+data8 0xdfc28e033aaaf7c7 , 0x00003ffc //   log(1/frcpa(1+ 62/2^-8))
+data8 0xe2e012a5f91d2f55 , 0x00003ffc //   log(1/frcpa(1+ 63/2^-8))
+data8 0xe600064ed9e292a8 , 0x00003ffc //   log(1/frcpa(1+ 64/2^-8))
+data8 0xe9226cce42b39f60 , 0x00003ffc //   log(1/frcpa(1+ 65/2^-8))
+//
+data8 0xec4749fd97a28360 , 0x00003ffc //   log(1/frcpa(1+ 66/2^-8))
+data8 0xef6ea1bf57780495 , 0x00003ffc //   log(1/frcpa(1+ 67/2^-8))
+data8 0xf29877ff38809091 , 0x00003ffc //   log(1/frcpa(1+ 68/2^-8))
+data8 0xf5c4d0b245cb89be , 0x00003ffc //   log(1/frcpa(1+ 69/2^-8))
+data8 0xf8f3afd6fcdef3aa , 0x00003ffc //   log(1/frcpa(1+ 70/2^-8))
+//
+data8 0xfc2519756be1abc7 , 0x00003ffc //   log(1/frcpa(1+ 71/2^-8))
+data8 0xff59119f503e6832 , 0x00003ffc //   log(1/frcpa(1+ 72/2^-8))
+data8 0x8147ce381ae0e146 , 0x00003ffd //   log(1/frcpa(1+ 73/2^-8))
+data8 0x82e45f06cb1ad0f2 , 0x00003ffd //   log(1/frcpa(1+ 74/2^-8))
+data8 0x842f5c7c573cbaa2 , 0x00003ffd //   log(1/frcpa(1+ 75/2^-8))
+//
+data8 0x85ce471968c8893a , 0x00003ffd //   log(1/frcpa(1+ 76/2^-8))
+data8 0x876e8305bc04066d , 0x00003ffd //   log(1/frcpa(1+ 77/2^-8))
+data8 0x891012678031fbb3 , 0x00003ffd //   log(1/frcpa(1+ 78/2^-8))
+data8 0x8a5f1493d766a05f , 0x00003ffd //   log(1/frcpa(1+ 79/2^-8))
+data8 0x8c030c778c56fa00 , 0x00003ffd //   log(1/frcpa(1+ 80/2^-8))
+//
+data8 0x8da85df17e31d9ae , 0x00003ffd //   log(1/frcpa(1+ 81/2^-8))
+data8 0x8efa663e7921687e , 0x00003ffd //   log(1/frcpa(1+ 82/2^-8))
+data8 0x90a22b6875c6a1f8 , 0x00003ffd //   log(1/frcpa(1+ 83/2^-8))
+data8 0x91f62cc8f5d24837 , 0x00003ffd //   log(1/frcpa(1+ 84/2^-8))
+data8 0x93a06cfc3857d980 , 0x00003ffd //   log(1/frcpa(1+ 85/2^-8))
+//
+data8 0x94f66d5e6fd01ced , 0x00003ffd //   log(1/frcpa(1+ 86/2^-8))
+data8 0x96a330156e6772f2 , 0x00003ffd //   log(1/frcpa(1+ 87/2^-8))
+data8 0x97fb3582754ea25b , 0x00003ffd //   log(1/frcpa(1+ 88/2^-8))
+data8 0x99aa8259aad1bbf2 , 0x00003ffd //   log(1/frcpa(1+ 89/2^-8))
+data8 0x9b0492f6227ae4a8 , 0x00003ffd //   log(1/frcpa(1+ 90/2^-8))
+//
+data8 0x9c5f8e199bf3a7a5 , 0x00003ffd //   log(1/frcpa(1+ 91/2^-8))
+data8 0x9e1293b9998c1daa , 0x00003ffd //   log(1/frcpa(1+ 92/2^-8))
+data8 0x9f6fa31e0b41f308 , 0x00003ffd //   log(1/frcpa(1+ 93/2^-8))
+data8 0xa0cda11eaf46390e , 0x00003ffd //   log(1/frcpa(1+ 94/2^-8))
+data8 0xa22c8f029cfa45aa , 0x00003ffd //   log(1/frcpa(1+ 95/2^-8))
+//
+data8 0xa3e48badb7856b34 , 0x00003ffd //   log(1/frcpa(1+ 96/2^-8))
+data8 0xa5459a0aa95849f9 , 0x00003ffd //   log(1/frcpa(1+ 97/2^-8))
+data8 0xa6a79c84480cfebd , 0x00003ffd //   log(1/frcpa(1+ 98/2^-8))
+data8 0xa80a946d0fcb3eb2 , 0x00003ffd //   log(1/frcpa(1+ 99/2^-8))
+data8 0xa96e831a3ea7b314 , 0x00003ffd //   log(1/frcpa(1+100/2^-8))
+//
+data8 0xaad369e3dc544e3b , 0x00003ffd //   log(1/frcpa(1+101/2^-8))
+data8 0xac92e9588952c815 , 0x00003ffd //   log(1/frcpa(1+102/2^-8))
+data8 0xadfa035aa1ed8fdc , 0x00003ffd //   log(1/frcpa(1+103/2^-8))
+data8 0xaf6219eae1ad6e34 , 0x00003ffd //   log(1/frcpa(1+104/2^-8))
+data8 0xb0cb2e6d8160f753 , 0x00003ffd //   log(1/frcpa(1+105/2^-8))
+//
+data8 0xb2354249ad950f72 , 0x00003ffd //   log(1/frcpa(1+106/2^-8))
+data8 0xb3a056e98ef4a3b4 , 0x00003ffd //   log(1/frcpa(1+107/2^-8))
+data8 0xb50c6dba52c6292a , 0x00003ffd //   log(1/frcpa(1+108/2^-8))
+data8 0xb679882c33876165 , 0x00003ffd //   log(1/frcpa(1+109/2^-8))
+data8 0xb78c07429785cedc , 0x00003ffd //   log(1/frcpa(1+110/2^-8))
+//
+data8 0xb8faeb8dc4a77d24 , 0x00003ffd //   log(1/frcpa(1+111/2^-8))
+data8 0xba6ad77eb36ae0d6 , 0x00003ffd //   log(1/frcpa(1+112/2^-8))
+data8 0xbbdbcc915e9bee50 , 0x00003ffd //   log(1/frcpa(1+113/2^-8))
+data8 0xbd4dcc44f8cf12ef , 0x00003ffd //   log(1/frcpa(1+114/2^-8))
+data8 0xbec0d81bf5b531fa , 0x00003ffd //   log(1/frcpa(1+115/2^-8))
+//
+data8 0xc034f19c139186f4 , 0x00003ffd //   log(1/frcpa(1+116/2^-8))
+data8 0xc14cb69f7c5e55ab , 0x00003ffd //   log(1/frcpa(1+117/2^-8))
+data8 0xc2c2abbb6e5fd56f , 0x00003ffd //   log(1/frcpa(1+118/2^-8))
+data8 0xc439b2c193e6771e , 0x00003ffd //   log(1/frcpa(1+119/2^-8))
+data8 0xc553acb9d5c67733 , 0x00003ffd //   log(1/frcpa(1+120/2^-8))
+//
+data8 0xc6cc96e441272441 , 0x00003ffd //   log(1/frcpa(1+121/2^-8))
+data8 0xc8469753eca88c30 , 0x00003ffd //   log(1/frcpa(1+122/2^-8))
+data8 0xc962cf3ce072b05c , 0x00003ffd //   log(1/frcpa(1+123/2^-8))
+data8 0xcadeba8771f694aa , 0x00003ffd //   log(1/frcpa(1+124/2^-8))
+data8 0xcc5bc08d1f72da94 , 0x00003ffd //   log(1/frcpa(1+125/2^-8))
+//
+data8 0xcd7a3f99ea035c29 , 0x00003ffd //   log(1/frcpa(1+126/2^-8))
+data8 0xcef93860c8a53c35 , 0x00003ffd //   log(1/frcpa(1+127/2^-8))
+data8 0xd0192f68a7ed23df , 0x00003ffd //   log(1/frcpa(1+128/2^-8))
+data8 0xd19a201127d3c645 , 0x00003ffd //   log(1/frcpa(1+129/2^-8))
+data8 0xd2bb92f4061c172c , 0x00003ffd //   log(1/frcpa(1+130/2^-8))
+//
+data8 0xd43e80b2ee8cc8fc , 0x00003ffd //   log(1/frcpa(1+131/2^-8))
+data8 0xd56173601fc4ade4 , 0x00003ffd //   log(1/frcpa(1+132/2^-8))
+data8 0xd6e6637efb54086f , 0x00003ffd //   log(1/frcpa(1+133/2^-8))
+data8 0xd80ad9f58f3c8193 , 0x00003ffd //   log(1/frcpa(1+134/2^-8))
+data8 0xd991d1d31aca41f8 , 0x00003ffd //   log(1/frcpa(1+135/2^-8))
+//
+data8 0xdab7d02231484a93 , 0x00003ffd //   log(1/frcpa(1+136/2^-8))
+data8 0xdc40d532cde49a54 , 0x00003ffd //   log(1/frcpa(1+137/2^-8))
+data8 0xdd685f79ed8b265e , 0x00003ffd //   log(1/frcpa(1+138/2^-8))
+data8 0xde9094bbc0e17b1d , 0x00003ffd //   log(1/frcpa(1+139/2^-8))
+data8 0xe01c91b78440c425 , 0x00003ffd //   log(1/frcpa(1+140/2^-8))
+//
+data8 0xe14658f26997e729 , 0x00003ffd //   log(1/frcpa(1+141/2^-8))
+data8 0xe270cdc2391e0d23 , 0x00003ffd //   log(1/frcpa(1+142/2^-8))
+data8 0xe3ffce3a2aa64922 , 0x00003ffd //   log(1/frcpa(1+143/2^-8))
+data8 0xe52bdb274ed82887 , 0x00003ffd //   log(1/frcpa(1+144/2^-8))
+data8 0xe6589852e75d7df6 , 0x00003ffd //   log(1/frcpa(1+145/2^-8))
+//
+data8 0xe786068c79937a7d , 0x00003ffd //   log(1/frcpa(1+146/2^-8))
+data8 0xe91903adad100911 , 0x00003ffd //   log(1/frcpa(1+147/2^-8))
+data8 0xea481236f7d35bb0 , 0x00003ffd //   log(1/frcpa(1+148/2^-8))
+data8 0xeb77d48c692e6b14 , 0x00003ffd //   log(1/frcpa(1+149/2^-8))
+data8 0xeca84b83d7297b87 , 0x00003ffd //   log(1/frcpa(1+150/2^-8))
+//
+data8 0xedd977f4962aa158 , 0x00003ffd //   log(1/frcpa(1+151/2^-8))
+data8 0xef7179a22f257754 , 0x00003ffd //   log(1/frcpa(1+152/2^-8))
+data8 0xf0a450d139366ca7 , 0x00003ffd //   log(1/frcpa(1+153/2^-8))
+data8 0xf1d7e0524ff9ffdb , 0x00003ffd //   log(1/frcpa(1+154/2^-8))
+data8 0xf30c29036a8b6cae , 0x00003ffd //   log(1/frcpa(1+155/2^-8))
+//
+data8 0xf4412bc411ea8d92 , 0x00003ffd //   log(1/frcpa(1+156/2^-8))
+data8 0xf576e97564c8619d , 0x00003ffd //   log(1/frcpa(1+157/2^-8))
+data8 0xf6ad62fa1b5f172f , 0x00003ffd //   log(1/frcpa(1+158/2^-8))
+data8 0xf7e499368b55c542 , 0x00003ffd //   log(1/frcpa(1+159/2^-8))
+data8 0xf91c8d10abaffe22 , 0x00003ffd //   log(1/frcpa(1+160/2^-8))
+//
+data8 0xfa553f7018c966f3 , 0x00003ffd //   log(1/frcpa(1+161/2^-8))
+data8 0xfb8eb13e185d802c , 0x00003ffd //   log(1/frcpa(1+162/2^-8))
+data8 0xfcc8e3659d9bcbed , 0x00003ffd //   log(1/frcpa(1+163/2^-8))
+data8 0xfe03d6d34d487fd2 , 0x00003ffd //   log(1/frcpa(1+164/2^-8))
+data8 0xff3f8c7581e9f0ae , 0x00003ffd //   log(1/frcpa(1+165/2^-8))
+//
+data8 0x803e029e280173ae , 0x00003ffe //   log(1/frcpa(1+166/2^-8))
+data8 0x80dca10cc52d0757 , 0x00003ffe //   log(1/frcpa(1+167/2^-8))
+data8 0x817ba200632755a1 , 0x00003ffe //   log(1/frcpa(1+168/2^-8))
+data8 0x821b05f3b01d6774 , 0x00003ffe //   log(1/frcpa(1+169/2^-8))
+data8 0x82bacd623ff19d06 , 0x00003ffe //   log(1/frcpa(1+170/2^-8))
+//
+data8 0x835af8c88e7a8f47 , 0x00003ffe //   log(1/frcpa(1+171/2^-8))
+data8 0x83c5f8299e2b4091 , 0x00003ffe //   log(1/frcpa(1+172/2^-8))
+data8 0x8466cb43f3d87300 , 0x00003ffe //   log(1/frcpa(1+173/2^-8))
+data8 0x850803a67c80ca4b , 0x00003ffe //   log(1/frcpa(1+174/2^-8))
+data8 0x85a9a1d11a23b461 , 0x00003ffe //   log(1/frcpa(1+175/2^-8))
+//
+data8 0x864ba644a18e6e05 , 0x00003ffe //   log(1/frcpa(1+176/2^-8))
+data8 0x86ee1182dcc432f7 , 0x00003ffe //   log(1/frcpa(1+177/2^-8))
+data8 0x875a925d7e48c316 , 0x00003ffe //   log(1/frcpa(1+178/2^-8))
+data8 0x87fdaa109d23aef7 , 0x00003ffe //   log(1/frcpa(1+179/2^-8))
+data8 0x88a129ed4becfaf2 , 0x00003ffe //   log(1/frcpa(1+180/2^-8))
+//
+data8 0x89451278ecd7f9cf , 0x00003ffe //   log(1/frcpa(1+181/2^-8))
+data8 0x89b29295f8432617 , 0x00003ffe //   log(1/frcpa(1+182/2^-8))
+data8 0x8a572ac5a5496882 , 0x00003ffe //   log(1/frcpa(1+183/2^-8))
+data8 0x8afc2d0ce3b2dadf , 0x00003ffe //   log(1/frcpa(1+184/2^-8))
+data8 0x8b6a69c608cfd3af , 0x00003ffe //   log(1/frcpa(1+185/2^-8))
+//
+data8 0x8c101e106e899a83 , 0x00003ffe //   log(1/frcpa(1+186/2^-8))
+data8 0x8cb63de258f9d626 , 0x00003ffe //   log(1/frcpa(1+187/2^-8))
+data8 0x8d2539c5bd19e2b1 , 0x00003ffe //   log(1/frcpa(1+188/2^-8))
+data8 0x8dcc0e064b29e6f1 , 0x00003ffe //   log(1/frcpa(1+189/2^-8))
+data8 0x8e734f45d88357ae , 0x00003ffe //   log(1/frcpa(1+190/2^-8))
+//
+data8 0x8ee30cef034a20db , 0x00003ffe //   log(1/frcpa(1+191/2^-8))
+data8 0x8f8b0515686d1d06 , 0x00003ffe //   log(1/frcpa(1+192/2^-8))
+data8 0x90336bba039bf32f , 0x00003ffe //   log(1/frcpa(1+193/2^-8))
+data8 0x90a3edd23d1c9d58 , 0x00003ffe //   log(1/frcpa(1+194/2^-8))
+data8 0x914d0de2f5d61b32 , 0x00003ffe //   log(1/frcpa(1+195/2^-8))
+//
+data8 0x91be0c20d28173b5 , 0x00003ffe //   log(1/frcpa(1+196/2^-8))
+data8 0x9267e737c06cd34a , 0x00003ffe //   log(1/frcpa(1+197/2^-8))
+data8 0x92d962ae6abb1237 , 0x00003ffe //   log(1/frcpa(1+198/2^-8))
+data8 0x9383fa6afbe2074c , 0x00003ffe //   log(1/frcpa(1+199/2^-8))
+data8 0x942f0421651c1c4e , 0x00003ffe //   log(1/frcpa(1+200/2^-8))
+//
+data8 0x94a14a3845bb985e , 0x00003ffe //   log(1/frcpa(1+201/2^-8))
+data8 0x954d133857f861e7 , 0x00003ffe //   log(1/frcpa(1+202/2^-8))
+data8 0x95bfd96468e604c4 , 0x00003ffe //   log(1/frcpa(1+203/2^-8))
+data8 0x9632d31cafafa858 , 0x00003ffe //   log(1/frcpa(1+204/2^-8))
+data8 0x96dfaabd86fa1647 , 0x00003ffe //   log(1/frcpa(1+205/2^-8))
+//
+data8 0x9753261fcbb2a594 , 0x00003ffe //   log(1/frcpa(1+206/2^-8))
+data8 0x9800c11b426b996d , 0x00003ffe //   log(1/frcpa(1+207/2^-8))
+data8 0x9874bf4d45ae663c , 0x00003ffe //   log(1/frcpa(1+208/2^-8))
+data8 0x99231f5ee9a74f79 , 0x00003ffe //   log(1/frcpa(1+209/2^-8))
+data8 0x9997a18a56bcad28 , 0x00003ffe //   log(1/frcpa(1+210/2^-8))
+//
+data8 0x9a46c873a3267e79 , 0x00003ffe //   log(1/frcpa(1+211/2^-8))
+data8 0x9abbcfc621eb6cb6 , 0x00003ffe //   log(1/frcpa(1+212/2^-8))
+data8 0x9b310cb0d354c990 , 0x00003ffe //   log(1/frcpa(1+213/2^-8))
+data8 0x9be14cf9e1b3515c , 0x00003ffe //   log(1/frcpa(1+214/2^-8))
+data8 0x9c5710b8cbb73a43 , 0x00003ffe //   log(1/frcpa(1+215/2^-8))
+//
+data8 0x9ccd0abd301f399c , 0x00003ffe //   log(1/frcpa(1+216/2^-8))
+data8 0x9d7e67f3bdce8888 , 0x00003ffe //   log(1/frcpa(1+217/2^-8))
+data8 0x9df4ea81a99daa01 , 0x00003ffe //   log(1/frcpa(1+218/2^-8))
+data8 0x9e6ba405a54514ba , 0x00003ffe //   log(1/frcpa(1+219/2^-8))
+data8 0x9f1e21c8c7bb62b3 , 0x00003ffe //   log(1/frcpa(1+220/2^-8))
+//
+data8 0x9f956593f6b6355c , 0x00003ffe //   log(1/frcpa(1+221/2^-8))
+data8 0xa00ce1092e5498c3 , 0x00003ffe //   log(1/frcpa(1+222/2^-8))
+data8 0xa0c08309c4b912c1 , 0x00003ffe //   log(1/frcpa(1+223/2^-8))
+data8 0xa1388a8c6faa2afa , 0x00003ffe //   log(1/frcpa(1+224/2^-8))
+data8 0xa1b0ca7095b5f985 , 0x00003ffe //   log(1/frcpa(1+225/2^-8))
+//
+data8 0xa22942eb47534a00 , 0x00003ffe //   log(1/frcpa(1+226/2^-8))
+data8 0xa2de62326449d0a3 , 0x00003ffe //   log(1/frcpa(1+227/2^-8))
+data8 0xa357690f88bfe345 , 0x00003ffe //   log(1/frcpa(1+228/2^-8))
+data8 0xa3d0a93f45169a4b , 0x00003ffe //   log(1/frcpa(1+229/2^-8))
+data8 0xa44a22f7ffe65f30 , 0x00003ffe //   log(1/frcpa(1+230/2^-8))
+//
+data8 0xa500c5e5b4c1aa36 , 0x00003ffe //   log(1/frcpa(1+231/2^-8))
+data8 0xa57ad064eb2ebbc2 , 0x00003ffe //   log(1/frcpa(1+232/2^-8))
+data8 0xa5f5152dedf4384e , 0x00003ffe //   log(1/frcpa(1+233/2^-8))
+data8 0xa66f9478856233ec , 0x00003ffe //   log(1/frcpa(1+234/2^-8))
+data8 0xa6ea4e7cca02c32e , 0x00003ffe //   log(1/frcpa(1+235/2^-8))
+//
+data8 0xa765437325341ccf , 0x00003ffe //   log(1/frcpa(1+236/2^-8))
+data8 0xa81e21e6c75b4020 , 0x00003ffe //   log(1/frcpa(1+237/2^-8))
+data8 0xa899ab333fe2b9ca , 0x00003ffe //   log(1/frcpa(1+238/2^-8))
+data8 0xa9157039c51ebe71 , 0x00003ffe //   log(1/frcpa(1+239/2^-8))
+data8 0xa991713433c2b999 , 0x00003ffe //   log(1/frcpa(1+240/2^-8))
+//
+data8 0xaa0dae5cbcc048b3 , 0x00003ffe //   log(1/frcpa(1+241/2^-8))
+data8 0xaa8a27ede5eb13ad , 0x00003ffe //   log(1/frcpa(1+242/2^-8))
+data8 0xab06de228a9e3499 , 0x00003ffe //   log(1/frcpa(1+243/2^-8))
+data8 0xab83d135dc633301 , 0x00003ffe //   log(1/frcpa(1+244/2^-8))
+data8 0xac3fb076adc7fe7a , 0x00003ffe //   log(1/frcpa(1+245/2^-8))
+//
+data8 0xacbd3cbbe47988f1 , 0x00003ffe //   log(1/frcpa(1+246/2^-8))
+data8 0xad3b06b1a5dc57c3 , 0x00003ffe //   log(1/frcpa(1+247/2^-8))
+data8 0xadb90e94af887717 , 0x00003ffe //   log(1/frcpa(1+248/2^-8))
+data8 0xae3754a218f7c816 , 0x00003ffe //   log(1/frcpa(1+249/2^-8))
+data8 0xaeb5d9175437afa2 , 0x00003ffe //   log(1/frcpa(1+250/2^-8))
+//
+data8 0xaf349c322e9c7cee , 0x00003ffe //   log(1/frcpa(1+251/2^-8))
+data8 0xafb39e30d1768d1c , 0x00003ffe //   log(1/frcpa(1+252/2^-8))
+data8 0xb032df51c2c93116 , 0x00003ffe //   log(1/frcpa(1+253/2^-8))
+data8 0xb0b25fd3e6035ad9 , 0x00003ffe //   log(1/frcpa(1+254/2^-8))
+data8 0xb1321ff67cba178c , 0x00003ffe //   log(1/frcpa(1+255/2^-8))
+LOCAL_OBJECT_END(log_table_3)
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(acosh)
+
+{ .mfi
+      getf.exp   acosh_GR_f8 = f8
+      fclass.m   p6,p0 = f8, 0xc3                    // Test for x = NaN
+      mov        log_GR_comp2 = 0x1003e
+}
+{ .mfi
+      addl       NR_table_address = @ltoff(log_table_1), gp
+      fms.s1     log_y = f8, f8, f1                  // y = x^2-1
+      nop.i      0
+}
+;;
+
+{ .mfi
+      getf.sig   acosh_GR_f8_sig = f8
+      fclass.m   p11,p0 = f8, 0x21                   // Test for x=+inf
+      mov        log_GR_exp_17_ones = 0x1ffff
+}
+{ .mfi
+      ld8        NR_table_address = [NR_table_address]
+      fms.s1     log_w = f8,f1,f1                    // w = x - 1
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fcmp.lt.s1 p7,p8 = f8, f1            // Test for x<1.0
+      addl       log_GR_comp = 0x10020C,r0 // Upper 21 bits of signif of 1.0005
+}
+{ .mfb
+      mov        log_GR_exp_16_ones = 0xffff         //BIAS
+(p6)  fma.d.s0   f8 = f8,f1,f0      // quietize nan result if x=nan
+(p6)  br.ret.spnt b0                // Exit for x=nan
+}
+;;
+
+{ .mfb
+      //get second table address
+      adds       log_table_address2 = 0x40, NR_table_address
+      fcmp.eq.s1 p10,p0 = f8, f1      // Test for x=+1.0
+(p11) br.ret.spnt b0                  // Exit for x=+inf
+}
+;;
+
+{ .mfi
+      ldfpd      NR1,NR2 = [log_table_address2],16
+      frsqrta.s1 log_y_rs,p0 = log_y  // z=1/sqrt(y)
+      nop.i      0
+}
+{ .mfb
+      nop.m      0
+      fma.s1     log_arg = f8,f1,f8
+(p7)  br.cond.spnt ACOSH_LESS_ONE     // Branch if path 7, x < 1.0
+}
+;;
+
+{ .mfi
+      ldfe       log_C4 = [log_table_address2],16
+(p8)  fcmp.eq.s0 p6,p0 = f8, f0       // Dummy op sets denorm flag if unorm>=1.0
+      nop.i      0
+}
+{ .mfb
+(p8)  cmp.le.unc p13,p0 = log_GR_comp2,acosh_GR_f8
+      nop.f      0
+(p13) br.cond.spnt LOG_COMMON1        // Branch if path 4, x >= 2^63
+}
+;;
+
+{ .mfi
+      ldfe       log_C3 = [log_table_address2],16
+(p10) fmerge.s   f8 = f0, f0          // Return 0 if x=1.0
+      shr.u      acosh_GR_f8_sig = acosh_GR_f8_sig,43
+}
+{ .mib
+      cmp.eq     p14,p0 = log_GR_exp_16_ones,acosh_GR_f8
+      nop.i      0
+(p10) br.ret.spnt b0                  // Exit for x=1.0
+}
+;;
+
+{ .mfi
+      ldfe       log_C2 = [log_table_address2],16
+      frsqrta.s1 acosh_w_rs,p0 = log_w // t=1/sqrt(w)
+      nop.i      0
+}
+{ .mfb
+(p14) cmp.lt.unc p15,p0 = acosh_GR_f8_sig,log_GR_comp
+      nop.f      0
+(p15) br.cond.spnt ACOSH_NEAR_ONE     // Branch if path 2, 1.0 < x < 1.0005
+}
+;;
+
+// Here is main path, 1.0005 <= x < 2^63
+/////////////// The first iteration //////////////////////////////////
+{ .mfi
+      ldfpd      acosh_comp,log_P5 = [NR_table_address],16
+      fma.s1     log_y_rs_iter = log_y_rs,log_y,f0              // y*z
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfpd      log_P4,log_P3 = [NR_table_address],16
+      fnma.s1    log_y_rs_iter = log_y_rs_iter,log_y_rs,NR2     // 3-(y*z)*z
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs,NR1,f0               // 0.5*z
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfpd      log_P2,log_P1 = [NR_table_address],16
+      //(0.5*z)*(3-(y*z)*z)
+      fma.s1     log_y_rs_iter = log_y_rs_iter1,log_y_rs_iter,f0
+      nop.i      0
+}
+;;
+
+/////////////////////////// The second iteration /////////////////////////////
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs = log_y_rs_iter,log_y,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fnma.s1    log_y_rs = log_y_rs,log_y_rs_iter,NR2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs_iter,NR1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //(0.5*z)*(3-(y*z)*z)
+      fma.s1     log_y_rs_iter = log_y_rs_iter1,log_y_rs,f0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      //(0.5*z)*(3-(y*z)*z)
+      fma.s1     log_arg_early = log_y_rs_iter1,log_y_rs,f0
+      nop.i      0
+}
+;;
+
+//////////////////////////////////////// The third iteration /////////////////
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs = log_y_rs_iter,log_y,f0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs_iter,NR1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_arg_early = log_arg_early,log_y,f8
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fnma.s1    log_y_rs = log_y_rs,log_y_rs_iter,NR2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs_iter1,log_y,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      frcpa.s1   log_C,p0 = f1,log_arg_early
+      nop.i      0
+}
+;;
+
+{ .mfi
+      getf.exp   log_GR_signexp_f8 = log_arg_early
+      nop.f      0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      getf.sig   log_GR_significand_f8 = log_arg_early
+      fma.s1     log_arg = log_y_rs_iter1,log_y_rs,f8 // (0.5*z)*(3-(y*z)*z)
+      adds       log_table_address3 = 0x70, NR_table_address
+}
+;;
+
+///////////////////////////////// The end NR iterations /////////////////////
+{ .mfi
+      ldfe       log2 = [NR_table_address],16
+      nop.f      0
+      nop.i      0
+}
+;;
+
+{ .mmi
+      //significant bit destruction
+      and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones
+;;
+      //BIAS subtraction
+      sub        log_GR_true_exp_f8 = log_GR_exp_f8, log_GR_exp_16_ones
+      nop.i      0
+}
+;;
+
+{ .mfi
+      setf.sig   log_int_Nfloat = log_GR_true_exp_f8
+      fms.s1     log_r = log_C,log_arg,f1  // C = frcpa(x); r = C * x - 1
+      extr.u     log_GR_index = log_GR_significand_f8,55,8 //Extract 8 bits
+}
+;;
+
+{ .mmi
+      //pre-index*16 + index
+      shladd     log_table_address3 = log_GR_index,4,log_table_address3
+;;
+      ldfe       log_T = [log_table_address3]
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rsq = log_r, log_r, f0         //r^2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p4 = log_P5, log_r, log_P4  //P5*r + P4
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p32 = log_P3, log_r, log_P2 //P3*r + P2
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //convert N to the floating-point format log_Nfloat
+      fcvt.xf    log_Nfloat = log_int_Nfloat
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rcube = log_rsq, log_r, f0      //r^3
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p10 = log_rsq, log_P1, log_r //P1*r^2 + r
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //(P5*r + P4)*r^2 + P3*r + P2
+      fma.s1     log_rp_p2 = log_rp_p4, log_rsq, log_rp_p32
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_T_plus_Nlog2 = log_Nfloat,log2,log_T    //N*log2 + T
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      //((P5*r + P4)*r^2 + P3*r + P2)*r^3 + P1*r^2 + r
+      fma.s1     log_r2P_r = log_rp_p2, log_rcube, log_rp_p10
+      nop.i      0
+}
+;;
+
+{ .mfb
+      nop.m      0
+      // N*log2 + T + ((P5*r + P4)*r^2 + P3*r + P2)*w^3 + P1*r^2 + r
+      fadd.d.s0  f8 = log_T_plus_Nlog2, log_r2P_r
+      br.ret.sptk b0           // Exit main path, path 3: 1.0005 <= x < 2^63
+}
+;;
+
+// Here if path 2, 1.0 < x < 1.0005
+ACOSH_NEAR_ONE:
+// The first NR iteration
+{ .mfi
+      ldfe       log_C1 = [log_table_address2],16
+      fma.s1     acosh_w_iter1 = acosh_w_rs,log_w,f0  //t*w
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_1 = f8,log_C4,log_C3         //x*C4 + C3
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfe       log_C0 = [log_table_address2],16
+      fma.s1     acosh_w_iter2 = acosh_w_rs,NR1,f0    //t*0.5
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fnma.s1    acosh_w_iter1 = acosh_w_iter1,acosh_w_rs,NR2 //3-t*t*w
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //(3-t*t*w)*t*0.5
+      fma.s1     acosh_w_iter2 = acosh_w_iter2,acosh_w_iter1,f0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_1 = acosh_w_1,log_w,log_C2 //(x*C4 + C3)*(x-1) + C2
+      nop.i      0
+}
+;;
+
+// The second NR iteration
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_rs = acosh_w_iter2,log_w,f0  //t*w
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      //((x*C4 + C3)*(x-1) + C2)*(x-1) + C1
+      fma.s1     acosh_w_1 = acosh_w_1,log_w,log_C1
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fnma.s1    acosh_w_iter1 = acosh_w_iter2,acosh_w_rs,NR2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_iter2 = acosh_w_iter2,NR1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_iter2 = acosh_w_iter2,acosh_w_iter1,f0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      //(((x*C4 + C3)*(x-1) + C2)*(x-1) + C1)*(x-1) + C0
+      fma.s1     acosh_w_1 = acosh_w_1,log_w,log_C0
+      nop.i      0
+}
+;;
+
+//The third NR iteration
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_rs = acosh_w_iter2,log_w,f0  //t*w
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fnma.s1    acosh_w_iter1 = acosh_w_iter2,acosh_w_rs,NR2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_iter2 = acosh_w_iter2,NR1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_iter2 = acosh_w_iter2,acosh_w_iter1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_sqrt = acosh_w_iter2,log_w,f0
+      nop.i      0
+}
+;;
+
+{ .mfb
+      nop.m      0
+      fma.d.s0   f8 = acosh_w_1,acosh_w_sqrt,f0
+      br.ret.sptk b0               // Exit path 2, 1.0 < x < 1.0005
+}
+;;
+
+// Here if path 4, x >= 2^63
+LOG_COMMON1:
+{ .mfi
+      ldfpd      acosh_comp,log_P5 = [NR_table_address],16
+      frcpa.s1   log_C,p0 = f1,log_arg
+      nop.i      0
+}
+;;
+
+{ .mmi
+      getf.exp   log_GR_signexp_f8 = log_arg
+      ldfpd      log_P4,log_P3 = [NR_table_address],16
+      nop.i      0
+}
+;;
+
+{ .mmi
+      getf.sig   log_GR_significand_f8 = log_arg
+      ldfpd      log_P2,log_P1 = [NR_table_address],16
+      nop.i      0
+}
+;;
+
+{ .mfi
+      adds       log_table_address3 = 0x70, NR_table_address
+      nop.f      0
+      //significant bit destruction
+      and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones
+}
+;;
+
+{ .mmf
+      ldfe       log2 = [NR_table_address],16
+      //BIAS subtraction
+      sub        log_GR_true_exp_f8 = log_GR_exp_f8, log_GR_exp_16_ones
+      fms.s1     log_r = log_C,log_arg,f1  // C = frcpa(x); r = C * x - 1
+}
+;;
+
+{ .mfi
+      setf.sig   log_int_Nfloat = log_GR_true_exp_f8
+      nop.f      0
+      extr.u     log_GR_index = log_GR_significand_f8,55,8 //Extract 8 bits
+}
+;;
+
+{ .mmi
+      //pre-index*16 + index
+      shladd     log_table_address3 = log_GR_index,4,log_table_address3
+;;
+      ldfe       log_T = [log_table_address3]
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rsq = log_r, log_r, f0         //r^2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p4 = log_P5, log_r, log_P4  //P5*r + P4
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p32 = log_P3, log_r, log_P2 //P3*r + P2
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rcube = log_rsq, log_r, f0     //r^3
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p10 = log_rsq, log_P1, log_r //P1*r^2 + r
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //convert N to the floating-point format log_Nfloat
+      fcvt.xf    log_Nfloat = log_int_Nfloat
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      //(P5*r + P4)*r^2 + P3*r + P2
+      fma.s1     log_rp_p2 = log_rp_p4, log_rsq, log_rp_p32
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_T_plus_Nlog2 = log_Nfloat,log2,log_T    //N*log2 + T
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      //((P5*r + P4)*r^2 + P3*r + P2)*w^3 + P1*r^2 + r
+      fma.s1     log_r2P_r = log_rp_p2, log_rcube, log_rp_p10
+      nop.i      0
+}
+;;
+
+{ .mfb
+      nop.m      0
+      //  N*log2 + T + ((P5*r + P4)*r^2 + P3*r + P2)*w^3 + P1*r^2 + r
+      fadd.d.s0  f8 = log_T_plus_Nlog2, log_r2P_r
+      br.ret.sptk b0              // Exit path 4, x >= 2^63
+}
+;;
+
+// Here if path 7, x < 1.0
+ACOSH_LESS_ONE:
+{ .mfi
+      alloc      r32 = ar.pfs,1,3,4,0
+      fmerge.s   f10 = f8,f8
+      nop.i      0
+}
+;;
+
+{ .mfb
+      mov        acosh_GR_tag = 136
+      frcpa.s0   f8,p0 = f0,f0
+      br.cond.sptk __libm_error_region
+}
+;;
+
+GLOBAL_LIBM_END(acosh)
+libm_alias_double_other (acosh, acosh)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                          // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                      // Save gp
+};;
+
+{ .mmi
+        stfd [GR_Parameter_Y] = f1,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp            // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                     // Save b0
+};;
+
+.body
+{ .mib
+        stfd [GR_Parameter_X] = f10           // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = f8            // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support# // Call error handling function
+};;
+
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_acoshf.S
@@ -0,0 +1,1030 @@
+.file "acoshf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// ==============================================================
+// History
+// ==============================================================
+// 03/28/01 Initial version
+// 04/19/01 Improved speed of the paths #1,2,3,4,5
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+// 05/14/03 Improved performance, set denormal flag for unorms >= 1.0
+//
+// API
+// ==============================================================
+// float acoshf(float)
+//
+// Overview of operation
+// ==============================================================
+//
+// There are 7 paths:
+// 1. x = 1.0
+//    Return acoshf(x) = 0.0
+// 2. 1.0 < x < 1.000499725341796875(0x3FF0020C00000000)
+//    Return acoshf(x) = sqrt(x-1) * Pol4(x),
+//    where Pol4(x) = (x*C2 + C1)*(x-1) + C0
+//
+// 3. 1.000499725341796875(0x3FF0020C00000000) <= x < 2^51
+//    Return acoshf(x) = log(x + sqrt(x^2 -1.0))
+//    To compute x + sqrt(x^2 -1.0) modified Newton Raphson method is used
+//      (2 iterations)
+//    Algorithm description for log function see below.
+//
+// 4. 2^51 <= x < +INF
+//    Return acoshf(x) = log(2*x)
+//    Algorithm description for log function see below.
+//
+// 5. x = +INF
+//    Return acoshf(x) = +INF
+//
+// 6. x = [S,Q]NaN
+//    Return acoshf(x) = QNaN
+//
+// 7. x < 1.0
+//    It's domain error. Error handler with tag = 137 is called
+//
+//==============================================================
+// Algorithm Description for log(x) function
+// Below we are using the fact that inequality x - 1.0 > 2^(-6) is always
+//   true for this acosh implementation
+//
+// Consider  x = 2^N 1.f1 f2 f3 f4...f63
+// Log(x) = log(frcpa(x) x/frcpa(x))
+//        = log(1/frcpa(x)) + log(frcpa(x) x)
+//        = -log(frcpa(x)) + log(frcpa(x) x)
+//
+// frcpa(x)       = 2^-N frcpa((1.f1 f2 ... f63)
+//
+// -log(frcpa(x)) = -log(C)
+//                = -log(2^-N) - log(frcpa(1.f1 f2 ... f63))
+//
+// -log(frcpa(x)) = -log(C)
+//                = +Nlog2 - log(frcpa(1.f1 f2 ... f63))
+//
+// -log(frcpa(x)) = -log(C)
+//                = +Nlog2 + log(frcpa(1.f1 f2 ... f63))
+//
+// Log(x) = log(1/frcpa(x)) + log(frcpa(x) x)
+//
+// Log(x) =  +Nlog2 + log(1./frcpa(1.f1 f2 ... f63)) + log(frcpa(x) x)
+// Log(x) =  +Nlog2 - log(/frcpa(1.f1 f2 ... f63))   + log(frcpa(x) x)
+// Log(x) =  +Nlog2 + T                              + log(frcpa(x) x)
+//
+// Log(x) =  +Nlog2 + T                     + log(C x)
+//
+// Cx = 1 + r
+//
+// Log(x) =  +Nlog2 + T  + log(1+r)
+// Log(x) =  +Nlog2 + T  + Series( r - r^2/2 + r^3/3 - r^4/4 ....)
+//
+// 1.f1 f2 ... f8 has 256 entries.
+// They are 1 + k/2^8, k = 0 ... 255
+// These 256 values are the table entries.
+//
+// Implementation
+//==============================================================
+// C = frcpa(x)
+// r = C * x - 1
+//
+// Form rseries = r + P1*r^2 + P2*r^3 + P3*r^4
+//
+// x = f * 2*n where f is 1.f_1f_2f_3....f_63
+// Nfloat = float(n)  where n is the true unbiased exponent
+// pre-index = f_1f_2....f_8
+// index = pre_index * 8
+// get the dxt table entry at index + offset = T
+//
+// result = (T + Nfloat * log(2)) + rseries
+//
+// The T table is calculated as follows
+// Form x_k = 1 + k/2^8 where k goes from 0... 255
+//      y_k = frcpa(x_k)
+//      log(1/y_k)  in quad and round to double
+//
+
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input
+// f9 -> f15,  f32 -> f62
+//
+// General registers used:
+// r14 -> r27, r32 -> r39
+//
+// Predicate registers used:
+// p6 -> p15
+//
+// p6 to filter out case when x = [Q,S]NaN
+// p7,p8 to filter out case when x < 1.0
+//
+// p10 to select path #1
+// p11 to filter out case when x = +INF
+// p12 used in the frcpa
+// p13 to select path #4
+// p14,p15 to select path #2
+
+// Assembly macros
+//==============================================================
+log_GR_exp_17_ones    = r14
+log_GR_signexp_f8     = r15
+log_table_address2    = r16
+log_GR_exp_16_ones    = r17
+log_GR_exp_f8         = r18
+log_GR_true_exp_f8    = r19
+log_GR_significand_f8 = r20
+log_GR_index          = r21
+log_GR_comp2          = r22
+acosh_GR_f8           = r23
+log_GR_comp           = r24
+acosh_GR_f8_sig       = r25
+log_table_address3    = r26
+NR_table_address      = r27
+
+GR_SAVE_B0            = r33
+GR_SAVE_GP            = r34
+GR_SAVE_PFS           = r35
+
+GR_Parameter_X        = r36
+GR_Parameter_Y        = r37
+GR_Parameter_RESULT   = r38
+acosh_GR_tag          = r39
+
+//==============================================================
+log_y            = f9
+NR1              = f10
+NR2              = f11
+log_y_rs         = f12
+log_y_rs_iter    = f13
+log_y_rs_iter1   = f14
+log_NORM_f8      = f15
+log_w            = f32
+acosh_comp       = f34
+acosh_comp2      = f33
+log_P3           = f35
+log_P2           = f36
+log_P1           = f37
+log2             = f38
+log_C0           = f39
+log_C1           = f40
+log_C2           = f41
+acosh_w_rs       = f42
+log_C            = f43
+log_arg          = f44
+acosh_w_iter1    = f45
+acosh_w_iter2    = f46
+log_int_Nfloat   = f47
+log_r            = f48
+log_rsq          = f49
+log_rp_p4        = f50
+log_rp_p32       = f51
+log_rcube        = f52
+log_rp_p10       = f53
+log_rp_p2        = f54
+log_Nfloat       = f55
+log_T            = f56
+log_r2P_r        = f57
+log_T_plus_Nlog2 = f58
+acosh_w_sqrt     = f59
+acosh_w_1        = f60
+log_arg_early    = f61
+log_y_rs_iter2   = f62
+
+
+// Data tables
+//==============================================================
+
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(log_table_1)
+data8 0xbfd0001008f39d59 // p3
+data8 0x3fd5556073e0c45a // p2
+data8 0xbfdffffffffaea15 // p1
+data8 0x3FE62E42FEFA39EF // log2
+LOCAL_OBJECT_END(log_table_1)
+
+LOCAL_OBJECT_START(log_table_2)
+
+data8 0x3FE0000000000000 // 0.5
+data8 0x4008000000000000 // 3.0
+data8 0xD92CBAD213719F11, 0x00003FF9 // C2 3FF9D92CBAD213719F11
+data8 0x93D38EBF2EC9B073, 0x0000BFFC // C1 BFFC93D38EBF2EC9B073
+data8 0xB504F333F9DA0E32, 0x00003FFF // C0 3FFFB504F333F9DA0E32
+LOCAL_OBJECT_END(log_table_2)
+
+LOCAL_OBJECT_START(log_table_3)
+data8 0x3F60040155D5889E    //log(1/frcpa(1+   0/256)
+data8 0x3F78121214586B54    //log(1/frcpa(1+   1/256)
+data8 0x3F841929F96832F0    //log(1/frcpa(1+   2/256)
+data8 0x3F8C317384C75F06    //log(1/frcpa(1+   3/256)
+data8 0x3F91A6B91AC73386    //log(1/frcpa(1+   4/256)
+data8 0x3F95BA9A5D9AC039    //log(1/frcpa(1+   5/256)
+data8 0x3F99D2A8074325F4    //log(1/frcpa(1+   6/256)
+data8 0x3F9D6B2725979802    //log(1/frcpa(1+   7/256)
+data8 0x3FA0C58FA19DFAAA    //log(1/frcpa(1+   8/256)
+data8 0x3FA2954C78CBCE1B    //log(1/frcpa(1+   9/256)
+data8 0x3FA4A94D2DA96C56    //log(1/frcpa(1+  10/256)
+data8 0x3FA67C94F2D4BB58    //log(1/frcpa(1+  11/256)
+data8 0x3FA85188B630F068    //log(1/frcpa(1+  12/256)
+data8 0x3FAA6B8ABE73AF4C    //log(1/frcpa(1+  13/256)
+data8 0x3FAC441E06F72A9E    //log(1/frcpa(1+  14/256)
+data8 0x3FAE1E6713606D07    //log(1/frcpa(1+  15/256)
+data8 0x3FAFFA6911AB9301    //log(1/frcpa(1+  16/256)
+data8 0x3FB0EC139C5DA601    //log(1/frcpa(1+  17/256)
+data8 0x3FB1DBD2643D190B    //log(1/frcpa(1+  18/256)
+data8 0x3FB2CC7284FE5F1C    //log(1/frcpa(1+  19/256)
+data8 0x3FB3BDF5A7D1EE64    //log(1/frcpa(1+  20/256)
+data8 0x3FB4B05D7AA012E0    //log(1/frcpa(1+  21/256)
+data8 0x3FB580DB7CEB5702    //log(1/frcpa(1+  22/256)
+data8 0x3FB674F089365A7A    //log(1/frcpa(1+  23/256)
+data8 0x3FB769EF2C6B568D    //log(1/frcpa(1+  24/256)
+data8 0x3FB85FD927506A48    //log(1/frcpa(1+  25/256)
+data8 0x3FB9335E5D594989    //log(1/frcpa(1+  26/256)
+data8 0x3FBA2B0220C8E5F5    //log(1/frcpa(1+  27/256)
+data8 0x3FBB0004AC1A86AC    //log(1/frcpa(1+  28/256)
+data8 0x3FBBF968769FCA11    //log(1/frcpa(1+  29/256)
+data8 0x3FBCCFEDBFEE13A8    //log(1/frcpa(1+  30/256)
+data8 0x3FBDA727638446A2    //log(1/frcpa(1+  31/256)
+data8 0x3FBEA3257FE10F7A    //log(1/frcpa(1+  32/256)
+data8 0x3FBF7BE9FEDBFDE6    //log(1/frcpa(1+  33/256)
+data8 0x3FC02AB352FF25F4    //log(1/frcpa(1+  34/256)
+data8 0x3FC097CE579D204D    //log(1/frcpa(1+  35/256)
+data8 0x3FC1178E8227E47C    //log(1/frcpa(1+  36/256)
+data8 0x3FC185747DBECF34    //log(1/frcpa(1+  37/256)
+data8 0x3FC1F3B925F25D41    //log(1/frcpa(1+  38/256)
+data8 0x3FC2625D1E6DDF57    //log(1/frcpa(1+  39/256)
+data8 0x3FC2D1610C86813A    //log(1/frcpa(1+  40/256)
+data8 0x3FC340C59741142E    //log(1/frcpa(1+  41/256)
+data8 0x3FC3B08B6757F2A9    //log(1/frcpa(1+  42/256)
+data8 0x3FC40DFB08378003    //log(1/frcpa(1+  43/256)
+data8 0x3FC47E74E8CA5F7C    //log(1/frcpa(1+  44/256)
+data8 0x3FC4EF51F6466DE4    //log(1/frcpa(1+  45/256)
+data8 0x3FC56092E02BA516    //log(1/frcpa(1+  46/256)
+data8 0x3FC5D23857CD74D5    //log(1/frcpa(1+  47/256)
+data8 0x3FC6313A37335D76    //log(1/frcpa(1+  48/256)
+data8 0x3FC6A399DABBD383    //log(1/frcpa(1+  49/256)
+data8 0x3FC70337DD3CE41B    //log(1/frcpa(1+  50/256)
+data8 0x3FC77654128F6127    //log(1/frcpa(1+  51/256)
+data8 0x3FC7E9D82A0B022D    //log(1/frcpa(1+  52/256)
+data8 0x3FC84A6B759F512F    //log(1/frcpa(1+  53/256)
+data8 0x3FC8AB47D5F5A310    //log(1/frcpa(1+  54/256)
+data8 0x3FC91FE49096581B    //log(1/frcpa(1+  55/256)
+data8 0x3FC981634011AA75    //log(1/frcpa(1+  56/256)
+data8 0x3FC9F6C407089664    //log(1/frcpa(1+  57/256)
+data8 0x3FCA58E729348F43    //log(1/frcpa(1+  58/256)
+data8 0x3FCABB55C31693AD    //log(1/frcpa(1+  59/256)
+data8 0x3FCB1E104919EFD0    //log(1/frcpa(1+  60/256)
+data8 0x3FCB94EE93E367CB    //log(1/frcpa(1+  61/256)
+data8 0x3FCBF851C067555F    //log(1/frcpa(1+  62/256)
+data8 0x3FCC5C0254BF23A6    //log(1/frcpa(1+  63/256)
+data8 0x3FCCC000C9DB3C52    //log(1/frcpa(1+  64/256)
+data8 0x3FCD244D99C85674    //log(1/frcpa(1+  65/256)
+data8 0x3FCD88E93FB2F450    //log(1/frcpa(1+  66/256)
+data8 0x3FCDEDD437EAEF01    //log(1/frcpa(1+  67/256)
+data8 0x3FCE530EFFE71012    //log(1/frcpa(1+  68/256)
+data8 0x3FCEB89A1648B971    //log(1/frcpa(1+  69/256)
+data8 0x3FCF1E75FADF9BDE    //log(1/frcpa(1+  70/256)
+data8 0x3FCF84A32EAD7C35    //log(1/frcpa(1+  71/256)
+data8 0x3FCFEB2233EA07CD    //log(1/frcpa(1+  72/256)
+data8 0x3FD028F9C7035C1C    //log(1/frcpa(1+  73/256)
+data8 0x3FD05C8BE0D9635A    //log(1/frcpa(1+  74/256)
+data8 0x3FD085EB8F8AE797    //log(1/frcpa(1+  75/256)
+data8 0x3FD0B9C8E32D1911    //log(1/frcpa(1+  76/256)
+data8 0x3FD0EDD060B78081    //log(1/frcpa(1+  77/256)
+data8 0x3FD122024CF0063F    //log(1/frcpa(1+  78/256)
+data8 0x3FD14BE2927AECD4    //log(1/frcpa(1+  79/256)
+data8 0x3FD180618EF18ADF    //log(1/frcpa(1+  80/256)
+data8 0x3FD1B50BBE2FC63B    //log(1/frcpa(1+  81/256)
+data8 0x3FD1DF4CC7CF242D    //log(1/frcpa(1+  82/256)
+data8 0x3FD214456D0EB8D4    //log(1/frcpa(1+  83/256)
+data8 0x3FD23EC5991EBA49    //log(1/frcpa(1+  84/256)
+data8 0x3FD2740D9F870AFB    //log(1/frcpa(1+  85/256)
+data8 0x3FD29ECDABCDFA04    //log(1/frcpa(1+  86/256)
+data8 0x3FD2D46602ADCCEE    //log(1/frcpa(1+  87/256)
+data8 0x3FD2FF66B04EA9D4    //log(1/frcpa(1+  88/256)
+data8 0x3FD335504B355A37    //log(1/frcpa(1+  89/256)
+data8 0x3FD360925EC44F5D    //log(1/frcpa(1+  90/256)
+data8 0x3FD38BF1C3337E75    //log(1/frcpa(1+  91/256)
+data8 0x3FD3C25277333184    //log(1/frcpa(1+  92/256)
+data8 0x3FD3EDF463C1683E    //log(1/frcpa(1+  93/256)
+data8 0x3FD419B423D5E8C7    //log(1/frcpa(1+  94/256)
+data8 0x3FD44591E0539F49    //log(1/frcpa(1+  95/256)
+data8 0x3FD47C9175B6F0AD    //log(1/frcpa(1+  96/256)
+data8 0x3FD4A8B341552B09    //log(1/frcpa(1+  97/256)
+data8 0x3FD4D4F3908901A0    //log(1/frcpa(1+  98/256)
+data8 0x3FD501528DA1F968    //log(1/frcpa(1+  99/256)
+data8 0x3FD52DD06347D4F6    //log(1/frcpa(1+ 100/256)
+data8 0x3FD55A6D3C7B8A8A    //log(1/frcpa(1+ 101/256)
+data8 0x3FD5925D2B112A59    //log(1/frcpa(1+ 102/256)
+data8 0x3FD5BF406B543DB2    //log(1/frcpa(1+ 103/256)
+data8 0x3FD5EC433D5C35AE    //log(1/frcpa(1+ 104/256)
+data8 0x3FD61965CDB02C1F    //log(1/frcpa(1+ 105/256)
+data8 0x3FD646A84935B2A2    //log(1/frcpa(1+ 106/256)
+data8 0x3FD6740ADD31DE94    //log(1/frcpa(1+ 107/256)
+data8 0x3FD6A18DB74A58C5    //log(1/frcpa(1+ 108/256)
+data8 0x3FD6CF31058670EC    //log(1/frcpa(1+ 109/256)
+data8 0x3FD6F180E852F0BA    //log(1/frcpa(1+ 110/256)
+data8 0x3FD71F5D71B894F0    //log(1/frcpa(1+ 111/256)
+data8 0x3FD74D5AEFD66D5C    //log(1/frcpa(1+ 112/256)
+data8 0x3FD77B79922BD37E    //log(1/frcpa(1+ 113/256)
+data8 0x3FD7A9B9889F19E2    //log(1/frcpa(1+ 114/256)
+data8 0x3FD7D81B037EB6A6    //log(1/frcpa(1+ 115/256)
+data8 0x3FD8069E33827231    //log(1/frcpa(1+ 116/256)
+data8 0x3FD82996D3EF8BCB    //log(1/frcpa(1+ 117/256)
+data8 0x3FD85855776DCBFB    //log(1/frcpa(1+ 118/256)
+data8 0x3FD8873658327CCF    //log(1/frcpa(1+ 119/256)
+data8 0x3FD8AA75973AB8CF    //log(1/frcpa(1+ 120/256)
+data8 0x3FD8D992DC8824E5    //log(1/frcpa(1+ 121/256)
+data8 0x3FD908D2EA7D9512    //log(1/frcpa(1+ 122/256)
+data8 0x3FD92C59E79C0E56    //log(1/frcpa(1+ 123/256)
+data8 0x3FD95BD750EE3ED3    //log(1/frcpa(1+ 124/256)
+data8 0x3FD98B7811A3EE5B    //log(1/frcpa(1+ 125/256)
+data8 0x3FD9AF47F33D406C    //log(1/frcpa(1+ 126/256)
+data8 0x3FD9DF270C1914A8    //log(1/frcpa(1+ 127/256)
+data8 0x3FDA0325ED14FDA4    //log(1/frcpa(1+ 128/256)
+data8 0x3FDA33440224FA79    //log(1/frcpa(1+ 129/256)
+data8 0x3FDA57725E80C383    //log(1/frcpa(1+ 130/256)
+data8 0x3FDA87D0165DD199    //log(1/frcpa(1+ 131/256)
+data8 0x3FDAAC2E6C03F896    //log(1/frcpa(1+ 132/256)
+data8 0x3FDADCCC6FDF6A81    //log(1/frcpa(1+ 133/256)
+data8 0x3FDB015B3EB1E790    //log(1/frcpa(1+ 134/256)
+data8 0x3FDB323A3A635948    //log(1/frcpa(1+ 135/256)
+data8 0x3FDB56FA04462909    //log(1/frcpa(1+ 136/256)
+data8 0x3FDB881AA659BC93    //log(1/frcpa(1+ 137/256)
+data8 0x3FDBAD0BEF3DB165    //log(1/frcpa(1+ 138/256)
+data8 0x3FDBD21297781C2F    //log(1/frcpa(1+ 139/256)
+data8 0x3FDC039236F08819    //log(1/frcpa(1+ 140/256)
+data8 0x3FDC28CB1E4D32FD    //log(1/frcpa(1+ 141/256)
+data8 0x3FDC4E19B84723C2    //log(1/frcpa(1+ 142/256)
+data8 0x3FDC7FF9C74554C9    //log(1/frcpa(1+ 143/256)
+data8 0x3FDCA57B64E9DB05    //log(1/frcpa(1+ 144/256)
+data8 0x3FDCCB130A5CEBB0    //log(1/frcpa(1+ 145/256)
+data8 0x3FDCF0C0D18F326F    //log(1/frcpa(1+ 146/256)
+data8 0x3FDD232075B5A201    //log(1/frcpa(1+ 147/256)
+data8 0x3FDD490246DEFA6B    //log(1/frcpa(1+ 148/256)
+data8 0x3FDD6EFA918D25CD    //log(1/frcpa(1+ 149/256)
+data8 0x3FDD9509707AE52F    //log(1/frcpa(1+ 150/256)
+data8 0x3FDDBB2EFE92C554    //log(1/frcpa(1+ 151/256)
+data8 0x3FDDEE2F3445E4AF    //log(1/frcpa(1+ 152/256)
+data8 0x3FDE148A1A2726CE    //log(1/frcpa(1+ 153/256)
+data8 0x3FDE3AFC0A49FF40    //log(1/frcpa(1+ 154/256)
+data8 0x3FDE6185206D516E    //log(1/frcpa(1+ 155/256)
+data8 0x3FDE882578823D52    //log(1/frcpa(1+ 156/256)
+data8 0x3FDEAEDD2EAC990C    //log(1/frcpa(1+ 157/256)
+data8 0x3FDED5AC5F436BE3    //log(1/frcpa(1+ 158/256)
+data8 0x3FDEFC9326D16AB9    //log(1/frcpa(1+ 159/256)
+data8 0x3FDF2391A2157600    //log(1/frcpa(1+ 160/256)
+data8 0x3FDF4AA7EE03192D    //log(1/frcpa(1+ 161/256)
+data8 0x3FDF71D627C30BB0    //log(1/frcpa(1+ 162/256)
+data8 0x3FDF991C6CB3B379    //log(1/frcpa(1+ 163/256)
+data8 0x3FDFC07ADA69A910    //log(1/frcpa(1+ 164/256)
+data8 0x3FDFE7F18EB03D3E    //log(1/frcpa(1+ 165/256)
+data8 0x3FE007C053C5002E    //log(1/frcpa(1+ 166/256)
+data8 0x3FE01B942198A5A1    //log(1/frcpa(1+ 167/256)
+data8 0x3FE02F74400C64EB    //log(1/frcpa(1+ 168/256)
+data8 0x3FE04360BE7603AD    //log(1/frcpa(1+ 169/256)
+data8 0x3FE05759AC47FE34    //log(1/frcpa(1+ 170/256)
+data8 0x3FE06B5F1911CF52    //log(1/frcpa(1+ 171/256)
+data8 0x3FE078BF0533C568    //log(1/frcpa(1+ 172/256)
+data8 0x3FE08CD9687E7B0E    //log(1/frcpa(1+ 173/256)
+data8 0x3FE0A10074CF9019    //log(1/frcpa(1+ 174/256)
+data8 0x3FE0B5343A234477    //log(1/frcpa(1+ 175/256)
+data8 0x3FE0C974C89431CE    //log(1/frcpa(1+ 176/256)
+data8 0x3FE0DDC2305B9886    //log(1/frcpa(1+ 177/256)
+data8 0x3FE0EB524BAFC918    //log(1/frcpa(1+ 178/256)
+data8 0x3FE0FFB54213A476    //log(1/frcpa(1+ 179/256)
+data8 0x3FE114253DA97D9F    //log(1/frcpa(1+ 180/256)
+data8 0x3FE128A24F1D9AFF    //log(1/frcpa(1+ 181/256)
+data8 0x3FE1365252BF0865    //log(1/frcpa(1+ 182/256)
+data8 0x3FE14AE558B4A92D    //log(1/frcpa(1+ 183/256)
+data8 0x3FE15F85A19C765B    //log(1/frcpa(1+ 184/256)
+data8 0x3FE16D4D38C119FA    //log(1/frcpa(1+ 185/256)
+data8 0x3FE18203C20DD133    //log(1/frcpa(1+ 186/256)
+data8 0x3FE196C7BC4B1F3B    //log(1/frcpa(1+ 187/256)
+data8 0x3FE1A4A738B7A33C    //log(1/frcpa(1+ 188/256)
+data8 0x3FE1B981C0C9653D    //log(1/frcpa(1+ 189/256)
+data8 0x3FE1CE69E8BB106B    //log(1/frcpa(1+ 190/256)
+data8 0x3FE1DC619DE06944    //log(1/frcpa(1+ 191/256)
+data8 0x3FE1F160A2AD0DA4    //log(1/frcpa(1+ 192/256)
+data8 0x3FE2066D7740737E    //log(1/frcpa(1+ 193/256)
+data8 0x3FE2147DBA47A394    //log(1/frcpa(1+ 194/256)
+data8 0x3FE229A1BC5EBAC3    //log(1/frcpa(1+ 195/256)
+data8 0x3FE237C1841A502E    //log(1/frcpa(1+ 196/256)
+data8 0x3FE24CFCE6F80D9A    //log(1/frcpa(1+ 197/256)
+data8 0x3FE25B2C55CD5762    //log(1/frcpa(1+ 198/256)
+data8 0x3FE2707F4D5F7C41    //log(1/frcpa(1+ 199/256)
+data8 0x3FE285E0842CA384    //log(1/frcpa(1+ 200/256)
+data8 0x3FE294294708B773    //log(1/frcpa(1+ 201/256)
+data8 0x3FE2A9A2670AFF0C    //log(1/frcpa(1+ 202/256)
+data8 0x3FE2B7FB2C8D1CC1    //log(1/frcpa(1+ 203/256)
+data8 0x3FE2C65A6395F5F5    //log(1/frcpa(1+ 204/256)
+data8 0x3FE2DBF557B0DF43    //log(1/frcpa(1+ 205/256)
+data8 0x3FE2EA64C3F97655    //log(1/frcpa(1+ 206/256)
+data8 0x3FE3001823684D73    //log(1/frcpa(1+ 207/256)
+data8 0x3FE30E97E9A8B5CD    //log(1/frcpa(1+ 208/256)
+data8 0x3FE32463EBDD34EA    //log(1/frcpa(1+ 209/256)
+data8 0x3FE332F4314AD796    //log(1/frcpa(1+ 210/256)
+data8 0x3FE348D90E7464D0    //log(1/frcpa(1+ 211/256)
+data8 0x3FE35779F8C43D6E    //log(1/frcpa(1+ 212/256)
+data8 0x3FE36621961A6A99    //log(1/frcpa(1+ 213/256)
+data8 0x3FE37C299F3C366A    //log(1/frcpa(1+ 214/256)
+data8 0x3FE38AE2171976E7    //log(1/frcpa(1+ 215/256)
+data8 0x3FE399A157A603E7    //log(1/frcpa(1+ 216/256)
+data8 0x3FE3AFCCFE77B9D1    //log(1/frcpa(1+ 217/256)
+data8 0x3FE3BE9D503533B5    //log(1/frcpa(1+ 218/256)
+data8 0x3FE3CD7480B4A8A3    //log(1/frcpa(1+ 219/256)
+data8 0x3FE3E3C43918F76C    //log(1/frcpa(1+ 220/256)
+data8 0x3FE3F2ACB27ED6C7    //log(1/frcpa(1+ 221/256)
+data8 0x3FE4019C2125CA93    //log(1/frcpa(1+ 222/256)
+data8 0x3FE4181061389722    //log(1/frcpa(1+ 223/256)
+data8 0x3FE42711518DF545    //log(1/frcpa(1+ 224/256)
+data8 0x3FE436194E12B6BF    //log(1/frcpa(1+ 225/256)
+data8 0x3FE445285D68EA69    //log(1/frcpa(1+ 226/256)
+data8 0x3FE45BCC464C893A    //log(1/frcpa(1+ 227/256)
+data8 0x3FE46AED21F117FC    //log(1/frcpa(1+ 228/256)
+data8 0x3FE47A1527E8A2D3    //log(1/frcpa(1+ 229/256)
+data8 0x3FE489445EFFFCCC    //log(1/frcpa(1+ 230/256)
+data8 0x3FE4A018BCB69835    //log(1/frcpa(1+ 231/256)
+data8 0x3FE4AF5A0C9D65D7    //log(1/frcpa(1+ 232/256)
+data8 0x3FE4BEA2A5BDBE87    //log(1/frcpa(1+ 233/256)
+data8 0x3FE4CDF28F10AC46    //log(1/frcpa(1+ 234/256)
+data8 0x3FE4DD49CF994058    //log(1/frcpa(1+ 235/256)
+data8 0x3FE4ECA86E64A684    //log(1/frcpa(1+ 236/256)
+data8 0x3FE503C43CD8EB68    //log(1/frcpa(1+ 237/256)
+data8 0x3FE513356667FC57    //log(1/frcpa(1+ 238/256)
+data8 0x3FE522AE0738A3D8    //log(1/frcpa(1+ 239/256)
+data8 0x3FE5322E26867857    //log(1/frcpa(1+ 240/256)
+data8 0x3FE541B5CB979809    //log(1/frcpa(1+ 241/256)
+data8 0x3FE55144FDBCBD62    //log(1/frcpa(1+ 242/256)
+data8 0x3FE560DBC45153C7    //log(1/frcpa(1+ 243/256)
+data8 0x3FE5707A26BB8C66    //log(1/frcpa(1+ 244/256)
+data8 0x3FE587F60ED5B900    //log(1/frcpa(1+ 245/256)
+data8 0x3FE597A7977C8F31    //log(1/frcpa(1+ 246/256)
+data8 0x3FE5A760D634BB8B    //log(1/frcpa(1+ 247/256)
+data8 0x3FE5B721D295F10F    //log(1/frcpa(1+ 248/256)
+data8 0x3FE5C6EA94431EF9    //log(1/frcpa(1+ 249/256)
+data8 0x3FE5D6BB22EA86F6    //log(1/frcpa(1+ 250/256)
+data8 0x3FE5E6938645D390    //log(1/frcpa(1+ 251/256)
+data8 0x3FE5F673C61A2ED2    //log(1/frcpa(1+ 252/256)
+data8 0x3FE6065BEA385926    //log(1/frcpa(1+ 253/256)
+data8 0x3FE6164BFA7CC06B    //log(1/frcpa(1+ 254/256)
+data8 0x3FE62643FECF9743    //log(1/frcpa(1+ 255/256)
+LOCAL_OBJECT_END(log_table_3)
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(acoshf)
+
+{ .mfi
+      getf.exp   acosh_GR_f8 = f8
+      fclass.m   p6,p0 = f8, 0xc3                    // Test for x = NaN
+      mov        log_GR_comp2 = 0x10032
+}
+{ .mfi
+      addl       NR_table_address = @ltoff(log_table_1), gp
+      fms.s1     log_y = f8, f8, f1                  // y = x^2-1
+      nop.i      0
+}
+;;
+
+{ .mfi
+      getf.sig   acosh_GR_f8_sig = f8
+      fclass.m   p11,p0 = f8, 0x21                   // Test for x=+inf
+      mov        log_GR_exp_17_ones = 0x1ffff
+}
+{ .mfi
+      ld8        NR_table_address = [NR_table_address]
+      fms.s1     log_w = f8,f1,f1                    // w = x - 1
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fcmp.lt.s1 p7,p8 = f8, f1            // Test for x<1.0
+      addl       log_GR_comp = 0x10020C,r0 // Upper 21 bits of signif of 1.0005
+}
+{ .mfb
+      mov        log_GR_exp_16_ones = 0xffff         //BIAS
+(p6)  fma.s.s0   f8 = f8,f1,f0      // quietize nan result if x=nan
+(p6)  br.ret.spnt b0                // Exit for x=nan
+}
+;;
+
+{ .mfb
+      //get second table address
+      adds       log_table_address2 = 0x20, NR_table_address
+      fcmp.eq.s1 p10,p0 = f8, f1      // Test for x=+1.0
+(p11) br.ret.spnt b0                  // Exit for x=+inf
+}
+;;
+
+{ .mfi
+      ldfpd      NR1,NR2 = [log_table_address2],16
+      frsqrta.s1 log_y_rs,p0 = log_y  // z=1/sqrt(y)
+      nop.i      0
+}
+{ .mfb
+      nop.m      0
+      fma.s1     log_arg = f8,f1,f8
+(p7)  br.cond.spnt ACOSH_LESS_ONE     // Branch if path 7, x < 1.0
+}
+;;
+
+{ .mfi
+      ldfe       log_C2 = [log_table_address2],16
+(p8)  fcmp.eq.s0 p6,p0 = f8, f0       // Dummy op sets denorm flag if unorm>=1.0
+      nop.i      0
+}
+{ .mfb
+(p8)  cmp.le.unc p13,p0 = log_GR_comp2,acosh_GR_f8
+      nop.f      0
+(p13) br.cond.spnt LOG_COMMON1        // Branch if path 4, x >= 2^51
+}
+;;
+
+{ .mfi
+      ldfe       log_C1 = [log_table_address2],16
+(p10) fmerge.s   f8 = f0, f0          // Return 0 if x=1.0
+      shr.u      acosh_GR_f8_sig = acosh_GR_f8_sig,43
+}
+{ .mib
+      cmp.eq     p14,p0 = log_GR_exp_16_ones,acosh_GR_f8
+      nop.i      0
+(p10) br.ret.spnt b0                  // Exit for x=1.0
+}
+;;
+
+{ .mfi
+      ldfe       log_C0 = [log_table_address2],16
+      frsqrta.s1 acosh_w_rs,p0 = log_w // t=1/sqrt(w)
+      nop.i      0
+}
+{ .mfb
+(p14) cmp.lt.unc p15,p0 = acosh_GR_f8_sig,log_GR_comp
+      nop.f      0
+(p15) br.cond.spnt ACOSH_NEAR_ONE     // Branch if path 2, 1.0 < x < 1.0005
+}
+;;
+
+// Here is main path, 1.0005 <= x < 2^51
+/////////////// The first iteration //////////////////////////////////
+{ .mfi
+      ldfpd      log_P3,log_P2 = [NR_table_address],16
+      fma.s1     log_y_rs_iter = log_y_rs,log_y,f0              // y*z
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfpd      log_P1,log2 = [NR_table_address],16
+      fnma.s1    log_y_rs_iter2 = log_y_rs_iter,log_y_rs,NR2    // 3-(y*z)*z
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs,NR1,f0               // 0.5*z
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      // (0.5*z)*(3-(y*z)*z)
+      fma.s1     log_y_rs_iter = log_y_rs_iter1,log_y_rs_iter2,f0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      // (0.5*z)*(3-(y*z)*z)
+      fma.s1     log_arg_early = log_y_rs_iter1,log_y_rs_iter2,f0
+      nop.i      0
+}
+;;
+
+/////////////////////////// The second iteration /////////////////////////////
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs = log_y_rs_iter,log_y,f0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs_iter,NR1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_arg_early = log_arg_early,log_y,f8
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fnma.s1    log_y_rs = log_y_rs,log_y_rs_iter,NR2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs_iter1,log_y,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      frcpa.s1   log_C,p0 = f1,log_arg_early
+      nop.i      0
+}
+;;
+
+{ .mfi
+      getf.exp   log_GR_signexp_f8 = log_arg_early
+      nop.f      0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      getf.sig   log_GR_significand_f8 = log_arg_early
+      fma.s1     log_arg = log_y_rs_iter1,log_y_rs,f8 // (0.5*z)*(3-(y*z)*z)
+      adds       log_table_address3 = 0x40, NR_table_address
+}
+;;
+
+///////////////////////////////// The end NR iterations /////////////////////
+
+{ .mmi
+      //significant bit destruction
+      and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones
+;;
+      //BIAS subtraction
+      sub        log_GR_true_exp_f8 = log_GR_exp_f8, log_GR_exp_16_ones
+      nop.i      0
+}
+;;
+
+{ .mfi
+      setf.sig   log_int_Nfloat = log_GR_true_exp_f8
+      fms.s1     log_r = log_C,log_arg,f1  // C = frcpa(x); r = C * x - 1
+      extr.u     log_GR_index = log_GR_significand_f8,55,8 //Extract 8 bits
+}
+;;
+
+{ .mmi
+      //pre-index*8 + index
+      shladd     log_table_address3 = log_GR_index,3,log_table_address3
+;;
+      ldfd       log_T = [log_table_address3]
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rsq = log_r, log_r, f0         //r^2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p32 = log_P3, log_r, log_P2 //P3*r + P2
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p10 = log_P1, log_r, f1     //P1*r + 1.0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //convert N to the floating-point format log_Nfloat
+      fcvt.xf    log_Nfloat = log_int_Nfloat
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //(P3*r + P2)*r^2 + P1*r + 1.0
+      fma.s1     log_rp_p2 = log_rp_p32, log_rsq, log_rp_p10
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_T_plus_Nlog2 = log_Nfloat,log2,log_T    //N*log2 + T
+      nop.i      0
+}
+;;
+
+{ .mfb
+      nop.m      0
+      fma.s.s0   f8 = log_rp_p2,log_r,log_T_plus_Nlog2
+      br.ret.sptk b0          // Exit main path, path 3: 1.0005 <= x < 2^51
+}
+;;
+
+// Here if path 2, 1.0 < x < 1.0005
+ACOSH_NEAR_ONE:
+// The first NR iteration
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_iter1 = acosh_w_rs,log_w,f0  //t*w
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_1 = f8,log_C2,log_C1         //x*C2 + C1
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_iter2 = acosh_w_rs,NR1,f0    //t*0.5
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fnma.s1    acosh_w_iter1 = acosh_w_iter1,acosh_w_rs,NR2 //3-t*t*w
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //(3-t*t*w)*t*0.5
+      fma.s1     acosh_w_iter2 = acosh_w_iter2,acosh_w_iter1,f0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_1 = acosh_w_1,log_w,log_C0 //(x*C2 + C1)*(x-1) + C0
+      nop.i      0
+}
+;;
+
+// The second NR iteration
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_rs = acosh_w_iter2,log_w,f0  //t*w
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fnma.s1    acosh_w_iter1 = acosh_w_iter2,acosh_w_rs,NR2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_iter2 = acosh_w_iter2,NR1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_iter2 = acosh_w_iter2,acosh_w_iter1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     acosh_w_sqrt = acosh_w_iter2,log_w,f0
+      nop.i      0
+}
+;;
+
+{ .mfb
+      nop.m      0
+      fma.s.s0   f8 = acosh_w_1,acosh_w_sqrt,f0
+      br.ret.sptk b0          // Exit path 2, 1.0 < x < 1.0005
+}
+;;
+
+// Here if path 4, x >= 2^51
+LOG_COMMON1:
+{ .mfi
+      ldfpd      log_P3,log_P2 = [NR_table_address],16
+      frcpa.s1   log_C,p0 = f1,log_arg
+      nop.i      0
+}
+;;
+
+{ .mmi
+      getf.exp   log_GR_signexp_f8 = log_arg
+      ldfpd      log_P1,log2 = [NR_table_address],16
+      nop.i      0
+}
+;;
+
+{ .mmi
+      getf.sig   log_GR_significand_f8 = log_arg
+      nop.m      0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      adds       log_table_address3 = 0x40, NR_table_address
+      nop.f      0
+      //significant bit destruction
+      and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones
+}
+;;
+
+{ .mmf
+      nop.m      0
+      //BIAS subtraction
+      sub        log_GR_true_exp_f8 = log_GR_exp_f8, log_GR_exp_16_ones
+      fms.s1     log_r = log_C,log_arg,f1  // C = frcpa(x); r = C * x - 1
+}
+;;
+
+{ .mfi
+      setf.sig   log_int_Nfloat = log_GR_true_exp_f8
+      nop.f      0
+      extr.u     log_GR_index = log_GR_significand_f8,55,8 //Extract 8 bits
+}
+;;
+
+{ .mmi
+      //pre-index*8 + index
+      shladd     log_table_address3 = log_GR_index,3,log_table_address3
+;;
+      ldfd       log_T = [log_table_address3]
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rsq = log_r, log_r, f0         //r^2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p32 = log_P3, log_r, log_P2 //P3*r + P2
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p10 = log_P1, log_r, f1     //P1*r + 1.0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //convert N to the floating-point format log_Nfloat
+      fcvt.xf    log_Nfloat = log_int_Nfloat
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p2 = log_rp_p32, log_rsq, log_rp_p10
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_T_plus_Nlog2 = log_Nfloat,log2,log_T    //N*log2 + T
+      nop.i      0
+}
+;;
+
+{ .mfb
+      nop.m      0
+      fma.s.s0   f8 = log_rp_p2,log_r,log_T_plus_Nlog2
+      br.ret.sptk b0        // Exit path 4, x >= 2^51
+}
+;;
+
+// Here if path 7, x < 1.0
+ACOSH_LESS_ONE:
+{ .mfi
+      alloc      r32 = ar.pfs,1,3,4,0
+      fmerge.s   f10 = f8,f8
+      nop.i      0
+}
+;;
+
+{ .mfb
+      mov        acosh_GR_tag = 137
+      frcpa.s0   f8,p0 = f0,f0
+      br.cond.sptk __libm_error_region
+}
+;;
+
+GLOBAL_LIBM_END(acoshf)
+libm_alias_float_other (acosh, acosh)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                          // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                      // Save gp
+};;
+
+{ .mmi
+        stfs [GR_Parameter_Y] = f1,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp            // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                     // Save b0
+};;
+
+.body
+{ .mib
+        stfs [GR_Parameter_X] = f10           // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfs [GR_Parameter_Y] = f8            // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support# // Call error handling function
+};;
+
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+
+{ .mmi
+        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_acoshl.S
@@ -0,0 +1,1712 @@
+.file "acoshl.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 10/01/01 Initial version
+// 10/10/01 Performance inproved
+// 12/11/01 Changed huges_logp to not be global
+// 01/02/02 Corrected .restore syntax
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 08/14/02 Changed mli templates to mlx
+// 02/06/03 Reorganized data tables
+// 03/31/05 Reformatted delimiters between data tables
+//
+//*********************************************************************
+//
+// API
+//==============================================================
+// long double acoshl(long double);
+//
+// Overview of operation
+//==============================================================
+//
+// There are 6 paths:
+// 1. x = 1
+//    Return acoshl(x) = 0;
+//
+// 2. x < 1
+//    Return acoshl(x) = Nan (Domain error, error handler call with tag 135);
+//
+// 3. x = [S,Q]Nan or +INF
+//    Return acoshl(x) = x + x;
+//
+// 4. 'Near 1': 1 < x < 1+1/8
+//    Return acoshl(x) = sqrtl(2*y)*(1-P(y)/Q(y)),
+//                   where y = 1, P(y)/Q(y) - rational approximation
+//
+// 5. 'Huges': x > 0.5*2^64
+//    Return acoshl(x) = (logl(2*x-1));
+//
+// 6. 'Main path': 1+1/8 < x < 0.5*2^64
+//    b_hi + b_lo = x + sqrt(x^2 - 1);
+//    acoshl(x) = logl_special(b_hi, b_lo);
+//
+// Algorithm description
+//==============================================================
+//
+// I. Near 1 path algorithm
+// **************************************************************
+// The formula is acoshl(x) = sqrtl(2*y)*(1-P(y)/Q(y)),
+//                 where y = 1, P(y)/Q(y) - rational approximation
+//
+// 1) y = x - 1, y2 = 2 * y
+//
+// 2) Compute in parallel sqrtl(2*y) and P(y)/Q(y)
+//    a) sqrtl computation method described below (main path algorithm, item 2))
+//       As result we obtain (gg+gl) - multiprecision result
+//       as pair of double extended values
+//    b) P(y) and Q(y) calculated without any extra precision manipulations
+//    c) P/Q division:
+//       y = frcpa(Q)         initial approximation of 1/Q
+//       z = P*y              initial approximation of P/Q
+//
+//       e = 1 - b*y
+//       e2 = e + e^2
+//       e1 = e^2
+//       y1 = y + y*e2 = y + y*(e+e^2)
+//
+//       e3 = e + e1^2
+//       y2 = y + y1*e3 = y + y*(e+e^2+..+e^6)
+//
+//       r = P - Q*z
+//       e = 1 - Q*y2
+//       xx = z + r*y2         high part of a/b
+//
+//       y3 = y2 + y2*e4
+//       r1 = P  - Q*xx
+//       xl = r1*y3            low part of a/b
+//
+// 3) res = sqrt(2*y) - sqrt(2*y)*(P(y)/Q(y)) =
+//        = (gg+gl) - (gg + gl)*(xx+xl);
+//
+//    a) hh = gg*xx; hl = gg*xl; lh = gl*xx; ll = gl*xl;
+//    b) res = ((((gl + ll) + lh) + hl) + hh) + gg;
+//       (exactly in this order)
+//
+// II. Main path algorithm
+// ( thanks to Peter Markstein for the idea of sqrt(x^2+1) computation! )
+// **********************************************************************
+//
+// There are 3 parts of x+sqrt(x^2-1) computation:
+//
+//  1) m2 = (m2_hi+m2_lo) = x^2-1 obtaining
+//     ------------------------------------
+//     m2_hi = x2_hi - 1, where x2_hi = x * x;
+//     m2_lo = x2_lo + p1_lo, where
+//                            x2_lo = FMS(x*x-x2_hi),
+//                            p1_lo = (1 + m2_hi) - x2_hi;
+//
+//  2) g = (g_hi+g_lo) = sqrt(m2) = sqrt(m2_hi+m2_lo)
+//     ----------------------------------------------
+//     r = invsqrt(m2_hi) (8-bit reciprocal square root approximation);
+//     g = m2_hi * r (first 8 bit-approximation of sqrt);
+//
+//     h = 0.5 * r;
+//     e = 0.5 - g * h;
+//     g = g * e + g (second 16 bit-approximation of sqrt);
+//
+//     h = h * e + h;
+//     e = 0.5 - g * h;
+//     g = g * e + g (third 32 bit-approximation of sqrt);
+//
+//     h = h * e + h;
+//     e = 0.5 - g * h;
+//     g_hi = g * e + g (fourth 64 bit-approximation of sqrt);
+//
+//     Remainder computation:
+//     h = h * e + h;
+//     d = (m2_hi - g_hi * g_hi) + m2_lo;
+//     g_lo = d * h;
+//
+//  3) b = (b_hi + b_lo) = x + g, where g = (g_hi + g_lo) = sqrt(x^2-1)
+//     -------------------------------------------------------------------
+//     b_hi = (g_hi + x) + gl;
+//     b_lo = (x - b_hi) + g_hi + gl;
+//
+//  Now we pass b presented as sum b_hi + b_lo to special version
+//  of logl function which accept a pair of arguments as
+//  mutiprecision value.
+//
+//  Special log algorithm overview
+//  ================================
+//   Here we use a table lookup method. The basic idea is that in
+//   order to compute logl(Arg) for an argument Arg in [1,2),
+//   we construct a value G such that G*Arg is close to 1 and that
+//   logl(1/G) is obtainable easily from a table of values calculated
+//   beforehand. Thus
+//
+//      logl(Arg) = logl(1/G) + logl((G*Arg - 1))
+//
+//   Because |G*Arg - 1| is small, the second term on the right hand
+//   side can be approximated by a short polynomial. We elaborate
+//   this method in four steps.
+//
+//   Step 0: Initialization
+//
+//   We need to calculate logl( X+1 ). Obtain N, S_hi such that
+//
+//      X = 2^N * ( S_hi + S_lo )   exactly
+//
+//   where S_hi in [1,2) and S_lo is a correction to S_hi in the sense
+//   that |S_lo| <= ulp(S_hi).
+//
+//   For the special version of logl: S_lo = b_lo
+//   !-----------------------------------------------!
+//
+//   Step 1: Argument Reduction
+//
+//   Based on S_hi, obtain G_1, G_2, G_3 from a table and calculate
+//
+//      G := G_1 * G_2 * G_3
+//      r := (G * S_hi - 1) + G * S_lo
+//
+//   These G_j's have the property that the product is exactly
+//   representable and that |r| < 2^(-12) as a result.
+//
+//   Step 2: Approximation
+//
+//   logl(1 + r) is approximated by a short polynomial poly(r).
+//
+//   Step 3: Reconstruction
+//
+//   Finally, logl( X ) = logl( X+1 ) is given by
+//
+//   logl( X )   =   logl( 2^N * (S_hi + S_lo) )
+//                 ~=~  N*logl(2) + logl(1/G) + logl(1 + r)
+//                 ~=~  N*logl(2) + logl(1/G) + poly(r).
+//
+//   For detailed description see logl or log1pl function, regular path.
+//
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input
+// f32 -> f95 (64 registers)
+
+// General registers used:
+// r32 -> r67 (36 registers)
+
+// Predicate registers used:
+// p7 -> p11
+// p7  for 'NaNs, Inf' path
+// p8  for 'near 1' path
+// p9  for 'huges' path
+// p10 for x = 1
+// p11 for x < 1
+//
+//*********************************************************************
+// IEEE Special Conditions:
+//
+//    acoshl(+inf)  = +inf
+//    acoshl(-inf) = QNaN
+//    acoshl(1)    = 0
+//    acoshl(x<1)  = QNaN
+//    acoshl(SNaN) = QNaN
+//    acoshl(QNaN) = QNaN
+//
+
+// Data tables
+//==============================================================
+
+RODATA
+.align 64
+
+// Near 1 path rational approximation coefficients
+LOCAL_OBJECT_START(Poly_P)
+data8 0xB0978143F695D40F, 0x3FF1  // .84205539791447100108478906277453574946e-4
+data8 0xB9800D841A8CAD29, 0x3FF6  // .28305085180397409672905983082168721069e-2
+data8 0xC889F455758C1725, 0x3FF9  // .24479844297887530847660233111267222945e-1
+data8 0x9BE1DFF006F45F12, 0x3FFB  // .76114415657565879842941751209926938306e-1
+data8 0x9E34AF4D372861E0, 0x3FFB  // .77248925727776366270605984806795850504e-1
+data8 0xF3DC502AEE14C4AE, 0x3FA6  // .3077953476682583606615438814166025592e-26
+LOCAL_OBJECT_END(Poly_P)
+
+//
+LOCAL_OBJECT_START(Poly_Q)
+data8 0xF76E3FD3C7680357, 0x3FF1  // .11798413344703621030038719253730708525e-3
+data8 0xD107D2E7273263AE, 0x3FF7  // .63791065024872525660782716786703188820e-2
+data8 0xB609BE5CDE206AEF, 0x3FFB  // .88885771950814004376363335821980079985e-1
+data8 0xF7DEACAC28067C8A, 0x3FFD  // .48412074662702495416825113623936037072302
+data8 0x8F9BE5890CEC7E38, 0x3FFF  // 1.1219450873557867470217771071068369729526
+data8 0xED4F06F3D2BC92D1, 0x3FFE  // .92698710873331639524734537734804056798748
+LOCAL_OBJECT_END(Poly_Q)
+
+// Q coeffs
+LOCAL_OBJECT_START(Constants_Q)
+data4  0x00000000,0xB1721800,0x00003FFE,0x00000000
+data4  0x4361C4C6,0x82E30865,0x0000BFE2,0x00000000
+data4  0x328833CB,0xCCCCCAF2,0x00003FFC,0x00000000
+data4  0xA9D4BAFB,0x80000077,0x0000BFFD,0x00000000
+data4  0xAAABE3D2,0xAAAAAAAA,0x00003FFD,0x00000000
+data4  0xFFFFDAB7,0xFFFFFFFF,0x0000BFFD,0x00000000
+LOCAL_OBJECT_END(Constants_Q)
+
+// Z1 - 16 bit fixed
+LOCAL_OBJECT_START(Constants_Z_1)
+data4  0x00008000
+data4  0x00007879
+data4  0x000071C8
+data4  0x00006BCB
+data4  0x00006667
+data4  0x00006187
+data4  0x00005D18
+data4  0x0000590C
+data4  0x00005556
+data4  0x000051EC
+data4  0x00004EC5
+data4  0x00004BDB
+data4  0x00004925
+data4  0x0000469F
+data4  0x00004445
+data4  0x00004211
+LOCAL_OBJECT_END(Constants_Z_1)
+
+// G1 and H1 - IEEE single and h1 - IEEE double
+LOCAL_OBJECT_START(Constants_G_H_h1)
+data4  0x3F800000,0x00000000
+data8  0x0000000000000000
+data4  0x3F70F0F0,0x3D785196
+data8  0x3DA163A6617D741C
+data4  0x3F638E38,0x3DF13843
+data8  0x3E2C55E6CBD3D5BB
+data4  0x3F579430,0x3E2FF9A0
+data8  0xBE3EB0BFD86EA5E7
+data4  0x3F4CCCC8,0x3E647FD6
+data8  0x3E2E6A8C86B12760
+data4  0x3F430C30,0x3E8B3AE7
+data8  0x3E47574C5C0739BA
+data4  0x3F3A2E88,0x3EA30C68
+data8  0x3E20E30F13E8AF2F
+data4  0x3F321640,0x3EB9CEC8
+data8  0xBE42885BF2C630BD
+data4  0x3F2AAAA8,0x3ECF9927
+data8  0x3E497F3497E577C6
+data4  0x3F23D708,0x3EE47FC5
+data8  0x3E3E6A6EA6B0A5AB
+data4  0x3F1D89D8,0x3EF8947D
+data8  0xBDF43E3CD328D9BE
+data4  0x3F17B420,0x3F05F3A1
+data8  0x3E4094C30ADB090A
+data4  0x3F124920,0x3F0F4303
+data8  0xBE28FBB2FC1FE510
+data4  0x3F0D3DC8,0x3F183EBF
+data8  0x3E3A789510FDE3FA
+data4  0x3F088888,0x3F20EC80
+data8  0x3E508CE57CC8C98F
+data4  0x3F042108,0x3F29516A
+data8  0xBE534874A223106C
+LOCAL_OBJECT_END(Constants_G_H_h1)
+
+// Z2 - 16 bit fixed
+LOCAL_OBJECT_START(Constants_Z_2)
+data4  0x00008000
+data4  0x00007F81
+data4  0x00007F02
+data4  0x00007E85
+data4  0x00007E08
+data4  0x00007D8D
+data4  0x00007D12
+data4  0x00007C98
+data4  0x00007C20
+data4  0x00007BA8
+data4  0x00007B31
+data4  0x00007ABB
+data4  0x00007A45
+data4  0x000079D1
+data4  0x0000795D
+data4  0x000078EB
+LOCAL_OBJECT_END(Constants_Z_2)
+
+// G2 and H2 - IEEE single and h2 - IEEE double
+LOCAL_OBJECT_START(Constants_G_H_h2)
+data4  0x3F800000,0x00000000
+data8  0x0000000000000000
+data4  0x3F7F00F8,0x3B7F875D
+data8  0x3DB5A11622C42273
+data4  0x3F7E03F8,0x3BFF015B
+data8  0x3DE620CF21F86ED3
+data4  0x3F7D08E0,0x3C3EE393
+data8  0xBDAFA07E484F34ED
+data4  0x3F7C0FC0,0x3C7E0586
+data8  0xBDFE07F03860BCF6
+data4  0x3F7B1880,0x3C9E75D2
+data8  0x3DEA370FA78093D6
+data4  0x3F7A2328,0x3CBDC97A
+data8  0x3DFF579172A753D0
+data4  0x3F792FB0,0x3CDCFE47
+data8  0x3DFEBE6CA7EF896B
+data4  0x3F783E08,0x3CFC15D0
+data8  0x3E0CF156409ECB43
+data4  0x3F774E38,0x3D0D874D
+data8  0xBE0B6F97FFEF71DF
+data4  0x3F766038,0x3D1CF49B
+data8  0xBE0804835D59EEE8
+data4  0x3F757400,0x3D2C531D
+data8  0x3E1F91E9A9192A74
+data4  0x3F748988,0x3D3BA322
+data8  0xBE139A06BF72A8CD
+data4  0x3F73A0D0,0x3D4AE46F
+data8  0x3E1D9202F8FBA6CF
+data4  0x3F72B9D0,0x3D5A1756
+data8  0xBE1DCCC4BA796223
+data4  0x3F71D488,0x3D693B9D
+data8  0xBE049391B6B7C239
+LOCAL_OBJECT_END(Constants_G_H_h2)
+
+// G3 and H3 - IEEE single and h3 - IEEE double
+LOCAL_OBJECT_START(Constants_G_H_h3)
+data4  0x3F7FFC00,0x38800100
+data8  0x3D355595562224CD
+data4  0x3F7FF400,0x39400480
+data8  0x3D8200A206136FF6
+data4  0x3F7FEC00,0x39A00640
+data8  0x3DA4D68DE8DE9AF0
+data4  0x3F7FE400,0x39E00C41
+data8  0xBD8B4291B10238DC
+data4  0x3F7FDC00,0x3A100A21
+data8  0xBD89CCB83B1952CA
+data4  0x3F7FD400,0x3A300F22
+data8  0xBDB107071DC46826
+data4  0x3F7FCC08,0x3A4FF51C
+data8  0x3DB6FCB9F43307DB
+data4  0x3F7FC408,0x3A6FFC1D
+data8  0xBD9B7C4762DC7872
+data4  0x3F7FBC10,0x3A87F20B
+data8  0xBDC3725E3F89154A
+data4  0x3F7FB410,0x3A97F68B
+data8  0xBD93519D62B9D392
+data4  0x3F7FAC18,0x3AA7EB86
+data8  0x3DC184410F21BD9D
+data4  0x3F7FA420,0x3AB7E101
+data8  0xBDA64B952245E0A6
+data4  0x3F7F9C20,0x3AC7E701
+data8  0x3DB4B0ECAABB34B8
+data4  0x3F7F9428,0x3AD7DD7B
+data8  0x3D9923376DC40A7E
+data4  0x3F7F8C30,0x3AE7D474
+data8  0x3DC6E17B4F2083D3
+data4  0x3F7F8438,0x3AF7CBED
+data8  0x3DAE314B811D4394
+data4  0x3F7F7C40,0x3B03E1F3
+data8  0xBDD46F21B08F2DB1
+data4  0x3F7F7448,0x3B0BDE2F
+data8  0xBDDC30A46D34522B
+data4  0x3F7F6C50,0x3B13DAAA
+data8  0x3DCB0070B1F473DB
+data4  0x3F7F6458,0x3B1BD766
+data8  0xBDD65DDC6AD282FD
+data4  0x3F7F5C68,0x3B23CC5C
+data8  0xBDCDAB83F153761A
+data4  0x3F7F5470,0x3B2BC997
+data8  0xBDDADA40341D0F8F
+data4  0x3F7F4C78,0x3B33C711
+data8  0x3DCD1BD7EBC394E8
+data4  0x3F7F4488,0x3B3BBCC6
+data8  0xBDC3532B52E3E695
+data4  0x3F7F3C90,0x3B43BAC0
+data8  0xBDA3961EE846B3DE
+data4  0x3F7F34A0,0x3B4BB0F4
+data8  0xBDDADF06785778D4
+data4  0x3F7F2CA8,0x3B53AF6D
+data8  0x3DCC3ED1E55CE212
+data4  0x3F7F24B8,0x3B5BA620
+data8  0xBDBA31039E382C15
+data4  0x3F7F1CC8,0x3B639D12
+data8  0x3D635A0B5C5AF197
+data4  0x3F7F14D8,0x3B6B9444
+data8  0xBDDCCB1971D34EFC
+data4  0x3F7F0CE0,0x3B7393BC
+data8  0x3DC7450252CD7ADA
+data4  0x3F7F04F0,0x3B7B8B6D
+data8  0xBDB68F177D7F2A42
+LOCAL_OBJECT_END(Constants_G_H_h3)
+
+// Assembly macros
+//==============================================================
+
+// Floating Point Registers
+
+FR_Arg          = f8
+FR_Res          = f8
+
+
+FR_PP0          = f32
+FR_PP1          = f33
+FR_PP2          = f34
+FR_PP3          = f35
+FR_PP4          = f36
+FR_PP5          = f37
+FR_QQ0          = f38
+FR_QQ1          = f39
+FR_QQ2          = f40
+FR_QQ3          = f41
+FR_QQ4          = f42
+FR_QQ5          = f43
+
+FR_Q1           = f44
+FR_Q2           = f45
+FR_Q3           = f46
+FR_Q4           = f47
+
+FR_Half         = f48
+FR_Two          = f49
+
+FR_log2_hi      = f50
+FR_log2_lo      = f51
+
+
+FR_X2           = f52
+FR_M2           = f53
+FR_M2L          = f54
+FR_Rcp          = f55
+FR_GG           = f56
+FR_HH           = f57
+FR_EE           = f58
+FR_DD           = f59
+FR_GL           = f60
+FR_Tmp          = f61
+
+
+FR_XM1          = f62
+FR_2XM1         = f63
+FR_XM12         = f64
+
+
+
+    // Special logl registers
+FR_XLog_Hi      = f65
+FR_XLog_Lo      = f66
+
+FR_Y_hi         = f67
+FR_Y_lo         = f68
+
+FR_S_hi         = f69
+FR_S_lo         = f70
+
+FR_poly_lo      = f71
+FR_poly_hi      = f72
+
+FR_G            = f73
+FR_H            = f74
+FR_h            = f75
+
+FR_G2           = f76
+FR_H2           = f77
+FR_h2           = f78
+
+FR_r            = f79
+FR_rsq          = f80
+FR_rcub         = f81
+
+FR_float_N      = f82
+
+FR_G3           = f83
+FR_H3           = f84
+FR_h3           = f85
+
+FR_2_to_minus_N = f86
+
+
+   // Near 1  registers
+FR_PP           = f65
+FR_QQ           = f66
+
+
+FR_PV6          = f69
+FR_PV4          = f70
+FR_PV3          = f71
+FR_PV2          = f72
+
+FR_QV6          = f73
+FR_QV4          = f74
+FR_QV3          = f75
+FR_QV2          = f76
+
+FR_Y0           = f77
+FR_Q0           = f78
+FR_E0           = f79
+FR_E2           = f80
+FR_E1           = f81
+FR_Y1           = f82
+FR_E3           = f83
+FR_Y2           = f84
+FR_R0           = f85
+FR_E4           = f86
+FR_Y3           = f87
+FR_R1           = f88
+FR_X_Hi         = f89
+FR_X_lo         = f90
+
+FR_HH           = f91
+FR_LL           = f92
+FR_HL           = f93
+FR_LH           = f94
+
+
+
+	// Error handler registers
+FR_Arg_X        = f95
+FR_Arg_Y        = f0
+
+
+// General Purpose Registers
+
+    // General prolog registers
+GR_PFS          = r32
+GR_OneP125      = r33
+GR_TwoP63       = r34
+GR_Arg          = r35
+GR_Half         = r36
+
+    // Near 1 path registers
+GR_Poly_P       = r37
+GR_Poly_Q       = r38
+
+    // Special logl registers
+GR_Index1       = r39
+GR_Index2       = r40
+GR_signif       = r41
+GR_X_0          = r42
+GR_X_1          = r43
+GR_X_2          = r44
+GR_minus_N      = r45
+GR_Z_1          = r46
+GR_Z_2          = r47
+GR_N            = r48
+GR_Bias         = r49
+GR_M            = r50
+GR_Index3       = r51
+GR_exp_2tom80   = r52
+GR_exp_mask     = r53
+GR_exp_2tom7    = r54
+GR_ad_ln10      = r55
+GR_ad_tbl_1     = r56
+GR_ad_tbl_2     = r57
+GR_ad_tbl_3     = r58
+GR_ad_q         = r59
+GR_ad_z_1       = r60
+GR_ad_z_2       = r61
+GR_ad_z_3       = r62
+
+//
+// Added for unwind support
+//
+GR_SAVE_PFS         = r32
+GR_SAVE_B0          = r33
+GR_SAVE_GP          = r34
+
+GR_Parameter_X      = r64
+GR_Parameter_Y      = r65
+GR_Parameter_RESULT = r66
+GR_Parameter_TAG    = r67
+
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(acoshl)
+
+{ .mfi
+      alloc      GR_PFS       = ar.pfs,0,32,4,0     // Local frame allocation
+      fcmp.lt.s1 p11, p0      = FR_Arg, f1          // if arg is less than 1
+      mov	     GR_Half      = 0xfffe              // 0.5's exp
+}
+{ .mfi
+      addl       GR_Poly_Q    = @ltoff(Poly_Q), gp  // Address of Q-coeff table
+      fma.s1     FR_X2        = FR_Arg, FR_Arg, f0  // Obtain x^2
+      addl       GR_Poly_P    = @ltoff(Poly_P), gp  // Address of P-coeff table
+};;
+
+{ .mfi
+      getf.d     GR_Arg       = FR_Arg        // get argument as double (int64)
+      fma.s0        FR_Two       = f1, f1, f1    // construct 2.0
+      addl       GR_ad_z_1    = @ltoff(Constants_Z_1#),gp // logl tables
+}
+{ .mlx
+      nop.m 0
+      movl       GR_TwoP63    = 0x43E8000000000000 // 0.5*2^63 (huge arguments)
+};;
+
+{ .mfi
+      ld8        GR_Poly_P    = [GR_Poly_P]  // get actual P-coeff table address
+      fcmp.eq.s1 p10, p0      = FR_Arg, f1   // if arg == 1 (return 0)
+      nop.i 0
+}
+{ .mlx
+      ld8        GR_Poly_Q    = [GR_Poly_Q]  // get actual Q-coeff table address
+      movl       GR_OneP125   = 0x3FF2000000000000  // 1.125 (near 1 path bound)
+};;
+
+{ .mfi
+      ld8        GR_ad_z_1    = [GR_ad_z_1]      // Get pointer to Constants_Z_1
+      fclass.m   p7,p0        = FR_Arg, 0xe3       // if arg NaN inf
+      cmp.le     p9, p0       = GR_TwoP63, GR_Arg // if arg > 0.5*2^63 ('huges')
+}
+{ .mfb
+      cmp.ge     p8, p0       = GR_OneP125, GR_Arg // if arg<1.125 -near 1 path
+	  fms.s1     FR_XM1       = FR_Arg, f1, f1     // X0 = X-1 (for near 1 path)
+(p11) br.cond.spnt acoshl_lt_pone                  // error branch (less than 1)
+};;
+
+{ .mmi
+      setf.exp	FR_Half       = GR_Half     // construct 0.5
+(p9)  setf.s    FR_XLog_Lo    = r0          // Low of logl arg=0 (Huges path)
+      mov        GR_exp_mask  = 0x1FFFF         // Create exponent mask
+};;
+
+{ .mmf
+(p8)  ldfe       FR_PP5       = [GR_Poly_P],16     // Load P5
+(p8)  ldfe       FR_QQ5       = [GR_Poly_Q],16     // Load Q5
+      fms.s1     FR_M2        = FR_X2, f1, f1      // m2 = x^2 - 1
+};;
+
+{ .mfi
+(p8)  ldfe       FR_QQ4       = [GR_Poly_Q],16         // Load Q4
+      fms.s1     FR_M2L       = FR_Arg, FR_Arg, FR_X2  // low part of
+	                                                   //    m2 = fma(X*X - m2)
+      add        GR_ad_tbl_1  = 0x040, GR_ad_z_1    // Point to Constants_G_H_h1
+}
+{ .mfb
+(p8)  ldfe       FR_PP4       = [GR_Poly_P],16     // Load P4
+(p7)  fma.s0     FR_Res       = FR_Arg,f1,FR_Arg   // r = a + a (Nan, Inf)
+(p7)  br.ret.spnt b0                               // return    (Nan, Inf)
+};;
+
+{ .mfi
+(p8)  ldfe       FR_PP3       = [GR_Poly_P],16      // Load P3
+      nop.f 0
+      add        GR_ad_q      = -0x60, GR_ad_z_1    // Point to Constants_P
+}
+{ .mfb
+(p8)  ldfe       FR_QQ3       = [GR_Poly_Q],16      // Load Q3
+(p9)  fms.s1 FR_XLog_Hi       = FR_Two, FR_Arg, f1  // Hi  of log arg = 2*X-1
+(p9)  br.cond.spnt huges_logl                       // special version of log
+}
+;;
+
+{ .mfi
+(p8)  ldfe       FR_PP2       = [GR_Poly_P],16       // Load P2
+(p8)  fma.s1     FR_2XM1      = FR_Two, FR_XM1, f0   // 2X0 = 2 * X0
+      add        GR_ad_z_2    = 0x140, GR_ad_z_1    // Point to Constants_Z_2
+}
+{ .mfb
+(p8)  ldfe       FR_QQ2       = [GR_Poly_Q],16       // Load Q2
+(p10) fma.s0   FR_Res         = f0,f1,f0             // r = 0  (arg = 1)
+(p10) br.ret.spnt b0                                 // return (arg = 1)
+};;
+
+{ .mmi
+(p8)  ldfe       FR_PP1       = [GR_Poly_P],16       // Load P1
+(p8)  ldfe       FR_QQ1       = [GR_Poly_Q],16       // Load Q1
+      add        GR_ad_tbl_2  = 0x180, GR_ad_z_1    // Point to Constants_G_H_h2
+}
+;;
+
+{ .mfi
+(p8)  ldfe       FR_PP0       = [GR_Poly_P]          // Load P0
+      fma.s1     FR_Tmp       = f1, f1, FR_M2        // Tmp = 1 + m2
+      add        GR_ad_tbl_3  = 0x280, GR_ad_z_1    // Point to Constants_G_H_h3
+}
+{ .mfb
+(p8)  ldfe       FR_QQ0       = [GR_Poly_Q]
+      nop.f 0
+(p8)  br.cond.spnt near_1                            // near 1 path
+};;
+{ .mfi
+      ldfe       FR_log2_hi   = [GR_ad_q],16      // Load log2_hi
+      nop.f 0
+      mov        GR_Bias      = 0x0FFFF                  // Create exponent bias
+};;
+{ .mfi
+      nop.m 0
+      frsqrta.s1 FR_Rcp, p0   = FR_M2           // Rcp = 1/m2 reciprocal appr.
+      nop.i 0
+};;
+
+{ .mfi
+      ldfe       FR_log2_lo   = [GR_ad_q],16     // Load log2_lo
+      fms.s1     FR_Tmp       = FR_X2, f1, FR_Tmp  // Tmp =  x^2 - Tmp
+      nop.i 0
+};;
+
+{ .mfi
+      ldfe       FR_Q4        = [GR_ad_q],16          // Load Q4
+      fma.s1     FR_GG        = FR_Rcp, FR_M2, f0   // g = Rcp * m2
+                                               // 8 bit Newton Raphson iteration
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_HH 		  = FR_Half, FR_Rcp, f0      // h = 0.5 * Rcp
+      nop.i 0
+};;
+{ .mfi
+      ldfe       FR_Q3        = [GR_ad_q],16   // Load Q3
+      fnma.s1    FR_EE        = FR_GG, FR_HH, FR_Half   // e = 0.5 - g * h
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_M2L       = FR_Tmp, f1, FR_M2L  // low part of m2 = Tmp+m2l
+      nop.i 0
+};;
+
+{ .mfi
+      ldfe       FR_Q2        = [GR_ad_q],16      // Load Q2
+      fma.s1     FR_GG        = FR_GG, FR_EE, FR_GG     // g = g * e + g
+                                              // 16 bit Newton Raphson iteration
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_HH        = FR_HH, FR_EE, FR_HH     // h = h * e + h
+      nop.i 0
+};;
+
+{ .mfi
+      ldfe       FR_Q1        = [GR_ad_q]                // Load Q1
+      fnma.s1    FR_EE        = FR_GG, FR_HH, FR_Half   // e = 0.5 - g * h
+      nop.i 0
+};;
+{ .mfi
+      nop.m 0
+      fma.s1    FR_GG         = FR_GG, FR_EE, FR_GG     // g = g * e + g
+                                              // 32 bit Newton Raphson iteration
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_HH         = FR_HH, FR_EE, FR_HH     // h = h * e + h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fnma.s1   FR_EE         = FR_GG, FR_HH, FR_Half   // e = 0.5 - g * h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_GG         = FR_GG, FR_EE, FR_GG     // g = g * e + g
+                                              // 64 bit Newton Raphson iteration
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_HH         = FR_HH, FR_EE, FR_HH     // h = h * e + h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fnma.s1   FR_DD         = FR_GG, FR_GG, FR_M2  // Remainder d = g * g - p2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_XLog_Hi     = FR_Arg, f1, FR_GG // bh = z + gh
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_DD         = FR_DD, f1, FR_M2L       // add p2l: d = d + p2l
+      nop.i 0
+};;
+
+{ .mfi
+      getf.sig  GR_signif     = FR_XLog_Hi     // Get significand of x+1
+      nop.f 0
+      mov       GR_exp_2tom7  = 0x0fff8        // Exponent of 2^-7
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_GL         = FR_DD, FR_HH, f0        // gl = d * h
+      extr.u    GR_Index1     = GR_signif, 59, 4    // Get high 4 bits of signif
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_XLog_Hi     = FR_DD,  FR_HH, FR_XLog_Hi // bh = bh + gl
+      nop.i 0
+};;
+
+
+
+{ .mmi
+      shladd    GR_ad_z_1     = GR_Index1, 2, GR_ad_z_1  // Point to Z_1
+      shladd    GR_ad_tbl_1   = GR_Index1, 4, GR_ad_tbl_1  // Point to G_1
+      extr.u    GR_X_0        = GR_signif, 49, 15 // Get high 15 bits of signif.
+};;
+
+{ .mmi
+      ld4       GR_Z_1        = [GR_ad_z_1]    // Load Z_1
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mmi
+      ldfps     FR_G, FR_H    = [GR_ad_tbl_1],8     // Load G_1, H_1
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fms.s1    FR_XLog_Lo     = FR_Arg,  f1,   FR_XLog_Hi // bl = x - bh
+      pmpyshr2.u GR_X_1       = GR_X_0,GR_Z_1,15  // Get bits 30-15 of X_0 * Z_1
+};;
+
+// WE CANNOT USE GR_X_1 IN NEXT 3 CYCLES BECAUSE OF POSSIBLE 10 CLOCKS STALL!
+// "DEAD" ZONE!
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fmerge.se FR_S_hi       =  f1,FR_XLog_Hi            // Form |x+1|
+      nop.i 0
+};;
+
+
+{ .mmi
+      getf.exp  GR_N          =  FR_XLog_Hi    // Get N = exponent of x+1
+      ldfd      FR_h          = [GR_ad_tbl_1]        // Load h_1
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      extr.u    GR_Index2     = GR_X_1, 6, 4      // Extract bits 6-9 of X_1
+};;
+
+{ .mfi
+      shladd    GR_ad_tbl_2   = GR_Index2, 4, GR_ad_tbl_2  // Point to G_2
+      fma.s1    FR_XLog_Lo    = FR_XLog_Lo, f1, FR_GG // bl = bl + gg
+      mov       GR_exp_2tom80 = 0x0ffaf           // Exponent of 2^-80
+}
+{ .mfi
+      shladd    GR_ad_z_2     = GR_Index2, 2, GR_ad_z_2  // Point to Z_2
+      nop.f 0
+      sub       GR_N          = GR_N, GR_Bias // sub bias from exp
+};;
+
+{ .mmi
+      ldfps     FR_G2, FR_H2  = [GR_ad_tbl_2],8       // Load G_2, H_2
+      ld4       GR_Z_2        = [GR_ad_z_2]                // Load Z_2
+      sub       GR_minus_N    = GR_Bias, GR_N         // Form exponent of 2^(-N)
+};;
+
+{ .mmi
+      ldfd      FR_h2         = [GR_ad_tbl_2]             // Load h_2
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mmi
+      setf.sig  FR_float_N    = GR_N        // Put integer N into rightmost sign
+      setf.exp  FR_2_to_minus_N = GR_minus_N   // Form 2^(-N)
+      pmpyshr2.u GR_X_2       = GR_X_1,GR_Z_2,15 // Get bits 30-15 of X_1 * Z_2
+};;
+
+// WE CANNOT USE GR_X_2 IN NEXT 3 CYCLES ("DEAD" ZONE!)
+// BECAUSE OF POSSIBLE 10 CLOCKS STALL!
+// (Just nops added - nothing to do here)
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_XLog_Lo     = FR_XLog_Lo, f1, FR_GL // bl = bl + gl
+      nop.i 0
+};;
+{ .mfi
+      nop.m 0
+      nop.f 0
+      nop.i 0
+};;
+{ .mfi
+      nop.m 0
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      extr.u    GR_Index3     = GR_X_2, 1, 5         // Extract bits 1-5 of X_2
+};;
+
+{ .mfi
+      shladd    GR_ad_tbl_3   = GR_Index3, 4, GR_ad_tbl_3  // Point to G_3
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      ldfps     FR_G3, FR_H3  = [GR_ad_tbl_3],8   // Load G_3, H_3
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      ldfd      FR_h3         = [GR_ad_tbl_3]            // Load h_3
+	  fcvt.xf   FR_float_N    = FR_float_N
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fmpy.s1   FR_G          = FR_G, FR_G2              // G = G_1 * G_2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fadd.s1   FR_H          = FR_H, FR_H2              // H = H_1 + H_2
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fadd.s1   FR_h          = FR_h, FR_h2              // h = h_1 + h_2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_S_lo     = FR_XLog_Lo, FR_2_to_minus_N, f0 //S_lo=S_lo*2^(-N)
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fmpy.s1   FR_G          = FR_G, FR_G3             // G = (G_1 * G_2) * G_3
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fadd.s1   FR_H          = FR_H, FR_H3             // H = (H_1 + H_2) + H_3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fadd.s1   FR_h          = FR_h, FR_h3             // h = (h_1 + h_2) + h_3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fms.s1    FR_r          = FR_G, FR_S_hi, f1           // r = G * S_hi - 1
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_Y_hi       = FR_float_N, FR_log2_hi, FR_H // Y_hi=N*log2_hi+H
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_h          = FR_float_N, FR_log2_lo, FR_h  // h=N*log2_lo+h
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_r          = FR_G, FR_S_lo, FR_r  // r=G*S_lo+(G*S_hi-1)
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_poly_lo    = FR_r, FR_Q4, FR_Q3      // poly_lo = r * Q4 + Q3
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fmpy.s1   FR_rsq        = FR_r, FR_r              // rsq = r * r
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_poly_lo    = FR_poly_lo, FR_r, FR_Q2 // poly_lo=poly_lo*r+Q2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_rcub       = FR_rsq, FR_r, f0        // rcub = r^3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_poly_hi    = FR_Q1, FR_rsq, FR_r // poly_hi = Q1*rsq + r
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_poly_lo    = FR_poly_lo, FR_rcub, FR_h//poly_lo=poly_lo*r^3+h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fadd.s0   FR_Y_lo       = FR_poly_hi, FR_poly_lo
+	                                                     // Y_lo=poly_hi+poly_lo
+      nop.i 0
+};;
+
+{ .mfb
+      nop.m 0
+      fadd.s0   FR_Res        = FR_Y_lo,FR_Y_hi    // Result=Y_lo+Y_hi
+      br.ret.sptk   b0                         // Common exit for 2^-7 < x < inf
+};;
+
+
+huges_logl:
+{ .mmi
+      getf.sig   GR_signif    = FR_XLog_Hi               // Get significand of x+1
+      mov        GR_exp_2tom7 = 0x0fff8            // Exponent of 2^-7
+      nop.i 0
+};;
+
+{ .mfi
+      add        GR_ad_tbl_1  = 0x040, GR_ad_z_1    // Point to Constants_G_H_h1
+      nop.f 0
+      add        GR_ad_q      = -0x60, GR_ad_z_1    // Point to Constants_P
+}
+{ .mfi
+      add        GR_ad_z_2    = 0x140, GR_ad_z_1    // Point to Constants_Z_2
+      nop.f 0
+      add        GR_ad_tbl_2  = 0x180, GR_ad_z_1    // Point to Constants_G_H_h2
+};;
+
+{ .mfi
+      add        GR_ad_tbl_3  = 0x280, GR_ad_z_1    // Point to Constants_G_H_h3
+      nop.f 0
+      extr.u     GR_Index1    = GR_signif, 59, 4    // Get high 4 bits of signif
+};;
+
+{ .mfi
+      shladd     GR_ad_z_1    = GR_Index1, 2, GR_ad_z_1  // Point to Z_1
+      nop.f 0
+      extr.u     GR_X_0       = GR_signif, 49, 15 // Get high 15 bits of signif.
+};;
+
+{ .mfi
+      ld4        GR_Z_1       = [GR_ad_z_1]     // Load Z_1
+      nop.f 0
+      mov        GR_exp_mask  = 0x1FFFF         // Create exponent mask
+}
+{ .mfi
+      shladd     GR_ad_tbl_1  = GR_Index1, 4, GR_ad_tbl_1 // Point to G_1
+      nop.f 0
+      mov        GR_Bias      = 0x0FFFF                  // Create exponent bias
+};;
+
+{ .mfi
+      ldfps      FR_G, FR_H   = [GR_ad_tbl_1],8     // Load G_1, H_1
+      fmerge.se  FR_S_hi      =  f1,FR_XLog_Hi            // Form |x|
+      nop.i 0
+};;
+
+{ .mmi
+      getf.exp   GR_N         =  FR_XLog_Hi         // Get N = exponent of x+1
+      ldfd       FR_h         = [GR_ad_tbl_1] // Load h_1
+      nop.i 0
+};;
+
+{ .mfi
+      ldfe       FR_log2_hi   = [GR_ad_q],16      // Load log2_hi
+      nop.f 0
+      pmpyshr2.u GR_X_1       = GR_X_0,GR_Z_1,15  // Get bits 30-15 of X_0 * Z_1
+};;
+
+{ .mmi
+      ldfe       FR_log2_lo   = [GR_ad_q],16     // Load log2_lo
+      sub        GR_N         = GR_N, GR_Bias
+      mov        GR_exp_2tom80 = 0x0ffaf         // Exponent of 2^-80
+};;
+
+{ .mfi
+      ldfe       FR_Q4        = [GR_ad_q],16          // Load Q4
+      nop.f 0
+      sub        GR_minus_N   = GR_Bias, GR_N         // Form exponent of 2^(-N)
+};;
+
+{ .mmf
+      ldfe       FR_Q3        = [GR_ad_q],16   // Load Q3
+      setf.sig   FR_float_N   = GR_N        // Put integer N into rightmost sign
+      nop.f 0
+};;
+
+{ .mmi
+      ldfe       FR_Q2        = [GR_ad_q],16      // Load Q2
+	  nop.m 0
+      extr.u     GR_Index2    = GR_X_1, 6, 4      // Extract bits 6-9 of X_1
+};;
+
+{ .mmi
+      ldfe       FR_Q1        = [GR_ad_q]                // Load Q1
+      shladd     GR_ad_z_2    = GR_Index2, 2, GR_ad_z_2  // Point to Z_2
+      nop.i 0
+};;
+
+{ .mmi
+      ld4        GR_Z_2       = [GR_ad_z_2]                // Load Z_2
+      shladd     GR_ad_tbl_2  = GR_Index2, 4, GR_ad_tbl_2  // Point to G_2
+	  nop.i 0
+};;
+
+{ .mmi
+      ldfps      FR_G2, FR_H2 = [GR_ad_tbl_2],8       // Load G_2, H_2
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mmf
+      ldfd       FR_h2        = [GR_ad_tbl_2]         // Load h_2
+      setf.exp FR_2_to_minus_N = GR_minus_N   // Form 2^(-N)
+      nop.f 0
+};;
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      pmpyshr2.u GR_X_2       = GR_X_1,GR_Z_2,15   // Get bits 30-15 of X_1*Z_2
+};;
+
+// WE CANNOT USE GR_X_2 IN NEXT 3 CYCLES ("DEAD" ZONE!)
+// BECAUSE OF POSSIBLE 10 CLOCKS STALL!
+// (Just nops added - nothing to do here)
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      extr.u     GR_Index3    = GR_X_2, 1, 5          // Extract bits 1-5 of X_2
+};;
+
+{ .mfi
+      shladd     GR_ad_tbl_3  = GR_Index3, 4, GR_ad_tbl_3  // Point to G_3
+	  fcvt.xf    FR_float_N   = FR_float_N
+      nop.i 0
+};;
+
+{ .mfi
+      ldfps      FR_G3, FR_H3 = [GR_ad_tbl_3],8   // Load G_3, H_3
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      ldfd       FR_h3        = [GR_ad_tbl_3]            // Load h_3
+      fmpy.s1    FR_G         = FR_G, FR_G2              // G = G_1 * G_2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fadd.s1    FR_H         = FR_H, FR_H2              // H = H_1 + H_2
+      nop.i 0
+};;
+
+{ .mmf
+      nop.m 0
+      nop.m 0
+      fadd.s1    FR_h         = FR_h, FR_h2              // h = h_1 + h_2
+};;
+
+{ .mfi
+      nop.m 0
+      fmpy.s1    FR_G         = FR_G, FR_G3              // G = (G_1 * G_2)*G_3
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fadd.s1    FR_H         = FR_H, FR_H3              // H = (H_1 + H_2)+H_3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fadd.s1    FR_h         = FR_h, FR_h3            // h = (h_1 + h_2) + h_3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fms.s1     FR_r         = FR_G, FR_S_hi, f1           // r = G * S_hi - 1
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_Y_hi      = FR_float_N, FR_log2_hi, FR_H // Y_hi=N*log2_hi+H
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_h         = FR_float_N, FR_log2_lo, FR_h  // h = N*log2_lo+h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_poly_lo   = FR_r, FR_Q4, FR_Q3      // poly_lo = r * Q4 + Q3
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fmpy.s1    FR_rsq       = FR_r, FR_r              // rsq = r * r
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_poly_lo   = FR_poly_lo, FR_r, FR_Q2 // poly_lo=poly_lo*r+Q2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_rcub      = FR_rsq, FR_r, f0        // rcub = r^3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_poly_hi   = FR_Q1, FR_rsq, FR_r     // poly_hi = Q1*rsq + r
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_poly_lo   = FR_poly_lo, FR_rcub, FR_h//poly_lo=poly_lo*r^3+h
+      nop.i 0
+};;
+{ .mfi
+      nop.m 0
+      fadd.s0    FR_Y_lo      = FR_poly_hi, FR_poly_lo  // Y_lo=poly_hi+poly_lo
+      nop.i 0
+};;
+{ .mfb
+      nop.m 0
+      fadd.s0    FR_Res       = FR_Y_lo,FR_Y_hi    // Result=Y_lo+Y_hi
+      br.ret.sptk   b0                        // Common exit
+};;
+
+
+// NEAR ONE INTERVAL
+near_1:
+{ .mfi
+      nop.m 0
+      frsqrta.s1 FR_Rcp, p0   = FR_2XM1 // Rcp = 1/x reciprocal appr. &SQRT&
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_PV6       = FR_PP5, FR_XM1, FR_PP4 // pv6 = P5*xm1+P4 $POLY$
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+	  fma.s1     FR_QV6       = FR_QQ5, FR_XM1, FR_QQ4 // qv6 = Q5*xm1+Q4 $POLY$
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+	  fma.s1     FR_PV4       = FR_PP3, FR_XM1, FR_PP2 // pv4 = P3*xm1+P2 $POLY$
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+	  fma.s1     FR_QV4       = FR_QQ3, FR_XM1, FR_QQ2 // qv4 = Q3*xm1+Q2 $POLY$
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+	  fma.s1     FR_XM12      = FR_XM1, FR_XM1, f0 // xm1^2 = xm1 * xm1 $POLY$
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+	  fma.s1     FR_PV2       = FR_PP1, FR_XM1, FR_PP0 // pv2 = P1*xm1+P0 $POLY$
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+	  fma.s1     FR_QV2       = FR_QQ1, FR_XM1, FR_QQ0 // qv2 = Q1*xm1+Q0 $POLY$
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_GG        = FR_Rcp, FR_2XM1, f0 // g = Rcp * x &SQRT&
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_HH        = FR_Half, FR_Rcp, f0 // h = 0.5 * Rcp &SQRT&
+      nop.i 0
+};;
+
+
+{ .mfi
+      nop.m 0
+	  fma.s1    FR_PV3       = FR_XM12, FR_PV6, FR_PV4//pv3=pv6*xm1^2+pv4 $POLY$
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+	  fma.s1    FR_QV3       = FR_XM12, FR_QV6, FR_QV4//qv3=qv6*xm1^2+qv4 $POLY$
+      nop.i 0
+};;
+
+
+{ .mfi
+      nop.m 0
+      fnma.s1   FR_EE        = FR_GG, FR_HH, FR_Half   // e = 0.5 - g * h &SQRT&
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+	  fma.s1    FR_PP        = FR_XM12, FR_PV3, FR_PV2 //pp=pv3*xm1^2+pv2 $POLY$
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+	  fma.s1    FR_QQ        = FR_XM12, FR_QV3, FR_QV2 //qq=qv3*xm1^2+qv2 $POLY$
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_GG        = FR_GG, FR_EE, FR_GG  // g = g * e + g &SQRT&
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_HH        = FR_HH, FR_EE, FR_HH  // h = h * e + h &SQRT&
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      frcpa.s1   FR_Y0,p0     = f1,FR_QQ // y = frcpa(b)  #DIV#
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fnma.s1    FR_EE        = FR_GG, FR_HH, FR_Half // e = 0.5 - g*h &SQRT&
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_Q0        = FR_PP,FR_Y0,f0 // q = a*y  #DIV#
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fnma.s1    FR_E0        = FR_Y0,FR_QQ,f1 // e = 1 - b*y  #DIV#
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_GG        = FR_GG, FR_EE, FR_GG // g = g * e + g &SQRT&
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_HH        = FR_HH, FR_EE, FR_HH // h = h * e + h &SQRT&
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_E2        = FR_E0,FR_E0,FR_E0 // e2 = e+e^2 #DIV#
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_E1        = FR_E0,FR_E0,f0 // e1 = e^2 #DIV#
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fnma.s1   FR_EE        = FR_GG, FR_HH, FR_Half   // e = 0.5 - g * h &SQRT&
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+	  fnma.s1   FR_DD        = FR_GG, FR_GG, FR_2XM1   // d = x - g * g &SQRT&
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_Y1        = FR_Y0,FR_E2,FR_Y0 // y1 = y+y*e2 #DIV#
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_E3        = FR_E1,FR_E1,FR_E0 // e3 = e+e1^2 #DIV#
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_GG        = FR_DD, FR_HH, FR_GG // g = d * h + g &SQRT&
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_HH        = FR_HH, FR_EE, FR_HH // h = h * e + h &SQRT&
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_Y2        = FR_Y1,FR_E3,FR_Y0 // y2 = y+y1*e3 #DIV#
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fnma.s1    FR_R0        = FR_QQ,FR_Q0,FR_PP // r = a-b*q #DIV#
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fnma.s1    FR_DD        = FR_GG, FR_GG, FR_2XM1 // d = x - g * g &SQRT&
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fnma.s1    FR_E4        = FR_QQ,FR_Y2,f1    // e4 = 1-b*y2 #DIV#
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_X_Hi      = FR_R0,FR_Y2,FR_Q0 // x = q+r*y2 #DIV#
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_GL        = FR_DD, FR_HH, f0   // gl = d * h &SQRT&
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_Y3        = FR_Y2,FR_E4,FR_Y2 // y3 = y2+y2*e4 #DIV#
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fnma.s1    FR_R1        = FR_QQ,FR_X_Hi,FR_PP // r1 = a-b*x #DIV#
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_HH        = FR_GG, FR_X_Hi, f0 // hh = gg * x_hi
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_LH        = FR_GL, FR_X_Hi, f0 // lh = gl * x_hi
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_X_lo      = FR_R1,FR_Y3,f0 // x_lo = r1*y3 #DIV#
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1     FR_LL        = FR_GL, FR_X_lo, f0 // ll = gl*x_lo
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1     FR_HL        = FR_GG, FR_X_lo, f0 // hl = gg * x_lo
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+	  fms.s1     FR_Res       = FR_GL,  f1, FR_LL // res = gl + ll
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+	  fms.s1     FR_Res       = FR_Res, f1, FR_LH // res = res + lh
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+	  fms.s1     FR_Res       = FR_Res, f1, FR_HL // res = res + hl
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+	  fms.s1     FR_Res       = FR_Res, f1, FR_HH // res = res + hh
+      nop.i 0
+};;
+
+{ .mfb
+      nop.m 0
+	  fma.s0     FR_Res       = FR_Res, f1, FR_GG  // result = res + gg
+      br.ret.sptk   b0                     // Exit for near 1 path
+};;
+// NEAR ONE INTERVAL END
+
+
+
+
+acoshl_lt_pone:
+{ .mfi
+      nop.m 0
+      fmerge.s   FR_Arg_X            = FR_Arg, FR_Arg
+      nop.i 0
+};;
+{ .mfb
+      mov        GR_Parameter_TAG    = 135
+      frcpa.s0   FR_Res,p0           = f0,f0 // get QNaN,and raise invalid
+      br.cond.sptk  __libm_error_region      // exit if x < 1.0
+};;
+
+GLOBAL_LIBM_END(acoshl)
+libm_alias_ldouble_other (acosh, acosh)
+
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add      GR_Parameter_Y      = -32,sp        // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov      GR_SAVE_PFS         = ar.pfs        // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add      sp                  = -64,sp        // Create new stack
+        nop.f 0
+        mov      GR_SAVE_GP          = gp            // Save gp
+};;
+
+{ .mmi
+        stfe     [GR_Parameter_Y]    = FR_Arg_Y,16   // Parameter 2 to stack
+        add      GR_Parameter_X      = 16,sp         // Parameter 1 address
+.save   b0,GR_SAVE_B0
+        mov      GR_SAVE_B0          = b0            // Save b0
+};;
+
+.body
+{ .mib
+        stfe     [GR_Parameter_X]    = FR_Arg_X         // Parameter 1 to stack
+        add      GR_Parameter_RESULT = 0,GR_Parameter_Y // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfe     [GR_Parameter_Y]    = FR_Res        // Parameter 3 to stack
+        add      GR_Parameter_Y      = -16,GR_Parameter_Y
+        br.call.sptk b0 = __libm_error_support#      // Error handling function
+};;
+
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add      GR_Parameter_RESULT = 48,sp
+};;
+
+{ .mmi
+        ldfe     f8                  = [GR_Parameter_RESULT]  // Get return res
+.restore sp
+        add      sp                  = 64,sp       // Restore stack pointer
+        mov      b0                  = GR_SAVE_B0  // Restore return address
+};;
+
+{ .mib
+        mov      gp                  = GR_SAVE_GP  // Restore gp
+        mov      ar.pfs              = GR_SAVE_PFS // Restore ar.pfs
+        br.ret.sptk b0                             // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region#)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_acosl.S
@@ -0,0 +1,2546 @@
+.file "acosl.s"
+
+
+// Copyright (c) 2001 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 08/28/01 New version
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+//
+// API
+//==============================================================
+// long double acosl(long double)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// For |s| in [2^{-4}, sqrt(2)/2]:
+// Let t= 2^k*1.b1 b2..b6 1, where s= 2^k*1.b1 b2.. b52
+// acos(s)= pi/2-asin(t)-asin(r), where r= s*sqrt(1-t^2)-t*sqrt(1-s^2), i.e.
+// r= (s-t)*sqrt(1-t^2)-t*sqrt(1-t^2)*(sqrt((1-s^2)/(1-t^2))-1)
+// asin(r)-r evaluated as 9-degree polynomial (c3*r^3+c5*r^5+c7*r^7+c9*r^9)
+// The 64-bit significands of sqrt(1-t^2), 1/(1-t^2) are read from the table,
+// along with the high and low parts of asin(t) (stored as two double precision
+// values)
+//
+// |s| in (sqrt(2)/2, sqrt(255/256)):
+// Let t= 2^k*1.b1 b2..b6 1, where (1-s^2)*frsqrta(1-s^2)= 2^k*1.b1 b2..b6..
+// acos(|s|)= asin(t)-asin(r)
+// acos(-|s|)=pi-asin(t)+asin(r),   r= s*t-sqrt(1-s^2)*sqrt(1-t^2)
+// To minimize accumulated errors, r is computed as
+// r= (t*s)_s-t^2*y*z+z*y*(t^2-1+s^2)_s+z*y*(1-s^2)_s*x+z'*y*(1-s^2)*PS29+
+// +(t*s-(t*s)_s)+z*y*((t^2-1-(t^2-1+s^2)_s)+s^2)+z*y*(1-s^2-(1-s^2)_s)+
+// +ez*z'*y*(1-s^2)*(1-x),
+// where y= frsqrta(1-s^2), z= (sqrt(1-t^2))_s (rounded to 24 significant bits)
+// z'= sqrt(1-t^2), x= ((1-s^2)*y^2-1)/2
+//
+// |s|<2^{-4}: evaluate asin(s) as 17-degree polynomial, return pi/2-asin(s)
+// (or simply return pi/2-s, if|s|<2^{-64})
+//
+// |s| in [sqrt(255/256), 1): acos(|s|)= asin(sqrt(1-s^2))
+// acos(-|s|)= pi-asin(sqrt(1-s^2))
+// use 17-degree polynomial for asin(sqrt(1-s^2)),
+// 9-degree polynomial to evaluate sqrt(1-s^2)
+// High order term is (pi)_high-(y*(1-s^2))_high, for s<0,
+// or y*(1-s^2)_s, for s>0
+//
+
+
+
+// Registers used
+//==============================================================
+// f6-f15, f32-f36
+// r2-r3, r23-r23
+// p6, p7, p8, p12
+//
+
+
+       GR_SAVE_B0= r33
+       GR_SAVE_PFS= r34
+       GR_SAVE_GP= r35 // This reg. can safely be used
+       GR_SAVE_SP= r36
+
+       GR_Parameter_X= r37
+       GR_Parameter_Y= r38
+       GR_Parameter_RESULT= r39
+       GR_Parameter_TAG= r40
+
+       FR_X= f10
+       FR_Y= f1
+       FR_RESULT= f8
+
+
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(T_table)
+
+// stores 64-bit significand of 1/(1-t^2), 64-bit significand of sqrt(1-t^2),
+// asin(t)_high (double precision), asin(t)_low (double precision)
+
+data8 0x80828692b71c4391, 0xff7ddcec2d87e879
+data8 0x3fb022bc0ae531a0, 0x3c9f599c7bb42af6
+data8 0x80869f0163d0b082, 0xff79cad2247914d3
+data8 0x3fb062dd26afc320, 0x3ca4eff21bd49c5c
+data8 0x808ac7d5a8690705, 0xff75a89ed6b626b9
+data8 0x3fb0a2ff4a1821e0, 0x3cb7e33b58f164cc
+data8 0x808f0112ad8ad2e0, 0xff7176517c2cc0cb
+data8 0x3fb0e32279319d80, 0x3caee31546582c43
+data8 0x80934abba8a1da0a, 0xff6d33e949b1ed31
+data8 0x3fb12346b8101da0, 0x3cb8bfe463d087cd
+data8 0x8097a4d3dbe63d8f, 0xff68e16571015c63
+data8 0x3fb1636c0ac824e0, 0x3c8870a7c5a3556f
+data8 0x809c0f5e9662b3dd, 0xff647ec520bca0f0
+data8 0x3fb1a392756ed280, 0x3c964f1a927461ae
+data8 0x80a08a5f33fadc66, 0xff600c07846a6830
+data8 0x3fb1e3b9fc19e580, 0x3c69eb3576d56332
+data8 0x80a515d91d71acd4, 0xff5b892bc475affa
+data8 0x3fb223e2a2dfbe80, 0x3c6a4e19fd972fb6
+data8 0x80a9b1cfc86ff7cd, 0xff56f631062cf93d
+data8 0x3fb2640c6dd76260, 0x3c62041160e0849e
+data8 0x80ae5e46b78b0d68, 0xff5253166bc17794
+data8 0x3fb2a43761187c80, 0x3cac61651af678c0
+data8 0x80b31b417a4b756b, 0xff4d9fdb14463dc8
+data8 0x3fb2e46380bb6160, 0x3cb06ef23eeba7a1
+data8 0x80b7e8c3ad33c369, 0xff48dc7e1baf6738
+data8 0x3fb32490d0d910c0, 0x3caa05f480b300d5
+data8 0x80bcc6d0f9c784d6, 0xff4408fe9ad13e37
+data8 0x3fb364bf558b3820, 0x3cb01e7e403aaab9
+data8 0x80c1b56d1692492d, 0xff3f255ba75f5f4e
+data8 0x3fb3a4ef12ec3540, 0x3cb4fe8fcdf5f5f1
+data8 0x80c6b49bc72ec446, 0xff3a319453ebd961
+data8 0x3fb3e5200d171880, 0x3caf2dc089b2b7e2
+data8 0x80cbc460dc4e0ae8, 0xff352da7afe64ac6
+data8 0x3fb425524827a720, 0x3cb75a855e7c6053
+data8 0x80d0e4c033bee9c4, 0xff301994c79afb32
+data8 0x3fb46585c83a5e00, 0x3cb3264981c019ab
+data8 0x80d615bdb87556db, 0xff2af55aa431f291
+data8 0x3fb4a5ba916c73c0, 0x3c994251d94427b5
+data8 0x80db575d6291fd8a, 0xff25c0f84bae0cb9
+data8 0x3fb4e5f0a7dbdb20, 0x3cbee2fcc4c786cb
+data8 0x80e0a9a33769e535, 0xff207c6cc0ec09fd
+data8 0x3fb526280fa74620, 0x3c940656e5549b91
+data8 0x80e60c93498e32cd, 0xff1b27b703a19c98
+data8 0x3fb56660ccee2740, 0x3ca7082374d7b2cd
+data8 0x80eb8031b8d4052d, 0xff15c2d6105c72f8
+data8 0x3fb5a69ae3d0b520, 0x3c7c4d46e09ac68a
+data8 0x80f10482b25c6c8a, 0xff104dc8e0813ed4
+data8 0x3fb5e6d6586fec20, 0x3c9aa84ffd9b4958
+data8 0x80f6998a709c7cfb, 0xff0ac88e6a4ab926
+data8 0x3fb627132eed9140, 0x3cbced2cbbbe7d16
+data8 0x80fc3f4d3b657c44, 0xff053325a0c8a2ec
+data8 0x3fb667516b6c34c0, 0x3c6489c5fc68595a
+data8 0x8101f5cf67ed2af8, 0xfeff8d8d73dec2bb
+data8 0x3fb6a791120f33a0, 0x3cbe12acf159dfad
+data8 0x8107bd1558d6291f, 0xfef9d7c4d043df29
+data8 0x3fb6e7d226fabba0, 0x3ca386d099cd0dc7
+data8 0x810d95237e38766a, 0xfef411ca9f80b5f7
+data8 0x3fb72814ae53cc20, 0x3cb9f35731e71dd6
+data8 0x81137dfe55aa0e29, 0xfeee3b9dc7eef009
+data8 0x3fb76858ac403a00, 0x3c74df3dd959141a
+data8 0x811977aa6a479f0f, 0xfee8553d2cb8122c
+data8 0x3fb7a89e24e6b0e0, 0x3ca6034406ee42bc
+data8 0x811f822c54bd5ef8, 0xfee25ea7add46a91
+data8 0x3fb7e8e51c6eb6a0, 0x3cb82f8f78e68ed7
+data8 0x81259d88bb4ffac1, 0xfedc57dc2809fb1d
+data8 0x3fb8292d9700ad60, 0x3cbebb73c0e653f9
+data8 0x812bc9c451e5a257, 0xfed640d974eb6068
+data8 0x3fb8697798c5d620, 0x3ca2feee76a9701b
+data8 0x813206e3da0f3124, 0xfed0199e6ad6b585
+data8 0x3fb8a9c325e852e0, 0x3cb9e88f2f4d0efe
+data8 0x813854ec231172f9, 0xfec9e229dcf4747d
+data8 0x3fb8ea1042932a00, 0x3ca5ff40d81f66fd
+data8 0x813eb3e209ee858f, 0xfec39a7a9b36538b
+data8 0x3fb92a5ef2f247c0, 0x3cb5e3bece4d6b07
+data8 0x814523ca796f56ce, 0xfebd428f72561efe
+data8 0x3fb96aaf3b3281a0, 0x3cb7b9e499436d7c
+data8 0x814ba4aa6a2d3ff9, 0xfeb6da672bd48fe4
+data8 0x3fb9ab011f819860, 0x3cb9168143cc1a7f
+data8 0x81523686e29bbdd7, 0xfeb062008df81f50
+data8 0x3fb9eb54a40e3ac0, 0x3cb6e544197eb1e1
+data8 0x8158d964f7124614, 0xfea9d95a5bcbd65a
+data8 0x3fba2ba9cd080800, 0x3ca9a717be8f7446
+data8 0x815f8d49c9d639e4, 0xfea34073551e1ac8
+data8 0x3fba6c009e9f9260, 0x3c741e989a60938a
+data8 0x8166523a8b24f626, 0xfe9c974a367f785c
+data8 0x3fbaac591d0661a0, 0x3cb2c1290107e57d
+data8 0x816d283c793e0114, 0xfe95ddddb94166cb
+data8 0x3fbaecb34c6ef600, 0x3c9c7d5fbaec405d
+data8 0x81740f54e06d55bd, 0xfe8f142c93750c50
+data8 0x3fbb2d0f310cca00, 0x3cbc09479a9cbcfb
+data8 0x817b07891b15cd5e, 0xfe883a3577e9fceb
+data8 0x3fbb6d6ccf1455e0, 0x3cb9450bff4ee307
+data8 0x818210de91bba6c8, 0xfe814ff7162cf62f
+data8 0x3fbbadcc2abb1180, 0x3c9227fda12a8d24
+data8 0x81892b5abb0f2bf9, 0xfe7a55701a8697b1
+data8 0x3fbbee2d48377700, 0x3cb6fad72acfe356
+data8 0x819057031bf7760e, 0xfe734a9f2dfa1810
+data8 0x3fbc2e902bc10600, 0x3cb4465b588d16ad
+data8 0x819793dd479d4fbe, 0xfe6c2f82f643f68b
+data8 0x3fbc6ef4d9904580, 0x3c8b9ac54823960d
+data8 0x819ee1eedf76367a, 0xfe65041a15d8a92c
+data8 0x3fbcaf5b55dec6a0, 0x3ca2b8d28a954db2
+data8 0x81a6413d934f7a66, 0xfe5dc8632be3477f
+data8 0x3fbcefc3a4e727a0, 0x3c9380da83713ab4
+data8 0x81adb1cf21597d4b, 0xfe567c5cd44431d5
+data8 0x3fbd302dcae51600, 0x3ca995b83421756a
+data8 0x81b533a9563310b8, 0xfe4f2005a78fb50f
+data8 0x3fbd7099cc155180, 0x3caefa2f7a817d5f
+data8 0x81bcc6d20cf4f373, 0xfe47b35c3b0caaeb
+data8 0x3fbdb107acb5ae80, 0x3cb455fc372dd026
+data8 0x81c46b4f2f3d6e68, 0xfe40365f20b316d6
+data8 0x3fbdf177710518c0, 0x3cbee3dcc5b01434
+data8 0x81cc2126b53c1144, 0xfe38a90ce72abf36
+data8 0x3fbe31e91d439620, 0x3cb3e131c950aebd
+data8 0x81d3e85ea5bd8ee2, 0xfe310b6419c9c33a
+data8 0x3fbe725cb5b24900, 0x3c01d3fac6029027
+data8 0x81dbc0fd1637b9c1, 0xfe295d6340932d15
+data8 0x3fbeb2d23e937300, 0x3c6304cc44aeedd1
+data8 0x81e3ab082ad5a0a4, 0xfe219f08e03580b3
+data8 0x3fbef349bc2a77e0, 0x3cac1d2d6abe9c72
+data8 0x81eba6861683cb97, 0xfe19d0537a0946e2
+data8 0x3fbf33c332bbe020, 0x3ca0909dba4e96ca
+data8 0x81f3b37d1afc9979, 0xfe11f1418c0f94e2
+data8 0x3fbf743ea68d5b60, 0x3c937fc12a2a779a
+data8 0x81fbd1f388d4be45, 0xfe0a01d190f09063
+data8 0x3fbfb4bc1be5c340, 0x3cbf51a504b55813
+data8 0x820401efbf87e248, 0xfe020201fff9efea
+data8 0x3fbff53b970d1e80, 0x3ca625444b260078
+data8 0x82106ad2ffdca049, 0xfdf5e3940a49135e
+data8 0x3fc02aff52065460, 0x3c9125d113e22a57
+data8 0x8221343d6ea1d3e2, 0xfde581a45429b0a0
+data8 0x3fc06b84f8e03220, 0x3caccf362295894b
+data8 0x82324434adbf99c2, 0xfdd4de1a001fb775
+data8 0x3fc0ac0ed1fe7240, 0x3cc22f676096b0af
+data8 0x82439aee8d0c7747, 0xfdc3f8e8269d1f03
+data8 0x3fc0ec9cee9e4820, 0x3cca147e2886a628
+data8 0x825538a1d0fcb2f0, 0xfdb2d201a9b1ba66
+data8 0x3fc12d2f6006f0a0, 0x3cc72b36633bc2d4
+data8 0x82671d86345c5cee, 0xfda1695934d723e7
+data8 0x3fc16dc63789de60, 0x3cb11f9c47c7b83f
+data8 0x827949d46a121770, 0xfd8fbee13cbbb823
+data8 0x3fc1ae618682e620, 0x3cce1b59020cef8e
+data8 0x828bbdc61eeab9ba, 0xfd7dd28bff0c9f34
+data8 0x3fc1ef015e586c40, 0x3cafec043e0225ee
+data8 0x829e7995fb6de9e1, 0xfd6ba44b823ee1ca
+data8 0x3fc22fa5d07b90c0, 0x3cba905409caf8e3
+data8 0x82b17d7fa5bbc982, 0xfd5934119557883a
+data8 0x3fc2704eee685da0, 0x3cb5ef21838a823e
+data8 0x82c4c9bfc373d276, 0xfd4681cfcfb2c161
+data8 0x3fc2b0fcc9a5f3e0, 0x3ccc7952c5e0e312
+data8 0x82d85e93fba50136, 0xfd338d7790ca0f41
+data8 0x3fc2f1af73c6ba00, 0x3cbecf5f977d1ca9
+data8 0x82ec3c3af8c76b32, 0xfd2056f9fff97727
+data8 0x3fc33266fe6889a0, 0x3c9d329c022ebdb5
+data8 0x830062f46abf6022, 0xfd0cde480c43b327
+data8 0x3fc373237b34de60, 0x3cc95806d4928adb
+data8 0x8314d30108ea35f0, 0xfcf923526c1562b2
+data8 0x3fc3b3e4fbe10520, 0x3cbc299fe7223d54
+data8 0x83298ca29434df97, 0xfce526099d0737ed
+data8 0x3fc3f4ab922e4a60, 0x3cb59d8bb8fdbccc
+data8 0x833e901bd93c7009, 0xfcd0e65de39f1f7c
+data8 0x3fc435774fea2a60, 0x3c9ec18b43340914
+data8 0x8353ddb0b278aad8, 0xfcbc643f4b106055
+data8 0x3fc4764846ee80a0, 0x3cb90402efd87ed6
+data8 0x836975a60a70c52e, 0xfca79f9da4fab13a
+data8 0x3fc4b71e8921b860, 0xbc58f23449ed6365
+data8 0x837f5841ddfa7a46, 0xfc92986889284148
+data8 0x3fc4f7fa2876fca0, 0xbc6294812bf43acd
+data8 0x839585cb3e839773, 0xfc7d4e8f554ab12f
+data8 0x3fc538db36ee6960, 0x3cb910b773d4c578
+data8 0x83abfe8a5466246f, 0xfc67c2012cb6fa68
+data8 0x3fc579c1c6953cc0, 0x3cc5ede909fc47fc
+data8 0x83c2c2c861474d91, 0xfc51f2acf82041d5
+data8 0x3fc5baade9860880, 0x3cac63cdfc3588e5
+data8 0x83d9d2cfc2813637, 0xfc3be08165519325
+data8 0x3fc5fb9fb1e8e3a0, 0x3cbf7c8466578c29
+data8 0x83f12eebf397daac, 0xfc258b6ce6e6822f
+data8 0x3fc63c9731f39d40, 0x3cb6d2a7ffca3e9e
+data8 0x8408d76990b9296e, 0xfc0ef35db402af94
+data8 0x3fc67d947be9eec0, 0x3cb1980da09e6566
+data8 0x8420cc9659487cd7, 0xfbf81841c8082dc4
+data8 0x3fc6be97a21daf00, 0x3cc2ac8330e59aa5
+data8 0x84390ec132759ecb, 0xfbe0fa06e24cc390
+data8 0x3fc6ffa0b6ef05e0, 0x3ccc1a030fee56c4
+data8 0x84519e3a29df811a, 0xfbc9989a85ce0954
+data8 0x3fc740afcccca000, 0x3cc19692a5301ca6
+data8 0x846a7b527842d61b, 0xfbb1f3e9f8e45dc4
+data8 0x3fc781c4f633e2c0, 0x3cc0e98f3868a508
+data8 0x8483a65c8434b5f0, 0xfb9a0be244f4af45
+data8 0x3fc7c2e045b12140, 0x3cb2a8d309754420
+data8 0x849d1fabe4e97dd7, 0xfb81e070362116d1
+data8 0x3fc80401cddfd120, 0x3ca7a44544aa4ce6
+data8 0x84b6e795650817ea, 0xfb6971805af8411e
+data8 0x3fc84529a16ac020, 0x3c9e3b709c7d6f94
+data8 0x84d0fe6f0589da92, 0xfb50beff0423a2f5
+data8 0x3fc88657d30c49e0, 0x3cc60d65a7f0a278
+data8 0x84eb649000a73014, 0xfb37c8d84414755c
+data8 0x3fc8c78c758e8e80, 0x3cc94b2ee984c2b7
+data8 0x85061a50ccd13781, 0xfb1e8ef7eeaf764b
+data8 0x3fc908c79bcba900, 0x3cc8540ae794a2fe
+data8 0x8521200b1fb8916e, 0xfb05114998f76a83
+data8 0x3fc94a0958ade6c0, 0x3ca127f49839fa9c
+data8 0x853c7619f1618bf6, 0xfaeb4fb898b65d19
+data8 0x3fc98b51bf2ffee0, 0x3c8c9ba7a803909a
+data8 0x85581cd97f45e274, 0xfad14a3004259931
+data8 0x3fc9cca0e25d4ac0, 0x3cba458e91d3bf54
+data8 0x857414a74f8446b4, 0xfab7009ab1945a54
+data8 0x3fca0df6d551fe80, 0x3cc78ea1d329d2b2
+data8 0x85905de2341dea46, 0xfa9c72e3370d2fbc
+data8 0x3fca4f53ab3b6200, 0x3ccf60dca86d57ef
+data8 0x85acf8ea4e423ff8, 0xfa81a0f3e9fa0ee9
+data8 0x3fca90b777580aa0, 0x3ca4c4e2ec8a867e
+data8 0x85c9e62111a92e7d, 0xfa668ab6dec711b1
+data8 0x3fcad2224cf814e0, 0x3c303de5980d071c
+data8 0x85e725e947fbee97, 0xfa4b3015e883dbfe
+data8 0x3fcb13943f7d5f80, 0x3cc29d4eefa5cb1e
+data8 0x8604b8a7144cd054, 0xfa2f90fa9883a543
+data8 0x3fcb550d625bc6a0, 0x3c9e01a746152daf
+data8 0x86229ebff69e2415, 0xfa13ad4e3dfbe1c1
+data8 0x3fcb968dc9195ea0, 0x3ccc091bd73ae518
+data8 0x8640d89acf78858c, 0xf9f784f9e5a1877b
+data8 0x3fcbd815874eb160, 0x3cb5f4b89875e187
+data8 0x865f669fe390c7f5, 0xf9db17e65944eacf
+data8 0x3fcc19a4b0a6f9c0, 0x3cc5c0bc2b0bbf14
+data8 0x867e4938df7dc45f, 0xf9be65fc1f6c2e6e
+data8 0x3fcc5b3b58e061e0, 0x3cc1ca70df8f57e7
+data8 0x869d80d0db7e4c0c, 0xf9a16f237aec427a
+data8 0x3fcc9cd993cc4040, 0x3cbae93acc85eccf
+data8 0x86bd0dd45f4f8265, 0xf98433446a806e70
+data8 0x3fccde7f754f5660, 0x3cb22f70e64568d0
+data8 0x86dcf0b16613e37a, 0xf966b246a8606170
+data8 0x3fcd202d11620fa0, 0x3c962030e5d4c849
+data8 0x86fd29d7624b3d5d, 0xf948ec11a9d4c45b
+data8 0x3fcd61e27c10c0a0, 0x3cc7083c91d59217
+data8 0x871db9b741dbe44a, 0xf92ae08c9eca4941
+data8 0x3fcda39fc97be7c0, 0x3cc9258579e57211
+data8 0x873ea0c3722d6af2, 0xf90c8f9e71633363
+data8 0x3fcde5650dd86d60, 0x3ca4755a9ea582a9
+data8 0x875fdf6fe45529e8, 0xf8edf92dc5875319
+data8 0x3fce27325d6fe520, 0x3cbc1e2b6c1954f9
+data8 0x878176321154e2bc, 0xf8cf1d20f87270b8
+data8 0x3fce6907cca0d060, 0x3cb6ca4804750830
+data8 0x87a36580fe6bccf5, 0xf8affb5e20412199
+data8 0x3fceaae56fdee040, 0x3cad6b310d6fd46c
+data8 0x87c5add5417a5cb9, 0xf89093cb0b7c0233
+data8 0x3fceeccb5bb33900, 0x3cc16e99cedadb20
+data8 0x87e84fa9057914ca, 0xf870e64d40a15036
+data8 0x3fcf2eb9a4bcb600, 0x3cc75ee47c8b09e9
+data8 0x880b4b780f02b709, 0xf850f2c9fdacdf78
+data8 0x3fcf70b05fb02e20, 0x3cad6350d379f41a
+data8 0x882ea1bfc0f228ac, 0xf830b926379e6465
+data8 0x3fcfb2afa158b8a0, 0x3cce0ccd9f829985
+data8 0x885252ff21146108, 0xf810394699fe0e8e
+data8 0x3fcff4b77e97f3e0, 0x3c9b30faa7a4c703
+data8 0x88765fb6dceebbb3, 0xf7ef730f865f6df0
+data8 0x3fd01b6406332540, 0x3cdc5772c9e0b9bd
+data8 0x88ad1f69be2cc730, 0xf7bdc59bc9cfbd97
+data8 0x3fd04cf8ad203480, 0x3caeef44fe21a74a
+data8 0x88f763f70ae2245e, 0xf77a91c868a9c54e
+data8 0x3fd08f23ce0162a0, 0x3cd6290ab3fe5889
+data8 0x89431fc7bc0c2910, 0xf73642973c91298e
+data8 0x3fd0d1610f0c1ec0, 0x3cc67401a01f08cf
+data8 0x8990573407c7738e, 0xf6f0d71d1d7a2dd6
+data8 0x3fd113b0c65d88c0, 0x3cc7aa4020fe546f
+data8 0x89df0eb108594653, 0xf6aa4e6a05cfdef2
+data8 0x3fd156134ada6fe0, 0x3cc87369da09600c
+data8 0x8a2f4ad16e0ed78a, 0xf662a78900c35249
+data8 0x3fd19888f43427a0, 0x3cc62b220f38e49c
+data8 0x8a811046373e0819, 0xf619e180181d97cc
+data8 0x3fd1db121aed7720, 0x3ca3ede7490b52f4
+data8 0x8ad463df6ea0fa2c, 0xf5cffb504190f9a2
+data8 0x3fd21daf185fa360, 0x3caafad98c1d6c1b
+data8 0x8b294a8cf0488daf, 0xf584f3f54b8604e6
+data8 0x3fd2606046bf95a0, 0x3cdb2d704eeb08fa
+data8 0x8b7fc95f35647757, 0xf538ca65c960b582
+data8 0x3fd2a32601231ec0, 0x3cc661619fa2f126
+data8 0x8bd7e588272276f8, 0xf4eb7d92ff39fccb
+data8 0x3fd2e600a3865760, 0x3c8a2a36a99aca4a
+data8 0x8c31a45bf8e9255e, 0xf49d0c68cd09b689
+data8 0x3fd328f08ad12000, 0x3cb9efaf1d7ab552
+data8 0x8c8d0b520a35eb18, 0xf44d75cd993cfad2
+data8 0x3fd36bf614dcc040, 0x3ccacbb590bef70d
+data8 0x8cea2005d068f23d, 0xf3fcb8a23ab4942b
+data8 0x3fd3af11a079a6c0, 0x3cd9775872cf037d
+data8 0x8d48e837c8cd5027, 0xf3aad3c1e2273908
+data8 0x3fd3f2438d754b40, 0x3ca03304f667109a
+data8 0x8da969ce732f3ac7, 0xf357c60202e2fd7e
+data8 0x3fd4358c3ca032e0, 0x3caecf2504ff1a9d
+data8 0x8e0baad75555e361, 0xf3038e323ae9463a
+data8 0x3fd478ec0fd419c0, 0x3cc64bdc3d703971
+data8 0x8e6fb18807ba877e, 0xf2ae2b1c3a6057f7
+data8 0x3fd4bc6369fa40e0, 0x3cbb7122ec245cf2
+data8 0x8ed5843f4bda74d5, 0xf2579b83aa556f0c
+data8 0x3fd4fff2af11e2c0, 0x3c9cfa2dc792d394
+data8 0x8f3d29862c861fef, 0xf1ffde2612ca1909
+data8 0x3fd5439a4436d000, 0x3cc38d46d310526b
+data8 0x8fa6a81128940b2d, 0xf1a6f1bac0075669
+data8 0x3fd5875a8fa83520, 0x3cd8bf59b8153f8a
+data8 0x901206c1686317a6, 0xf14cd4f2a730d480
+data8 0x3fd5cb33f8cf8ac0, 0x3c9502b5c4d0e431
+data8 0x907f4ca5fe9cf739, 0xf0f186784a125726
+data8 0x3fd60f26e847b120, 0x3cc8a1a5e0acaa33
+data8 0x90ee80fd34aeda5e, 0xf09504ef9a212f18
+data8 0x3fd65333c7e43aa0, 0x3cae5b029cb1f26e
+data8 0x915fab35e37421c6, 0xf0374ef5daab5c45
+data8 0x3fd6975b02b8e360, 0x3cd5aa1c280c45e6
+data8 0x91d2d2f0d894d73c, 0xefd86321822dbb51
+data8 0x3fd6db9d05213b20, 0x3cbecf2c093ccd8b
+data8 0x9248000249200009, 0xef7840021aca5a72
+data8 0x3fd71ffa3cc87fc0, 0x3cb8d273f08d00d9
+data8 0x92bf3a7351f081d2, 0xef16e42021d7cbd5
+data8 0x3fd7647318b1ad20, 0x3cbce099d79cdc46
+data8 0x93388a8386725713, 0xeeb44dfce6820283
+data8 0x3fd7a908093fc1e0, 0x3ccb033ec17a30d9
+data8 0x93b3f8aa8e653812, 0xee507c126774fa45
+data8 0x3fd7edb9803e3c20, 0x3cc10aedb48671eb
+data8 0x94318d99d341ade4, 0xedeb6cd32f891afb
+data8 0x3fd83287f0e9cf80, 0x3c994c0c1505cd2a
+data8 0x94b1523e3dedc630, 0xed851eaa3168f43c
+data8 0x3fd87773cff956e0, 0x3cda3b7bce6a6b16
+data8 0x95334fc20577563f, 0xed1d8ffaa2279669
+data8 0x3fd8bc7d93a70440, 0x3cd4922edc792ce2
+data8 0x95b78f8e8f92f274, 0xecb4bf1fd2be72da
+data8 0x3fd901a5b3b9cf40, 0x3cd3fea1b00f9d0d
+data8 0x963e1b4e63a87c3f, 0xec4aaa6d08694cc1
+data8 0x3fd946eca98f2700, 0x3cdba4032d968ff1
+data8 0x96c6fcef314074fc, 0xebdf502d53d65fea
+data8 0x3fd98c52f024e800, 0x3cbe7be1ab8c95c9
+data8 0x97523ea3eab028b2, 0xeb72aea36720793e
+data8 0x3fd9d1d904239860, 0x3cd72d08a6a22b70
+data8 0x97dfeae6f4ee4a9a, 0xeb04c4096a884e94
+data8 0x3fda177f63e8ef00, 0x3cd818c3c1ebfac7
+data8 0x98700c7c6d85d119, 0xea958e90cfe1efd7
+data8 0x3fda5d468f92a540, 0x3cdf45fbfaa080fe
+data8 0x9902ae7487a9caa1, 0xea250c6224aab21a
+data8 0x3fdaa32f090998e0, 0x3cd715a9353cede4
+data8 0x9997dc2e017a9550, 0xe9b33b9ce2bb7638
+data8 0x3fdae939540d3f00, 0x3cc545c014943439
+data8 0x9a2fa158b29b649b, 0xe9401a573f8aa706
+data8 0x3fdb2f65f63f6c60, 0x3cd4a63c2f2ca8e2
+data8 0x9aca09f835466186, 0xe8cba69df9f0bf35
+data8 0x3fdb75b5773075e0, 0x3cda310ce1b217ec
+data8 0x9b672266ab1e0136, 0xe855de74266193d4
+data8 0x3fdbbc28606babc0, 0x3cdc84b75cca6c44
+data8 0x9c06f7579f0b7bd5, 0xe7debfd2f98c060b
+data8 0x3fdc02bf3d843420, 0x3cd225d967ffb922
+data8 0x9ca995db058cabdc, 0xe76648a991511c6e
+data8 0x3fdc497a9c224780, 0x3cde08101c5b825b
+data8 0x9d4f0b605ce71e88, 0xe6ec76dcbc02d9a7
+data8 0x3fdc905b0c10d420, 0x3cb1abbaa3edf120
+data8 0x9df765b9eecad5e6, 0xe6714846bdda7318
+data8 0x3fdcd7611f4b8a00, 0x3cbf6217ae80aadf
+data8 0x9ea2b320350540fe, 0xe5f4bab71494cd6b
+data8 0x3fdd1e8d6a0d56c0, 0x3cb726e048cc235c
+data8 0x9f51023562fc5676, 0xe576cbf239235ecb
+data8 0x3fdd65e082df5260, 0x3cd9e66872bd5250
+data8 0xa002620915c2a2f6, 0xe4f779b15f5ec5a7
+data8 0x3fddad5b02a82420, 0x3c89743b0b57534b
+data8 0xa0b6e21c2caf9992, 0xe476c1a233a7873e
+data8 0x3fddf4fd84bbe160, 0x3cbf7adea9ee3338
+data8 0xa16e9264cc83a6b2, 0xe3f4a16696608191
+data8 0x3fde3cc8a6ec6ee0, 0x3cce46f5a51f49c6
+data8 0xa22983528f3d8d49, 0xe3711694552da8a8
+data8 0x3fde84bd099a6600, 0x3cdc78f6490a2d31
+data8 0xa2e7c5d2e2e69460, 0xe2ec1eb4e1e0a5fb
+data8 0x3fdeccdb4fc685c0, 0x3cdd3aedb56a4825
+data8 0xa3a96b5599bd2532, 0xe265b74506fbe1c9
+data8 0x3fdf15241f23b3e0, 0x3cd440f3c6d65f65
+data8 0xa46e85d1ae49d7de, 0xe1ddddb499b3606f
+data8 0x3fdf5d98202994a0, 0x3cd6c44bd3fb745a
+data8 0xa53727ca3e11b99e, 0xe1548f662951b00d
+data8 0x3fdfa637fe27bf60, 0x3ca8ad1cd33054dd
+data8 0xa6036453bdc20186, 0xe0c9c9aeabe5e481
+data8 0x3fdfef0467599580, 0x3cc0f1ac0685d78a
+data8 0xa6d34f1969dda338, 0xe03d89d5281e4f81
+data8 0x3fe01bff067d6220, 0x3cc0731e8a9ef057
+data8 0xa7a6fc62f7246ff3, 0xdfafcd125c323f54
+data8 0x3fe04092d1ae3b40, 0x3ccabda24b59906d
+data8 0xa87e811a861df9b9, 0xdf20909061bb9760
+data8 0x3fe0653df0fd9fc0, 0x3ce94c8dcc722278
+data8 0xa959f2d2dd687200, 0xde8fd16a4e5f88bd
+data8 0x3fe08a00c1cae320, 0x3ce6b888bb60a274
+data8 0xaa3967cdeea58bda, 0xddfd8cabd1240d22
+data8 0x3fe0aedba3221c00, 0x3ced5941cd486e46
+data8 0xab904fd587263c84, 0xdd1f4472e1cf64ed
+data8 0x3fe0e651e85229c0, 0x3cdb6701042299b1
+data8 0xad686d44dd5a74bb, 0xdbf173e1f6b46e92
+data8 0x3fe1309cbf4cdb20, 0x3cbf1be7bb3f0ec5
+data8 0xaf524e15640ebee4, 0xdabd54896f1029f6
+data8 0x3fe17b4ee1641300, 0x3ce81dd055b792f1
+data8 0xb14eca24ef7db3fa, 0xd982cb9ae2f47e41
+data8 0x3fe1c66b9ffd6660, 0x3cd98ea31eb5ddc7
+data8 0xb35ec807669920ce, 0xd841bd1b8291d0b6
+data8 0x3fe211f66db3a5a0, 0x3ca480c35a27b4a2
+data8 0xb5833e4755e04dd1, 0xd6fa0bd3150b6930
+data8 0x3fe25df2e05b6c40, 0x3ca4bc324287a351
+data8 0xb7bd34c8000b7bd3, 0xd5ab9939a7d23aa1
+data8 0x3fe2aa64b32f7780, 0x3cba67314933077c
+data8 0xba0dc64d126cc135, 0xd4564563ce924481
+data8 0x3fe2f74fc9289ac0, 0x3cec1a1dc0efc5ec
+data8 0xbc76222cbbfa74a6, 0xd2f9eeed501125a8
+data8 0x3fe344b82f859ac0, 0x3ceeef218de413ac
+data8 0xbef78e31985291a9, 0xd19672e2182f78be
+data8 0x3fe392a22087b7e0, 0x3cd2619ba201204c
+data8 0xc19368b2b0629572, 0xd02baca5427e436a
+data8 0x3fe3e11206694520, 0x3cb5d0b3143fe689
+data8 0xc44b2ae8c6733e51, 0xceb975d60b6eae5d
+data8 0x3fe4300c7e945020, 0x3cbd367143da6582
+data8 0xc7206b894212dfef, 0xcd3fa6326ff0ac9a
+data8 0x3fe47f965d201d60, 0x3ce797c7a4ec1d63
+data8 0xca14e1b0622de526, 0xcbbe13773c3c5338
+data8 0x3fe4cfb4b09d1a20, 0x3cedfadb5347143c
+data8 0xcd2a6825eae65f82, 0xca34913d425a5ae9
+data8 0x3fe5206cc637e000, 0x3ce2798b38e54193
+data8 0xd06301095e1351ee, 0xc8a2f0d3679c08c0
+data8 0x3fe571c42e3d0be0, 0x3ccd7cb9c6c2ca68
+data8 0xd3c0d9f50057adda, 0xc70901152d59d16b
+data8 0x3fe5c3c0c108f940, 0x3ceb6c13563180ab
+data8 0xd74650a98cc14789, 0xc5668e3d4cbf8828
+data8 0x3fe61668a46ffa80, 0x3caa9092e9e3c0e5
+data8 0xdaf5f8579dcc8f8f, 0xc3bb61b3eed42d02
+data8 0x3fe669c251ad69e0, 0x3cccf896ef3b4fee
+data8 0xded29f9f9a6171b4, 0xc20741d7f8e8e8af
+data8 0x3fe6bdd49bea05c0, 0x3cdc6b29937c575d
+data8 0xe2df5765854ccdb0, 0xc049f1c2d1b8014b
+data8 0x3fe712a6b76c6e80, 0x3ce1ddc6f2922321
+data8 0xe71f7a9b94fcb4c3, 0xbe833105ec291e91
+data8 0x3fe76840418978a0, 0x3ccda46e85432c3d
+data8 0xeb96b72d3374b91e, 0xbcb2bb61493b28b3
+data8 0x3fe7bea9496d5a40, 0x3ce37b42ec6e17d3
+data8 0xf049183c3f53c39b, 0xbad848720223d3a8
+data8 0x3fe815ea59dab0a0, 0x3cb03ad41bfc415b
+data8 0xf53b11ec7f415f15, 0xb8f38b57c53c9c48
+data8 0x3fe86e0c84010760, 0x3cc03bfcfb17fe1f
+data8 0xfa718f05adbf2c33, 0xb70432500286b185
+data8 0x3fe8c7196b9225c0, 0x3ced99fcc6866ba9
+data8 0xfff200c3f5489608, 0xb509e6454dca33cc
+data8 0x3fe9211b54441080, 0x3cb789cb53515688
+// The following table entries are not used
+//data8 0x82e138a0fac48700, 0xb3044a513a8e6132
+//data8 0x3fe97c1d30f5b7c0, 0x3ce1eb765612d1d0
+//data8 0x85f4cc7fc670d021, 0xb0f2fb2ea6cbbc88
+//data8 0x3fe9d82ab4b5fde0, 0x3ced3fe6f27e8039
+//data8 0x89377c1387d5b908, 0xaed58e9a09014d5c
+//data8 0x3fea355065f87fa0, 0x3cbef481d25f5b58
+//data8 0x8cad7a2c98dec333, 0xacab929ce114d451
+//data8 0x3fea939bb451e2a0, 0x3c8e92b4fbf4560f
+//data8 0x905b7dfc99583025, 0xaa748cc0dbbbc0ec
+//data8 0x3feaf31b11270220, 0x3cdced8c61bd7bd5
+//data8 0x9446d8191f80dd42, 0xa82ff92687235baf
+//data8 0x3feb53de0bcffc20, 0x3cbe1722fb47509e
+//data8 0x98758ba086e4000a, 0xa5dd497a9c184f58
+//data8 0x3febb5f571cb0560, 0x3ce0c7774329a613
+//data8 0x9cee6c7bf18e4e24, 0xa37be3c3cd1de51b
+//data8 0x3fec197373bc7be0, 0x3ce08ebdb55c3177
+//data8 0xa1b944000a1b9440, 0xa10b2101b4f27e03
+//data8 0x3fec7e6bd023da60, 0x3ce5fc5fd4995959
+//data8 0xa6defd8ba04d3e38, 0x9e8a4b93cad088ec
+//data8 0x3fece4f404e29b20, 0x3cea3413401132b5
+//data8 0xac69dd408a10c62d, 0x9bf89d5d17ddae8c
+//data8 0x3fed4d2388f63600, 0x3cd5a7fb0d1d4276
+//data8 0xb265c39cbd80f97a, 0x99553d969fec7beb
+//data8 0x3fedb714101e0a00, 0x3cdbda21f01193f2
+//data8 0xb8e081a16ae4ae73, 0x969f3e3ed2a0516c
+//data8 0x3fee22e1da97bb00, 0x3ce7231177f85f71
+//data8 0xbfea427678945732, 0x93d5990f9ee787af
+//data8 0x3fee90ac13b18220, 0x3ce3c8a5453363a5
+//data8 0xc79611399b8c90c5, 0x90f72bde80febc31
+//data8 0x3fef009542b712e0, 0x3ce218fd79e8cb56
+//data8 0xcffa8425040624d7, 0x8e02b4418574ebed
+//data8 0x3fef72c3d2c57520, 0x3cd32a717f82203f
+//data8 0xd93299cddcf9cf23, 0x8af6ca48e9c44024
+//data8 0x3fefe762b77744c0, 0x3ce53478a6bbcf94
+//data8 0xe35eda760af69ad9, 0x87d1da0d7f45678b
+//data8 0x3ff02f511b223c00, 0x3ced6e11782c28fc
+//data8 0xeea6d733421da0a6, 0x84921bbe64ae029a
+//data8 0x3ff06c5c6f8ce9c0, 0x3ce71fc71c1ffc02
+//data8 0xfb3b2c73fc6195cc, 0x813589ba3a5651b6
+//data8 0x3ff0aaf2613700a0, 0x3cf2a72d2fd94ef3
+//data8 0x84ac1fcec4203245, 0xfb73a828893df19e
+//data8 0x3ff0eb367c3fd600, 0x3cf8054c158610de
+//data8 0x8ca50621110c60e6, 0xf438a14c158d867c
+//data8 0x3ff12d51caa6b580, 0x3ce6bce9748739b6
+//data8 0x95b8c2062d6f8161, 0xecb3ccdd37b369da
+//data8 0x3ff1717418520340, 0x3ca5c2732533177c
+//data8 0xa0262917caab4ad1, 0xe4dde4ddc81fd119
+//data8 0x3ff1b7d59dd40ba0, 0x3cc4c7c98e870ff5
+//data8 0xac402c688b72f3f4, 0xdcae469be46d4c8d
+//data8 0x3ff200b93cc5a540, 0x3c8dd6dc1bfe865a
+//data8 0xba76968b9eabd9ab, 0xd41a8f3df1115f7f
+//data8 0x3ff24c6f8f6affa0, 0x3cf1acb6d2a7eff7
+//data8 0xcb63c87c23a71dc5, 0xcb161074c17f54ec
+//data8 0x3ff29b5b338b7c80, 0x3ce9b5845f6ec746
+//data8 0xdfe323b8653af367, 0xc19107d99ab27e42
+//data8 0x3ff2edf6fac7f5a0, 0x3cf77f961925fa02
+//data8 0xf93746caaba3e1f1, 0xb777744a9df03bff
+//data8 0x3ff344df237486c0, 0x3cf6ddf5f6ddda43
+//data8 0x8ca77052f6c340f0, 0xacaf476f13806648
+//data8 0x3ff3a0dfa4bb4ae0, 0x3cfee01bbd761bff
+//data8 0xa1a48604a81d5c62, 0xa11575d30c0aae50
+//data8 0x3ff4030b73c55360, 0x3cf1cf0e0324d37c
+//data8 0xbe45074b05579024, 0x9478e362a07dd287
+//data8 0x3ff46ce4c738c4e0, 0x3ce3179555367d12
+//data8 0xe7a08b5693d214ec, 0x8690e3575b8a7c3b
+//data8 0x3ff4e0a887c40a80, 0x3cfbd5d46bfefe69
+//data8 0x94503d69396d91c7, 0xedd2ce885ff04028
+//data8 0x3ff561ebd9c18cc0, 0x3cf331bd176b233b
+//data8 0xced1d96c5bb209e6, 0xc965278083808702
+//data8 0x3ff5f71d7ff42c80, 0x3ce3301cc0b5a48c
+//data8 0xabac2cee0fc24e20, 0x9c4eb1136094cbbd
+//data8 0x3ff6ae4c63222720, 0x3cf5ff46874ee51e
+//data8 0x8040201008040201, 0xb4d7ac4d9acb1bf4
+//data8 0x3ff7b7d33b928c40, 0x3cfacdee584023bb
+LOCAL_OBJECT_END(T_table)
+
+
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+       // C_3
+data8 0xaaaaaaaaaaaaaaab, 0x0000000000003ffc
+       // C_5
+data8 0x999999999999999a, 0x0000000000003ffb
+       // C_7, C_9
+data8 0x3fa6db6db6db6db7, 0x3f9f1c71c71c71c8
+       // pi/2 (low, high)
+data8 0x3C91A62633145C07, 0x3FF921FB54442D18
+       // C_11, C_13
+data8 0x3f96e8ba2e8ba2e9, 0x3f91c4ec4ec4ec4e
+       // C_15, C_17
+data8 0x3f8c99999999999a, 0x3f87a87878787223
+       // pi (low, high)
+data8 0x3CA1A62633145C07, 0x400921FB54442D18
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+R_DBL_S = r21
+R_EXP0 = r22
+R_EXP = r15
+R_SGNMASK = r23
+R_TMP = r24
+R_TMP2 = r25
+R_INDEX = r26
+R_TMP3 = r27
+R_TMP03 = r27
+R_TMP4 = r28
+R_TMP5 = r23
+R_TMP6 = r22
+R_TMP7 = r21
+R_T = r29
+R_BIAS = r20
+
+F_T = f6
+F_1S2 = f7
+F_1S2_S = f9
+F_INV_1T2 = f10
+F_SQRT_1T2 = f11
+F_S2T2 = f12
+F_X = f13
+F_D = f14
+F_2M64 = f15
+
+F_CS2 = f32
+F_CS3 = f33
+F_CS4 = f34
+F_CS5 = f35
+F_CS6 = f36
+F_CS7 = f37
+F_CS8 = f38
+F_CS9 = f39
+F_S23 = f40
+F_S45 = f41
+F_S67 = f42
+F_S89 = f43
+F_S25 = f44
+F_S69 = f45
+F_S29 = f46
+F_X2 = f47
+F_X4 = f48
+F_TSQRT = f49
+F_DTX = f50
+F_R = f51
+F_R2 = f52
+F_R3 = f53
+F_R4 = f54
+
+F_C3 = f55
+F_C5 = f56
+F_C7 = f57
+F_C9 = f58
+F_P79 = f59
+F_P35 = f60
+F_P39 = f61
+
+F_ATHI = f62
+F_ATLO = f63
+
+F_T1 = f64
+F_Y = f65
+F_Y2 = f66
+F_ANDMASK = f67
+F_ORMASK = f68
+F_S = f69
+F_05 = f70
+F_SQRT_1S2 = f71
+F_DS = f72
+F_Z = f73
+F_1T2 = f74
+F_DZ = f75
+F_ZE = f76
+F_YZ = f77
+F_Y1S2 = f78
+F_Y1S2X = f79
+F_1X = f80
+F_ST = f81
+F_1T2_ST = f82
+F_TSS = f83
+F_Y1S2X2 = f84
+F_DZ_TERM = f85
+F_DTS = f86
+F_DS2X = f87
+F_T2 = f88
+F_ZY1S2S = f89
+F_Y1S2_1X = f90
+F_TS = f91
+F_PI2_LO = f92
+F_PI2_HI = f93
+F_S19 = f94
+F_INV1T2_2 = f95
+F_CORR = f96
+F_DZ0 = f97
+
+F_C11 = f98
+F_C13 = f99
+F_C15 = f100
+F_C17 = f101
+F_P1113 = f102
+F_P1517 = f103
+F_P1117 = f104
+F_P317 = f105
+F_R8 = f106
+F_HI = f107
+F_1S2_HI = f108
+F_DS2 = f109
+F_Y2_2 = f110
+//F_S2 = f111
+//F_S_DS2 = f112
+F_S_1S2S = f113
+F_XL = f114
+F_2M128 = f115
+F_1AS = f116
+F_AS = f117
+
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(acosl)
+
+{.mfi
+       // get exponent, mantissa (rounded to double precision) of s
+       getf.d R_DBL_S = f8
+       // 1-s^2
+       fnma.s1 F_1S2 = f8, f8, f1
+       // r2 = pointer to T_table
+       addl r2 = @ltoff(T_table), gp
+}
+
+{.mfi
+       // sign mask
+       mov R_SGNMASK = 0x20000
+       nop.f 0
+       // bias-63-1
+       mov R_TMP03 = 0xffff-64;;
+}
+
+
+{.mfi
+       // get exponent of s
+       getf.exp R_EXP = f8
+       nop.f 0
+       // R_TMP4 = 2^45
+       shl R_TMP4 = R_SGNMASK, 45-17
+}
+
+{.mlx
+       // load bias-4
+       mov R_TMP = 0xffff-4
+       // load RU(sqrt(2)/2) to integer register (in double format, shifted left by 1)
+       movl R_TMP2 = 0x7fcd413cccfe779a;;
+}
+
+
+{.mfi
+       // load 2^{-64} in FP register
+       setf.exp F_2M64 = R_TMP03
+       nop.f 0
+       // index = (0x7-exponent)|b1 b2.. b6
+       extr.u R_INDEX = R_DBL_S, 46, 9
+}
+
+{.mfi
+       // get t = sign|exponent|b1 b2.. b6 1 x.. x
+       or R_T = R_DBL_S, R_TMP4
+       nop.f 0
+       // R_TMP4 = 2^45-1
+       sub R_TMP4 = R_TMP4, r0, 1;;
+}
+
+
+{.mfi
+       // get t = sign|exponent|b1 b2.. b6 1 0.. 0
+       andcm R_T = R_T, R_TMP4
+       nop.f 0
+       // eliminate sign from R_DBL_S (shift left by 1)
+       shl R_TMP3 = R_DBL_S, 1
+}
+
+{.mfi
+       // R_BIAS = 3*2^6
+       mov R_BIAS = 0xc0
+       nop.f 0
+       // eliminate sign from R_EXP
+       andcm R_EXP0 = R_EXP, R_SGNMASK;;
+}
+
+
+
+{.mfi
+       // load start address for T_table
+       ld8 r2 = [r2]
+       nop.f 0
+       // p8 = 1 if |s|> = sqrt(2)/2
+       cmp.geu p8, p0 = R_TMP3, R_TMP2
+}
+
+{.mlx
+       // p7 = 1 if |s|<2^{-4} (exponent of s<bias-4)
+       cmp.lt p7, p0 = R_EXP0, R_TMP
+       // sqrt coefficient cs8 = -33*13/128
+       movl R_TMP2 = 0xc0568000;;
+}
+
+
+
+{.mbb
+       // load t in FP register
+       setf.d F_T = R_T
+       // if |s|<2^{-4}, take alternate path
+ (p7) br.cond.spnt SMALL_S
+       // if |s|> = sqrt(2)/2, take alternate path
+ (p8) br.cond.sptk LARGE_S
+}
+
+{.mlx
+       // index = (4-exponent)|b1 b2.. b6
+       sub R_INDEX = R_INDEX, R_BIAS
+       // sqrt coefficient cs9 = 55*13/128
+       movl R_TMP = 0x40b2c000;;
+}
+
+
+{.mfi
+       // sqrt coefficient cs8 = -33*13/128
+       setf.s F_CS8 = R_TMP2
+       nop.f 0
+       // shift R_INDEX by 5
+       shl R_INDEX = R_INDEX, 5
+}
+
+{.mfi
+       // sqrt coefficient cs3 = 0.5 (set exponent = bias-1)
+       mov R_TMP4 = 0xffff - 1
+       nop.f 0
+       // sqrt coefficient cs6 = -21/16
+       mov R_TMP6 = 0xbfa8;;
+}
+
+
+{.mlx
+       // table index
+       add r2 = r2, R_INDEX
+       // sqrt coefficient cs7 = 33/16
+       movl R_TMP2 = 0x40040000;;
+}
+
+
+{.mmi
+       // load cs9 = 55*13/128
+       setf.s F_CS9 = R_TMP
+       // sqrt coefficient cs5 = 7/8
+       mov R_TMP3 = 0x3f60
+       // sqrt coefficient cs6 = 21/16
+       shl R_TMP6 = R_TMP6, 16;;
+}
+
+
+{.mmi
+       // load significand of 1/(1-t^2)
+       ldf8 F_INV_1T2 = [r2], 8
+       // sqrt coefficient cs7 = 33/16
+       setf.s F_CS7 = R_TMP2
+       // sqrt coefficient cs4 = -5/8
+       mov R_TMP5 = 0xbf20;;
+}
+
+
+{.mmi
+       // load significand of sqrt(1-t^2)
+       ldf8 F_SQRT_1T2 = [r2], 8
+       // sqrt coefficient cs6 = 21/16
+       setf.s F_CS6 = R_TMP6
+       // sqrt coefficient cs5 = 7/8
+       shl R_TMP3 = R_TMP3, 16;;
+}
+
+
+{.mmi
+       // sqrt coefficient cs3 = 0.5 (set exponent = bias-1)
+       setf.exp F_CS3 = R_TMP4
+       // r3 = pointer to polynomial coefficients
+       addl r3 = @ltoff(poly_coeffs), gp
+       // sqrt coefficient cs4 = -5/8
+       shl R_TMP5 = R_TMP5, 16;;
+}
+
+
+{.mfi
+       // sqrt coefficient cs5 = 7/8
+       setf.s F_CS5 = R_TMP3
+       // d = s-t
+       fms.s1 F_D = f8, f1, F_T
+       // set p6 = 1 if s<0, p11 = 1 if s> = 0
+       cmp.ge p6, p11 = R_EXP, R_DBL_S
+}
+
+{.mfi
+       // r3 = load start address to polynomial coefficients
+       ld8 r3 = [r3]
+       // s+t
+       fma.s1 F_S2T2 = f8, f1, F_T
+       nop.i 0;;
+}
+
+
+{.mfi
+       // sqrt coefficient cs4 = -5/8
+       setf.s F_CS4 = R_TMP5
+       // s^2-t^2
+       fma.s1 F_S2T2 = F_S2T2, F_D, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       // load C3
+       ldfe F_C3 = [r3], 16
+       // 0.5/(1-t^2) = 2^{-64}*(2^63/(1-t^2))
+       fma.s1 F_INV_1T2 = F_INV_1T2, F_2M64, f0
+       nop.i 0;;
+}
+
+{.mfi
+       // load C_5
+       ldfe F_C5 = [r3], 16
+       // set correct exponent for sqrt(1-t^2)
+       fma.s1 F_SQRT_1T2 = F_SQRT_1T2, F_2M64, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       // load C_7, C_9
+       ldfpd F_C7, F_C9 = [r3], 16
+       // x = -(s^2-t^2)/(1-t^2)/2
+       fnma.s1 F_X = F_INV_1T2, F_S2T2, f0
+       nop.i 0;;
+}
+
+
+{.mmf
+       // load asin(t)_high, asin(t)_low
+       ldfpd F_ATHI, F_ATLO = [r2]
+	   // load pi/2
+	   ldfpd F_PI2_LO, F_PI2_HI = [r3]
+       // t*sqrt(1-t^2)
+       fma.s1 F_TSQRT = F_T, F_SQRT_1T2, f0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // cs9*x+cs8
+       fma.s1 F_S89 = F_CS9, F_X, F_CS8
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // cs7*x+cs6
+       fma.s1 F_S67 = F_CS7, F_X, F_CS6
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // cs5*x+cs4
+       fma.s1 F_S45 = F_CS5, F_X, F_CS4
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x*x
+       fma.s1 F_X2 = F_X, F_X, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (s-t)-t*x
+       fnma.s1 F_DTX = F_T, F_X, F_D
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // cs3*x+cs2 (cs2 = -0.5 = -cs3)
+       fms.s1 F_S23 = F_CS3, F_X, F_CS3
+       nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // if sign is negative, negate table values: asin(t)_low
+  (p6) fnma.s1 F_ATLO = F_ATLO, f1, f0
+  nop.i 0
+}
+
+{.mfi
+  nop.m 0
+  // if sign is negative, negate table values: asin(t)_high
+  (p6) fnma.s1 F_ATHI = F_ATHI, f1, f0
+  nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // cs9*x^3+cs8*x^2+cs7*x+cs6
+       fma.s1 F_S69 = F_S89, F_X2, F_S67
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x^4
+       fma.s1 F_X4 = F_X2, F_X2, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // t*sqrt(1-t^2)*x^2
+       fma.s1 F_TSQRT = F_TSQRT, F_X2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // cs5*x^3+cs4*x^2+cs3*x+cs2
+       fma.s1 F_S25 = F_S45, F_X2, F_S23
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // ((s-t)-t*x)*sqrt(1-t^2)
+       fma.s1 F_DTX = F_DTX, F_SQRT_1T2, f0
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // (pi/2)_high - asin(t)_high
+       fnma.s1 F_ATHI = F_ATHI, f1, F_PI2_HI
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // asin(t)_low - (pi/2)_low
+       fnma.s1 F_ATLO = F_PI2_LO, f1, F_ATLO
+	   nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // PS29 = cs9*x^7+..+cs5*x^3+cs4*x^2+cs3*x+cs2
+       fma.s1 F_S29 = F_S69, F_X4, F_S25
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // R = ((s-t)-t*x)*sqrt(1-t^2)-t*sqrt(1-t^2)*x^2*PS29
+       fnma.s1 F_R = F_S29, F_TSQRT, F_DTX
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // R^2
+       fma.s1 F_R2 = F_R, F_R, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c7+c9*R^2
+       fma.s1 F_P79 = F_C9, F_R2, F_C7
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2
+       fma.s1 F_P35 = F_C5, F_R2, F_C3
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // R^3
+       fma.s1 F_R4 = F_R2, F_R2, f0
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // R^3
+       fma.s1 F_R3 = F_R2, F_R, f0
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2+c7*R^4+c9*R^6
+       fma.s1 F_P39 = F_P79, F_R4, F_P35
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fma.s1 F_P39 = F_P39, F_R3, F_ATLO
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // R+asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fma.s1 F_P39 = F_P39, f1, F_R
+       nop.i 0;;
+}
+
+
+{.mfb
+       nop.m 0
+       // result = (pi/2)-asin(t)_high+R+asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fnma.s0 f8 = F_P39, f1, F_ATHI
+       // return
+       br.ret.sptk b0;;
+}
+
+
+
+
+LARGE_S:
+
+{.mfi
+       // bias-1
+       mov R_TMP3 = 0xffff - 1
+       // y ~ 1/sqrt(1-s^2)
+       frsqrta.s1 F_Y, p7 = F_1S2
+       // c9 = 55*13*17/128
+       mov R_TMP4 = 0x10af7b
+}
+
+{.mlx
+       // c8 = -33*13*15/128
+       mov R_TMP5 = 0x184923
+       movl R_TMP2 = 0xff00000000000000;;
+}
+
+{.mfi
+       // set p6 = 1 if s<0, p11 = 1 if s>0
+       cmp.ge p6, p11 = R_EXP, R_DBL_S
+       // 1-s^2
+       fnma.s1 F_1S2 = f8, f8, f1
+       // set p9 = 1
+       cmp.eq p9, p0 = r0, r0;;
+}
+
+
+{.mfi
+       // load 0.5
+       setf.exp F_05 = R_TMP3
+       // (1-s^2) rounded to single precision
+       fnma.s.s1 F_1S2_S = f8, f8, f1
+       // c9 = 55*13*17/128
+       shl R_TMP4 = R_TMP4, 10
+}
+
+{.mlx
+       // AND mask for getting t ~ sqrt(1-s^2)
+       setf.sig F_ANDMASK = R_TMP2
+       // OR mask
+       movl R_TMP2 = 0x0100000000000000;;
+}
+
+.pred.rel "mutex", p6, p11
+{.mfi
+       nop.m 0
+	   // 1-|s|
+ (p6)  fma.s1 F_1AS = f8, f1, f1
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // 1-|s|
+ (p11) fnma.s1 F_1AS = f8, f1, f1
+       nop.i 0;;
+}
+
+
+{.mfi
+       // c9 = 55*13*17/128
+       setf.s F_CS9 = R_TMP4
+	   // |s|
+ (p6)  fnma.s1 F_AS = f8, f1, f0
+       // c8 = -33*13*15/128
+       shl R_TMP5 = R_TMP5, 11
+}
+
+{.mfi
+       // c7 = 33*13/16
+       mov R_TMP4 = 0x41d68
+	   // |s|
+ (p11) fma.s1 F_AS = f8, f1, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       setf.sig F_ORMASK = R_TMP2
+       // y^2
+       fma.s1 F_Y2 = F_Y, F_Y, f0
+       // c7 = 33*13/16
+       shl R_TMP4 = R_TMP4, 12
+}
+
+{.mfi
+       // c6 = -33*7/16
+       mov R_TMP6 = 0xc1670
+       // y' ~ sqrt(1-s^2)
+       fma.s1 F_T1 = F_Y, F_1S2, f0
+       // c5 = 63/8
+       mov R_TMP7 = 0x40fc;;
+}
+
+
+{.mlx
+       // load c8 = -33*13*15/128
+       setf.s F_CS8 = R_TMP5
+       // c4 = -35/8
+       movl R_TMP5 = 0xc08c0000;;
+}
+
+{.mfi
+       // r3 = pointer to polynomial coefficients
+       addl r3 = @ltoff(poly_coeffs), gp
+       // 1-s-(1-s^2)_s
+       fnma.s1 F_DS = F_1S2_S, f1, F_1AS
+       // p9 = 0 if p7 = 1 (p9 = 1 for special cases only)
+ (p7) cmp.ne p9, p0 = r0, r0
+}
+
+{.mlx
+       // load c7 = 33*13/16
+       setf.s F_CS7 = R_TMP4
+       // c3 = 5/2
+       movl R_TMP4 = 0x40200000;;
+}
+
+
+{.mlx
+       // load c4 = -35/8
+       setf.s F_CS4 = R_TMP5
+       // c2 = -3/2
+       movl R_TMP5 = 0xbfc00000;;
+}
+
+
+{.mfi
+       // load c3 = 5/2
+       setf.s F_CS3 = R_TMP4
+       // x = (1-s^2)_s*y^2-1
+       fms.s1 F_X = F_1S2_S, F_Y2, f1
+       // c6 = -33*7/16
+       shl R_TMP6 = R_TMP6, 12
+}
+
+{.mfi
+       nop.m 0
+       // y^2/2
+       fma.s1 F_Y2_2 = F_Y2, F_05, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       // load c6 = -33*7/16
+       setf.s F_CS6 = R_TMP6
+       // eliminate lower bits from y'
+       fand F_T = F_T1, F_ANDMASK
+       // c5 = 63/8
+       shl R_TMP7 = R_TMP7, 16
+}
+
+
+{.mfb
+       // r3 = load start address to polynomial coefficients
+       ld8 r3 = [r3]
+       // 1-(1-s^2)_s-s^2
+       fma.s1 F_DS = F_AS, F_1AS, F_DS
+       // p9 = 1 if s is a special input (NaN, or |s|> = 1)
+ (p9) br.cond.spnt acosl_SPECIAL_CASES;;
+}
+
+{.mmf
+       // get exponent, significand of y' (in single prec.)
+       getf.s R_TMP = F_T1
+       // load c3 = -3/2
+       setf.s F_CS2 = R_TMP5
+       // y*(1-s^2)
+       fma.s1 F_Y1S2 = F_Y, F_1S2, f0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // if s<0, set s = -s
+ (p6) fnma.s1 f8 = f8, f1, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       // load c5 = 63/8
+       setf.s F_CS5 = R_TMP7
+       // x = (1-s^2)_s*y^2-1+(1-(1-s^2)_s-s^2)*y^2
+       fma.s1 F_X = F_DS, F_Y2, F_X
+       // for t = 2^k*1.b1 b2.., get 7-k|b1.. b6
+       extr.u R_INDEX = R_TMP, 17, 9;;
+}
+
+
+{.mmi
+       // index = (4-exponent)|b1 b2.. b6
+       sub R_INDEX = R_INDEX, R_BIAS
+       nop.m 0
+       // get exponent of y
+       shr.u R_TMP2 = R_TMP, 23;;
+}
+
+{.mmi
+       // load C3
+       ldfe F_C3 = [r3], 16
+       // set p8 = 1 if y'<2^{-4}
+       cmp.gt p8, p0 = 0x7b, R_TMP2
+       // shift R_INDEX by 5
+       shl R_INDEX = R_INDEX, 5;;
+}
+
+
+{.mfb
+       // get table index for sqrt(1-t^2)
+       add r2 = r2, R_INDEX
+       // get t = 2^k*1.b1 b2.. b7 1
+       for F_T = F_T, F_ORMASK
+ (p8) br.cond.spnt VERY_LARGE_INPUT;;
+}
+
+
+
+{.mmf
+       // load C5
+       ldfe F_C5 = [r3], 16
+       // load 1/(1-t^2)
+       ldfp8 F_INV_1T2, F_SQRT_1T2 = [r2], 16
+       // x = ((1-s^2)*y^2-1)/2
+       fma.s1 F_X = F_X, F_05, f0;;
+}
+
+
+
+{.mmf
+       nop.m 0
+       // C7, C9
+       ldfpd F_C7, F_C9 = [r3], 16
+       // set correct exponent for t
+       fmerge.se F_T = F_T1, F_T;;
+}
+
+
+
+{.mfi
+       // get address for loading pi
+	   add r3 = 48, r3
+       // c9*x+c8
+       fma.s1 F_S89 = F_X, F_CS9, F_CS8
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x^2
+       fma.s1 F_X2 = F_X, F_X, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       // pi (low, high)
+       ldfpd F_PI2_LO, F_PI2_HI = [r3]
+       // y*(1-s^2)*x
+       fma.s1 F_Y1S2X = F_Y1S2, F_X, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c7*x+c6
+       fma.s1 F_S67 = F_X, F_CS7, F_CS6
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // 1-x
+       fnma.s1 F_1X = F_X, f1, f1
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3*x+c2
+       fma.s1 F_S23 = F_X, F_CS3, F_CS2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // 1-t^2
+       fnma.s1 F_1T2 = F_T, F_T, f1
+       nop.i 0
+}
+
+{.mfi
+       // load asin(t)_high, asin(t)_low
+       ldfpd F_ATHI, F_ATLO = [r2]
+       // c5*x+c4
+       fma.s1 F_S45 = F_X, F_CS5, F_CS4
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // t*s
+       fma.s1 F_TS = F_T, f8, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // 0.5/(1-t^2)
+       fma.s1 F_INV_1T2 = F_INV_1T2, F_2M64, f0
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // z~sqrt(1-t^2), rounded to 24 significant bits
+       fma.s.s1 F_Z = F_SQRT_1T2, F_2M64, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // sqrt(1-t^2)
+       fma.s1 F_SQRT_1T2 = F_SQRT_1T2, F_2M64, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)*x^2
+       fma.s1 F_Y1S2X2 = F_Y1S2, F_X2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x^4
+       fma.s1 F_X4 = F_X2, F_X2, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // s*t rounded to 24 significant bits
+       fma.s.s1 F_TSS = F_T, f8, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c9*x^3+..+c6
+       fma.s1 F_S69 = F_X2, F_S89, F_S67
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // ST = (t^2-1+s^2) rounded to 24 significant bits
+       fms.s.s1 F_ST = f8, f8, F_1T2
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c5*x^3+..+c2
+       fma.s1 F_S25 = F_X2, F_S45, F_S23
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // 0.25/(1-t^2)
+       fma.s1 F_INV1T2_2 = F_05, F_INV_1T2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // t*s-sqrt(1-t^2)*(1-s^2)*y
+       fnma.s1 F_TS = F_Y1S2, F_SQRT_1T2, F_TS
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // z*0.5/(1-t^2)
+       fma.s1 F_ZE = F_INV_1T2, F_SQRT_1T2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // z^2+t^2-1
+       fms.s1 F_DZ0 = F_Z, F_Z, F_1T2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (1-s^2-(1-s^2)_s)*x
+       fma.s1 F_DS2X = F_X, F_DS, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // t*s-(t*s)_s
+       fms.s1 F_DTS = F_T, f8, F_TSS
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c9*x^7+..+c2
+       fma.s1 F_S29 = F_X4, F_S69, F_S25
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*z
+       fma.s1 F_YZ = F_Z, F_Y, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // t^2
+       fma.s1 F_T2 = F_T, F_T, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // 1-t^2+ST
+       fma.s1 F_1T2_ST = F_ST, f1, F_1T2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)(1-x)
+       fma.s1 F_Y1S2_1X = F_Y1S2, F_1X, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // dz ~ sqrt(1-t^2)-z
+       fma.s1 F_DZ = F_DZ0, F_ZE, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // -1+correction for sqrt(1-t^2)-z
+       fnma.s1 F_CORR = F_INV1T2_2, F_DZ0, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (PS29*x^2+x)*y*(1-s^2)
+       fma.s1 F_S19 = F_Y1S2X2, F_S29, F_Y1S2X
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // z*y*(1-s^2)_s
+       fma.s1 F_ZY1S2S = F_YZ, F_1S2_S, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // s^2-(1-t^2+ST)
+       fms.s1 F_1T2_ST = f8, f8, F_1T2_ST
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (t*s-(t*s)_s)+z*y*(1-s^2-(1-s^2)_s)*x
+       fma.s1 F_DTS = F_YZ, F_DS2X, F_DTS
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // dz*y*(1-s^2)*(1-x)
+       fma.s1 F_DZ_TERM = F_DZ, F_Y1S2_1X, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // R = t*s-sqrt(1-t^2)*(1-s^2)*y+sqrt(1-t^2)*(1-s^2)*y*PS19
+       // (used for polynomial evaluation)
+       fma.s1 F_R = F_S19, F_SQRT_1T2, F_TS
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (PS29*x^2)*y*(1-s^2)
+       fma.s1 F_S29 = F_Y1S2X2, F_S29, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // apply correction to dz*y*(1-s^2)*(1-x)
+       fma.s1 F_DZ_TERM = F_DZ_TERM, F_CORR, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // R^2
+       fma.s1 F_R2 = F_R, F_R, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (t*s-(t*s)_s)+z*y*(1-s^2-(1-s^2)_s)*x+dz*y*(1-s^2)*(1-x)
+       fma.s1 F_DZ_TERM = F_DZ_TERM, f1, F_DTS
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c7+c9*R^2
+       fma.s1 F_P79 = F_C9, F_R2, F_C7
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2
+       fma.s1 F_P35 = F_C5, F_R2, F_C3
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // asin(t)_low-(pi)_low (if s<0)
+ (p6)  fms.s1 F_ATLO = F_ATLO, f1, F_PI2_LO
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // R^4
+       fma.s1 F_R4 = F_R2, F_R2, f0
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // R^3
+       fma.s1 F_R3 = F_R2, F_R, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (t*s)_s-t^2*y*z
+       fnma.s1 F_TSS = F_T2, F_YZ, F_TSS
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // d(ts)+z*y*d(1-s^2)*x+dz*y*(1-s^2)*(1-x)+z*y*(s^2-1+t^2-ST)
+       fma.s1 F_DZ_TERM = F_YZ, F_1T2_ST, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (pi)_hi-asin(t)_hi (if s<0)
+ (p6)  fms.s1 F_ATHI = F_PI2_HI, f1, F_ATHI
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2+c7*R^4+c9*R^6
+       fma.s1 F_P39 = F_P79, F_R4, F_P35
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // d(ts)+z*y*d(1-s^2)*x+dz*y*(1-s^2)*(1-x)+z*y*(s^2-1+t^2-ST)+
+       // + sqrt(1-t^2)*y*(1-s^2)*x^2*PS29
+       fma.s1 F_DZ_TERM = F_SQRT_1T2, F_S29, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (t*s)_s-t^2*y*z+z*y*ST
+       fma.s1 F_TSS = F_YZ, F_ST, F_TSS
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // -asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fms.s1 F_P39 = F_P39, F_R3, F_ATLO
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // d(ts)+z*y*d(1-s^2)*x+dz*y*(1-s^2)*(1-x)+z*y*(s^2-1+t^2-ST) +
+       // + sqrt(1-t^2)*y*(1-s^2)*x^2*PS29 +
+       // - asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fma.s1 F_DZ_TERM = F_P39, f1, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // d(ts)+z*y*d(1-s^2)*x+dz*y*(1-s^2)*(1-x)+z*y*(s^2-1+t^2-ST) +
+       // + sqrt(1-t^2)*y*(1-s^2)*x^2*PS29 + z*y*(1-s^2)_s*x +
+       // - asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fma.s1 F_DZ_TERM = F_ZY1S2S, F_X, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // d(ts)+z*y*d(1-s^2)*x+dz*y*(1-s^2)*(1-x)+z*y*(s^2-1+t^2-ST) +
+       // + sqrt(1-t^2)*y*(1-s^2)*x^2*PS29 + z*y*(1-s^2)_s*x +
+       // - asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6) +
+       // + (t*s)_s-t^2*y*z+z*y*ST
+       fma.s1 F_DZ_TERM = F_TSS, f1, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+.pred.rel "mutex", p6, p11
+{.mfi
+       nop.m 0
+       // result: add high part of table value
+       // s>0 in this case
+ (p11) fnma.s0 f8 = F_DZ_TERM, f1, F_ATHI
+       nop.i 0
+}
+
+{.mfb
+       nop.m 0
+       // result: add high part of pi-table value
+       // if s<0
+ (p6)  fma.s0 f8 = F_DZ_TERM, f1, F_ATHI
+       br.ret.sptk b0;;
+}
+
+
+
+
+
+
+SMALL_S:
+
+       // use 15-term polynomial approximation
+
+{.mmi
+       // r3 = pointer to polynomial coefficients
+       addl r3 = @ltoff(poly_coeffs), gp;;
+       // load start address for coefficients
+       ld8 r3 = [r3]
+       mov R_TMP = 0x3fbf;;
+}
+
+
+{.mmi
+       add r2 = 64, r3
+       ldfe F_C3 = [r3], 16
+       // p7 = 1 if |s|<2^{-64} (exponent of s<bias-64)
+       cmp.lt p7, p0 = R_EXP0, R_TMP;;
+}
+
+{.mmf
+       ldfe F_C5 = [r3], 16
+       ldfpd F_C11, F_C13 = [r2], 16
+	   nop.f 0;;
+}
+
+{.mmf
+       ldfpd F_C7, F_C9 = [r3], 16
+       ldfpd F_C15, F_C17 = [r2]
+       nop.f 0;;
+}
+
+
+
+{.mfb
+       // load pi/2
+       ldfpd F_PI2_LO, F_PI2_HI = [r3]
+       // s^2
+       fma.s1 F_R2 = f8, f8, f0
+	   // |s|<2^{-64}
+  (p7) br.cond.spnt  RETURN_PI2;;
+}
+
+
+{.mfi
+       nop.m 0
+       // s^3
+       fma.s1 F_R3 = f8, F_R2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // s^4
+       fma.s1 F_R4 = F_R2, F_R2, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c3+c5*s^2
+       fma.s1 F_P35 = F_C5, F_R2, F_C3
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c11+c13*s^2
+       fma.s1 F_P1113 = F_C13, F_R2, F_C11
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c7+c9*s^2
+       fma.s1 F_P79 = F_C9, F_R2, F_C7
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c15+c17*s^2
+       fma.s1 F_P1517 = F_C17, F_R2, F_C15
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+	   // (pi/2)_high-s_high
+	   fnma.s1 F_T = f8, f1, F_PI2_HI
+	   nop.i 0
+}
+{.mfi
+       nop.m 0
+       // s^8
+       fma.s1 F_R8 = F_R4, F_R4, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c3+c5*s^2+c7*s^4+c9*s^6
+       fma.s1 F_P39 = F_P79, F_R4, F_P35
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c11+c13*s^2+c15*s^4+c17*s^6
+       fma.s1 F_P1117 = F_P1517, F_R4, F_P1113
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+	   // -s_high
+	   fms.s1 F_S = F_T, f1, F_PI2_HI
+	   nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // c3+..+c17*s^14
+       fma.s1 F_P317 = F_R8, F_P1117, F_P39
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+	   // s_low
+	   fma.s1 F_DS = f8, f1, F_S
+	   nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // (pi/2)_low-s^3*(c3+..+c17*s^14)
+       fnma.s0 F_P317 = F_P317, F_R3, F_PI2_LO
+	   nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+	   // (pi/2)_low-s_low-s^3*(c3+..+c17*s^14)
+	   fms.s1 F_P317 = F_P317, f1, F_DS
+	   nop.i 0;;
+}
+
+{.mfb
+       nop.m 0
+	   // result: pi/2-s-c3*s^3-..-c17*s^17
+	   fma.s0 f8 = F_T, f1, F_P317
+       br.ret.sptk b0;;
+}
+
+
+
+
+
+RETURN_PI2:
+
+{.mfi
+       nop.m 0
+       // (pi/2)_low-s
+	   fms.s0 F_PI2_LO = F_PI2_LO, f1, f8
+	   nop.i 0;;
+}
+
+{.mfb
+       nop.m 0
+	   // (pi/2)-s
+	   fma.s0 f8 = F_PI2_HI, f1, F_PI2_LO
+	   br.ret.sptk b0;;
+}
+
+
+
+
+
+VERY_LARGE_INPUT:
+
+
+{.mmf
+       // pointer to pi_low, pi_high
+	   add r2 = 80, r3
+       // load C5
+       ldfe F_C5 = [r3], 16
+       // x = ((1-(s^2)_s)*y^2-1)/2-(s^2-(s^2)_s)*y^2/2
+       fma.s1 F_X = F_X, F_05, f0;;
+}
+
+.pred.rel "mutex", p6, p11
+{.mmf
+       // load pi (low, high), if s<0
+ (p6)  ldfpd F_PI2_LO, F_PI2_HI = [r2]
+       // C7, C9
+       ldfpd F_C7, F_C9 = [r3], 16
+	   // if s>0, set F_PI2_LO=0
+ (p11) fma.s1 F_PI2_HI = f0, f0, f0;;
+}
+
+{.mfi
+       nop.m 0
+ (p11) fma.s1 F_PI2_LO = f0, f0, f0
+       nop.i 0;;
+}
+
+{.mfi
+       // adjust address for C_11
+	   add r3 = 16, r3
+       // c9*x+c8
+       fma.s1 F_S89 = F_X, F_CS9, F_CS8
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x^2
+       fma.s1 F_X2 = F_X, F_X, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)*x
+       fma.s1 F_Y1S2X = F_Y1S2, F_X, f0
+       nop.i 0
+}
+
+{.mfi
+       // C11, C13
+       ldfpd F_C11, F_C13 = [r3], 16
+       // c7*x+c6
+       fma.s1 F_S67 = F_X, F_CS7, F_CS6
+       nop.i 0;;
+}
+
+
+{.mfi
+       // C15, C17
+       ldfpd F_C15, F_C17 = [r3], 16
+       // c3*x+c2
+       fma.s1 F_S23 = F_X, F_CS3, F_CS2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c5*x+c4
+       fma.s1 F_S45 = F_X, F_CS5, F_CS4
+       nop.i 0;;
+}
+
+
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)*x^2
+       fma.s1 F_Y1S2X2 = F_Y1S2, F_X2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x^4
+       fma.s1 F_X4 = F_X2, F_X2, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c9*x^3+..+c6
+       fma.s1 F_S69 = F_X2, F_S89, F_S67
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c5*x^3+..+c2
+       fma.s1 F_S25 = F_X2, F_S45, F_S23
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // (pi)_high-y*(1-s^2)_s
+       fnma.s1 F_HI = F_Y, F_1S2_S, F_PI2_HI
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c9*x^7+..+c2
+       fma.s1 F_S29 = F_X4, F_S69, F_S25
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // -(y*(1-s^2)_s)_high
+       fms.s1 F_1S2_HI = F_HI, f1, F_PI2_HI
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (PS29*x^2+x)*y*(1-s^2)
+       fma.s1 F_S19 = F_Y1S2X2, F_S29, F_Y1S2X
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)_s-(y*(1-s^2))_high
+       fma.s1 F_DS2 = F_Y, F_1S2_S, F_1S2_HI
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // R ~ sqrt(1-s^2)
+       // (used for polynomial evaluation)
+       fnma.s1 F_R = F_S19, f1, F_Y1S2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)-(y*(1-s^2))_high
+       fma.s1 F_DS2 = F_Y, F_DS, F_DS2
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // (pi)_low+(PS29*x^2)*y*(1-s^2)
+       fma.s1 F_S29 = F_Y1S2X2, F_S29, F_PI2_LO
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // R^2
+       fma.s1 F_R2 = F_R, F_R, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+	   // if s<0
+       // (pi)_low+(PS29*x^2)*y*(1-s^2)-(y*(1-s^2)-(y*(1-s^2))_high)
+       fms.s1 F_S29 = F_S29, f1, F_DS2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c7+c9*R^2
+       fma.s1 F_P79 = F_C9, F_R2, F_C7
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2
+       fma.s1 F_P35 = F_C5, F_R2, F_C3
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // R^4
+       fma.s1 F_R4 = F_R2, F_R2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // R^3
+       fma.s1 F_R3 = F_R2, F_R, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c11+c13*R^2
+       fma.s1 F_P1113 = F_C13, F_R2, F_C11
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c15+c17*R^2
+       fma.s1 F_P1517 = F_C17, F_R2, F_C15
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (pi)_low+(PS29*x^2)*y*(1-s^2)-(y*(1-s^2)-(y*(1-s^2))_high)+y*(1-s^2)*x
+       fma.s1 F_S29 = F_Y1S2, F_X, F_S29
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c11+c13*R^2+c15*R^4+c17*R^6
+       fma.s1 F_P1117 = F_P1517, F_R4, F_P1113
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2+c7*R^4+c9*R^6
+       fma.s1 F_P39 = F_P79, F_R4, F_P35
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // R^8
+       fma.s1 F_R8 = F_R4, F_R4, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2+c7*R^4+c9*R^6+..+c17*R^14
+       fma.s1 F_P317 = F_P1117, F_R8, F_P39
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (pi)_low-(PS29*x^2)*y*(1-s^2)-(y*(1-s^2)-
+       // -(y*(1-s^2))_high)+y*(1-s^2)*x - P3, 17
+       fnma.s1 F_S29 = F_P317, F_R3, F_S29
+       nop.i 0;;
+}
+
+.pred.rel "mutex", p6, p11
+{.mfi
+       nop.m 0
+       // Result (if s<0):
+       // (pi)_low-(PS29*x^2)*y*(1-s^2)-(y*(1-s^2)-
+       // -(y*(1-s^2))_high)+y*(1-s^2)*x - P3, 17
+       // +(pi)_high-(y*(1-s^2))_high
+ (p6)  fma.s0 f8 = F_S29, f1, F_HI
+       nop.i 0
+}
+
+{.mfb
+       nop.m 0
+	   // Result (if s>0):
+       // (PS29*x^2)*y*(1-s^2)-
+       // -y*(1-s^2)*x + P3, 17
+       // +(y*(1-s^2))
+ (p11) fms.s0 f8 = F_Y, F_1S2_S, F_S29
+       br.ret.sptk b0;;
+}
+
+
+
+
+
+
+acosl_SPECIAL_CASES:
+
+{.mfi
+       alloc r32 = ar.pfs, 1, 4, 4, 0
+       // check if the input is a NaN, or unsupported format
+       // (i.e. not infinity or normal/denormal)
+       fclass.nm p7, p8 = f8, 0x3f
+       // pointer to pi/2
+       add r3 = 96, r3;;
+}
+
+
+{.mfi
+       // load pi/2
+       ldfpd F_PI2_HI, F_PI2_LO = [r3]
+       // get |s|
+       fmerge.s F_S = f0, f8
+       nop.i 0
+}
+
+{.mfb
+       nop.m 0
+       // if NaN, quietize it, and return
+ (p7) fma.s0 f8 = f8, f1, f0
+ (p7) br.ret.spnt b0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // |s| = 1 ?
+       fcmp.eq.s0 p9, p10 = F_S, f1
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // load FR_X
+       fma.s1 FR_X = f8, f1, f0
+       // load error tag
+       mov GR_Parameter_TAG = 57;;
+}
+
+
+{.mfi
+       nop.m 0
+       // if s = 1, result is 0
+ (p9)  fma.s0 f8 = f0, f0, f0
+       // set p6=0 for |s|>1
+ (p10) cmp.ne p6, p0 = r0, r0;;
+}
+
+
+{.mfb
+       nop.m 0
+       //  if s = -1, result is pi
+ (p6) fma.s0 f8 = F_PI2_HI, f1, F_PI2_LO
+       // return if |s| = 1
+ (p9) br.ret.sptk b0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // get Infinity
+       frcpa.s1 FR_RESULT, p0 = f1, f0
+       nop.i 0;;
+}
+
+
+{.mfb
+       nop.m 0
+       // return QNaN indefinite (0*Infinity)
+       fma.s0 FR_RESULT = f0, FR_RESULT, f0
+       nop.b 0;;
+}
+
+
+GLOBAL_LIBM_END(acosl)
+libm_alias_ldouble_other (acos, acos)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+// (1)
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                          // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                      // Save gp
+};;
+
+
+// (2)
+{ .mmi
+        stfe [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
+        add GR_Parameter_X = 16,sp            // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                     // Save b0
+};;
+
+.body
+// (3)
+{ .mib
+        stfe [GR_Parameter_X] = FR_X              // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfe [GR_Parameter_Y] = FR_RESULT             // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+
+// (4)
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_asin.S
@@ -0,0 +1,854 @@
+.file "asin.s"
+
+
+// Copyright (c) 2000 - 2003 Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 08/17/00 New and much faster algorithm.
+// 08/31/00 Avoided bank conflicts on loads, shortened |x|=1 path,
+//          fixed mfb split issue stalls.
+// 12/19/00 Fixed small arg cases to force inexact, or inexact and underflow.
+// 08/02/02 New and much faster algorithm II
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+
+// Description
+//=========================================
+// The asin function computes the principal value of the arc sine of x.
+// asin(0) returns 0, asin(1) returns pi/2, asin(-1) returns -pi/2.
+// A domain error occurs for arguments not in the range [-1,+1].
+//
+// The asin function returns the arc sine in the range [-pi/2, +pi/2] radians.
+//
+// There are 8 paths:
+// 1. x = +/-0.0
+//    Return asin(x) = +/-0.0
+//
+// 2. 0.0 < |x| < 0.625
+//    Return asin(x) = x + x^3 *PolA(x^2)
+//    where PolA(x^2) = A3 + A5*x^2 + A7*x^4 +...+ A35*x^32
+//
+// 3. 0.625 <=|x| < 1.0
+//    Return asin(x) = sign(x) * ( Pi/2 - sqrt(R) * PolB(R))
+//    Where R = 1 - |x|,
+//          PolB(R) = B0 + B1*R + B2*R^2 +...+B12*R^12
+//
+//    sqrt(R) is approximated using the following sequence:
+//        y0 = (1 + eps)/sqrt(R) - initial approximation by frsqrta,
+//             |eps| < 2^(-8)
+//        Then 3 iterations are used to refine the result:
+//        H0 = 0.5*y0
+//        S0 = R*y0
+//
+//        d0 = 0.5 - H0*S0
+//        H1 = H0 + d0*H0
+//        S1 = S0 + d0*S0
+//
+//        d1 = 0.5 - H1*S1
+//        H2 = H1 + d0*H1
+//        S2 = S1 + d0*S1
+//
+//        d2 = 0.5 - H2*S2
+//        S3 = S3 + d2*S3
+//
+//        S3 approximates sqrt(R) with enough accuracy for this algorithm
+//
+//    So, the result should be reconstracted as follows:
+//    asin(x) = sign(x) * (Pi/2 - S3*PolB(R))
+//
+//    But for optimization perposes the reconstruction step is slightly
+//    changed:
+//    asin(x) = sign(x)*(Pi/2 - PolB(R)*S2) + sign(x)*d2*S2*PolB(R)
+//
+// 4. |x| = 1.0
+//    Return asin(x) = sign(x)*Pi/2
+//
+// 5. 1.0 < |x| <= +INF
+//    A domain error occurs for arguments not in the range [-1,+1]
+//
+// 6. x = [S,Q]NaN
+//    Return asin(x) = QNaN
+//
+// 7. x is denormal
+//    Return asin(x) = x + x^3,
+//
+// 8. x is unnormal
+//    Normalize input in f8 and return to the very beginning of the function
+//
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input, output
+// f6, f7, f9 -> f15, f32 -> f63
+
+// General registers used:
+// r3, r21 -> r31, r32 -> r38
+
+// Predicate registers used:
+// p0, p6 -> p14
+
+//
+// Assembly macros
+//=========================================
+// integer registers used
+// scratch
+rTblAddr                      = r3
+
+rPiBy2Ptr                     = r21
+rTmpPtr3                      = r22
+rDenoBound                    = r23
+rOne                          = r24
+rAbsXBits                     = r25
+rHalf                         = r26
+r0625                         = r27
+rSign                         = r28
+rXBits                        = r29
+rTmpPtr2                      = r30
+rTmpPtr1                      = r31
+
+// stacked
+GR_SAVE_PFS                   = r32
+GR_SAVE_B0                    = r33
+GR_SAVE_GP                    = r34
+GR_Parameter_X                = r35
+GR_Parameter_Y                = r36
+GR_Parameter_RESULT           = r37
+GR_Parameter_TAG              = r38
+
+// floating point registers used
+FR_X                          = f10
+FR_Y                          = f1
+FR_RESULT                     = f8
+
+
+// scratch
+fXSqr                         = f6
+fXCube                        = f7
+fXQuadr                       = f9
+f1pX                          = f10
+f1mX                          = f11
+f1pXRcp                       = f12
+f1mXRcp                       = f13
+fH                            = f14
+fS                            = f15
+// stacked
+fA3                           = f32
+fB1                           = f32
+fA5                           = f33
+fB2                           = f33
+fA7                           = f34
+fPiBy2                        = f34
+fA9                           = f35
+fA11                          = f36
+fB10                          = f35
+fB11                          = f36
+fA13                          = f37
+fA15                          = f38
+fB4                           = f37
+fB5                           = f38
+fA17                          = f39
+fA19                          = f40
+fB6                           = f39
+fB7                           = f40
+fA21                          = f41
+fA23                          = f42
+fB3                           = f41
+fB8                           = f42
+fA25                          = f43
+fA27                          = f44
+fB9                           = f43
+fB12                          = f44
+fA29                          = f45
+fA31                          = f46
+fA33                          = f47
+fA35                          = f48
+fBaseP                        = f49
+fB0                           = f50
+fSignedS                      = f51
+fD                            = f52
+fHalf                         = f53
+fR                            = f54
+fCloseTo1Pol                  = f55
+fSignX                        = f56
+fDenoBound                    = f57
+fNormX                        = f58
+fX8                           = f59
+fRSqr                         = f60
+fRQuadr                       = f61
+fR8                           = f62
+fX16                          = f63
+// Data tables
+//==============================================================
+RODATA
+.align 16
+LOCAL_OBJECT_START(asin_base_range_table)
+// Ai: Polynomial coefficients for the asin(x), |x| < .625000
+// Bi: Polynomial coefficients for the asin(x), |x| > .625000
+data8 0xBFDAAB56C01AE468 //A29
+data8 0x3FE1C470B76A5B2B //A31
+data8 0xBFDC5FF82A0C4205 //A33
+data8 0x3FC71FD88BFE93F0 //A35
+data8 0xB504F333F9DE6487, 0x00003FFF //B0
+data8 0xAAAAAAAAAAAAFC18, 0x00003FFC //A3
+data8 0x3F9F1C71BC4A7823 //A9
+data8 0x3F96E8BBAAB216B2 //A11
+data8 0x3F91C4CA1F9F8A98 //A13
+data8 0x3F8C9DDCEDEBE7A6 //A15
+data8 0x3F877784442B1516 //A17
+data8 0x3F859C0491802BA2 //A19
+data8 0x9999999998C88B8F, 0x00003FFB //A5
+data8 0x3F6BD7A9A660BF5E //A21
+data8 0x3F9FC1659340419D //A23
+data8 0xB6DB6DB798149BDF, 0x00003FFA //A7
+data8 0xBFB3EF18964D3ED3 //A25
+data8 0x3FCD285315542CF2 //A27
+data8 0xF15BEEEFF7D2966A, 0x00003FFB //B1
+data8 0x3EF0DDA376D10FB3 //B10
+data8 0xBEB83CAFE05EBAC9 //B11
+data8 0x3F65FFB67B513644 //B4
+data8 0x3F5032FBB86A4501 //B5
+data8 0x3F392162276C7CBA //B6
+data8 0x3F2435949FD98BDF //B7
+data8 0xD93923D7FA08341C, 0x00003FF9 //B2
+data8 0x3F802995B6D90BDB //B3
+data8 0x3F10DF86B341A63F //B8
+data8 0xC90FDAA22168C235, 0x00003FFF // Pi/2
+data8 0x3EFA3EBD6B0ECB9D //B9
+data8 0x3EDE18BA080E9098 //B12
+LOCAL_OBJECT_END(asin_base_range_table)
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(asin)
+asin_unnormal_back:
+{ .mfi
+      getf.d             rXBits = f8 // grab bits of input value
+      // set p12 = 1 if x is a NaN, denormal, or zero
+      fclass.m           p12, p0 = f8, 0xcf
+      adds               rSign = 1, r0
+}
+{ .mfi
+      addl               rTblAddr = @ltoff(asin_base_range_table),gp
+      // 1 - x = 1 - |x| for positive x
+      fms.s1             f1mX = f1, f1, f8
+      addl               rHalf = 0xFFFE, r0 // exponent of 1/2
+}
+;;
+{ .mfi
+      addl               r0625 = 0x3FE4, r0 // high 16 bits of 0.625
+      // set p8 = 1 if x < 0
+      fcmp.lt.s1         p8, p9 = f8, f0
+      shl                rSign = rSign, 63 // sign bit
+}
+{ .mfi
+      // point to the beginning of the table
+      ld8                rTblAddr = [rTblAddr]
+      // 1 + x = 1 - |x| for negative x
+      fma.s1             f1pX = f1, f1, f8
+      adds               rOne = 0x3FF, r0
+}
+;;
+{ .mfi
+      andcm              rAbsXBits = rXBits, rSign // bits of |x|
+      fmerge.s           fSignX = f8, f1 // signum(x)
+      shl                r0625 = r0625, 48 // bits of DP representation of 0.625
+}
+{ .mfb
+      setf.exp           fHalf = rHalf // load A2 to FP reg
+      fma.s1             fXSqr = f8, f8, f0 // x^2
+      // branch on special path if x is a NaN, denormal, or zero
+(p12) br.cond.spnt       asin_special
+}
+;;
+{ .mfi
+      adds               rPiBy2Ptr = 272, rTblAddr
+      nop.f              0
+      shl                rOne = rOne, 52 // bits of 1.0
+}
+{ .mfi
+      adds               rTmpPtr1 = 16, rTblAddr
+      nop.f              0
+      // set p6 = 1 if |x| < 0.625
+      cmp.lt             p6, p7 = rAbsXBits, r0625
+}
+;;
+{ .mfi
+      ldfpd              fA29, fA31 = [rTblAddr] // A29, fA31
+      // 1 - x = 1 - |x| for positive x
+(p9)  fms.s1             fR = f1, f1, f8
+      // point to coefficient of "near 1" polynomial
+(p7)  adds               rTmpPtr2 = 176, rTblAddr
+}
+{ .mfi
+      ldfpd              fA33, fA35 = [rTmpPtr1], 16 // A33, fA35
+      // 1 + x = 1 - |x| for negative x
+(p8)  fma.s1             fR = f1, f1, f8
+(p6)  adds               rTmpPtr2 = 48, rTblAddr
+}
+;;
+{ .mfi
+      ldfe               fB0 = [rTmpPtr1], 16 // B0
+      nop.f              0
+      nop.i              0
+}
+{ .mib
+      adds               rTmpPtr3 = 16, rTmpPtr2
+      // set p10 = 1 if |x| = 1.0
+      cmp.eq             p10, p0 = rAbsXBits, rOne
+      // branch on special path for |x| = 1.0
+(p10) br.cond.spnt       asin_abs_1
+}
+;;
+{ .mfi
+      ldfe               fA3 = [rTmpPtr2], 48 // A3 or B1
+      nop.f              0
+      adds               rTmpPtr1 = 64, rTmpPtr3
+}
+{ .mib
+      ldfpd              fA9, fA11 = [rTmpPtr3], 16 // A9, A11 or B10, B11
+      // set p11 = 1 if |x| > 1.0
+      cmp.gt             p11, p0 = rAbsXBits, rOne
+      // branch on special path for |x| > 1.0
+(p11) br.cond.spnt       asin_abs_gt_1
+}
+;;
+{ .mfi
+      ldfpd              fA17, fA19 = [rTmpPtr2], 16 // A17, A19 or B6, B7
+      // initial approximation of 1 / sqrt(1 - x)
+      frsqrta.s1         f1mXRcp, p0 = f1mX
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA13, fA15 = [rTmpPtr3] // A13, A15 or B4, B5
+      fma.s1             fXCube = fXSqr, f8, f0 // x^3
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fA5 = [rTmpPtr2], 48 // A5 or B2
+      // initial approximation of 1 / sqrt(1 + x)
+      frsqrta.s1         f1pXRcp, p0 = f1pX
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA21, fA23 = [rTmpPtr1], 16 // A21, A23 or B3, B8
+      fma.s1             fXQuadr = fXSqr, fXSqr, f0 // x^4
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fA7 = [rTmpPtr1] // A7 or Pi/2
+      fma.s1             fRSqr = fR, fR, f0 // R^2
+      nop.i              0
+}
+{ .mfb
+      ldfpd              fA25, fA27 = [rTmpPtr2] // A25, A27 or B9, B12
+      nop.f              0
+(p6)  br.cond.spnt       asin_base_range;
+}
+;;
+
+{ .mfi
+      nop.m              0
+(p9)  fma.s1             fH = fHalf, f1mXRcp, f0 // H0 for x > 0
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+(p9)  fma.s1             fS = f1mX, f1mXRcp, f0  // S0 for x > 0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+(p8)  fma.s1             fH = fHalf, f1pXRcp, f0 // H0 for x < 0
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+(p8)  fma.s1             fS = f1pX, f1pXRcp, f0  // S0 for x > 0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRQuadr = fRSqr, fRSqr, f0 // R^4
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB11 = fB11, fR, fB10
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB1 = fB1, fR, fB0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB5 = fB5, fR, fB4
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB7 = fB7, fR, fB6
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB3 = fB3, fR, fB2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fnma.s1            fD = fH, fS, fHalf // d0 = 1/2 - H0*S0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fR8 = fRQuadr, fRQuadr, f0 // R^4
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB9 = fB9, fR, fB8
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fB12 = fB12, fRSqr, fB11
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fma.s1             fB7 = fB7, fRSqr, fB5
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fB3 = fB3, fRSqr, fB1
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fH = fH, fD, fH // H1 = H0 + H0*d0
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fS = fS, fD, fS // S1 = S0 + S0*d0
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fPiBy2 = fPiBy2, fSignX, f0 // signum(x)*Pi/2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB12 = fB12, fRSqr, fB9
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB7 = fB7, fRQuadr, fB3
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fnma.s1            fD = fH, fS, fHalf // d1 = 1/2 - H1*S1
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fnma.s1            fSignedS = fSignX, fS, f0 // -signum(x)*S1
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fCloseTo1Pol = fB12, fR8, fB7
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fH = fH, fD, fH // H2 = H1 + H1*d1
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fS = fS, fD, fS // S2 = S1 + S1*d1
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // -signum(x)* S2 = -signum(x)*(S1 + S1*d1)
+      fma.s1             fSignedS = fSignedS, fD, fSignedS
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fnma.s1            fD = fH, fS, fHalf // d2 = 1/2 - H2*S2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // signum(x)*(Pi/2 - PolB*S2)
+      fma.s1             fPiBy2 = fSignedS, fCloseTo1Pol, fPiBy2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // -signum(x)*PolB * S2
+      fma.s1             fCloseTo1Pol = fSignedS, fCloseTo1Pol, f0
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      // final result for 0.625 <= |x| < 1
+      fma.d.s0           f8 = fCloseTo1Pol, fD, fPiBy2
+      // exit here for  0.625 <= |x| < 1
+      br.ret.sptk        b0
+}
+;;
+
+
+// here if |x| < 0.625
+.align 32
+asin_base_range:
+{ .mfi
+      nop.m              0
+      fma.s1             fA33 = fA33, fXSqr, fA31
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA15 = fA15, fXSqr, fA13
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA29 = fA29, fXSqr, fA27
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA25 = fA25, fXSqr, fA23
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA21 = fA21, fXSqr, fA19
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA9 = fA9, fXSqr, fA7
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA5 = fA5, fXSqr, fA3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA35 = fA35, fXQuadr, fA33
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA17 = fA17, fXQuadr, fA15
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fX8 = fXQuadr, fXQuadr, f0 // x^8
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA25 = fA25, fXQuadr, fA21
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA9 = fA9, fXQuadr, fA5
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA35 = fA35, fXQuadr, fA29
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA17 = fA17, fXSqr, fA11
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fX16 = fX8, fX8, f0 // x^16
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA35 = fA35, fX8, fA25
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA17 = fA17, fX8, fA9
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fBaseP = fA35, fX16, fA17
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      // final result for |x| < 0.625
+      fma.d.s0           f8 = fBaseP, fXCube, f8
+      // exit here for |x| < 0.625 path
+      br.ret.sptk        b0
+}
+;;
+
+// here if |x| = 1
+// asin(x) = sign(x) * Pi/2
+.align 32
+asin_abs_1:
+{ .mfi
+      ldfe               fPiBy2 = [rPiBy2Ptr] // Pi/2
+      nop.f              0
+      nop.i              0
+}
+;;
+{.mfb
+      nop.m              0
+      // result for |x| = 1.0
+      fma.d.s0           f8 = fPiBy2, fSignX, f0
+      // exit here for |x| = 1.0
+      br.ret.sptk        b0
+}
+;;
+
+// here if x is a NaN, denormal, or zero
+.align 32
+asin_special:
+{ .mfi
+      nop.m              0
+      // set p12 = 1 if x is a NaN
+      fclass.m           p12, p0 = f8, 0xc3
+      nop.i              0
+}
+{ .mlx
+      nop.m              0
+      // smallest positive DP normalized number
+      movl               rDenoBound = 0x0010000000000000
+}
+;;
+{ .mfi
+      nop.m              0
+      // set p13 = 1 if x = 0.0
+      fclass.m           p13, p0 = f8, 0x07
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fnorm.s1           fNormX = f8
+      nop.i              0
+}
+;;
+{ .mfb
+      // load smallest normal to FP reg
+      setf.d             fDenoBound = rDenoBound
+      // answer if x is a NaN
+(p12) fma.d.s0           f8 = f8,f1,f0
+      // exit here if x is a NaN
+(p12) br.ret.spnt        b0
+}
+;;
+{ .mfb
+      nop.m              0
+      nop.f              0
+      // exit here if x = 0.0
+(p13) br.ret.spnt        b0
+}
+;;
+// if we still here then x is denormal or unnormal
+{ .mfi
+      nop.m              0
+      // absolute value of normalized x
+      fmerge.s           fNormX = f1, fNormX
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // set p14 = 1 if normalized x is greater than or
+      // equal to the smallest denormalized value
+      // So, if p14 is set to 1 it means that we deal with
+      // unnormal rather than with "true" denormal
+      fcmp.ge.s1         p14, p0 = fNormX, fDenoBound
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+(p14) fcmp.eq.s0         p6, p0 = f8, f0      // Set D flag if x unnormal
+      nop.i              0
+}
+{ .mfb
+      nop.m              0
+      // normalize unnormal input
+(p14) fnorm.s1           f8 = f8
+      // return to the main path
+(p14) br.cond.sptk       asin_unnormal_back
+}
+;;
+// if we still here it means that input is "true" denormal
+{ .mfb
+      nop.m              0
+      // final result if x is denormal
+      fma.d.s0           f8 = f8, fXSqr, f8
+      // exit here if x is denormal
+      br.ret.sptk        b0
+}
+;;
+
+// here if |x| > 1.0
+// error handler should be called
+.align 32
+asin_abs_gt_1:
+{ .mfi
+      alloc              r32 = ar.pfs, 0, 3, 4, 0 // get some registers
+      fmerge.s           FR_X = f8,f8
+      nop.i              0
+}
+{ .mfb
+      mov                GR_Parameter_TAG = 61 // error code
+      frcpa.s0           FR_RESULT, p0 = f0,f0
+      // call error handler routine
+      br.cond.sptk       __libm_error_region
+}
+;;
+GLOBAL_LIBM_END(asin)
+libm_alias_double_other (asin, asin)
+
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfd [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfd [GR_Parameter_X] = FR_X                  // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = FR_RESULT             // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#         // Call error handling function
+};;
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_asinf.S
@@ -0,0 +1,675 @@
+.file "asinf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 06/28/00 Improved speed
+// 06/31/00 Changed register allocation because of some duplicate macros
+//          moved nan exit bundle up to gain a cycle.
+// 08/08/00 Improved speed by avoiding SIR flush.
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 08/17/00 Changed predicate register macro-usage to direct predicate
+//          names due to an assembler bug.
+// 10/17/00 Improved speed of x=0 and x=1 paths, set D flag if x denormal.
+// 03/13/01 Corrected sign of imm1 value in dep instruction.
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+
+
+// Description
+//=========================================
+// The asinf function computes the arc sine of x in the range [-pi,+pi].
+// A domain error occurs for arguments not in the range [-1,+1].
+// asinf(+-0) returns +-0
+// asinf(x) returns a Nan and raises the invalid exception for |x| >1
+
+// The acosf function returns the arc cosine in the range [0, +pi] radians.
+// A domain error occurs for arguments not in the range [-1,+1].
+// acosf(1) returns +0
+// acosf(x) returns a Nan and raises the invalid exception for |x| >1
+
+
+// |x| <= sqrt(2)/2. get Ax and Bx
+
+// poly_p1 = x p1
+// poly_p3 = x2 p4 + p3
+// poly_p1 = x2 (poly_p1) + x  = x2(x p1) + x
+// poly_p2 = x2( poly_p3) + p2 = x2(x2 p4 + p3) + p2
+
+// poly_Ax = x5(x2( poly_p3) + p2) + x2(x p1) + x
+//         = x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x
+
+// poly_p7 = x2 p8 + p7
+// poly_p5 = x2 p6 + p5
+
+// poly_p7 = x4 p9 + (poly_p7)
+// poly_p7 = x4 p9 + (x2 p8 + p7)
+// poly_Bx = x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5
+
+// answer1 = x11(x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5) + x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x
+//         = x19 p9 + x17 p8 + x15 p7 x13 p6 + x11 p5 + x9 p4 + x7 p3 + x5 p2 + x3 p1 + x
+
+
+
+// |x| >  sqrt(2)/2
+
+// Get z = sqrt(1-x2)
+
+// Get polynomial in t = 1-x2
+
+// t2      = t t
+// t4      = t2 t2
+
+// poly_p4 = t p5 + p4
+// poly_p1 = t p1 + 1
+
+// poly_p6 = t p7 + p6
+// poly_p2 = t p3 + p2
+
+// poly_p8 = t p9 + p8
+
+// poly_p4 = t2 poly_p6 + poly_p4
+//         = t2 (t p7 + p6) + (t p5 + p4)
+
+// poly_p2 = t2 poly_p2 + poly_p1
+//         = t2 (t p3 + p2) + (t p1 + 1)
+
+// poly_p4 = t4 poly_p8 + poly_p4
+//         = t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4))
+
+// P(t)    = poly_p2 + t4 poly_p8
+//         = t2 (t p3 + p2) + (t p1 + 1) + t4 (t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4)))
+//         = t3 p3 + t2 p2 + t p1 + 1 + t9 p9 + t8 p8 + t7 p7 + t6 p6 + t5 p5 + t4 p4
+
+
+//  answer2 = - sign(x) z P(t) + (sign(x) pi/2)
+//
+
+
+// Assembly macros
+//=========================================
+
+// predicate registers
+//asinf_pred_LEsqrt2by2            = p7
+//asinf_pred_GTsqrt2by2            = p8
+
+// integer registers
+ASINF_Addr1                      = r33
+ASINF_Addr2                      = r34
+ASINF_GR_1by2                    = r35
+
+ASINF_GR_3by2                    = r36
+ASINF_GR_5by2                    = r37
+
+GR_SAVE_B0                    = r38
+GR_SAVE_PFS                   = r39
+GR_SAVE_GP                    = r40
+
+GR_Parameter_X                = r41
+GR_Parameter_Y                = r42
+GR_Parameter_RESULT           = r43
+GR_Parameter_TAG              = r44
+
+// floating point registers
+
+asinf_y                          = f32
+asinf_abs_x                      = f33
+asinf_x2                         = f34
+asinf_sgn_x                      = f35
+
+asinf_1by2                       = f36
+asinf_3by2                       = f37
+asinf_5by2                       = f38
+asinf_coeff_P3                   = f39
+asinf_coeff_P8                   = f40
+
+asinf_coeff_P1                   = f41
+asinf_coeff_P4                   = f42
+asinf_coeff_P5                   = f43
+asinf_coeff_P2                   = f44
+asinf_coeff_P7                   = f45
+
+asinf_coeff_P6                   = f46
+asinf_coeff_P9                   = f47
+asinf_x2                         = f48
+asinf_x3                         = f49
+asinf_x4                         = f50
+
+asinf_x8                         = f51
+asinf_x5                         = f52
+asinf_const_piby2                = f53
+asinf_const_sqrt2by2             = f54
+asinf_x11                        = f55
+
+asinf_poly_p1                    = f56
+asinf_poly_p3                    = f57
+asinf_sinf1                      = f58
+asinf_poly_p2                    = f59
+asinf_poly_Ax                    = f60
+
+asinf_poly_p7                    = f61
+asinf_poly_p5                    = f62
+asinf_sgnx_t4                    = f63
+asinf_poly_Bx                    = f64
+asinf_t                          = f65
+
+asinf_yby2                       = f66
+asinf_B                          = f67
+asinf_B2                         = f68
+asinf_Az                         = f69
+asinf_dz                         = f70
+
+asinf_Sz                         = f71
+asinf_d2z                        = f72
+asinf_Fz                         = f73
+asinf_z                          = f74
+asinf_sgnx_z                     = f75
+
+asinf_t2                         = f76
+asinf_2poly_p4                   = f77
+asinf_2poly_p6                   = f78
+asinf_2poly_p1                   = f79
+asinf_2poly_p2                   = f80
+
+asinf_2poly_p8                   = f81
+asinf_t4                         = f82
+asinf_Pt                         = f83
+asinf_sgnx_2poly_p2              = f84
+asinf_sgn_x_piby2                = f85
+
+asinf_poly_p7a                   = f86
+asinf_2poly_p4a                  = f87
+asinf_2poly_p4b                  = f88
+asinf_2poly_p2a                  = f89
+asinf_poly_p1a                   = f90
+
+
+
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(asinf_coeff_1_table)
+data8 0x3FC5555607DCF816 // P1
+data8 0x3F9CF81AD9BAB2C6 // P4
+data8 0x3FC59E0975074DF3 // P7
+data8 0xBFA6F4CC2780AA1D // P6
+data8 0x3FC2DD45292E93CB // P9
+data8 0x3fe6a09e667f3bcd // sqrt(2)/2
+LOCAL_OBJECT_END(asinf_coeff_1_table)
+
+LOCAL_OBJECT_START(asinf_coeff_2_table)
+data8 0x3FA6F108E31EFBA6 // P3
+data8 0xBFCA31BF175D82A0 // P8
+data8 0x3FA30C0337F6418B // P5
+data8 0x3FB332C9266CB1F9 // P2
+data8 0x3ff921fb54442d18 // pi_by_2
+LOCAL_OBJECT_END(asinf_coeff_2_table)
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(asinf)
+
+// Load the addresses of the two tables.
+// Then, load the coefficients and other constants.
+
+{     .mfi
+     alloc      r32            = ar.pfs,1,8,4,0
+     fnma.s1   asinf_t        =    f8,f8,f1
+     dep.z ASINF_GR_1by2 =    0x3f,24,8    // 0x3f000000
+}
+{     .mfi
+     addl ASINF_Addr1    =    @ltoff(asinf_coeff_1_table),gp
+     fma.s1    asinf_x2       =    f8,f8,f0
+     addl      ASINF_Addr2    =    @ltoff(asinf_coeff_2_table),gp ;;
+}
+
+
+{     .mfi
+     ld8       ASINF_Addr1    =    [ASINF_Addr1]
+     fmerge.s  asinf_abs_x    =    f1,f8
+     dep ASINF_GR_3by2 =    -1,r0,22,8     // 0x3fc00000
+}
+{     .mlx
+     nop.m                      999
+     movl      ASINF_GR_5by2  =    0x40200000;;
+}
+
+
+
+{     .mfi
+     setf.s    asinf_1by2     =    ASINF_GR_1by2
+     fmerge.s  asinf_sgn_x    =    f8,f1
+     nop.i                      999
+}
+{     .mfi
+     ld8       ASINF_Addr2    =    [ASINF_Addr2]
+     nop.f 0
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     setf.s    asinf_5by2     =    ASINF_GR_5by2
+     fcmp.lt.s1 p11,p12 = f8,f0
+     nop.i                      999;;
+}
+
+{ .mmf
+     ldfpd     asinf_coeff_P1,asinf_coeff_P4 =    [ASINF_Addr1],16
+     setf.s    asinf_3by2     =    ASINF_GR_3by2
+     fclass.m.unc p8,p0      = f8, 0xc3 ;;	//@qnan | @snan
+}
+
+
+{     .mfi
+     ldfpd     asinf_coeff_P7,asinf_coeff_P6 =    [ASINF_Addr1],16
+     fma.s1    asinf_t2                      =    asinf_t,asinf_t,f0
+     nop.i                                     999
+}
+{     .mfi
+     ldfpd     asinf_coeff_P3,asinf_coeff_P8 =    [ASINF_Addr2],16
+     fma.s1    asinf_x4                      =    asinf_x2,asinf_x2,f0
+     nop.i                                     999;;
+}
+
+
+{     .mfi
+     ldfpd     asinf_coeff_P9,asinf_const_sqrt2by2     =    [ASINF_Addr1]
+     fclass.m.unc p10,p0      = f8, 0x07	//@zero
+     nop.i                                     999
+}
+{     .mfi
+     ldfpd     asinf_coeff_P5,asinf_coeff_P2 =    [ASINF_Addr2],16
+     fma.s1    asinf_x3  =    f8,asinf_x2,f0
+     nop.i                                     999;;
+}
+
+
+{     .mfi
+     ldfd      asinf_const_piby2   =    [ASINF_Addr2]
+     frsqrta.s1     asinf_B,p0                   =    asinf_t
+     nop.i                                               999
+}
+{     .mfb
+     nop.m                                               999
+(p8) fma.s.s0 f8                = f8,f1,f0
+(p8) br.ret.spnt   b0 ;;  // Exit if x=nan
+}
+
+
+{     .mfb
+     nop.m                 999
+     fcmp.eq.s1 p6,p0 = asinf_abs_x,f1
+(p10) br.ret.spnt  b0 ;;     // Exit if x=0
+}
+
+{     .mfi
+     nop.m                 999
+     fcmp.gt.s1 p9,p0 = asinf_abs_x,f1
+     nop.i                 999;;
+}
+
+{     .mfi
+     nop.m                 999
+     fma.s1    asinf_x8  =    asinf_x4,asinf_x4,f0
+     nop.i                 999
+}
+{     .mfb
+     nop.m                      999
+     fma.s1    asinf_t4  =    asinf_t2,asinf_t2,f0
+(p6) br.cond.spnt  ASINF_ABS_ONE ;;     // Branch if |x|=1
+}
+
+{     .mfi
+     nop.m                 999
+     fma.s1    asinf_x5  =    asinf_x2,asinf_x3,f0
+     nop.i                 999
+}
+{     .mfb
+(p9) mov            GR_Parameter_TAG = 62
+     fma.s1    asinf_yby2     =    asinf_t,asinf_1by2,f0
+(p9) br.cond.spnt  __libm_error_region ;;    // Branch if |x|>1
+}
+
+
+{     .mfi
+     nop.m                 999
+     fma.s1    asinf_Az  =    asinf_t,asinf_B,f0
+     nop.i                 999
+}
+{     .mfi
+     nop.m                 999
+     fma.s1    asinf_B2  =    asinf_B,asinf_B,f0
+     nop.i                 999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_poly_p1  =    f8,asinf_coeff_P1,f0
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_2poly_p1 =    asinf_coeff_P1,asinf_t,f1
+     nop.i                      999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_poly_p3  =    asinf_coeff_P4,asinf_x2,asinf_coeff_P3
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_2poly_p6 =    asinf_coeff_P7,asinf_t,asinf_coeff_P6
+     nop.i                      999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_poly_p7  =    asinf_x2,asinf_coeff_P8,asinf_coeff_P7
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_2poly_p2 =    asinf_coeff_P3,asinf_t,asinf_coeff_P2
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_poly_p5  =    asinf_x2,asinf_coeff_P6,asinf_coeff_P5
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_2poly_p4 =    asinf_coeff_P5,asinf_t,asinf_coeff_P4
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                 999
+     fma.d.s1    asinf_x11 =    asinf_x8,asinf_x3,f0
+     nop.i                 999
+}
+{     .mfi
+     nop.m                 999
+     fnma.s1   asinf_dz  =    asinf_B2,asinf_yby2,asinf_1by2
+     nop.i                 999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_poly_p1a =    asinf_x2,asinf_poly_p1,f8
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_2poly_p8 =    asinf_coeff_P9,asinf_t,asinf_coeff_P8
+     nop.i                      999;;
+}
+
+
+// Get the absolute value of x and determine the region in which x lies
+
+{     .mfi
+     nop.m                      999
+     fcmp.le.s1     p7,p8 = asinf_abs_x,asinf_const_sqrt2by2
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_poly_p2  =    asinf_x2,asinf_poly_p3,asinf_coeff_P2
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_poly_p7a =    asinf_x4,asinf_coeff_P9,asinf_poly_p7
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    asinf_2poly_p2a =    asinf_2poly_p2,asinf_t2,asinf_2poly_p1
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                                                         999
+(p8) fma.s1    asinf_sgnx_t4  =    asinf_sgn_x,asinf_t4,f0
+     nop.i                                                         999
+}
+{     .mfi
+     nop.m                      999
+(p8) fma.s1    asinf_2poly_p4a =    asinf_2poly_p6,asinf_t2,asinf_2poly_p4
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                 999
+(p8) fma.s1    asinf_Sz  =    asinf_5by2,asinf_dz,asinf_3by2
+     nop.i                 999
+}
+{     .mfi
+     nop.m                 999
+(p8) fma.s1    asinf_d2z =    asinf_dz,asinf_dz,f0
+     nop.i                 999;;
+}
+
+
+{     .mfi
+     nop.m                           999
+(p8) fma.s1   asinf_sgn_x_piby2 =    asinf_sgn_x,asinf_const_piby2,f0
+     nop.i                           999
+}
+{     .mfi
+     nop.m                      999
+(p7) fma.d.s1    asinf_poly_Ax  =    asinf_x5,asinf_poly_p2,asinf_poly_p1a
+     nop.i                 999;;
+}
+
+{     .mfi
+     nop.m                      999
+(p7) fma.d.s1    asinf_poly_Bx  =    asinf_x4,asinf_poly_p7a,asinf_poly_p5
+     nop.i                      999
+}
+{     .mfi
+     nop.m                           999
+(p8) fma.s1    asinf_sgnx_2poly_p2 =    asinf_sgn_x,asinf_2poly_p2a,f0
+     nop.i                           999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fcmp.eq.s0 p6,p0 = f8,f0      // Only purpose is to set D if x denormal
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+(p8) fma.s1    asinf_2poly_p4b =    asinf_2poly_p8,asinf_t4,asinf_2poly_p4a
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+(p8) fma.s1    asinf_Fz  =    asinf_d2z,asinf_Sz,asinf_dz
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                 999
+(p8) fma.d.s1  asinf_Pt  =    asinf_2poly_p4b,asinf_sgnx_t4,asinf_sgnx_2poly_p2
+     nop.i                 999;;
+}
+
+{     .mfi
+     nop.m                 999
+(p8) fma.d.s1  asinf_z   =    asinf_Az,asinf_Fz,asinf_Az
+     nop.i                 999;;
+}
+
+.pred.rel "mutex",p8,p7    //asinf_pred_GTsqrt2by2,asinf_pred_LEsqrt2by2
+{     .mfi
+                         nop.m            999
+(p8)  fnma.s.s0     f8   =    asinf_z,asinf_Pt,asinf_sgn_x_piby2
+                         nop.i            999
+}
+
+{     .mfb
+                         nop.m            999
+(p7)  fma.s.s0    f8    =    asinf_x11,asinf_poly_Bx,asinf_poly_Ax
+                         br.ret.sptk b0 ;;
+}
+
+ASINF_ABS_ONE:
+// Here for short exit if |x|=1
+{     .mfb
+     nop.m                      999
+     fma.s.s0    f8 =    asinf_sgn_x,asinf_const_piby2,f0
+     br.ret.sptk b0
+}
+;;
+
+GLOBAL_LIBM_END(asinf)
+libm_alias_float_other (asin, asin)
+
+// Stack operations when calling error support.
+//       (1)               (2)
+//   sp   -> +          psp -> +
+//           |                 |
+//           |                 | <- GR_Y
+//           |                 |
+//           | <-GR_Y      Y2->|
+//           |                 |
+//           |                 | <- GR_X
+//           |                 |
+//  sp-64 -> +          sp ->  +
+//    save ar.pfs          save b0
+//    save gp
+
+
+// Stack operations when calling error support.
+//     (3) (call)              (4)
+//  psp -> +                   sp -> +
+//         |                         |
+//    R3 ->| <- GR_RESULT            | -> f8
+//         |                         |
+//    Y2 ->| <- GR_Y                 |
+//         |                         |
+//    X1 ->|                         |
+//         |                         |
+//  sp ->  +                         +
+//                              restore gp
+//                              restore ar.pfs
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+                nop.f 999
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfs [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+
+.body
+{ .mfi
+        nop.m 0
+        frcpa.s0 f9,p0 = f0,f0
+        nop.i 0
+};;
+
+{ .mib
+        stfs [GR_Parameter_X] = f8            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfs [GR_Parameter_Y] = f9           // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+
+{ .mmi
+        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_asinl.S
@@ -0,0 +1,2523 @@
+.file "asinl.s"
+
+
+// Copyright (c) 2001 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 08/28/01 New version
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+//
+// API
+//==============================================================
+// long double asinl(long double)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// For |s| in [2^{-4}, sqrt(2)/2]:
+// Let t= 2^k*1.b1 b2..b6 1, where s= 2^k*1.b1 b2.. b52
+// asin(s)= asin(t)+asin(r), where r= s*sqrt(1-t^2)-t*sqrt(1-s^2), i.e.
+// r= (s-t)*sqrt(1-t^2)-t*sqrt(1-t^2)*(sqrt((1-s^2)/(1-t^2))-1)
+// asin(r)-r evaluated as 9-degree polynomial (c3*r^3+c5*r^5+c7*r^7+c9*r^9)
+// The 64-bit significands of sqrt(1-t^2), 1/(1-t^2) are read from the table,
+// along with the high and low parts of asin(t) (stored as two double precision
+// values)
+//
+// |s| in (sqrt(2)/2, sqrt(255/256)):
+// Let t= 2^k*1.b1 b2..b6 1, where (1-s^2)*frsqrta(1-s^2)= 2^k*1.b1 b2..b6..
+// asin(|s|)= pi/2-asin(t)+asin(r), r= s*t-sqrt(1-s^2)*sqrt(1-t^2)
+// To minimize accumulated errors, r is computed as
+// r= (t*s)_s-t^2*y*z+z*y*(t^2-1+s^2)_s+z*y*(1-s^2)_s*x+z'*y*(1-s^2)*PS29+
+// +(t*s-(t*s)_s)+z*y*((t^2-1-(t^2-1+s^2)_s)+s^2)+z*y*(1-s^2-(1-s^2)_s)+
+// +ez*z'*y*(1-s^2)*(1-x),
+// where y= frsqrta(1-s^2), z= (sqrt(1-t^2))_s (rounded to 24 significant bits)
+// z'= sqrt(1-t^2), x= ((1-s^2)*y^2-1)/2
+//
+// |s|<2^{-4}: evaluate as 17-degree polynomial
+// (or simply return s, if|s|<2^{-64})
+//
+// |s| in [sqrt(255/256), 1): asin(|s|)= pi/2-asin(sqrt(1-s^2))
+// use 17-degree polynomial for asin(sqrt(1-s^2)),
+// 9-degree polynomial to evaluate sqrt(1-s^2)
+// High order term is (pi/2)_high-(y*(1-s^2))_high
+//
+
+
+
+// Registers used
+//==============================================================
+// f6-f15, f32-f36
+// r2-r3, r23-r23
+// p6, p7, p8, p12
+//
+
+
+       GR_SAVE_B0= r33
+       GR_SAVE_PFS= r34
+       GR_SAVE_GP= r35 // This reg. can safely be used
+       GR_SAVE_SP= r36
+
+       GR_Parameter_X= r37
+       GR_Parameter_Y= r38
+       GR_Parameter_RESULT= r39
+       GR_Parameter_TAG= r40
+
+       FR_X= f10
+       FR_Y= f1
+       FR_RESULT= f8
+
+
+
+RODATA
+
+.align 16
+
+
+
+LOCAL_OBJECT_START(T_table)
+
+// stores 64-bit significand of 1/(1-t^2), 64-bit significand of sqrt(1-t^2),
+// asin(t)_high (double precision), asin(t)_low (double precision)
+
+data8 0x80828692b71c4391, 0xff7ddcec2d87e879
+data8 0x3fb022bc0ae531a0, 0x3c9f599c7bb42af6
+data8 0x80869f0163d0b082, 0xff79cad2247914d3
+data8 0x3fb062dd26afc320, 0x3ca4eff21bd49c5c
+data8 0x808ac7d5a8690705, 0xff75a89ed6b626b9
+data8 0x3fb0a2ff4a1821e0, 0x3cb7e33b58f164cc
+data8 0x808f0112ad8ad2e0, 0xff7176517c2cc0cb
+data8 0x3fb0e32279319d80, 0x3caee31546582c43
+data8 0x80934abba8a1da0a, 0xff6d33e949b1ed31
+data8 0x3fb12346b8101da0, 0x3cb8bfe463d087cd
+data8 0x8097a4d3dbe63d8f, 0xff68e16571015c63
+data8 0x3fb1636c0ac824e0, 0x3c8870a7c5a3556f
+data8 0x809c0f5e9662b3dd, 0xff647ec520bca0f0
+data8 0x3fb1a392756ed280, 0x3c964f1a927461ae
+data8 0x80a08a5f33fadc66, 0xff600c07846a6830
+data8 0x3fb1e3b9fc19e580, 0x3c69eb3576d56332
+data8 0x80a515d91d71acd4, 0xff5b892bc475affa
+data8 0x3fb223e2a2dfbe80, 0x3c6a4e19fd972fb6
+data8 0x80a9b1cfc86ff7cd, 0xff56f631062cf93d
+data8 0x3fb2640c6dd76260, 0x3c62041160e0849e
+data8 0x80ae5e46b78b0d68, 0xff5253166bc17794
+data8 0x3fb2a43761187c80, 0x3cac61651af678c0
+data8 0x80b31b417a4b756b, 0xff4d9fdb14463dc8
+data8 0x3fb2e46380bb6160, 0x3cb06ef23eeba7a1
+data8 0x80b7e8c3ad33c369, 0xff48dc7e1baf6738
+data8 0x3fb32490d0d910c0, 0x3caa05f480b300d5
+data8 0x80bcc6d0f9c784d6, 0xff4408fe9ad13e37
+data8 0x3fb364bf558b3820, 0x3cb01e7e403aaab9
+data8 0x80c1b56d1692492d, 0xff3f255ba75f5f4e
+data8 0x3fb3a4ef12ec3540, 0x3cb4fe8fcdf5f5f1
+data8 0x80c6b49bc72ec446, 0xff3a319453ebd961
+data8 0x3fb3e5200d171880, 0x3caf2dc089b2b7e2
+data8 0x80cbc460dc4e0ae8, 0xff352da7afe64ac6
+data8 0x3fb425524827a720, 0x3cb75a855e7c6053
+data8 0x80d0e4c033bee9c4, 0xff301994c79afb32
+data8 0x3fb46585c83a5e00, 0x3cb3264981c019ab
+data8 0x80d615bdb87556db, 0xff2af55aa431f291
+data8 0x3fb4a5ba916c73c0, 0x3c994251d94427b5
+data8 0x80db575d6291fd8a, 0xff25c0f84bae0cb9
+data8 0x3fb4e5f0a7dbdb20, 0x3cbee2fcc4c786cb
+data8 0x80e0a9a33769e535, 0xff207c6cc0ec09fd
+data8 0x3fb526280fa74620, 0x3c940656e5549b91
+data8 0x80e60c93498e32cd, 0xff1b27b703a19c98
+data8 0x3fb56660ccee2740, 0x3ca7082374d7b2cd
+data8 0x80eb8031b8d4052d, 0xff15c2d6105c72f8
+data8 0x3fb5a69ae3d0b520, 0x3c7c4d46e09ac68a
+data8 0x80f10482b25c6c8a, 0xff104dc8e0813ed4
+data8 0x3fb5e6d6586fec20, 0x3c9aa84ffd9b4958
+data8 0x80f6998a709c7cfb, 0xff0ac88e6a4ab926
+data8 0x3fb627132eed9140, 0x3cbced2cbbbe7d16
+data8 0x80fc3f4d3b657c44, 0xff053325a0c8a2ec
+data8 0x3fb667516b6c34c0, 0x3c6489c5fc68595a
+data8 0x8101f5cf67ed2af8, 0xfeff8d8d73dec2bb
+data8 0x3fb6a791120f33a0, 0x3cbe12acf159dfad
+data8 0x8107bd1558d6291f, 0xfef9d7c4d043df29
+data8 0x3fb6e7d226fabba0, 0x3ca386d099cd0dc7
+data8 0x810d95237e38766a, 0xfef411ca9f80b5f7
+data8 0x3fb72814ae53cc20, 0x3cb9f35731e71dd6
+data8 0x81137dfe55aa0e29, 0xfeee3b9dc7eef009
+data8 0x3fb76858ac403a00, 0x3c74df3dd959141a
+data8 0x811977aa6a479f0f, 0xfee8553d2cb8122c
+data8 0x3fb7a89e24e6b0e0, 0x3ca6034406ee42bc
+data8 0x811f822c54bd5ef8, 0xfee25ea7add46a91
+data8 0x3fb7e8e51c6eb6a0, 0x3cb82f8f78e68ed7
+data8 0x81259d88bb4ffac1, 0xfedc57dc2809fb1d
+data8 0x3fb8292d9700ad60, 0x3cbebb73c0e653f9
+data8 0x812bc9c451e5a257, 0xfed640d974eb6068
+data8 0x3fb8697798c5d620, 0x3ca2feee76a9701b
+data8 0x813206e3da0f3124, 0xfed0199e6ad6b585
+data8 0x3fb8a9c325e852e0, 0x3cb9e88f2f4d0efe
+data8 0x813854ec231172f9, 0xfec9e229dcf4747d
+data8 0x3fb8ea1042932a00, 0x3ca5ff40d81f66fd
+data8 0x813eb3e209ee858f, 0xfec39a7a9b36538b
+data8 0x3fb92a5ef2f247c0, 0x3cb5e3bece4d6b07
+data8 0x814523ca796f56ce, 0xfebd428f72561efe
+data8 0x3fb96aaf3b3281a0, 0x3cb7b9e499436d7c
+data8 0x814ba4aa6a2d3ff9, 0xfeb6da672bd48fe4
+data8 0x3fb9ab011f819860, 0x3cb9168143cc1a7f
+data8 0x81523686e29bbdd7, 0xfeb062008df81f50
+data8 0x3fb9eb54a40e3ac0, 0x3cb6e544197eb1e1
+data8 0x8158d964f7124614, 0xfea9d95a5bcbd65a
+data8 0x3fba2ba9cd080800, 0x3ca9a717be8f7446
+data8 0x815f8d49c9d639e4, 0xfea34073551e1ac8
+data8 0x3fba6c009e9f9260, 0x3c741e989a60938a
+data8 0x8166523a8b24f626, 0xfe9c974a367f785c
+data8 0x3fbaac591d0661a0, 0x3cb2c1290107e57d
+data8 0x816d283c793e0114, 0xfe95ddddb94166cb
+data8 0x3fbaecb34c6ef600, 0x3c9c7d5fbaec405d
+data8 0x81740f54e06d55bd, 0xfe8f142c93750c50
+data8 0x3fbb2d0f310cca00, 0x3cbc09479a9cbcfb
+data8 0x817b07891b15cd5e, 0xfe883a3577e9fceb
+data8 0x3fbb6d6ccf1455e0, 0x3cb9450bff4ee307
+data8 0x818210de91bba6c8, 0xfe814ff7162cf62f
+data8 0x3fbbadcc2abb1180, 0x3c9227fda12a8d24
+data8 0x81892b5abb0f2bf9, 0xfe7a55701a8697b1
+data8 0x3fbbee2d48377700, 0x3cb6fad72acfe356
+data8 0x819057031bf7760e, 0xfe734a9f2dfa1810
+data8 0x3fbc2e902bc10600, 0x3cb4465b588d16ad
+data8 0x819793dd479d4fbe, 0xfe6c2f82f643f68b
+data8 0x3fbc6ef4d9904580, 0x3c8b9ac54823960d
+data8 0x819ee1eedf76367a, 0xfe65041a15d8a92c
+data8 0x3fbcaf5b55dec6a0, 0x3ca2b8d28a954db2
+data8 0x81a6413d934f7a66, 0xfe5dc8632be3477f
+data8 0x3fbcefc3a4e727a0, 0x3c9380da83713ab4
+data8 0x81adb1cf21597d4b, 0xfe567c5cd44431d5
+data8 0x3fbd302dcae51600, 0x3ca995b83421756a
+data8 0x81b533a9563310b8, 0xfe4f2005a78fb50f
+data8 0x3fbd7099cc155180, 0x3caefa2f7a817d5f
+data8 0x81bcc6d20cf4f373, 0xfe47b35c3b0caaeb
+data8 0x3fbdb107acb5ae80, 0x3cb455fc372dd026
+data8 0x81c46b4f2f3d6e68, 0xfe40365f20b316d6
+data8 0x3fbdf177710518c0, 0x3cbee3dcc5b01434
+data8 0x81cc2126b53c1144, 0xfe38a90ce72abf36
+data8 0x3fbe31e91d439620, 0x3cb3e131c950aebd
+data8 0x81d3e85ea5bd8ee2, 0xfe310b6419c9c33a
+data8 0x3fbe725cb5b24900, 0x3c01d3fac6029027
+data8 0x81dbc0fd1637b9c1, 0xfe295d6340932d15
+data8 0x3fbeb2d23e937300, 0x3c6304cc44aeedd1
+data8 0x81e3ab082ad5a0a4, 0xfe219f08e03580b3
+data8 0x3fbef349bc2a77e0, 0x3cac1d2d6abe9c72
+data8 0x81eba6861683cb97, 0xfe19d0537a0946e2
+data8 0x3fbf33c332bbe020, 0x3ca0909dba4e96ca
+data8 0x81f3b37d1afc9979, 0xfe11f1418c0f94e2
+data8 0x3fbf743ea68d5b60, 0x3c937fc12a2a779a
+data8 0x81fbd1f388d4be45, 0xfe0a01d190f09063
+data8 0x3fbfb4bc1be5c340, 0x3cbf51a504b55813
+data8 0x820401efbf87e248, 0xfe020201fff9efea
+data8 0x3fbff53b970d1e80, 0x3ca625444b260078
+data8 0x82106ad2ffdca049, 0xfdf5e3940a49135e
+data8 0x3fc02aff52065460, 0x3c9125d113e22a57
+data8 0x8221343d6ea1d3e2, 0xfde581a45429b0a0
+data8 0x3fc06b84f8e03220, 0x3caccf362295894b
+data8 0x82324434adbf99c2, 0xfdd4de1a001fb775
+data8 0x3fc0ac0ed1fe7240, 0x3cc22f676096b0af
+data8 0x82439aee8d0c7747, 0xfdc3f8e8269d1f03
+data8 0x3fc0ec9cee9e4820, 0x3cca147e2886a628
+data8 0x825538a1d0fcb2f0, 0xfdb2d201a9b1ba66
+data8 0x3fc12d2f6006f0a0, 0x3cc72b36633bc2d4
+data8 0x82671d86345c5cee, 0xfda1695934d723e7
+data8 0x3fc16dc63789de60, 0x3cb11f9c47c7b83f
+data8 0x827949d46a121770, 0xfd8fbee13cbbb823
+data8 0x3fc1ae618682e620, 0x3cce1b59020cef8e
+data8 0x828bbdc61eeab9ba, 0xfd7dd28bff0c9f34
+data8 0x3fc1ef015e586c40, 0x3cafec043e0225ee
+data8 0x829e7995fb6de9e1, 0xfd6ba44b823ee1ca
+data8 0x3fc22fa5d07b90c0, 0x3cba905409caf8e3
+data8 0x82b17d7fa5bbc982, 0xfd5934119557883a
+data8 0x3fc2704eee685da0, 0x3cb5ef21838a823e
+data8 0x82c4c9bfc373d276, 0xfd4681cfcfb2c161
+data8 0x3fc2b0fcc9a5f3e0, 0x3ccc7952c5e0e312
+data8 0x82d85e93fba50136, 0xfd338d7790ca0f41
+data8 0x3fc2f1af73c6ba00, 0x3cbecf5f977d1ca9
+data8 0x82ec3c3af8c76b32, 0xfd2056f9fff97727
+data8 0x3fc33266fe6889a0, 0x3c9d329c022ebdb5
+data8 0x830062f46abf6022, 0xfd0cde480c43b327
+data8 0x3fc373237b34de60, 0x3cc95806d4928adb
+data8 0x8314d30108ea35f0, 0xfcf923526c1562b2
+data8 0x3fc3b3e4fbe10520, 0x3cbc299fe7223d54
+data8 0x83298ca29434df97, 0xfce526099d0737ed
+data8 0x3fc3f4ab922e4a60, 0x3cb59d8bb8fdbccc
+data8 0x833e901bd93c7009, 0xfcd0e65de39f1f7c
+data8 0x3fc435774fea2a60, 0x3c9ec18b43340914
+data8 0x8353ddb0b278aad8, 0xfcbc643f4b106055
+data8 0x3fc4764846ee80a0, 0x3cb90402efd87ed6
+data8 0x836975a60a70c52e, 0xfca79f9da4fab13a
+data8 0x3fc4b71e8921b860, 0xbc58f23449ed6365
+data8 0x837f5841ddfa7a46, 0xfc92986889284148
+data8 0x3fc4f7fa2876fca0, 0xbc6294812bf43acd
+data8 0x839585cb3e839773, 0xfc7d4e8f554ab12f
+data8 0x3fc538db36ee6960, 0x3cb910b773d4c578
+data8 0x83abfe8a5466246f, 0xfc67c2012cb6fa68
+data8 0x3fc579c1c6953cc0, 0x3cc5ede909fc47fc
+data8 0x83c2c2c861474d91, 0xfc51f2acf82041d5
+data8 0x3fc5baade9860880, 0x3cac63cdfc3588e5
+data8 0x83d9d2cfc2813637, 0xfc3be08165519325
+data8 0x3fc5fb9fb1e8e3a0, 0x3cbf7c8466578c29
+data8 0x83f12eebf397daac, 0xfc258b6ce6e6822f
+data8 0x3fc63c9731f39d40, 0x3cb6d2a7ffca3e9e
+data8 0x8408d76990b9296e, 0xfc0ef35db402af94
+data8 0x3fc67d947be9eec0, 0x3cb1980da09e6566
+data8 0x8420cc9659487cd7, 0xfbf81841c8082dc4
+data8 0x3fc6be97a21daf00, 0x3cc2ac8330e59aa5
+data8 0x84390ec132759ecb, 0xfbe0fa06e24cc390
+data8 0x3fc6ffa0b6ef05e0, 0x3ccc1a030fee56c4
+data8 0x84519e3a29df811a, 0xfbc9989a85ce0954
+data8 0x3fc740afcccca000, 0x3cc19692a5301ca6
+data8 0x846a7b527842d61b, 0xfbb1f3e9f8e45dc4
+data8 0x3fc781c4f633e2c0, 0x3cc0e98f3868a508
+data8 0x8483a65c8434b5f0, 0xfb9a0be244f4af45
+data8 0x3fc7c2e045b12140, 0x3cb2a8d309754420
+data8 0x849d1fabe4e97dd7, 0xfb81e070362116d1
+data8 0x3fc80401cddfd120, 0x3ca7a44544aa4ce6
+data8 0x84b6e795650817ea, 0xfb6971805af8411e
+data8 0x3fc84529a16ac020, 0x3c9e3b709c7d6f94
+data8 0x84d0fe6f0589da92, 0xfb50beff0423a2f5
+data8 0x3fc88657d30c49e0, 0x3cc60d65a7f0a278
+data8 0x84eb649000a73014, 0xfb37c8d84414755c
+data8 0x3fc8c78c758e8e80, 0x3cc94b2ee984c2b7
+data8 0x85061a50ccd13781, 0xfb1e8ef7eeaf764b
+data8 0x3fc908c79bcba900, 0x3cc8540ae794a2fe
+data8 0x8521200b1fb8916e, 0xfb05114998f76a83
+data8 0x3fc94a0958ade6c0, 0x3ca127f49839fa9c
+data8 0x853c7619f1618bf6, 0xfaeb4fb898b65d19
+data8 0x3fc98b51bf2ffee0, 0x3c8c9ba7a803909a
+data8 0x85581cd97f45e274, 0xfad14a3004259931
+data8 0x3fc9cca0e25d4ac0, 0x3cba458e91d3bf54
+data8 0x857414a74f8446b4, 0xfab7009ab1945a54
+data8 0x3fca0df6d551fe80, 0x3cc78ea1d329d2b2
+data8 0x85905de2341dea46, 0xfa9c72e3370d2fbc
+data8 0x3fca4f53ab3b6200, 0x3ccf60dca86d57ef
+data8 0x85acf8ea4e423ff8, 0xfa81a0f3e9fa0ee9
+data8 0x3fca90b777580aa0, 0x3ca4c4e2ec8a867e
+data8 0x85c9e62111a92e7d, 0xfa668ab6dec711b1
+data8 0x3fcad2224cf814e0, 0x3c303de5980d071c
+data8 0x85e725e947fbee97, 0xfa4b3015e883dbfe
+data8 0x3fcb13943f7d5f80, 0x3cc29d4eefa5cb1e
+data8 0x8604b8a7144cd054, 0xfa2f90fa9883a543
+data8 0x3fcb550d625bc6a0, 0x3c9e01a746152daf
+data8 0x86229ebff69e2415, 0xfa13ad4e3dfbe1c1
+data8 0x3fcb968dc9195ea0, 0x3ccc091bd73ae518
+data8 0x8640d89acf78858c, 0xf9f784f9e5a1877b
+data8 0x3fcbd815874eb160, 0x3cb5f4b89875e187
+data8 0x865f669fe390c7f5, 0xf9db17e65944eacf
+data8 0x3fcc19a4b0a6f9c0, 0x3cc5c0bc2b0bbf14
+data8 0x867e4938df7dc45f, 0xf9be65fc1f6c2e6e
+data8 0x3fcc5b3b58e061e0, 0x3cc1ca70df8f57e7
+data8 0x869d80d0db7e4c0c, 0xf9a16f237aec427a
+data8 0x3fcc9cd993cc4040, 0x3cbae93acc85eccf
+data8 0x86bd0dd45f4f8265, 0xf98433446a806e70
+data8 0x3fccde7f754f5660, 0x3cb22f70e64568d0
+data8 0x86dcf0b16613e37a, 0xf966b246a8606170
+data8 0x3fcd202d11620fa0, 0x3c962030e5d4c849
+data8 0x86fd29d7624b3d5d, 0xf948ec11a9d4c45b
+data8 0x3fcd61e27c10c0a0, 0x3cc7083c91d59217
+data8 0x871db9b741dbe44a, 0xf92ae08c9eca4941
+data8 0x3fcda39fc97be7c0, 0x3cc9258579e57211
+data8 0x873ea0c3722d6af2, 0xf90c8f9e71633363
+data8 0x3fcde5650dd86d60, 0x3ca4755a9ea582a9
+data8 0x875fdf6fe45529e8, 0xf8edf92dc5875319
+data8 0x3fce27325d6fe520, 0x3cbc1e2b6c1954f9
+data8 0x878176321154e2bc, 0xf8cf1d20f87270b8
+data8 0x3fce6907cca0d060, 0x3cb6ca4804750830
+data8 0x87a36580fe6bccf5, 0xf8affb5e20412199
+data8 0x3fceaae56fdee040, 0x3cad6b310d6fd46c
+data8 0x87c5add5417a5cb9, 0xf89093cb0b7c0233
+data8 0x3fceeccb5bb33900, 0x3cc16e99cedadb20
+data8 0x87e84fa9057914ca, 0xf870e64d40a15036
+data8 0x3fcf2eb9a4bcb600, 0x3cc75ee47c8b09e9
+data8 0x880b4b780f02b709, 0xf850f2c9fdacdf78
+data8 0x3fcf70b05fb02e20, 0x3cad6350d379f41a
+data8 0x882ea1bfc0f228ac, 0xf830b926379e6465
+data8 0x3fcfb2afa158b8a0, 0x3cce0ccd9f829985
+data8 0x885252ff21146108, 0xf810394699fe0e8e
+data8 0x3fcff4b77e97f3e0, 0x3c9b30faa7a4c703
+data8 0x88765fb6dceebbb3, 0xf7ef730f865f6df0
+data8 0x3fd01b6406332540, 0x3cdc5772c9e0b9bd
+data8 0x88ad1f69be2cc730, 0xf7bdc59bc9cfbd97
+data8 0x3fd04cf8ad203480, 0x3caeef44fe21a74a
+data8 0x88f763f70ae2245e, 0xf77a91c868a9c54e
+data8 0x3fd08f23ce0162a0, 0x3cd6290ab3fe5889
+data8 0x89431fc7bc0c2910, 0xf73642973c91298e
+data8 0x3fd0d1610f0c1ec0, 0x3cc67401a01f08cf
+data8 0x8990573407c7738e, 0xf6f0d71d1d7a2dd6
+data8 0x3fd113b0c65d88c0, 0x3cc7aa4020fe546f
+data8 0x89df0eb108594653, 0xf6aa4e6a05cfdef2
+data8 0x3fd156134ada6fe0, 0x3cc87369da09600c
+data8 0x8a2f4ad16e0ed78a, 0xf662a78900c35249
+data8 0x3fd19888f43427a0, 0x3cc62b220f38e49c
+data8 0x8a811046373e0819, 0xf619e180181d97cc
+data8 0x3fd1db121aed7720, 0x3ca3ede7490b52f4
+data8 0x8ad463df6ea0fa2c, 0xf5cffb504190f9a2
+data8 0x3fd21daf185fa360, 0x3caafad98c1d6c1b
+data8 0x8b294a8cf0488daf, 0xf584f3f54b8604e6
+data8 0x3fd2606046bf95a0, 0x3cdb2d704eeb08fa
+data8 0x8b7fc95f35647757, 0xf538ca65c960b582
+data8 0x3fd2a32601231ec0, 0x3cc661619fa2f126
+data8 0x8bd7e588272276f8, 0xf4eb7d92ff39fccb
+data8 0x3fd2e600a3865760, 0x3c8a2a36a99aca4a
+data8 0x8c31a45bf8e9255e, 0xf49d0c68cd09b689
+data8 0x3fd328f08ad12000, 0x3cb9efaf1d7ab552
+data8 0x8c8d0b520a35eb18, 0xf44d75cd993cfad2
+data8 0x3fd36bf614dcc040, 0x3ccacbb590bef70d
+data8 0x8cea2005d068f23d, 0xf3fcb8a23ab4942b
+data8 0x3fd3af11a079a6c0, 0x3cd9775872cf037d
+data8 0x8d48e837c8cd5027, 0xf3aad3c1e2273908
+data8 0x3fd3f2438d754b40, 0x3ca03304f667109a
+data8 0x8da969ce732f3ac7, 0xf357c60202e2fd7e
+data8 0x3fd4358c3ca032e0, 0x3caecf2504ff1a9d
+data8 0x8e0baad75555e361, 0xf3038e323ae9463a
+data8 0x3fd478ec0fd419c0, 0x3cc64bdc3d703971
+data8 0x8e6fb18807ba877e, 0xf2ae2b1c3a6057f7
+data8 0x3fd4bc6369fa40e0, 0x3cbb7122ec245cf2
+data8 0x8ed5843f4bda74d5, 0xf2579b83aa556f0c
+data8 0x3fd4fff2af11e2c0, 0x3c9cfa2dc792d394
+data8 0x8f3d29862c861fef, 0xf1ffde2612ca1909
+data8 0x3fd5439a4436d000, 0x3cc38d46d310526b
+data8 0x8fa6a81128940b2d, 0xf1a6f1bac0075669
+data8 0x3fd5875a8fa83520, 0x3cd8bf59b8153f8a
+data8 0x901206c1686317a6, 0xf14cd4f2a730d480
+data8 0x3fd5cb33f8cf8ac0, 0x3c9502b5c4d0e431
+data8 0x907f4ca5fe9cf739, 0xf0f186784a125726
+data8 0x3fd60f26e847b120, 0x3cc8a1a5e0acaa33
+data8 0x90ee80fd34aeda5e, 0xf09504ef9a212f18
+data8 0x3fd65333c7e43aa0, 0x3cae5b029cb1f26e
+data8 0x915fab35e37421c6, 0xf0374ef5daab5c45
+data8 0x3fd6975b02b8e360, 0x3cd5aa1c280c45e6
+data8 0x91d2d2f0d894d73c, 0xefd86321822dbb51
+data8 0x3fd6db9d05213b20, 0x3cbecf2c093ccd8b
+data8 0x9248000249200009, 0xef7840021aca5a72
+data8 0x3fd71ffa3cc87fc0, 0x3cb8d273f08d00d9
+data8 0x92bf3a7351f081d2, 0xef16e42021d7cbd5
+data8 0x3fd7647318b1ad20, 0x3cbce099d79cdc46
+data8 0x93388a8386725713, 0xeeb44dfce6820283
+data8 0x3fd7a908093fc1e0, 0x3ccb033ec17a30d9
+data8 0x93b3f8aa8e653812, 0xee507c126774fa45
+data8 0x3fd7edb9803e3c20, 0x3cc10aedb48671eb
+data8 0x94318d99d341ade4, 0xedeb6cd32f891afb
+data8 0x3fd83287f0e9cf80, 0x3c994c0c1505cd2a
+data8 0x94b1523e3dedc630, 0xed851eaa3168f43c
+data8 0x3fd87773cff956e0, 0x3cda3b7bce6a6b16
+data8 0x95334fc20577563f, 0xed1d8ffaa2279669
+data8 0x3fd8bc7d93a70440, 0x3cd4922edc792ce2
+data8 0x95b78f8e8f92f274, 0xecb4bf1fd2be72da
+data8 0x3fd901a5b3b9cf40, 0x3cd3fea1b00f9d0d
+data8 0x963e1b4e63a87c3f, 0xec4aaa6d08694cc1
+data8 0x3fd946eca98f2700, 0x3cdba4032d968ff1
+data8 0x96c6fcef314074fc, 0xebdf502d53d65fea
+data8 0x3fd98c52f024e800, 0x3cbe7be1ab8c95c9
+data8 0x97523ea3eab028b2, 0xeb72aea36720793e
+data8 0x3fd9d1d904239860, 0x3cd72d08a6a22b70
+data8 0x97dfeae6f4ee4a9a, 0xeb04c4096a884e94
+data8 0x3fda177f63e8ef00, 0x3cd818c3c1ebfac7
+data8 0x98700c7c6d85d119, 0xea958e90cfe1efd7
+data8 0x3fda5d468f92a540, 0x3cdf45fbfaa080fe
+data8 0x9902ae7487a9caa1, 0xea250c6224aab21a
+data8 0x3fdaa32f090998e0, 0x3cd715a9353cede4
+data8 0x9997dc2e017a9550, 0xe9b33b9ce2bb7638
+data8 0x3fdae939540d3f00, 0x3cc545c014943439
+data8 0x9a2fa158b29b649b, 0xe9401a573f8aa706
+data8 0x3fdb2f65f63f6c60, 0x3cd4a63c2f2ca8e2
+data8 0x9aca09f835466186, 0xe8cba69df9f0bf35
+data8 0x3fdb75b5773075e0, 0x3cda310ce1b217ec
+data8 0x9b672266ab1e0136, 0xe855de74266193d4
+data8 0x3fdbbc28606babc0, 0x3cdc84b75cca6c44
+data8 0x9c06f7579f0b7bd5, 0xe7debfd2f98c060b
+data8 0x3fdc02bf3d843420, 0x3cd225d967ffb922
+data8 0x9ca995db058cabdc, 0xe76648a991511c6e
+data8 0x3fdc497a9c224780, 0x3cde08101c5b825b
+data8 0x9d4f0b605ce71e88, 0xe6ec76dcbc02d9a7
+data8 0x3fdc905b0c10d420, 0x3cb1abbaa3edf120
+data8 0x9df765b9eecad5e6, 0xe6714846bdda7318
+data8 0x3fdcd7611f4b8a00, 0x3cbf6217ae80aadf
+data8 0x9ea2b320350540fe, 0xe5f4bab71494cd6b
+data8 0x3fdd1e8d6a0d56c0, 0x3cb726e048cc235c
+data8 0x9f51023562fc5676, 0xe576cbf239235ecb
+data8 0x3fdd65e082df5260, 0x3cd9e66872bd5250
+data8 0xa002620915c2a2f6, 0xe4f779b15f5ec5a7
+data8 0x3fddad5b02a82420, 0x3c89743b0b57534b
+data8 0xa0b6e21c2caf9992, 0xe476c1a233a7873e
+data8 0x3fddf4fd84bbe160, 0x3cbf7adea9ee3338
+data8 0xa16e9264cc83a6b2, 0xe3f4a16696608191
+data8 0x3fde3cc8a6ec6ee0, 0x3cce46f5a51f49c6
+data8 0xa22983528f3d8d49, 0xe3711694552da8a8
+data8 0x3fde84bd099a6600, 0x3cdc78f6490a2d31
+data8 0xa2e7c5d2e2e69460, 0xe2ec1eb4e1e0a5fb
+data8 0x3fdeccdb4fc685c0, 0x3cdd3aedb56a4825
+data8 0xa3a96b5599bd2532, 0xe265b74506fbe1c9
+data8 0x3fdf15241f23b3e0, 0x3cd440f3c6d65f65
+data8 0xa46e85d1ae49d7de, 0xe1ddddb499b3606f
+data8 0x3fdf5d98202994a0, 0x3cd6c44bd3fb745a
+data8 0xa53727ca3e11b99e, 0xe1548f662951b00d
+data8 0x3fdfa637fe27bf60, 0x3ca8ad1cd33054dd
+data8 0xa6036453bdc20186, 0xe0c9c9aeabe5e481
+data8 0x3fdfef0467599580, 0x3cc0f1ac0685d78a
+data8 0xa6d34f1969dda338, 0xe03d89d5281e4f81
+data8 0x3fe01bff067d6220, 0x3cc0731e8a9ef057
+data8 0xa7a6fc62f7246ff3, 0xdfafcd125c323f54
+data8 0x3fe04092d1ae3b40, 0x3ccabda24b59906d
+data8 0xa87e811a861df9b9, 0xdf20909061bb9760
+data8 0x3fe0653df0fd9fc0, 0x3ce94c8dcc722278
+data8 0xa959f2d2dd687200, 0xde8fd16a4e5f88bd
+data8 0x3fe08a00c1cae320, 0x3ce6b888bb60a274
+data8 0xaa3967cdeea58bda, 0xddfd8cabd1240d22
+data8 0x3fe0aedba3221c00, 0x3ced5941cd486e46
+data8 0xab904fd587263c84, 0xdd1f4472e1cf64ed
+data8 0x3fe0e651e85229c0, 0x3cdb6701042299b1
+data8 0xad686d44dd5a74bb, 0xdbf173e1f6b46e92
+data8 0x3fe1309cbf4cdb20, 0x3cbf1be7bb3f0ec5
+data8 0xaf524e15640ebee4, 0xdabd54896f1029f6
+data8 0x3fe17b4ee1641300, 0x3ce81dd055b792f1
+data8 0xb14eca24ef7db3fa, 0xd982cb9ae2f47e41
+data8 0x3fe1c66b9ffd6660, 0x3cd98ea31eb5ddc7
+data8 0xb35ec807669920ce, 0xd841bd1b8291d0b6
+data8 0x3fe211f66db3a5a0, 0x3ca480c35a27b4a2
+data8 0xb5833e4755e04dd1, 0xd6fa0bd3150b6930
+data8 0x3fe25df2e05b6c40, 0x3ca4bc324287a351
+data8 0xb7bd34c8000b7bd3, 0xd5ab9939a7d23aa1
+data8 0x3fe2aa64b32f7780, 0x3cba67314933077c
+data8 0xba0dc64d126cc135, 0xd4564563ce924481
+data8 0x3fe2f74fc9289ac0, 0x3cec1a1dc0efc5ec
+data8 0xbc76222cbbfa74a6, 0xd2f9eeed501125a8
+data8 0x3fe344b82f859ac0, 0x3ceeef218de413ac
+data8 0xbef78e31985291a9, 0xd19672e2182f78be
+data8 0x3fe392a22087b7e0, 0x3cd2619ba201204c
+data8 0xc19368b2b0629572, 0xd02baca5427e436a
+data8 0x3fe3e11206694520, 0x3cb5d0b3143fe689
+data8 0xc44b2ae8c6733e51, 0xceb975d60b6eae5d
+data8 0x3fe4300c7e945020, 0x3cbd367143da6582
+data8 0xc7206b894212dfef, 0xcd3fa6326ff0ac9a
+data8 0x3fe47f965d201d60, 0x3ce797c7a4ec1d63
+data8 0xca14e1b0622de526, 0xcbbe13773c3c5338
+data8 0x3fe4cfb4b09d1a20, 0x3cedfadb5347143c
+data8 0xcd2a6825eae65f82, 0xca34913d425a5ae9
+data8 0x3fe5206cc637e000, 0x3ce2798b38e54193
+data8 0xd06301095e1351ee, 0xc8a2f0d3679c08c0
+data8 0x3fe571c42e3d0be0, 0x3ccd7cb9c6c2ca68
+data8 0xd3c0d9f50057adda, 0xc70901152d59d16b
+data8 0x3fe5c3c0c108f940, 0x3ceb6c13563180ab
+data8 0xd74650a98cc14789, 0xc5668e3d4cbf8828
+data8 0x3fe61668a46ffa80, 0x3caa9092e9e3c0e5
+data8 0xdaf5f8579dcc8f8f, 0xc3bb61b3eed42d02
+data8 0x3fe669c251ad69e0, 0x3cccf896ef3b4fee
+data8 0xded29f9f9a6171b4, 0xc20741d7f8e8e8af
+data8 0x3fe6bdd49bea05c0, 0x3cdc6b29937c575d
+data8 0xe2df5765854ccdb0, 0xc049f1c2d1b8014b
+data8 0x3fe712a6b76c6e80, 0x3ce1ddc6f2922321
+data8 0xe71f7a9b94fcb4c3, 0xbe833105ec291e91
+data8 0x3fe76840418978a0, 0x3ccda46e85432c3d
+data8 0xeb96b72d3374b91e, 0xbcb2bb61493b28b3
+data8 0x3fe7bea9496d5a40, 0x3ce37b42ec6e17d3
+data8 0xf049183c3f53c39b, 0xbad848720223d3a8
+data8 0x3fe815ea59dab0a0, 0x3cb03ad41bfc415b
+data8 0xf53b11ec7f415f15, 0xb8f38b57c53c9c48
+data8 0x3fe86e0c84010760, 0x3cc03bfcfb17fe1f
+data8 0xfa718f05adbf2c33, 0xb70432500286b185
+data8 0x3fe8c7196b9225c0, 0x3ced99fcc6866ba9
+data8 0xfff200c3f5489608, 0xb509e6454dca33cc
+data8 0x3fe9211b54441080, 0x3cb789cb53515688
+// The following table entries are not used
+//data8 0x82e138a0fac48700, 0xb3044a513a8e6132
+//data8 0x3fe97c1d30f5b7c0, 0x3ce1eb765612d1d0
+//data8 0x85f4cc7fc670d021, 0xb0f2fb2ea6cbbc88
+//data8 0x3fe9d82ab4b5fde0, 0x3ced3fe6f27e8039
+//data8 0x89377c1387d5b908, 0xaed58e9a09014d5c
+//data8 0x3fea355065f87fa0, 0x3cbef481d25f5b58
+//data8 0x8cad7a2c98dec333, 0xacab929ce114d451
+//data8 0x3fea939bb451e2a0, 0x3c8e92b4fbf4560f
+//data8 0x905b7dfc99583025, 0xaa748cc0dbbbc0ec
+//data8 0x3feaf31b11270220, 0x3cdced8c61bd7bd5
+//data8 0x9446d8191f80dd42, 0xa82ff92687235baf
+//data8 0x3feb53de0bcffc20, 0x3cbe1722fb47509e
+//data8 0x98758ba086e4000a, 0xa5dd497a9c184f58
+//data8 0x3febb5f571cb0560, 0x3ce0c7774329a613
+//data8 0x9cee6c7bf18e4e24, 0xa37be3c3cd1de51b
+//data8 0x3fec197373bc7be0, 0x3ce08ebdb55c3177
+//data8 0xa1b944000a1b9440, 0xa10b2101b4f27e03
+//data8 0x3fec7e6bd023da60, 0x3ce5fc5fd4995959
+//data8 0xa6defd8ba04d3e38, 0x9e8a4b93cad088ec
+//data8 0x3fece4f404e29b20, 0x3cea3413401132b5
+//data8 0xac69dd408a10c62d, 0x9bf89d5d17ddae8c
+//data8 0x3fed4d2388f63600, 0x3cd5a7fb0d1d4276
+//data8 0xb265c39cbd80f97a, 0x99553d969fec7beb
+//data8 0x3fedb714101e0a00, 0x3cdbda21f01193f2
+//data8 0xb8e081a16ae4ae73, 0x969f3e3ed2a0516c
+//data8 0x3fee22e1da97bb00, 0x3ce7231177f85f71
+//data8 0xbfea427678945732, 0x93d5990f9ee787af
+//data8 0x3fee90ac13b18220, 0x3ce3c8a5453363a5
+//data8 0xc79611399b8c90c5, 0x90f72bde80febc31
+//data8 0x3fef009542b712e0, 0x3ce218fd79e8cb56
+//data8 0xcffa8425040624d7, 0x8e02b4418574ebed
+//data8 0x3fef72c3d2c57520, 0x3cd32a717f82203f
+//data8 0xd93299cddcf9cf23, 0x8af6ca48e9c44024
+//data8 0x3fefe762b77744c0, 0x3ce53478a6bbcf94
+//data8 0xe35eda760af69ad9, 0x87d1da0d7f45678b
+//data8 0x3ff02f511b223c00, 0x3ced6e11782c28fc
+//data8 0xeea6d733421da0a6, 0x84921bbe64ae029a
+//data8 0x3ff06c5c6f8ce9c0, 0x3ce71fc71c1ffc02
+//data8 0xfb3b2c73fc6195cc, 0x813589ba3a5651b6
+//data8 0x3ff0aaf2613700a0, 0x3cf2a72d2fd94ef3
+//data8 0x84ac1fcec4203245, 0xfb73a828893df19e
+//data8 0x3ff0eb367c3fd600, 0x3cf8054c158610de
+//data8 0x8ca50621110c60e6, 0xf438a14c158d867c
+//data8 0x3ff12d51caa6b580, 0x3ce6bce9748739b6
+//data8 0x95b8c2062d6f8161, 0xecb3ccdd37b369da
+//data8 0x3ff1717418520340, 0x3ca5c2732533177c
+//data8 0xa0262917caab4ad1, 0xe4dde4ddc81fd119
+//data8 0x3ff1b7d59dd40ba0, 0x3cc4c7c98e870ff5
+//data8 0xac402c688b72f3f4, 0xdcae469be46d4c8d
+//data8 0x3ff200b93cc5a540, 0x3c8dd6dc1bfe865a
+//data8 0xba76968b9eabd9ab, 0xd41a8f3df1115f7f
+//data8 0x3ff24c6f8f6affa0, 0x3cf1acb6d2a7eff7
+//data8 0xcb63c87c23a71dc5, 0xcb161074c17f54ec
+//data8 0x3ff29b5b338b7c80, 0x3ce9b5845f6ec746
+//data8 0xdfe323b8653af367, 0xc19107d99ab27e42
+//data8 0x3ff2edf6fac7f5a0, 0x3cf77f961925fa02
+//data8 0xf93746caaba3e1f1, 0xb777744a9df03bff
+//data8 0x3ff344df237486c0, 0x3cf6ddf5f6ddda43
+//data8 0x8ca77052f6c340f0, 0xacaf476f13806648
+//data8 0x3ff3a0dfa4bb4ae0, 0x3cfee01bbd761bff
+//data8 0xa1a48604a81d5c62, 0xa11575d30c0aae50
+//data8 0x3ff4030b73c55360, 0x3cf1cf0e0324d37c
+//data8 0xbe45074b05579024, 0x9478e362a07dd287
+//data8 0x3ff46ce4c738c4e0, 0x3ce3179555367d12
+//data8 0xe7a08b5693d214ec, 0x8690e3575b8a7c3b
+//data8 0x3ff4e0a887c40a80, 0x3cfbd5d46bfefe69
+//data8 0x94503d69396d91c7, 0xedd2ce885ff04028
+//data8 0x3ff561ebd9c18cc0, 0x3cf331bd176b233b
+//data8 0xced1d96c5bb209e6, 0xc965278083808702
+//data8 0x3ff5f71d7ff42c80, 0x3ce3301cc0b5a48c
+//data8 0xabac2cee0fc24e20, 0x9c4eb1136094cbbd
+//data8 0x3ff6ae4c63222720, 0x3cf5ff46874ee51e
+//data8 0x8040201008040201, 0xb4d7ac4d9acb1bf4
+//data8 0x3ff7b7d33b928c40, 0x3cfacdee584023bb
+LOCAL_OBJECT_END(T_table)
+
+
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+       // C_3
+data8 0xaaaaaaaaaaaaaaab, 0x0000000000003ffc
+       // C_5
+data8 0x999999999999999a, 0x0000000000003ffb
+       // C_7, C_9
+data8 0x3fa6db6db6db6db7, 0x3f9f1c71c71c71c8
+       // pi/2 (low, high)
+data8 0x3C91A62633145C07, 0x3FF921FB54442D18
+       // C_11, C_13
+data8 0x3f96e8ba2e8ba2e9, 0x3f91c4ec4ec4ec4e
+       // C_15, C_17
+data8 0x3f8c99999999999a, 0x3f87a87878787223
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+R_DBL_S = r21
+R_EXP0 = r22
+R_EXP = r15
+R_SGNMASK = r23
+R_TMP = r24
+R_TMP2 = r25
+R_INDEX = r26
+R_TMP3 = r27
+R_TMP03 = r27
+R_TMP4 = r28
+R_TMP5 = r23
+R_TMP6 = r22
+R_TMP7 = r21
+R_T = r29
+R_BIAS = r20
+
+F_T = f6
+F_1S2 = f7
+F_1S2_S = f9
+F_INV_1T2 = f10
+F_SQRT_1T2 = f11
+F_S2T2 = f12
+F_X = f13
+F_D = f14
+F_2M64 = f15
+
+F_CS2 = f32
+F_CS3 = f33
+F_CS4 = f34
+F_CS5 = f35
+F_CS6 = f36
+F_CS7 = f37
+F_CS8 = f38
+F_CS9 = f39
+F_S23 = f40
+F_S45 = f41
+F_S67 = f42
+F_S89 = f43
+F_S25 = f44
+F_S69 = f45
+F_S29 = f46
+F_X2 = f47
+F_X4 = f48
+F_TSQRT = f49
+F_DTX = f50
+F_R = f51
+F_R2 = f52
+F_R3 = f53
+F_R4 = f54
+
+F_C3 = f55
+F_C5 = f56
+F_C7 = f57
+F_C9 = f58
+F_P79 = f59
+F_P35 = f60
+F_P39 = f61
+
+F_ATHI = f62
+F_ATLO = f63
+
+F_T1 = f64
+F_Y = f65
+F_Y2 = f66
+F_ANDMASK = f67
+F_ORMASK = f68
+F_S = f69
+F_05 = f70
+F_SQRT_1S2 = f71
+F_DS = f72
+F_Z = f73
+F_1T2 = f74
+F_DZ = f75
+F_ZE = f76
+F_YZ = f77
+F_Y1S2 = f78
+F_Y1S2X = f79
+F_1X = f80
+F_ST = f81
+F_1T2_ST = f82
+F_TSS = f83
+F_Y1S2X2 = f84
+F_DZ_TERM = f85
+F_DTS = f86
+F_DS2X = f87
+F_T2 = f88
+F_ZY1S2S = f89
+F_Y1S2_1X = f90
+F_TS = f91
+F_PI2_LO = f92
+F_PI2_HI = f93
+F_S19 = f94
+F_INV1T2_2 = f95
+F_CORR = f96
+F_DZ0 = f97
+
+F_C11 = f98
+F_C13 = f99
+F_C15 = f100
+F_C17 = f101
+F_P1113 = f102
+F_P1517 = f103
+F_P1117 = f104
+F_P317 = f105
+F_R8 = f106
+F_HI = f107
+F_1S2_HI = f108
+F_DS2 = f109
+F_Y2_2 = f110
+F_S2 = f111
+F_S_DS2 = f112
+F_S_1S2S = f113
+F_XL = f114
+F_2M128 = f115
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(asinl)
+
+{.mfi
+       // get exponent, mantissa (rounded to double precision) of s
+       getf.d R_DBL_S = f8
+       // 1-s^2
+       fnma.s1 F_1S2 = f8, f8, f1
+       // r2 = pointer to T_table
+       addl r2 = @ltoff(T_table), gp
+}
+
+{.mfi
+       // sign mask
+       mov R_SGNMASK = 0x20000
+       nop.f 0
+       // bias-63-1
+       mov R_TMP03 = 0xffff-64;;
+}
+
+
+{.mfi
+       // get exponent of s
+       getf.exp R_EXP = f8
+       nop.f 0
+       // R_TMP4 = 2^45
+       shl R_TMP4 = R_SGNMASK, 45-17
+}
+
+{.mlx
+       // load bias-4
+       mov R_TMP = 0xffff-4
+       // load RU(sqrt(2)/2) to integer register (in double format, shifted left by 1)
+       movl R_TMP2 = 0x7fcd413cccfe779a;;
+}
+
+
+{.mfi
+       // load 2^{-64} in FP register
+       setf.exp F_2M64 = R_TMP03
+       nop.f 0
+       // index = (0x7-exponent)|b1 b2.. b6
+       extr.u R_INDEX = R_DBL_S, 46, 9
+}
+
+{.mfi
+       // get t = sign|exponent|b1 b2.. b6 1 x.. x
+       or R_T = R_DBL_S, R_TMP4
+       nop.f 0
+       // R_TMP4 = 2^45-1
+       sub R_TMP4 = R_TMP4, r0, 1;;
+}
+
+
+{.mfi
+       // get t = sign|exponent|b1 b2.. b6 1 0.. 0
+       andcm R_T = R_T, R_TMP4
+       nop.f 0
+       // eliminate sign from R_DBL_S (shift left by 1)
+       shl R_TMP3 = R_DBL_S, 1
+}
+
+{.mfi
+       // R_BIAS = 3*2^6
+       mov R_BIAS = 0xc0
+       nop.f 0
+       // eliminate sign from R_EXP
+       andcm R_EXP0 = R_EXP, R_SGNMASK;;
+}
+
+
+
+{.mfi
+       // load start address for T_table
+       ld8 r2 = [r2]
+       nop.f 0
+       // p8 = 1 if |s|> = sqrt(2)/2
+       cmp.geu p8, p0 = R_TMP3, R_TMP2
+}
+
+{.mlx
+       // p7 = 1 if |s|<2^{-4} (exponent of s<bias-4)
+       cmp.lt p7, p0 = R_EXP0, R_TMP
+       // sqrt coefficient cs8 = -33*13/128
+       movl R_TMP2 = 0xc0568000;;
+}
+
+
+
+{.mbb
+       // load t in FP register
+       setf.d F_T = R_T
+       // if |s|<2^{-4}, take alternate path
+ (p7) br.cond.spnt SMALL_S
+       // if |s|> = sqrt(2)/2, take alternate path
+ (p8) br.cond.sptk LARGE_S
+}
+
+{.mlx
+       // index = (4-exponent)|b1 b2.. b6
+       sub R_INDEX = R_INDEX, R_BIAS
+       // sqrt coefficient cs9 = 55*13/128
+       movl R_TMP = 0x40b2c000;;
+}
+
+
+{.mfi
+       // sqrt coefficient cs8 = -33*13/128
+       setf.s F_CS8 = R_TMP2
+       nop.f 0
+       // shift R_INDEX by 5
+       shl R_INDEX = R_INDEX, 5
+}
+
+{.mfi
+       // sqrt coefficient cs3 = 0.5 (set exponent = bias-1)
+       mov R_TMP4 = 0xffff - 1
+       nop.f 0
+       // sqrt coefficient cs6 = -21/16
+       mov R_TMP6 = 0xbfa8;;
+}
+
+
+{.mlx
+       // table index
+       add r2 = r2, R_INDEX
+       // sqrt coefficient cs7 = 33/16
+       movl R_TMP2 = 0x40040000;;
+}
+
+
+{.mmi
+       // load cs9 = 55*13/128
+       setf.s F_CS9 = R_TMP
+       // sqrt coefficient cs5 = 7/8
+       mov R_TMP3 = 0x3f60
+       // sqrt coefficient cs6 = 21/16
+       shl R_TMP6 = R_TMP6, 16;;
+}
+
+
+{.mmi
+       // load significand of 1/(1-t^2)
+       ldf8 F_INV_1T2 = [r2], 8
+       // sqrt coefficient cs7 = 33/16
+       setf.s F_CS7 = R_TMP2
+       // sqrt coefficient cs4 = -5/8
+       mov R_TMP5 = 0xbf20;;
+}
+
+
+{.mmi
+       // load significand of sqrt(1-t^2)
+       ldf8 F_SQRT_1T2 = [r2], 8
+       // sqrt coefficient cs6 = 21/16
+       setf.s F_CS6 = R_TMP6
+       // sqrt coefficient cs5 = 7/8
+       shl R_TMP3 = R_TMP3, 16;;
+}
+
+
+{.mmi
+       // sqrt coefficient cs3 = 0.5 (set exponent = bias-1)
+       setf.exp F_CS3 = R_TMP4
+       // r3 = pointer to polynomial coefficients
+       addl r3 = @ltoff(poly_coeffs), gp
+       // sqrt coefficient cs4 = -5/8
+       shl R_TMP5 = R_TMP5, 16;;
+}
+
+
+{.mfi
+       // sqrt coefficient cs5 = 7/8
+       setf.s F_CS5 = R_TMP3
+       // d = s-t
+       fms.s1 F_D = f8, f1, F_T
+       // set p6 = 1 if s<0, p11 = 1 if s> = 0
+       cmp.ge p6, p11 = R_EXP, R_DBL_S
+}
+
+{.mfi
+       // r3 = load start address to polynomial coefficients
+       ld8 r3 = [r3]
+       // s+t
+       fma.s1 F_S2T2 = f8, f1, F_T
+       nop.i 0;;
+}
+
+
+{.mfi
+       // sqrt coefficient cs4 = -5/8
+       setf.s F_CS4 = R_TMP5
+       // s^2-t^2
+       fma.s1 F_S2T2 = F_S2T2, F_D, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       // load C3
+       ldfe F_C3 = [r3], 16
+       // 0.5/(1-t^2) = 2^{-64}*(2^63/(1-t^2))
+       fma.s1 F_INV_1T2 = F_INV_1T2, F_2M64, f0
+       nop.i 0;;
+}
+
+{.mfi
+       // load C_5
+       ldfe F_C5 = [r3], 16
+       // set correct exponent for sqrt(1-t^2)
+       fma.s1 F_SQRT_1T2 = F_SQRT_1T2, F_2M64, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       // load C_7, C_9
+       ldfpd F_C7, F_C9 = [r3]
+       // x = -(s^2-t^2)/(1-t^2)/2
+       fnma.s1 F_X = F_INV_1T2, F_S2T2, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       // load asin(t)_high, asin(t)_low
+       ldfpd F_ATHI, F_ATLO = [r2]
+       // t*sqrt(1-t^2)
+       fma.s1 F_TSQRT = F_T, F_SQRT_1T2, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // cs9*x+cs8
+       fma.s1 F_S89 = F_CS9, F_X, F_CS8
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // cs7*x+cs6
+       fma.s1 F_S67 = F_CS7, F_X, F_CS6
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // cs5*x+cs4
+       fma.s1 F_S45 = F_CS5, F_X, F_CS4
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x*x
+       fma.s1 F_X2 = F_X, F_X, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (s-t)-t*x
+       fnma.s1 F_DTX = F_T, F_X, F_D
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // cs3*x+cs2 (cs2 = -0.5 = -cs3)
+       fms.s1 F_S23 = F_CS3, F_X, F_CS3
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // cs9*x^3+cs8*x^2+cs7*x+cs6
+       fma.s1 F_S69 = F_S89, F_X2, F_S67
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x^4
+       fma.s1 F_X4 = F_X2, F_X2, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // t*sqrt(1-t^2)*x^2
+       fma.s1 F_TSQRT = F_TSQRT, F_X2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // cs5*x^3+cs4*x^2+cs3*x+cs2
+       fma.s1 F_S25 = F_S45, F_X2, F_S23
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // ((s-t)-t*x)*sqrt(1-t^2)
+       fma.s1 F_DTX = F_DTX, F_SQRT_1T2, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // if sign is negative, negate table values: asin(t)_low
+ (p6) fnma.s1 F_ATLO = F_ATLO, f1, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // PS29 = cs9*x^7+..+cs5*x^3+cs4*x^2+cs3*x+cs2
+       fma.s1 F_S29 = F_S69, F_X4, F_S25
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // if sign is negative, negate table values: asin(t)_high
+ (p6) fnma.s1 F_ATHI = F_ATHI, f1, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // R = ((s-t)-t*x)*sqrt(1-t^2)-t*sqrt(1-t^2)*x^2*PS29
+       fnma.s1 F_R = F_S29, F_TSQRT, F_DTX
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // R^2
+       fma.s1 F_R2 = F_R, F_R, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c7+c9*R^2
+       fma.s1 F_P79 = F_C9, F_R2, F_C7
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2
+       fma.s1 F_P35 = F_C5, F_R2, F_C3
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // R^3
+       fma.s1 F_R4 = F_R2, F_R2, f0
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // R^3
+       fma.s1 F_R3 = F_R2, F_R, f0
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2+c7*R^4+c9*R^6
+       fma.s1 F_P39 = F_P79, F_R4, F_P35
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fma.s1 F_P39 = F_P39, F_R3, F_ATLO
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // R+asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fma.s1 F_P39 = F_P39, f1, F_R
+       nop.i 0;;
+}
+
+
+{.mfb
+       nop.m 0
+       // result = asin(t)_high+R+asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fma.s0 f8 = F_ATHI, f1, F_P39
+       // return
+       br.ret.sptk b0;;
+}
+
+
+
+
+LARGE_S:
+
+{.mfi
+       // bias-1
+       mov R_TMP3 = 0xffff - 1
+       // y ~ 1/sqrt(1-s^2)
+       frsqrta.s1 F_Y, p7 = F_1S2
+       // c9 = 55*13*17/128
+       mov R_TMP4 = 0x10af7b
+}
+
+{.mlx
+       // c8 = -33*13*15/128
+       mov R_TMP5 = 0x184923
+       movl R_TMP2 = 0xff00000000000000;;
+}
+
+{.mfi
+       // set p6 = 1 if s<0, p11 = 1 if s>0
+       cmp.ge p6, p11 = R_EXP, R_DBL_S
+       // 1-s^2
+       fnma.s1 F_1S2 = f8, f8, f1
+       // set p9 = 1
+       cmp.eq p9, p0 = r0, r0;;
+}
+
+
+{.mfi
+       // load 0.5
+       setf.exp F_05 = R_TMP3
+       // (1-s^2) rounded to single precision
+       fnma.s.s1 F_1S2_S = f8, f8, f1
+       // c9 = 55*13*17/128
+       shl R_TMP4 = R_TMP4, 10
+}
+
+{.mlx
+       // AND mask for getting t ~ sqrt(1-s^2)
+       setf.sig F_ANDMASK = R_TMP2
+       // OR mask
+       movl R_TMP2 = 0x0100000000000000;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (s^2)_s
+       fma.s.s1 F_S2 = f8, f8, f0
+       nop.i 0;;
+}
+
+
+{.mmi
+       // c9 = 55*13*17/128
+       setf.s F_CS9 = R_TMP4
+       // c7 = 33*13/16
+       mov R_TMP4 = 0x41d68
+       // c8 = -33*13*15/128
+       shl R_TMP5 = R_TMP5, 11;;
+}
+
+
+{.mfi
+       setf.sig F_ORMASK = R_TMP2
+       // y^2
+       fma.s1 F_Y2 = F_Y, F_Y, f0
+       // c7 = 33*13/16
+       shl R_TMP4 = R_TMP4, 12
+}
+
+{.mfi
+       // c6 = -33*7/16
+       mov R_TMP6 = 0xc1670
+       // y' ~ sqrt(1-s^2)
+       fma.s1 F_T1 = F_Y, F_1S2, f0
+       // c5 = 63/8
+       mov R_TMP7 = 0x40fc;;
+}
+
+
+{.mlx
+       // load c8 = -33*13*15/128
+       setf.s F_CS8 = R_TMP5
+       // c4 = -35/8
+       movl R_TMP5 = 0xc08c0000;;
+}
+
+{.mfi
+       // r3 = pointer to polynomial coefficients
+       addl r3 = @ltoff(poly_coeffs), gp
+       // 1-(1-s^2)_s
+       fnma.s1 F_DS = F_1S2_S, f1, f1
+       // p9 = 0 if p7 = 1 (p9 = 1 for special cases only)
+ (p7) cmp.ne p9, p0 = r0, r0
+}
+
+{.mlx
+       // load c7 = 33*13/16
+       setf.s F_CS7 = R_TMP4
+       // c3 = 5/2
+       movl R_TMP4 = 0x40200000;;
+}
+
+
+{.mfi
+       nop.m 0
+       // 1-(s^2)_s
+       fnma.s1 F_S_1S2S = F_S2, f1, f1
+       nop.i 0
+}
+
+{.mlx
+       // load c4 = -35/8
+       setf.s F_CS4 = R_TMP5
+       // c2 = -3/2
+       movl R_TMP5 = 0xbfc00000;;
+}
+
+
+{.mfi
+       // load c3 = 5/2
+       setf.s F_CS3 = R_TMP4
+       // x = (1-s^2)_s*y^2-1
+       fms.s1 F_X = F_1S2_S, F_Y2, f1
+       // c6 = -33*7/16
+       shl R_TMP6 = R_TMP6, 12
+}
+
+{.mfi
+       nop.m 0
+       // y^2/2
+       fma.s1 F_Y2_2 = F_Y2, F_05, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       // load c6 = -33*7/16
+       setf.s F_CS6 = R_TMP6
+       // eliminate lower bits from y'
+       fand F_T = F_T1, F_ANDMASK
+       // c5 = 63/8
+       shl R_TMP7 = R_TMP7, 16
+}
+
+{.mfb
+       // r3 = load start address to polynomial coefficients
+       ld8 r3 = [r3]
+       // 1-(1-s^2)_s-s^2
+       fnma.s1 F_DS = f8, f8, F_DS
+       // p9 = 1 if s is a special input (NaN, or |s|> = 1)
+ (p9) br.cond.spnt ASINL_SPECIAL_CASES;;
+}
+
+{.mmf
+       // get exponent, significand of y' (in single prec.)
+       getf.s R_TMP = F_T1
+       // load c3 = -3/2
+       setf.s F_CS2 = R_TMP5
+       // y*(1-s^2)
+       fma.s1 F_Y1S2 = F_Y, F_1S2, f0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // x' = (y^2/2)*(1-(s^2)_s)-0.5
+       fms.s1 F_XL = F_Y2_2, F_S_1S2S, F_05
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // s^2-(s^2)_s
+       fms.s1 F_S_DS2 = f8, f8, F_S2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // if s<0, set s = -s
+ (p6) fnma.s1 f8 = f8, f1, f0
+       nop.i 0;;
+}
+
+{.mfi
+       // load c5 = 63/8
+       setf.s F_CS5 = R_TMP7
+       // x = (1-s^2)_s*y^2-1+(1-(1-s^2)_s-s^2)*y^2
+       fma.s1 F_X = F_DS, F_Y2, F_X
+       // for t = 2^k*1.b1 b2.., get 7-k|b1.. b6
+       extr.u R_INDEX = R_TMP, 17, 9;;
+}
+
+
+{.mmi
+       // index = (4-exponent)|b1 b2.. b6
+       sub R_INDEX = R_INDEX, R_BIAS
+       nop.m 0
+       // get exponent of y
+       shr.u R_TMP2 = R_TMP, 23;;
+}
+
+{.mmi
+       // load C3
+       ldfe F_C3 = [r3], 16
+       // set p8 = 1 if y'<2^{-4}
+       cmp.gt p8, p0 = 0x7b, R_TMP2
+       // shift R_INDEX by 5
+       shl R_INDEX = R_INDEX, 5;;
+}
+
+
+{.mfb
+       // get table index for sqrt(1-t^2)
+       add r2 = r2, R_INDEX
+       // get t = 2^k*1.b1 b2.. b7 1
+       for F_T = F_T, F_ORMASK
+ (p8) br.cond.spnt VERY_LARGE_INPUT;;
+}
+
+
+
+{.mmf
+       // load C5
+       ldfe F_C5 = [r3], 16
+       // load 1/(1-t^2)
+       ldfp8 F_INV_1T2, F_SQRT_1T2 = [r2], 16
+       // x = ((1-s^2)*y^2-1)/2
+       fma.s1 F_X = F_X, F_05, f0;;
+}
+
+
+
+{.mmf
+       nop.m 0
+       // C7, C9
+       ldfpd F_C7, F_C9 = [r3], 16
+       // set correct exponent for t
+       fmerge.se F_T = F_T1, F_T;;
+}
+
+
+
+{.mfi
+       // pi/2 (low, high)
+       ldfpd F_PI2_LO, F_PI2_HI = [r3]
+       // c9*x+c8
+       fma.s1 F_S89 = F_X, F_CS9, F_CS8
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x^2
+       fma.s1 F_X2 = F_X, F_X, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)*x
+       fma.s1 F_Y1S2X = F_Y1S2, F_X, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c7*x+c6
+       fma.s1 F_S67 = F_X, F_CS7, F_CS6
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // 1-x
+       fnma.s1 F_1X = F_X, f1, f1
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3*x+c2
+       fma.s1 F_S23 = F_X, F_CS3, F_CS2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // 1-t^2
+       fnma.s1 F_1T2 = F_T, F_T, f1
+       nop.i 0
+}
+
+{.mfi
+       // load asin(t)_high, asin(t)_low
+       ldfpd F_ATHI, F_ATLO = [r2]
+       // c5*x+c4
+       fma.s1 F_S45 = F_X, F_CS5, F_CS4
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // t*s
+       fma.s1 F_TS = F_T, f8, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // 0.5/(1-t^2)
+       fma.s1 F_INV_1T2 = F_INV_1T2, F_2M64, f0
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // z~sqrt(1-t^2), rounded to 24 significant bits
+       fma.s.s1 F_Z = F_SQRT_1T2, F_2M64, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // sqrt(1-t^2)
+       fma.s1 F_SQRT_1T2 = F_SQRT_1T2, F_2M64, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)*x^2
+       fma.s1 F_Y1S2X2 = F_Y1S2, F_X2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x^4
+       fma.s1 F_X4 = F_X2, F_X2, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // s*t rounded to 24 significant bits
+       fma.s.s1 F_TSS = F_T, f8, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c9*x^3+..+c6
+       fma.s1 F_S69 = F_X2, F_S89, F_S67
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // ST = (t^2-1+s^2) rounded to 24 significant bits
+       fms.s.s1 F_ST = f8, f8, F_1T2
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c5*x^3+..+c2
+       fma.s1 F_S25 = F_X2, F_S45, F_S23
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // 0.25/(1-t^2)
+       fma.s1 F_INV1T2_2 = F_05, F_INV_1T2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // t*s-sqrt(1-t^2)*(1-s^2)*y
+       fnma.s1 F_TS = F_Y1S2, F_SQRT_1T2, F_TS
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // z*0.5/(1-t^2)
+       fma.s1 F_ZE = F_INV_1T2, F_SQRT_1T2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // z^2+t^2-1
+       fms.s1 F_DZ0 = F_Z, F_Z, F_1T2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (1-s^2-(1-s^2)_s)*x
+       fma.s1 F_DS2X = F_X, F_DS, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // t*s-(t*s)_s
+       fms.s1 F_DTS = F_T, f8, F_TSS
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c9*x^7+..+c2
+       fma.s1 F_S29 = F_X4, F_S69, F_S25
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*z
+       fma.s1 F_YZ = F_Z, F_Y, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // t^2
+       fma.s1 F_T2 = F_T, F_T, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // 1-t^2+ST
+       fma.s1 F_1T2_ST = F_ST, f1, F_1T2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)(1-x)
+       fma.s1 F_Y1S2_1X = F_Y1S2, F_1X, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // dz ~ sqrt(1-t^2)-z
+       fma.s1 F_DZ = F_DZ0, F_ZE, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // -1+correction for sqrt(1-t^2)-z
+       fnma.s1 F_CORR = F_INV1T2_2, F_DZ0, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (PS29*x^2+x)*y*(1-s^2)
+       fma.s1 F_S19 = F_Y1S2X2, F_S29, F_Y1S2X
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // z*y*(1-s^2)_s
+       fma.s1 F_ZY1S2S = F_YZ, F_1S2_S, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // s^2-(1-t^2+ST)
+       fms.s1 F_1T2_ST = f8, f8, F_1T2_ST
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (t*s-(t*s)_s)+z*y*(1-s^2-(1-s^2)_s)*x
+       fma.s1 F_DTS = F_YZ, F_DS2X, F_DTS
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // dz*y*(1-s^2)*(1-x)
+       fma.s1 F_DZ_TERM = F_DZ, F_Y1S2_1X, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // R = t*s-sqrt(1-t^2)*(1-s^2)*y+sqrt(1-t^2)*(1-s^2)*y*PS19
+       // (used for polynomial evaluation)
+       fma.s1 F_R = F_S19, F_SQRT_1T2, F_TS
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (PS29*x^2)*y*(1-s^2)
+       fma.s1 F_S29 = F_Y1S2X2, F_S29, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // apply correction to dz*y*(1-s^2)*(1-x)
+       fma.s1 F_DZ_TERM = F_DZ_TERM, F_CORR, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // R^2
+       fma.s1 F_R2 = F_R, F_R, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (t*s-(t*s)_s)+z*y*(1-s^2-(1-s^2)_s)*x+dz*y*(1-s^2)*(1-x)
+       fma.s1 F_DZ_TERM = F_DZ_TERM, f1, F_DTS
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c7+c9*R^2
+       fma.s1 F_P79 = F_C9, F_R2, F_C7
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2
+       fma.s1 F_P35 = F_C5, F_R2, F_C3
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // asin(t)_low-(pi/2)_low
+       fms.s1 F_ATLO = F_ATLO, f1, F_PI2_LO
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // R^4
+       fma.s1 F_R4 = F_R2, F_R2, f0
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // R^3
+       fma.s1 F_R3 = F_R2, F_R, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (t*s)_s-t^2*y*z
+       fnma.s1 F_TSS = F_T2, F_YZ, F_TSS
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // d(ts)+z*y*d(1-s^2)*x+dz*y*(1-s^2)*(1-x)+z*y*(s^2-1+t^2-ST)
+       fma.s1 F_DZ_TERM = F_YZ, F_1T2_ST, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (pi/2)_hi-asin(t)_hi
+       fms.s1 F_ATHI = F_PI2_HI, f1, F_ATHI
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2+c7*R^4+c9*R^6
+       fma.s1 F_P39 = F_P79, F_R4, F_P35
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // d(ts)+z*y*d(1-s^2)*x+dz*y*(1-s^2)*(1-x)+z*y*(s^2-1+t^2-ST)+
+       // + sqrt(1-t^2)*y*(1-s^2)*x^2*PS29
+       fma.s1 F_DZ_TERM = F_SQRT_1T2, F_S29, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (t*s)_s-t^2*y*z+z*y*ST
+       fma.s1 F_TSS = F_YZ, F_ST, F_TSS
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // -asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fms.s1 F_P39 = F_P39, F_R3, F_ATLO
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // if s<0, change sign of F_ATHI
+ (p6) fnma.s1 F_ATHI = F_ATHI, f1, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // d(ts)+z*y*d(1-s^2)*x+dz*y*(1-s^2)*(1-x)+z*y*(s^2-1+t^2-ST) +
+       // + sqrt(1-t^2)*y*(1-s^2)*x^2*PS29 +
+       // - asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fma.s1 F_DZ_TERM = F_P39, f1, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // d(ts)+z*y*d(1-s^2)*x+dz*y*(1-s^2)*(1-x)+z*y*(s^2-1+t^2-ST) +
+       // + sqrt(1-t^2)*y*(1-s^2)*x^2*PS29 + z*y*(1-s^2)_s*x +
+       // - asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6)
+       fma.s1 F_DZ_TERM = F_ZY1S2S, F_X, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // d(ts)+z*y*d(1-s^2)*x+dz*y*(1-s^2)*(1-x)+z*y*(s^2-1+t^2-ST) +
+       // + sqrt(1-t^2)*y*(1-s^2)*x^2*PS29 + z*y*(1-s^2)_s*x +
+       // - asin(t)_low+R^3*(c3+c5*R^2+c7*R^4+c9*R^6) +
+       // + (t*s)_s-t^2*y*z+z*y*ST
+       fma.s1 F_DZ_TERM = F_TSS, f1, F_DZ_TERM
+       nop.i 0;;
+}
+
+
+.pred.rel "mutex", p6, p11
+{.mfi
+       nop.m 0
+       // result: add high part of pi/2-table value
+       // s>0 in this case
+ (p11) fma.s0 f8 = F_DZ_TERM, f1, F_ATHI
+       nop.i 0
+}
+
+{.mfb
+       nop.m 0
+       // result: add high part of pi/2-table value
+       // if s<0
+ (p6) fnma.s0 f8 = F_DZ_TERM, f1, F_ATHI
+       br.ret.sptk b0;;
+}
+
+
+
+
+
+
+SMALL_S:
+
+       // use 15-term polynomial approximation
+
+{.mmi
+       // r3 = pointer to polynomial coefficients
+       addl r3 = @ltoff(poly_coeffs), gp;;
+       // load start address for coefficients
+       ld8 r3 = [r3]
+       mov R_TMP = 0x3fbf;;
+}
+
+
+{.mmi
+       add r2 = 64, r3
+       ldfe F_C3 = [r3], 16
+       // p7 = 1 if |s|<2^{-64} (exponent of s<bias-64)
+       cmp.lt p7, p0 = R_EXP0, R_TMP;;
+}
+
+{.mmf
+       ldfe F_C5 = [r3], 16
+       ldfpd F_C11, F_C13 = [r2], 16
+	   // 2^{-128}
+       fma.s1 F_2M128 = F_2M64, F_2M64, f0;;
+}
+
+{.mmf
+       ldfpd F_C7, F_C9 = [r3]
+       ldfpd F_C15, F_C17 = [r2]
+       // if |s|<2^{-64}, return s+2^{-128}*s
+ (p7) fma.s0 f8 = f8, F_2M128, f8;;
+}
+
+
+
+{.mfb
+       nop.m 0
+       // s^2
+       fma.s1 F_R2 = f8, f8, f0
+       // if |s|<2^{-64}, return s
+ (p7) br.ret.spnt b0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // s^3
+       fma.s1 F_R3 = f8, F_R2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // s^4
+       fma.s1 F_R4 = F_R2, F_R2, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c3+c5*s^2
+       fma.s1 F_P35 = F_C5, F_R2, F_C3
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c11+c13*s^2
+       fma.s1 F_P1113 = F_C13, F_R2, F_C11
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c7+c9*s^2
+       fma.s1 F_P79 = F_C9, F_R2, F_C7
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c15+c17*s^2
+       fma.s1 F_P1517 = F_C17, F_R2, F_C15
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // s^8
+       fma.s1 F_R8 = F_R4, F_R4, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c3+c5*s^2+c7*s^4+c9*s^6
+       fma.s1 F_P39 = F_P79, F_R4, F_P35
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c11+c13*s^2+c15*s^4+c17*s^6
+       fma.s1 F_P1117 = F_P1517, F_R4, F_P1113
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c3+..+c17*s^14
+       fma.s1 F_P317 = F_R8, F_P1117, F_P39
+       nop.i 0;;
+}
+
+
+{.mfb
+       nop.m 0
+       // result
+       fma.s0 f8 = F_P317, F_R3, f8
+       br.ret.sptk b0;;
+}
+
+
+{.mfb
+       nop.m 0
+       fma.s0 f8 = F_P317, F_R3, f0//F_P317, F_R3, F_S29
+       // nop.f 0//fma.s0 f8 = f13, f6, f0
+       br.ret.sptk b0;;
+}
+
+
+
+
+
+       VERY_LARGE_INPUT:
+
+{.mfi
+       nop.m 0
+       // s rounded to 24 significant bits
+       fma.s.s1 F_S = f8, f1, f0
+       nop.i 0
+}
+
+{.mfi
+       // load C5
+       ldfe F_C5 = [r3], 16
+       // x = ((1-(s^2)_s)*y^2-1)/2-(s^2-(s^2)_s)*y^2/2
+       fnma.s1 F_X = F_S_DS2, F_Y2_2, F_XL
+       nop.i 0;;
+}
+
+
+
+{.mmf
+       nop.m 0
+       // C7, C9
+       ldfpd F_C7, F_C9 = [r3], 16
+       nop.f 0;;
+}
+
+
+
+{.mfi
+       // pi/2 (low, high)
+       ldfpd F_PI2_LO, F_PI2_HI = [r3], 16
+       // c9*x+c8
+       fma.s1 F_S89 = F_X, F_CS9, F_CS8
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x^2
+       fma.s1 F_X2 = F_X, F_X, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)*x
+       fma.s1 F_Y1S2X = F_Y1S2, F_X, f0
+       nop.i 0
+}
+
+{.mfi
+       // C11, C13
+       ldfpd F_C11, F_C13 = [r3], 16
+       // c7*x+c6
+       fma.s1 F_S67 = F_X, F_CS7, F_CS6
+       nop.i 0;;
+}
+
+
+{.mfi
+       // C15, C17
+       ldfpd F_C15, F_C17 = [r3], 16
+       // c3*x+c2
+       fma.s1 F_S23 = F_X, F_CS3, F_CS2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c5*x+c4
+       fma.s1 F_S45 = F_X, F_CS5, F_CS4
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (s_s)^2
+       fma.s1 F_DS = F_S, F_S, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // 1-(s_s)^2
+       fnma.s1 F_1S2_S = F_S, F_S, f1
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)*x^2
+       fma.s1 F_Y1S2X2 = F_Y1S2, F_X2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // x^4
+       fma.s1 F_X4 = F_X2, F_X2, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c9*x^3+..+c6
+       fma.s1 F_S69 = F_X2, F_S89, F_S67
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c5*x^3+..+c2
+       fma.s1 F_S25 = F_X2, F_S45, F_S23
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // ((s_s)^2-s^2)
+       fnma.s1 F_DS = f8, f8, F_DS
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // (pi/2)_high-y*(1-(s_s)^2)
+       fnma.s1 F_HI = F_Y, F_1S2_S, F_PI2_HI
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c9*x^7+..+c2
+       fma.s1 F_S29 = F_X4, F_S69, F_S25
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // -(y*(1-(s_s)^2))_high
+       fms.s1 F_1S2_HI = F_HI, f1, F_PI2_HI
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (PS29*x^2+x)*y*(1-s^2)
+       fma.s1 F_S19 = F_Y1S2X2, F_S29, F_Y1S2X
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-(s_s)^2)-(y*(1-s^2))_high
+       fma.s1 F_DS2 = F_Y, F_1S2_S, F_1S2_HI
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // R ~ sqrt(1-s^2)
+       // (used for polynomial evaluation)
+       fnma.s1 F_R = F_S19, f1, F_Y1S2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // y*(1-s^2)-(y*(1-s^2))_high
+       fma.s1 F_DS2 = F_Y, F_DS, F_DS2
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // (pi/2)_low+(PS29*x^2)*y*(1-s^2)
+       fma.s1 F_S29 = F_Y1S2X2, F_S29, F_PI2_LO
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // R^2
+       fma.s1 F_R2 = F_R, F_R, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (pi/2)_low+(PS29*x^2)*y*(1-s^2)-(y*(1-s^2)-(y*(1-s^2))_high)
+       fms.s1 F_S29 = F_S29, f1, F_DS2
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c7+c9*R^2
+       fma.s1 F_P79 = F_C9, F_R2, F_C7
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2
+       fma.s1 F_P35 = F_C5, F_R2, F_C3
+       nop.i 0;;
+}
+
+
+
+{.mfi
+       nop.m 0
+       // R^4
+       fma.s1 F_R4 = F_R2, F_R2, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // R^3
+       fma.s1 F_R3 = F_R2, F_R, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c11+c13*R^2
+       fma.s1 F_P1113 = F_C13, F_R2, F_C11
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c15+c17*R^2
+       fma.s1 F_P1517 = F_C17, F_R2, F_C15
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (pi/2)_low+(PS29*x^2)*y*(1-s^2)-(y*(1-s^2)-(y*(1-s^2))_high)+y*(1-s^2)*x
+       fma.s1 F_S29 = F_Y1S2, F_X, F_S29
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c11+c13*R^2+c15*R^4+c17*R^6
+       fma.s1 F_P1117 = F_P1517, F_R4, F_P1113
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2+c7*R^4+c9*R^6
+       fma.s1 F_P39 = F_P79, F_R4, F_P35
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // R^8
+       fma.s1 F_R8 = F_R4, F_R4, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // c3+c5*R^2+c7*R^4+c9*R^6+..+c17*R^14
+       fma.s1 F_P317 = F_P1117, F_R8, F_P39
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // (pi/2)_low-(PS29*x^2)*y*(1-s^2)-(y*(1-s^2)-
+       // -(y*(1-s^2))_high)+y*(1-s^2)*x - P3, 17
+       fnma.s1 F_S29 = F_P317, F_R3, F_S29
+       nop.i 0;;
+}
+
+{.mfi
+       nop.m 0
+       // set sign
+  (p6) fnma.s1 F_S29 = F_S29, f1, f0
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+  (p6) fnma.s1 F_HI = F_HI, f1, f0
+       nop.i 0;;
+}
+
+
+{.mfb
+       nop.m 0
+       // Result:
+       // (pi/2)_low-(PS29*x^2)*y*(1-s^2)-(y*(1-s^2)-
+       // -(y*(1-s^2))_high)+y*(1-s^2)*x - P3, 17
+       // +(pi/2)_high-(y*(1-s^2))_high
+       fma.s0 f8 = F_S29, f1, F_HI
+       br.ret.sptk b0;;
+}
+
+
+
+
+
+
+
+
+
+       ASINL_SPECIAL_CASES:
+
+{.mfi
+       alloc r32 = ar.pfs, 1, 4, 4, 0
+       // check if the input is a NaN, or unsupported format
+       // (i.e. not infinity or normal/denormal)
+       fclass.nm p7, p8 = f8, 0x3f
+       // pointer to pi/2
+       add r3 = 48, r3;;
+}
+
+
+{.mfi
+       // load pi/2
+       ldfpd F_PI2_HI, F_PI2_LO = [r3]
+       // get |s|
+       fmerge.s F_S = f0, f8
+       nop.i 0
+}
+
+{.mfb
+       nop.m 0
+       // if NaN, quietize it, and return
+ (p7) fma.s0 f8 = f8, f1, f0
+ (p7) br.ret.spnt b0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // |s| = 1 ?
+       fcmp.eq.s0 p9, p0 = F_S, f1
+       nop.i 0
+}
+
+{.mfi
+       nop.m 0
+       // load FR_X
+       fma.s1 FR_X = f8, f1, f0
+       // load error tag
+       mov GR_Parameter_TAG = 60;;
+}
+
+
+{.mfb
+       nop.m 0
+       // change sign if s = -1
+ (p6)  fnma.s1 F_PI2_HI = F_PI2_HI, f1, f0
+       nop.b 0
+}
+
+{.mfb
+       nop.m 0
+       // change sign if s = -1
+ (p6)  fnma.s1 F_PI2_LO = F_PI2_LO, f1, f0
+       nop.b 0;;
+}
+
+{.mfb
+       nop.m 0
+       // if s = 1, result is pi/2
+ (p9) fma.s0 f8 = F_PI2_HI, f1, F_PI2_LO
+       // return if |s| = 1
+ (p9) br.ret.sptk b0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // get Infinity
+       frcpa.s1 FR_RESULT, p0 = f1, f0
+       nop.i 0;;
+}
+
+
+{.mfi
+       nop.m 0
+       // return QNaN indefinite (0*Infinity)
+       fma.s0 FR_RESULT = f0, FR_RESULT, f0
+       nop.i 0;;
+}
+
+
+GLOBAL_LIBM_END(asinl)
+libm_alias_ldouble_other (asin, asin)
+
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+// (1)
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                          // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                      // Save gp
+};;
+
+
+// (2)
+{ .mmi
+        stfe [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
+        add GR_Parameter_X = 16,sp            // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                     // Save b0
+};;
+
+.body
+// (3)
+{ .mib
+        stfe [GR_Parameter_X] = FR_X              // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfe [GR_Parameter_Y] = FR_RESULT             // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+
+// (4)
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_atan2.S
@@ -0,0 +1,1049 @@
+.file "atan2.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00  Initial version
+// 04/04/00  Unwind support added
+// 08/15/00  Bundle added after call to __libm_error_support to properly
+//           set [the previously overwritten] GR_Parameter_RESULT.
+// 08/17/00  Changed predicate register macro-usage to direct predicate
+//           names due to an assembler bug.
+// 09/28/00  Updated to set invalid on SNaN inputs
+// 01/19/01  Fixed flags for small results
+// 04/13/01  Rescheduled to make all paths faster
+// 05/20/02  Cleaned up namespace and sf0 syntax
+// 08/20/02  Corrected inexact flag and directed rounding symmetry bugs
+// 02/06/03  Reordered header: .section, .global, .proc, .align
+// 04/17/03  Added missing mutex directive
+// 12/23/03  atan2(NaN1,NaN2) now QNaN1, for consistency with atan2f, atan2l
+//
+// API
+//==============================================================
+// double atan2(double Y, double X)
+//
+// Overview of operation
+//==============================================================
+//
+// The atan2 function returns values in the interval [-pi,+pi].
+//
+// There are two basic paths: swap true and swap false.
+// atan2(Y,X) ==> atan2(V/U) where U >= V. If Y > X, we must swap.
+//
+// p6  swap True    |Y| > |X|
+// p7  swap False   |Y| <= |X|
+// p8  X+   (If swap=True p8=p9=0)
+// p9  X-
+//
+// all the other predicates p10 thru p15 are false for the main path
+//
+// Simple trigonometric identities show
+//   Region 1 (-45 to +45 degrees):
+//         X>0, |Y|<=X, V=Y, U=X     atan2(Y,X) = sgnY * (0 + atan(V/U))
+//
+//   Region 2 (-90 to -45 degrees, and +45 to +90 degrees):
+//         X>0, |Y|>X, V=X, U=Y      atan2(Y,X) = sgnY * (pi/2 - atan(V/U))
+//
+//   Region 3 (-135 to -90 degrees, and +90 to +135 degrees):
+//         X<0, |Y|>X, V=X, U=Y      atan2(Y,X) = sgnY * (pi/2 + atan(V/U))
+//
+//   Region 4 (-180 to -135 degrees, and +135 to +180 degrees):
+//         X<0, |Y|<=X, V=Y, U=X      atan2(Y,X) = sgnY * (pi - atan(V/U))
+//
+// So the result is always of the form atan2(Y,X) = P + sgnXY * atan(V/U)
+//
+// We compute atan(V/U) from the identity
+//      atan(z) + atan([(V/U)-z] / [1+(V/U)z])
+//      where z is a limited precision approximation (16 bits) to V/U
+//
+// z is calculated with the assistance of the frcpa instruction.
+//
+// atan(z) is calculated by a polynomial z + z^3 * p(w),  w=z^2
+// where p(w) = P0+P1*w+...+P22*w^22
+//
+// Let d = [(V/U)-z] / [1+(V/U)z]) = (V-U*z)/(U+V*z)
+//
+// Approximate atan(d) by d + P0*d^3
+// Let F = 1/(U+V*z) * (1-a), where |a|< 2^-8.8.
+// Compute q(a) = 1 + a + ... + a^5.
+// Then F*q(a) approximates the reciprocal to more than 50 bits.
+
+// Special values
+//==============================================================
+//              Y                 x          Result
+//             +number           +inf        +0
+//             -number           +inf        -0
+//             +number           -inf        +pi
+//             -number           -inf        -pi
+//
+//             +inf              +number     +pi/2
+//             -inf              +number     -pi/2
+//             +inf              -number     +pi/2
+//             -inf              -number     -pi/2
+//
+//             +inf              +inf        +pi/4
+//             -inf              +inf        -pi/4
+//             +inf              -inf        +3pi/4
+//             -inf              -inf        -3pi/4
+//
+//             +1                +1          +pi/4
+//             -1                +1          -pi/4
+//             +1                -1          +3pi/4
+//             -1                -1          -3pi/4
+//
+//             +number           +0          +pi/2
+//             -number           +0          -pi/2
+//             +number           -0          +pi/2
+//             -number           -0          -pi/2
+//
+//             +0                +number     +0
+//             -0                +number     -0
+//             +0                -number     +pi
+//             -0                -number     -pi
+//
+//             +0                +0          +0
+//             -0                +0          -0
+//             +0                -0          +pi
+//             -0                -0          -pi
+//
+//            Nan             anything      quiet Y
+//            Not NaN         NaN           quiet X
+
+// atan2(+-0/+-0) sets double error tag to 37
+
+// Registers used
+//==============================================================
+
+// predicate registers used:
+// p6 -> p15
+
+// floating-point registers used:
+// f8, f9 input
+// f32 -> f119
+
+// general registers used
+// r32 -> r41
+
+// Assembly macros
+//==============================================================
+
+EXP_AD_P1                    = r33
+EXP_AD_P2                    = r34
+rsig_near_one                = r35
+
+
+GR_SAVE_B0                   = r35
+GR_SAVE_GP                   = r36
+GR_SAVE_PFS                  = r37
+
+GR_Parameter_X               = r38
+GR_Parameter_Y               = r39
+GR_Parameter_RESULT          = r40
+atan2_GR_tag                 = r41
+
+atan2_Y                      = f8
+atan2_X                      = f9
+
+atan2_u1_X                   = f32
+atan2_u1_Y                   = f33
+atan2_z2_X                   = f34
+atan2_z2_Y                   = f35
+
+atan2_two                    = f36
+atan2_B1sq_Y                 = f37
+atan2_z1_X                   = f38
+atan2_z1_Y                   = f39
+atan2_B1X                    = f40
+
+atan2_B1Y                    = f41
+atan2_wp_X                   = f42
+atan2_B1sq_X                 = f43
+atan2_z                      = f44
+atan2_w                      = f45
+
+atan2_P0                     = f46
+atan2_P1                     = f47
+atan2_P2                     = f48
+atan2_P3                     = f49
+atan2_P4                     = f50
+
+atan2_P5                     = f51
+atan2_P6                     = f52
+atan2_P7                     = f53
+atan2_P8                     = f54
+atan2_P9                     = f55
+
+atan2_P10                    = f56
+atan2_P11                    = f57
+atan2_P12                    = f58
+atan2_P13                    = f59
+atan2_P14                    = f60
+
+atan2_P15                    = f61
+atan2_P16                    = f62
+atan2_P17                    = f63
+atan2_P18                    = f64
+atan2_P19                    = f65
+
+atan2_P20                    = f66
+atan2_P21                    = f67
+atan2_P22                    = f68
+atan2_tmp                    = f68
+atan2_pi_by_2                = f69
+atan2_sgn_pi_by_2            = f69
+atan2_V13                    = f70
+
+atan2_W11                    = f71
+atan2_E                      = f72
+atan2_wp_Y                   = f73
+atan2_V11                    = f74
+atan2_V12                    = f75
+
+atan2_V7                     = f76
+atan2_V8                     = f77
+atan2_W7                     = f78
+atan2_W8                     = f79
+atan2_W3                     = f80
+
+atan2_W4                     = f81
+atan2_V3                     = f82
+atan2_V4                     = f83
+atan2_F                      = f84
+atan2_gV                     = f85
+
+atan2_V10                    = f86
+atan2_zcub                   = f87
+atan2_V6                     = f88
+atan2_V9                     = f89
+atan2_W10                    = f90
+
+atan2_W6                     = f91
+atan2_W2                     = f92
+atan2_V2                     = f93
+atan2_alpha                  = f94
+atan2_alpha_1                = f95
+
+atan2_gVF                    = f96
+atan2_V5                     = f97
+atan2_W12                    = f98
+atan2_W5                     = f99
+atan2_alpha_sq               = f100
+
+atan2_Cp                     = f101
+atan2_V1                     = f102
+atan2_ysq                    = f103
+atan2_W1                     = f104
+atan2_alpha_cub              = f105
+
+atan2_C                      = f106
+atan2_xsq                    = f107
+atan2_d                      = f108
+atan2_A_hi                   = f109
+atan2_dsq                    = f110
+
+atan2_pd                     = f111
+atan2_A_lo                   = f112
+atan2_A                      = f113
+atan2_Pp                     = f114
+atan2_sgnY                   = f115
+
+atan2_sig_near_one           = f116
+atan2_near_one               = f116
+atan2_pi                     = f117
+atan2_sgn_pi                 = f117
+atan2_3pi_by_4               = f118
+atan2_pi_by_4                = f119
+
+
+/////////////////////////////////////////////////////////////
+
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(atan2_tb1)
+data8 0xA21922DC45605EA1 ,  0x00003FFA // P11
+data8 0xB199DD6D2675C40F ,  0x0000BFFA // P10
+data8 0xC2F01E5DDD100DBE ,  0x00003FFA // P9
+data8 0xD78F28FC2A592781 ,  0x0000BFFA // P8
+data8 0xF0F03ADB3FC930D3 ,  0x00003FFA // P7
+data8 0x88887EBB209E3543 ,  0x0000BFFB // P6
+data8 0x9D89D7D55C3287A5 ,  0x00003FFB // P5
+data8 0xBA2E8B9793955C77 ,  0x0000BFFB // P4
+data8 0xE38E38E320A8A098 ,  0x00003FFB // P3
+data8 0x9249249247E37913 ,  0x0000BFFC // P2
+data8 0xCCCCCCCCCCC906CD ,  0x00003FFC // P1
+data8 0xAAAAAAAAAAAAA8A9 ,  0x0000BFFD // P0
+data8 0xC90FDAA22168C235 ,  0x00004000 // pi
+LOCAL_OBJECT_END(atan2_tb1)
+
+LOCAL_OBJECT_START(atan2_tb2)
+data8 0xCE585A259BD8374C ,  0x00003FF0 // P21
+data8 0x9F90FB984D8E39D0 ,  0x0000BFF3 // P20
+data8 0x9D3436AABE218776 ,  0x00003FF5 // P19
+data8 0xDEC343E068A6D2A8 ,  0x0000BFF6 // P18
+data8 0xF396268151CFB11C ,  0x00003FF7 // P17
+data8 0xD818B4BB43D84BF2 ,  0x0000BFF8 // P16
+data8 0xA2270D30A90AA220 ,  0x00003FF9 // P15
+data8 0xD5F4F2182E7A8725 ,  0x0000BFF9 // P14
+data8 0x80D601879218B53A ,  0x00003FFA // P13
+data8 0x9297B23CCFFB291F ,  0x0000BFFA // P12
+data8 0xFE7E52D2A89995B3 ,  0x0000BFEC // P22
+data8 0xC90FDAA22168C235 ,  0x00003FFF // pi/2
+data8 0xC90FDAA22168C235 ,  0x00003FFE // pi/4
+data8 0x96cbe3f9990e91a8 ,  0x00004000 // 3pi/4
+LOCAL_OBJECT_END(atan2_tb2)
+
+
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(atan2)
+
+{ .mfi
+           alloc        r32           = ar.pfs,1,5,4,0
+           frcpa.s1     atan2_u1_X,p6 = f1,atan2_X
+           nop.i 999
+}
+{ .mfi
+           addl         EXP_AD_P1   = @ltoff(atan2_tb1), gp
+           fma.s1       atan2_two  = f1,f1,f1
+           nop.i 999
+;;
+}
+
+{ .mfi
+           ld8  EXP_AD_P1 = [EXP_AD_P1]
+           frcpa.s1     atan2_u1_Y,p7 = f1,atan2_Y
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_xsq  = atan2_X,atan2_X,f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fclass.m p10,p0 = atan2_Y, 0xc3     // Test for y=nan
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_ysq  = atan2_Y,atan2_Y,f0
+           nop.i 999
+}
+;;
+
+{ .mfi
+           add  EXP_AD_P2 = 0xd0,EXP_AD_P1
+           fclass.m p12,p0 = atan2_X, 0xc3     // Test for x nan
+           nop.i 999
+}
+;;
+
+
+// p10 Y NAN, quiet and return
+{ .mfi
+           ldfe         atan2_P11  = [EXP_AD_P1],16
+           fmerge.s     atan2_sgnY = atan2_Y,f1
+           nop.i 999
+}
+{ .mfb
+           ldfe         atan2_P21  = [EXP_AD_P2],16
+(p10)      fma.d.s0 f8 = atan2_X,atan2_Y,f0   // If y=nan, result quietized y
+(p10)      br.ret.spnt b0        // Exit if y=nan
+;;
+}
+
+
+{ .mfi
+           ldfe         atan2_P10  = [EXP_AD_P1],16
+           fma.s1       atan2_z1_X = atan2_u1_X, atan2_Y, f0
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P20  = [EXP_AD_P2],16
+           fnma.s1      atan2_B1X  = atan2_u1_X, atan2_X, atan2_two
+           nop.i 999
+;;
+}
+
+{ .mfi
+           ldfe         atan2_P9   = [EXP_AD_P1],16
+           fma.s1       atan2_z1_Y = atan2_u1_Y, atan2_X, f0
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P19  = [EXP_AD_P2],16
+           fnma.s1      atan2_B1Y  = atan2_u1_Y, atan2_Y, atan2_two
+           nop.i 999
+}
+;;
+
+{ .mfi
+           ldfe         atan2_P8   = [EXP_AD_P1],16
+           fma.s1       atan2_z2_X = atan2_u1_X, atan2_ysq, f0
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P18  = [EXP_AD_P2],16
+           fma.s1       atan2_z2_Y = atan2_u1_Y, atan2_xsq, f0
+           nop.i 999
+}
+;;
+
+// p10 ==> x  inf     y ?
+// p11 ==> x !inf     y ?
+{ .mfi
+           ldfe         atan2_P7   = [EXP_AD_P1],16
+           fclass.m p10,p11 = atan2_X, 0x23    // test for x inf
+           nop.i 999
+}
+{ .mfb
+           ldfe         atan2_P17  = [EXP_AD_P2],16
+(p12)      fma.d.s0        f8 = atan2_X,atan2_Y,f0     // If x nan, result quiet x
+(p12)      br.ret.spnt b0                 // Exit for x nan
+;;
+}
+
+// p6 true if swap,    means |y| >  |x|    or ysq > xsq
+// p7 true if no swap, means |x| >= |y|    or xsq >= ysq
+{ .mmf
+           ldfe         atan2_P6   = [EXP_AD_P1],16
+           ldfe         atan2_P16  = [EXP_AD_P2],16
+           fcmp.ge.s1 p7,p6    = atan2_xsq, atan2_ysq
+;;
+}
+
+{ .mfi
+           ldfe         atan2_P5   = [EXP_AD_P1],16
+           fma.s1       atan2_wp_X   = atan2_z1_X, atan2_z1_X, f0
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P15       = [EXP_AD_P2],16
+           fma.s1       atan2_B1sq_X = atan2_B1X, atan2_B1X, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           ldfe         atan2_P4   = [EXP_AD_P1],16
+(p6)       fma.s1       atan2_wp_Y   = atan2_z1_Y, atan2_z1_Y, f0
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P14  = [EXP_AD_P2],16
+(p6)       fma.s1       atan2_B1sq_Y = atan2_B1Y, atan2_B1Y, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           ldfe         atan2_P3        = [EXP_AD_P1],16
+(p6)       fma.s1       atan2_E         = atan2_z2_Y, atan2_B1Y, atan2_Y
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P13  = [EXP_AD_P2],16
+(p7)       fma.s1       atan2_E         = atan2_z2_X, atan2_B1X, atan2_X
+           nop.i 999
+;;
+}
+
+
+{ .mfi
+           ldfe         atan2_P2        = [EXP_AD_P1],16
+(p6)       fma.s1       atan2_z         = atan2_z1_Y, atan2_B1Y, f0
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P12  = [EXP_AD_P2],16
+(p7)       fma.s1       atan2_z         = atan2_z1_X, atan2_B1X, f0
+           nop.i 999
+;;
+}
+
+
+{ .mfi
+           ldfe         atan2_P1        = [EXP_AD_P1],16
+           fcmp.eq.s0  p14,p15=atan2_X,atan2_Y  // Dummy for denorm and invalid
+           nop.i 999
+}
+{ .mlx
+           ldfe         atan2_P22       = [EXP_AD_P2],16
+           movl         rsig_near_one = 0x8000000000000001 // signif near 1.0
+;;
+}
+
+
+// p12 ==> x  inf     y inf
+// p13 ==> x  inf     y !inf
+{ .mmf
+           ldfe         atan2_P0        = [EXP_AD_P1],16
+           ldfe         atan2_pi_by_2   = [EXP_AD_P2],16
+(p10)      fclass.m.unc p12,p13 = atan2_Y, 0x23  // x inf, test if y inf
+;;
+}
+
+{ .mfi
+           ldfe         atan2_pi        = [EXP_AD_P1],16
+(p6)       fma.s1       atan2_w         = atan2_wp_Y, atan2_B1sq_Y,f0
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_pi_by_4       = [EXP_AD_P2],16
+(p7)       fma.s1       atan2_w         = atan2_wp_X, atan2_B1sq_X,f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           ldfe         atan2_3pi_by_4       = [EXP_AD_P2],16
+(p11)      fclass.m.unc p9,p0 = atan2_Y, 0x23  // x not inf, test if y inf
+           nop.i 999
+;;
+}
+
+{ .mfi
+           setf.sig      atan2_sig_near_one = rsig_near_one
+(p12)      fcmp.gt.unc.s1 p10,p11 = atan2_X,f0 // x inf, y inf, test if x +inf
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+(p6)       fnma.s1       atan2_gV        = atan2_Y, atan2_z, atan2_X
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           frcpa.s1     atan2_F,p0     = f1, atan2_E
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+(p7)       fnma.s1       atan2_gV        = atan2_X, atan2_z, atan2_Y
+           nop.i 999
+;;
+}
+
+// p13 ==> x  inf     y !inf
+{ .mfi
+           nop.m 999
+(p13)      fcmp.gt.unc.s1 p14,p15 = atan2_X,f0 // x inf, y !inf, test if x +inf
+           nop.i 999
+}
+{ .mfb
+           nop.m 999
+(p9)       fma.d.s0  f8 = atan2_sgnY, atan2_pi_by_2, f0  // +-pi/2 if x !inf, y inf
+(p9)       br.ret.spnt b0      // exit if x not inf, y inf, result is +-pi/2
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V13       = atan2_w, atan2_P11, atan2_P10
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W11       = atan2_w, atan2_P21, atan2_P20
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V11       = atan2_w, atan2_P9, atan2_P8
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V12       = atan2_w, atan2_w, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V8        = atan2_w, atan2_P7 , atan2_P6
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W8        = atan2_w, atan2_P19, atan2_P18
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fnma.s1      atan2_alpha     = atan2_E, atan2_F, f1
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fnma.s1      atan2_alpha_1   = atan2_E, atan2_F, atan2_two
+           nop.i 999
+;;
+}
+
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V7        = atan2_w, atan2_P5 , atan2_P4
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W7        = atan2_w, atan2_P17, atan2_P16
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V4        = atan2_w, atan2_P3 , atan2_P2
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W4        = atan2_w, atan2_P15, atan2_P14
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V3        = atan2_w, atan2_P1 , atan2_P0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W3        = atan2_w, atan2_P13, atan2_P12
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V10       = atan2_V12, atan2_V13, atan2_V11
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_gVF       = atan2_gV, atan2_F, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_alpha_sq  = atan2_alpha, atan2_alpha, f0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_Cp        = atan2_alpha, atan2_alpha_1, f1
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V9        = atan2_V12, atan2_V12, f0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W10       = atan2_V12, atan2_P22 , atan2_W11
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V6        = atan2_V12, atan2_V8 , atan2_V7
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W6        = atan2_V12, atan2_W8 , atan2_W7
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V2        = atan2_V12, atan2_V4 , atan2_V3
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W2        = atan2_V12, atan2_W4  , atan2_W3
+           nop.i 999
+;;
+}
+
+// p8 ==> y   0     x?
+// p9 ==> y  !0     x?
+{ .mfi
+           nop.m 999
+           fclass.m p8,p9 = atan2_Y, 0x07  // Test for y=0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_zcub      = atan2_z, atan2_w, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_alpha_cub = atan2_alpha, atan2_alpha_sq, f0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_C         = atan2_gVF, atan2_Cp, f0
+           nop.i 999
+;;
+}
+
+// p12 ==>  y0     x0
+// p13 ==>  y0     x!0
+{ .mfi
+           nop.m 999
+(p8)       fclass.m.unc p12,p13 = atan2_X, 0x07  // y=0, test if x is 0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W12       = atan2_V9, atan2_V9, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V5        = atan2_V9, atan2_V10, atan2_V6
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W5        = atan2_V9, atan2_W10, atan2_W6
+           nop.i 999
+;;
+}
+
+
+// p9 ==>  y!0    x0
+{ .mfi
+           nop.m 999
+(p9)       fclass.m.unc p9,p0 = atan2_X, 0x07  // y not 0, test if x is 0
+           nop.i 999
+}
+// p10 ==> X +INF, Y +-INF
+{ .mfb
+           nop.m 999
+(p10)      fma.d.s0       f8 = atan2_sgnY, atan2_pi_by_4, f0 // x=+inf, y=inf
+(p10)      br.ret.spnt b0          // Exit for x=+inf, y=inf, result is +-pi/4
+;;
+}
+
+.pred.rel "mutex",p11,p14
+{ .mfi
+           nop.m 999
+(p14)      fmerge.s    f8 = atan2_sgnY, f0 // x=+inf, y !inf, result +-0
+           nop.i 999
+}
+// p11 ==> X -INF, Y +-INF
+{ .mfb
+           nop.m 999
+(p11)      fma.d.s0       f8 = atan2_sgnY, atan2_3pi_by_4, f0 // x=-inf, y=inf
+(p11)      br.ret.spnt b0          // Exit for x=-inf, y=inf, result is +-3pi/4
+;;
+}
+
+{ .mfi
+           nop.m 999
+(p13)      fcmp.gt.unc.s1 p10,p11 = atan2_X,f0 // x not 0, y=0, test if x>0
+           nop.i 999
+}
+{ .mfb
+           nop.m 999
+           fma.s1       atan2_d         = atan2_alpha_cub, atan2_C, atan2_C
+(p14)      br.ret.spnt b0         // Exit if x=+inf, y !inf, result +-0
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W12       = atan2_V9, atan2_W12, f0
+           nop.i 999
+}
+{ .mfb
+           nop.m 999
+(p9)       fma.d.s0       f8 = atan2_sgnY, atan2_pi_by_2, f0 // x=0, y not 0
+(p9)       br.ret.spnt b0      // Exit if x=0 and y not 0, result is +-pi/2
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V1        = atan2_V9, atan2_V5, atan2_V2
+           nop.i 999
+}
+{ .mfb
+           nop.m 999
+           fma.s1       atan2_W1        = atan2_V9, atan2_W5, atan2_W2
+(p12)      br.spnt ATAN2_ERROR            // Branch if x=0 and y=0
+;;
+}
+
+{ .mfi
+           nop.m 999
+(p10)      fmerge.s     f8              = atan2_sgnY, f0  // +-0 if x>0, y=0
+           nop.i 999
+}
+{ .mfb
+           nop.m 999
+(p11)      fma.d.s0        f8 = atan2_sgnY, atan2_pi, f0 // +-pi if x<0, y=0
+(p13)      br.ret.spnt b0      // Exit if x!0 and y=0
+;;
+}
+
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_pd        = atan2_P0, atan2_d, f0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_dsq       = atan2_d, atan2_d, f0
+           nop.i 999
+;;
+}
+
+
+{ .mfi
+           nop.m 999
+           fmerge.se    atan2_near_one = f1, atan2_sig_near_one // Const ~1.0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_Pp        = atan2_W12, atan2_W1, atan2_V1
+           nop.i 999
+;;
+}
+
+// p8 true if no swap and X positive
+// p9 true if no swap and X negative
+// both are false is swap is true
+{ .mfi
+           nop.m 999
+(p7)       fcmp.ge.unc.s1 p8,p9    = atan2_X,f0
+           nop.i 999
+}
+{ .mfb
+           nop.m 999
+(p15)      fma.d.s0        f8              = atan2_sgnY, atan2_pi, f0
+(p15)      br.ret.spnt b0         // Exit if x=-inf, y !inf, result +-pi
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_sgn_pi_by_2 = atan2_pi_by_2, atan2_sgnY, f0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_A_lo      = atan2_pd, atan2_dsq, atan2_d
+           nop.i 999
+;;
+}
+
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_sgn_pi = atan2_pi, atan2_sgnY, f0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_A_hi      = atan2_zcub, atan2_Pp, atan2_z
+           nop.i 999
+;;
+}
+
+
+// For |Y| <= |X| and X > 0, force inexact in case A_lo is zero
+{ .mfi
+           nop.m 999
+(p8)       fmpy.s0      atan2_tmp       = atan2_P22, atan2_P22
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_A         = atan2_A_hi, f1, atan2_A_lo
+           nop.i 999
+}
+// For |Y| <= |X| and X > 0, result is A_hi + A_lo
+{ .mfi
+           nop.m 999
+(p8)       fma.d.s0       f8         = atan2_A_hi, f1, atan2_A_lo
+           nop.i 999
+;;
+}
+
+.pred.rel "mutex",p6,p9
+// We perturb A by multiplying by 1.0+1ulp as we produce the result
+// in order to get symmetrically rounded results in directed rounding modes.
+// If we don't do this, there are a few cases where the trailing 11 bits of
+// the significand of the result, before converting to double, are zero.  These
+// cases do not round symmetrically in round to +infinity or round to -infinity.
+// The perturbation also insures that the inexact flag is set.
+// For |Y| > |X|, result is  +- pi/2 - (A_hi + A_lo)
+{ .mfi
+           nop.m 999
+(p6)       fnma.d.s0      f8        = atan2_A, atan2_near_one, atan2_sgn_pi_by_2
+           nop.i 999
+}
+// For |Y| <= |X|, and X < 0, result is  +- pi + (A_hi + A_lo)
+{ .mfb
+           nop.m 999
+(p9)       fma.d.s0        f8        = atan2_A, atan2_near_one, atan2_sgn_pi
+           br.ret.sptk  b0
+;;
+}
+
+ATAN2_ERROR:
+// Here if x=0 and y=0
+{ .mfi
+          nop.m 999
+          fclass.m p10,p11       = atan2_X,0x05  // Test if x=+0
+          nop.i 999
+}
+;;
+
+{ .mfi
+          mov        atan2_GR_tag     = 37
+(p10)     fmerge.s     f10             = atan2_sgnY, f0 // x=+0, y=0
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+(p11)     fma.d.s0        f10            = atan2_sgnY, atan2_pi, f0 // x=-0, y=0
+          nop.i 999
+;;
+}
+GLOBAL_IEEE754_END(atan2)
+libm_alias_double_other (__atan2, atan2)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+// (1)
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 999
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                          // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                      // Save gp
+};;
+
+
+// (2)
+{ .mmi
+        stfd [GR_Parameter_Y] = f8,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp            // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                     // Save b0
+};;
+
+.body
+// (3)
+{ .mib
+        stfd [GR_Parameter_X] = f9            // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = f10           // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support# // Call error handling function
+};;
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+
+// (4)
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_atan2f.S
@@ -0,0 +1,900 @@
+.file "atan2f.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+
+// History
+//==============================================================
+// 06/01/00 Initial version
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 08/17/00 Changed predicate register macro-usage to direct predicate
+//          names due to an assembler bug.
+// 01/05/01 Fixed flag settings for denormal input.
+// 01/19/01 Added documentation
+// 01/30/01 Improved speed
+// 02/06/02 Corrected .section statement
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+
+// Description
+//=========================================
+// The atan2 function computes the principle value of the arc tangent of y/x using
+// the signs of both arguments to determine the quadrant of the return value.
+// A domain error may occur if both arguments are zero.
+
+// The atan2 function returns the arc tangent of y/x in the range [-pi,+pi] radians.
+
+//..
+//..Let (v,u) = (y,x) if |y| <= |x|, and (v,u) = (x,y) otherwise. Note that
+//..v and u can be negative. We state the relationship between atan2(y,x) and
+//..atan(v/u).
+//..
+//..Let swap = false if v = y, and swap = true if v = x.
+//..Define C according to the matrix
+//..
+//..                   TABLE FOR C
+//..                              x +ve       x -ve
+//..   no swap (swap = false)    sgn(y)*0     sgn(y)*pi
+//..   swap    (swap = true )    sgn(y)*pi/2  sgn(y)*pi/2
+//..
+//..   atan2(y,x) =  C +  atan(v/u)  if no swap
+//..   atan2(y,x) =  C -  atan(v/u)  if  swap
+//..
+//..These relationship is more efficient to compute as we accommodate signs in v and u
+//..saving the need to obtain the absolute value before computation can proceed.
+//..
+//..Suppose (v,u) = (y,x), we calculate atan(v/u) as follows:
+//..A = y * frcpa(x)    (so A = (y/x)(1 - beta))
+//..atan(y/x) = atan(A) + atan( ((y/x)-A))/(1 + (y/x)A) ), the second term is
+//..a correction.
+//..atan(A) is approximated by a polynomial
+//..A + p1 A^3 + p2 A^5 + ... + p10 A^21,
+//..atan(G) is approximated as follows:
+//..Let G = (y - Ax)/(x + Ay), atan(G) can be approximated by G + g * p1
+//..where g is a limited precision approximation to G via g = (y - Ax)*frcpa(x + Ay).
+//..
+//..Suppose (v,u) = (x,y), we calculate atan(v/u) as follows:
+//..Z = x * frcpa(y)    (so Z = (x/y)(1 - beta))
+//..atan(x/y) = atan(Z) + atan( ((x/y)-Z))/(1 + (x/y)Z) ), the second term is
+//..a correction.
+//..atan(Z) is approximated by a polynomial
+//..Z + p1 Z^3 + p2 Z^5 + ... + p10 Z^21,
+//..atan(T) is approximated as follows:
+//..Let T = (x - Ay)/(y + Ax), atan(T) can be approximated by T + t * p1
+//..where t is a limited precision approximation to T via t = (x - Ay)*frcpa(y + Ax).
+//..
+//..
+//..A = y * frcpa(x)
+//..atan(A) ~=~ A + p1 A^3 + ... + P10 A^21
+//..
+//..This polynomial is computed as follows:
+//..Asq = A*A; Acub = A*Asq, A4 = Asq*Asq
+//..A5 = Asq*Acub, A6 = Asq*A4; A11 = A5 * A6
+//..
+//..poly_A1 = p9 + Asq*p10, poly_A2 = p7 + Asq*p8, poly_A3 = p5 + Asq*p6
+//..poly_A1 = poly_A2 + A4 * poly_A1
+//..poly_A1 = poly_A3 + A4 * poly_A1
+//..
+//..poly_A4 = p1 * A
+//,,poly_A5 = p3 + Asq * p4, poly_A4 = A + Asq*poly_A4
+//..poly_A5 = p2 + Asq * poly_A5
+//..poly_A4 = poly_A4 + A5 * poly_A5
+//..
+//..atan_A = poly_A4 + A11 * poly_A1
+//..
+//..atan(G) is approximated as follows:
+//..G_numer = y - A*x, G_denom = x + A*y
+//..H1 = frcpa(G_denom)
+//..H_beta = 1 - H1 * G_denom
+//..H2 = H1 + H1 * H_beta
+//..H_beta2 = H_beta*H_beta
+//..H3 = H2 + H2*H_beta2
+//..g = H1 * G_numer; gsq = g*g; atan_G = g*p1, atan_G = atan_G*gsq
+//..atan_G = G_numer*H3 + atan_G
+//..
+//..
+//..A = y * frcpa(x)
+//..atan(A) ~=~ A + p1 A^3 + ... + P10 A^21
+//..
+//..This polynomial is computed as follows:
+//..Asq = A*A; Acub = A*Asq, A4 = Asq*Asq
+//..A5 = Asq*Acub, A6 = Asq*A4; A11 = A5 * A6
+//..
+//..poly_A1 = p9 + Asq*p10, poly_A2 = p7 + Asq*p8, poly_A3 = p5 + Asq*p6
+//..poly_A1 = poly_A2 + A4 * poly_A1
+//..poly_A1 = poly_A3 + A4 * poly_A1
+//..
+//..poly_A4 = p1 * A
+//,,poly_A5 = p3 + Asq * p4, poly_A4 = A + Asq*poly_A4
+//..poly_A5 = p2 + Asq * poly_A5
+//..poly_A4 = poly_A4 + A5 * poly_A5
+//..
+//..atan_A = poly_A4 + A11 * poly_A1
+//..
+//..
+//..====================================================================
+//..	COEFFICIENTS USED IN THE COMPUTATION
+//..====================================================================
+
+//coef_pj, j = 1,2,...,10;  atan(A) ~=~ A + p1 A^3 + p2 A^5 + ... + p10 A^21
+//
+//  coef_p1          =      -.3333332707155439167401311806315789E+00
+//  coef_p1   in dbl = BFD5 5555 1219 1621
+//
+//  coef_p2          =       .1999967670926658391827857030875748E+00
+//  coef_p2   in dbl = 3FC9 997E 7AFB FF4E
+//
+//  coef_p3          =      -.1427989384500152360161563301087296E+00
+//  coef_p3   in dbl = BFC2 473C 5145 EE38
+//
+//  coef_p4          =       .1105852823460720770079031213661163E+00
+//  coef_p4   in dbl = 3FBC 4F51 2B18 65F5
+//
+//  coef_p5          =      -.8811839915595312348625710228448363E-01
+//  coef_p5   in dbl = BFB6 8EED 6A8C FA32
+//
+//  coef_p6          =       .6742329836955067042153645159059714E-01
+//  coef_p6   in dbl = 3FB1 42A7 3D7C 54E3
+//
+//  coef_p7          =      -.4468571068774672908561591262231909E-01
+//  coef_p7   in dbl = BFA6 E10B A401 393F
+//
+//  coef_p8          =       .2252333246746511135532726960586493E-01
+//  coef_p8   in dbl = 3F97 105B 4160 F86B
+//
+//  coef_p9          =      -.7303884867007574742501716845542314E-02
+//  coef_p9   in dbl = BF7D EAAD AA33 6451
+//
+//  coef_p10         =       .1109686868355312093949039454619058E-02
+//  coef_p10  in dbl = 3F52 2E5D 33BC 9BAA
+//
+
+// Special values
+//==============================================================
+//              Y                 x          Result
+//             +number           +inf        +0
+//             -number           +inf        -0
+//             +number           -inf        +pi
+//             -number           -inf        -pi
+//
+//             +inf              +number     +pi/2
+//             -inf              +number     -pi/2
+//             +inf              -number     +pi/2
+//             -inf              -number     -pi/2
+//
+//             +inf              +inf        +pi/4
+//             -inf              +inf        -pi/4
+//             +inf              -inf        +3pi/4
+//             -inf              -inf        -3pi/4
+//
+//             +1                +1          +pi/4
+//             -1                +1          -pi/4
+//             +1                -1          +3pi/4
+//             -1                -1          -3pi/4
+//
+//             +number           +0          +pi/2    // does not raise DBZ
+//             -number           +0          -pi/2    // does not raise DBZ
+//             +number           -0          +pi/2    // does not raise DBZ
+//             -number           -0          -pi/2    // does not raise DBZ
+//
+//             +0                +number     +0
+//             -0                +number     -0
+//             +0                -number     +pi
+//             -0                -number     -pi
+//
+//             +0                +0          +0      // does not raise invalid
+//             -0                +0          -0      // does not raise invalid
+//             +0                -0          +pi     // does not raise invalid
+//             -0                -0          -pi     // does not raise invalid
+//
+//            Nan             anything      quiet Y
+//            anything        NaN           quiet X
+
+// atan2(+-0/+-0) sets double error tag to 37
+// atan2f(+-0/+-0) sets single error tag to 38
+// These are domain errors.
+
+
+//
+// Assembly macros
+//=========================================
+
+
+// integer registers
+atan2f_GR_Addr_1              = r33
+atan2f_GR_Addr_2              = r34
+GR_SAVE_B0                    = r35
+
+GR_SAVE_PFS                   = r36
+GR_SAVE_GP                    = r37
+
+GR_Parameter_X                = r38
+GR_Parameter_Y                = r39
+GR_Parameter_RESULT           = r40
+GR_Parameter_TAG              = r41
+
+// floating point registers
+atan2f_coef_p1         = f32
+atan2f_coef_p10        = f33
+atan2f_coef_p7         = f34
+atan2f_coef_p6         = f35
+
+atan2f_coef_p3         = f36
+atan2f_coef_p2         = f37
+atan2f_coef_p9         = f38
+atan2f_coef_p8         = f39
+atan2f_coef_p5         = f40
+
+atan2f_coef_p4         = f41
+atan2f_const_piby2     = f42
+atan2f_const_pi        = f43
+atan2f_const_piby4     = f44
+atan2f_const_3piby4    = f45
+
+atan2f_xsq             = f46
+atan2f_ysq             = f47
+atan2f_xy              = f48
+atan2f_const_1         = f49
+atan2f_sgn_Y           = f50
+
+atan2f_Z0              = f51
+atan2f_A0              = f52
+atan2f_Z               = f53
+atan2f_A               = f54
+atan2f_C               = f55
+
+atan2f_U               = f56
+atan2f_Usq             = f57
+atan2f_U4              = f58
+atan2f_U6              = f59
+atan2f_U8              = f60
+
+atan2f_poly_u109       = f61
+atan2f_poly_u87        = f62
+atan2f_poly_u65        = f63
+atan2f_poly_u43        = f64
+atan2f_poly_u21        = f65
+
+atan2f_poly_u10to7     = f66
+atan2f_poly_u6to3      = f67
+atan2f_poly_u10to3     = f68
+atan2f_poly_u10to0     = f69
+atan2f_poly_u210       = f70
+
+atan2f_T_numer         = f71
+atan2f_T_denom         = f72
+atan2f_G_numer         = f73
+atan2f_G_denom         = f74
+atan2f_p1rnum          = f75
+
+atan2f_R_denom         = f76
+atan2f_R_numer         = f77
+atan2f_pR              = f78
+atan2f_pRC             = f79
+atan2f_pQRC            = f80
+
+atan2f_Q1              = f81
+atan2f_Q_beta          = f82
+atan2f_Q2              = f83
+atan2f_Q_beta2         = f84
+atan2f_Q3              = f85
+
+atan2f_r               = f86
+atan2f_rsq             = f87
+atan2f_poly_atan_U     = f88
+
+
+// predicate registers
+//atan2f_Pred_Swap     = p6 // |y| >  |x|
+//atan2f_Pred_noSwap   = p7 // |y| <= |x|
+//atan2f_Pred_Xpos     = p8 //  x  >=  0
+//atan2f_Pred_Xneg     = p9 //  x  <   0
+
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(atan2f_coef_table1)
+data8 0xBFD5555512191621 // p1
+data8 0x3F522E5D33BC9BAA // p10
+data8 0xBFA6E10BA401393F // p7
+data8 0x3FB142A73D7C54E3 // p6
+data8 0xBFC2473C5145EE38 // p3
+data8 0x3FC9997E7AFBFF4E // p2
+LOCAL_OBJECT_END(atan2f_coef_table1)
+
+LOCAL_OBJECT_START(atan2f_coef_table2)
+data8 0xBF7DEAADAA336451 // p9
+data8 0x3F97105B4160F86B // p8
+data8 0xBFB68EED6A8CFA32 // p5
+data8 0x3FBC4F512B1865F5 // p4
+data8 0x3ff921fb54442d18 // pi/2
+data8 0x400921fb54442d18 // pi
+data8 0x3fe921fb54442d18 // pi/4
+data8 0x4002d97c7f3321d2 // 3pi/4
+LOCAL_OBJECT_END(atan2f_coef_table2)
+
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(atan2f)
+
+{     .mfi
+     alloc      r32           = ar.pfs,1,5,4,0
+     frcpa.s1  atan2f_Z0,p0     =    f1,f8   // Approx to 1/y
+     nop.i  999
+}
+{     .mfi
+     addl      atan2f_GR_Addr_1    =    @ltoff(atan2f_coef_table1),gp
+     fma.s1    atan2f_xsq     =    f9,f9,f0
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     ld8       atan2f_GR_Addr_1    =    [atan2f_GR_Addr_1]
+     frcpa.s1  atan2f_A0,p0     =    f1,f9   // Approx to 1/x
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_ysq     =    f8,f8,f0
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m  999
+     fcmp.ge.s1     p8,p9  =    f9,f0  // Set p8 if x>=0, p9 if x<0
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_xy     =    f9,f8,f0
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     add   atan2f_GR_Addr_2 = 0x30, atan2f_GR_Addr_1
+     fmerge.s  atan2f_sgn_Y   =    f8,f1
+     nop.i  999 ;;
+}
+
+{     .mmf
+     ldfpd     atan2f_coef_p1,atan2f_coef_p10 =    [atan2f_GR_Addr_1],16
+     ldfpd     atan2f_coef_p9,atan2f_coef_p8 =    [atan2f_GR_Addr_2],16
+     fclass.m  p10,p0 =    f9,0xe7	// Test x @inf|@snan|@qnan|@zero
+}
+;;
+
+{     .mfi
+     ldfpd     atan2f_coef_p7,atan2f_coef_p6 =    [atan2f_GR_Addr_1],16
+     fma.s1    atan2f_T_denom =    atan2f_Z0,atan2f_xsq,f8
+     nop.i  999
+}
+{     .mfi
+     ldfpd     atan2f_coef_p5,atan2f_coef_p4     =    [atan2f_GR_Addr_2],16
+     fma.s1    atan2f_Z                      =    atan2f_Z0,f9,f0
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     ldfpd     atan2f_coef_p3,atan2f_coef_p2 =    [atan2f_GR_Addr_1],16
+     fma.s1    atan2f_G_denom =    atan2f_A0,atan2f_ysq,f9
+     nop.i  999
+}
+{     .mfi
+     ldfpd     atan2f_const_piby2,atan2f_const_pi =    [atan2f_GR_Addr_2],16
+     fma.s1    atan2f_A                           =    atan2f_A0,f8,f0
+     nop.i  999 ;;
+}
+
+{     .mfi
+     ldfpd     atan2f_const_piby4,atan2f_const_3piby4 = [atan2f_GR_Addr_2]
+     fclass.m  p11,p0 = f8,0xe7	// Test y @inf|@snan|@qnan|@zero
+     nop.i  999
+}
+{     .mfb
+     nop.m  999
+     fnma.s1   atan2f_T_numer =    atan2f_Z0,atan2f_xy,f9
+(p10) br.cond.spnt ATAN2F_XY_INF_NAN_ZERO ;;   // Branch on x nan,inf,zero
+}
+
+
+// p6 if |y|>|x|, p7 if |x|>=|y| , use xsq and ysq for test
+{     .mfi
+     nop.m  999
+     fcmp.gt.s1 p6,p7 = atan2f_ysq,atan2f_xsq
+     nop.i  999
+}
+{     .mfb
+     nop.m  999
+     fnma.s1   atan2f_G_numer =    atan2f_A0,atan2f_xy,f8
+(p11) br.cond.spnt ATAN2F_XY_INF_NAN_ZERO ;;  // Branch on y nan,inf,zero
+}
+
+
+{     .mfi
+     nop.m  999
+(p8) fma.s1    atan2f_const_1 =    atan2f_sgn_Y,f0,f0
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+(p9) fma.s1    atan2f_const_1 =    atan2f_sgn_Y,f1,f0
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     nop.m  999
+(p6) fnma.s1    atan2f_U       =    atan2f_Z,f1,f0
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+(p6) fma.s1    atan2f_Usq     =    atan2f_Z,atan2f_Z,f0
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     nop.m  999
+(p7) fma.s1    atan2f_U       =    atan2f_A,f1,f0
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+(p7) fma.s1    atan2f_Usq     =    atan2f_A,atan2f_A,f0
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     nop.m  999
+(p6) frcpa.s1  atan2f_Q1,p0    =    f1,atan2f_T_denom
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+(p6) fma.s1    atan2f_R_denom =   atan2f_T_denom,f1,f0
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     nop.m  999
+(p7) frcpa.s1  atan2f_Q1,p0    =    f1,atan2f_G_denom
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+(p7) fma.s1    atan2f_R_denom =   atan2f_G_denom,f1,f0
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     nop.m  999
+(p6) fnma.s1    atan2f_R_numer =   atan2f_T_numer,f1,f0
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+(p7) fma.s1    atan2f_R_numer =   atan2f_G_numer,f1,f0
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     nop.m  999
+(p6) fnma.s1    atan2f_p1rnum =   atan2f_T_numer,atan2f_coef_p1,f0
+     nop.i  999 ;;
+}
+{     .mfi
+     nop.m  999
+(p7) fma.s1    atan2f_p1rnum =   atan2f_G_numer,atan2f_coef_p1,f0
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_U4 =    atan2f_Usq,atan2f_Usq,f0
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_poly_u109 = atan2f_Usq,atan2f_coef_p10,atan2f_coef_p9
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_poly_u87 =    atan2f_Usq,atan2f_coef_p8,atan2f_coef_p7
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_poly_u65 =    atan2f_Usq,atan2f_coef_p6,atan2f_coef_p5
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_poly_u43 =    atan2f_Usq,atan2f_coef_p4,atan2f_coef_p3
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+     fnma.s1   atan2f_Q_beta  =    atan2f_Q1,atan2f_R_denom,f1
+     nop.i  999 ;;
+}
+
+
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_poly_u21 =    atan2f_Usq,atan2f_coef_p2,atan2f_coef_p1
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_r  =    atan2f_Q1,atan2f_R_numer,f0
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m  999
+(p6) fma.s1    atan2f_C  =    atan2f_sgn_Y,atan2f_const_piby2,f0
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+(p7) fma.s1    atan2f_C  =    atan2f_const_1,atan2f_const_pi,f0
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_U6 =    atan2f_U4,atan2f_Usq,f0
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_U8 =    atan2f_U4,atan2f_U4,f0
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_poly_u10to7 = atan2f_U4,atan2f_poly_u109,atan2f_poly_u87
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_pR = atan2f_p1rnum,atan2f_Q1,f0
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_poly_u6to3 = atan2f_U4,atan2f_poly_u65,atan2f_poly_u43
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_Q2 =    atan2f_Q1,atan2f_Q_beta,atan2f_Q1
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_Q_beta2 =    atan2f_Q_beta,atan2f_Q_beta,f0
+     nop.i  999
+}
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_rsq     =    atan2f_r,atan2f_r,f0
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_poly_u210 = atan2f_Usq,atan2f_poly_u21,f1
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m 999
+     fcmp.eq.s0 p8,p0 = f8,f9      // Dummy op to set flag on denormal inputs
+     nop.i 999
+}
+{     .mfi
+     nop.m  999
+     fma.s1 atan2f_poly_u10to3 = atan2f_U8,atan2f_poly_u10to7,atan2f_poly_u6to3
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m                 999
+     fma.s1    atan2f_Q3 =    atan2f_Q2,atan2f_Q_beta2,atan2f_Q2
+     nop.i                 999
+}
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_pRC = atan2f_rsq,atan2f_pR,atan2f_C
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m  999
+     fma.s1 atan2f_poly_u10to0 = atan2f_U6,atan2f_poly_u10to3,atan2f_poly_u210
+     nop.i  999 ;;
+}
+
+{     .mfi
+     nop.m  999
+     fma.s1    atan2f_pQRC = atan2f_R_numer,atan2f_Q3,atan2f_pRC
+     nop.i  999 ;;
+}
+
+{     .mfb
+     nop.m  999
+     fma.s.s0    f8 = atan2f_U,atan2f_poly_u10to0,atan2f_pQRC
+     br.ret.sptk b0 ;;
+}
+
+
+
+ATAN2F_XY_INF_NAN_ZERO:
+
+{ .mfi
+      nop.m 999
+      fclass.m   p10,p0 = f8,0xc3	// Is y nan
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m   p12,p0 = f9,0xc3	// Is x nan
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m   p6,p0 = f9,0x21	// Is x +inf
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+(p10) fma.s.s0 f8  = f9,f8,f0          // Result quietized y if y is nan
+(p10) br.ret.spnt b0                // Exit if y is nan
+}
+;;
+
+
+{ .mfi
+      nop.m 999
+(p6)  fclass.m.unc   p7,p8 = f8,0x23	// x +inf, is y inf
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+(p12) fnorm.s.s0 f8 = f9               // Result quietized x if x is nan, y not nan
+(p12) br.ret.spnt b0                // Exit if x is nan, y not nan
+}
+;;
+
+// Here if x or y inf, or x or y zero
+{ .mfi
+      nop.m 999
+      fcmp.eq.s0 p15,p0 = f8,f9     // Dummy op to set flag on denormal inputs
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m   p11,p12 = f9,0x22	// Is x -inf
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+(p7)  fma.s.s0 f8 = atan2f_sgn_Y, atan2f_const_piby4,f0 // Result +-pi/4
+(p7)  br.ret.spnt b0            // Exit if x +inf and y inf
+}
+;;
+
+{ .mfb
+      nop.m 999
+(p8)  fmerge.s   f8 = f8,f0     // If x +inf and y not inf, result +-0
+(p8)  br.ret.spnt b0            // Exit if x +inf and y not inf
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p12) fclass.m.unc   p13,p0 = f8,0x23	// x not -inf, is y inf
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p11) fclass.m.unc   p14,p15 = f8,0x23	// x -inf, is y inf
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m  p6,p7 = f9,0x7	// Is x zero
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+(p13) fma.s.s0   f8 = atan2f_sgn_Y, atan2f_const_piby2,f0 // Result +-pi/2
+(p13) br.ret.spnt b0           // Exit if x not -inf and y inf
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p14) fma.s.s0   f8 = atan2f_sgn_Y, atan2f_const_3piby4,f0 // Result +-3pi/4
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+(p15) fma.s.s0   f8 = atan2f_sgn_Y, atan2f_const_pi,f0 // Result +-pi
+(p11) br.ret.spnt b0           // Exit if x -inf
+}
+;;
+
+// Here if x or y zero
+{ .mfi
+      nop.m 999
+(p7)  fclass.m.unc   p8,p9 = f9,0x19	// x not zero, y zero, is x > zero
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p6)  fclass.m.unc   p10,p11 = f8,0x7	// x zero, is y zero
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p8)  fmerge.s  f8 = f8, f0  // x > zero and y zero, result is +-zero
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+(p9)  fma.s.s0  f8 = atan2f_sgn_Y, atan2f_const_pi,f0 // x < 0, y 0, result +-pi
+(p10) br.cond.spnt   __libm_error_region // Branch if x zero and y zero
+}
+;;
+
+{ .mfb
+      nop.m 999
+(p11) fma.s.s0  f8 = atan2f_sgn_Y, atan2f_const_piby2,f0 // x zero, y not zero
+      br.ret.sptk b0         // Final special case exit
+}
+;;
+
+
+GLOBAL_IEEE754_END(atan2f)
+libm_alias_float_other (__atan2, atan2)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+         mov            GR_Parameter_TAG      = 38
+         fclass.m       p10,p11               = f9,0x5	// @zero | @pos
+;;
+(p10)    fmerge.s       f10                   = f8, f0
+(p11)    fma.s.s0          f10                   = atan2f_sgn_Y, atan2f_const_pi,f0
+;;
+
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 999
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+}
+;;
+
+{ .mmi
+        stfs [GR_Parameter_Y] = f9,16         // Store Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+}
+;;
+
+
+.body
+{ .mib
+        stfs [GR_Parameter_X] = f8            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfs [GR_Parameter_Y] = f10       // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#   // Call error handling function
+}
+;;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+
+{ .mmi
+        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+}
+;;
+
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+}
+;;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_atan2l.c
@@ -0,0 +1 @@
+/* Not needed. */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_atanh.S
@@ -0,0 +1,1071 @@
+.file "atanh.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// ==============================================================
+// History
+// ==============================================================
+// 05/03/01  Initial version
+// 05/20/02  Cleaned up namespace and sf0 syntax
+// 02/06/03  Reordered header: .section, .global, .proc, .align
+// 05/26/03  Improved performance, fixed to handle unorms
+// 03/31/05  Reformatted delimiters between data tables
+//
+// API
+// ==============================================================
+// double atanh(double)
+//
+// Overview of operation
+// ==============================================================
+//
+// There are 7 paths:
+// 1. x = +/-0.0
+//    Return atanh(x) = +/-0.0
+//
+// 2. 0.0 < |x| < 1/4
+//    Return atanh(x) = Po2l(x),
+//    where Po2l(x) = (((((((((C9*x^2 + C8)*x^2 + C7)*x^2 + C6)*x^2 +
+//          C5)*x^2 + C4)*x^2 + C3)*x^2 + C2)*x^2 + C1)* x^2 + C0)*x^3 + x
+// 3. 1/4 <= |x| < 1
+//    Return atanh(x) = sign(x) * log((1 + |x|)/(1 - |x|))
+//    To compute (1 + |x|)/(1 - |x|) modified Newton Raphson method is used
+//    (3 iterations)
+//    Algorithm description for log function see below.
+//
+// 4. |x| = 1
+//    Return atanh(x) = sign(x) * +INF
+//
+// 5. 1 < |x| <= +INF
+//    Return atanh(x) = QNaN
+//
+// 6. x = [S,Q]NaN
+//    Return atanh(x) = QNaN
+//
+// 7. x = denormal
+//    Return atanh(x) = x
+//
+//==============================================================
+// Algorithm Description for log(x) function
+// Below we are using the fact that inequality x - 1.0 > 2^(-6) is always true
+// for this atanh implementation
+//
+// Consider  x = 2^N 1.f1 f2 f3 f4...f63
+// Log(x) = log(x * frcpa(x) / frcpa(x))
+//        = log(x * frcpa(x)) + log(1/frcpa(x))
+//        = log(x * frcpa(x)) - log(frcpa(x))
+//
+// frcpa(x)       = 2^-N * frcpa(1.f1 f2 ... f63)
+//
+// -log(frcpa(x)) = -log(C)
+//                = -log(2^-N) - log(frcpa(1.f1 f2 ... f63))
+//
+// -log(frcpa(x)) = -log(C)
+//                = N*log2 - log(frcpa(1.f1 f2 ... f63))
+//
+//
+// Log(x) = log(1/frcpa(x)) + log(frcpa(x) x)
+//
+// Log(x) = N*log2 + log(1./frcpa(1.f1 f2 ... f63)) + log(x * frcpa(x))
+// Log(x) = N*log2 + T                              + log(frcpa(x) x)
+//
+// Log(x) = N*log2 + T                              + log(C * x)
+//
+// C * x = 1 + r
+//
+// Log(x) = N*log2 + T + log(1 + r)
+// Log(x) = N*log2 + T + Series(r - r^2/2 + r^3/3 - r^4/4 + ...)
+//
+// 1.f1 f2 ... f8 has 256 entries.
+// They are 1 + k/2^8, k = 0 ... 255
+// These 256 values are the table entries.
+//
+// Implementation
+//==============================================================
+// C = frcpa(x)
+// r = C * x - 1
+//
+// Form rseries = r + P1*r^2 + P2*r^3 + P3*r^4 + P4*r^5 + P5*r^6
+//
+// x = f * 2*N where f is 1.f_1f_2f_3...f_63
+// Nfloat = float(n)  where n is the true unbiased exponent
+// pre-index = f_1f_2....f_8
+// index = pre_index * 16
+// get the dxt table entry at index + offset = T
+//
+// result = (T + Nfloat * log(2)) + rseries
+//
+// The T table is calculated as follows
+// Form x_k = 1 + k/2^8 where k goes from 0... 255
+//      y_k = frcpa(x_k)
+//      log(1/y_k)  in quad and round to double-extended
+//
+//
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input
+// f32 -> f77
+
+// General registers used:
+// r14 -> r27, r33 -> r39
+
+// Predicate registers used:
+// p6 -> p14
+
+// p10, p11      to indicate is argument positive or negative
+// p12           to filter out case when x = [Q,S]NaN or +/-0
+// p13           to filter out case when x = denormal
+// p6, p7        to filter out case when |x| >= 1
+// p8            to filter out case when |x| < 1/4
+
+// Assembly macros
+//==============================================================
+Data2Ptr              = r14
+Data3Ptr              = r15
+RcpTablePtr           = r16
+rExpbMask             = r17
+rBias                 = r18
+rNearZeroBound        = r19
+rArgSExpb             = r20
+rArgExpb              = r21
+rSExpb                = r22
+rExpb                 = r23
+rSig                  = r24
+rN                    = r25
+rInd                  = r26
+DataPtr               = r27
+
+GR_SAVE_B0            = r33
+GR_SAVE_GP            = r34
+GR_SAVE_PFS           = r35
+
+GR_Parameter_X        = r36
+GR_Parameter_Y        = r37
+GR_Parameter_RESULT   = r38
+atanh_GR_tag          = r39
+
+//==============================================================
+fAbsX                 = f32
+fOneMx                = f33
+fOnePx                = f34
+fY                    = f35
+fR                    = f36
+fR2                   = f37
+fR3                   = f38
+fRcp                  = f39
+fY4Rcp                = f40
+fRcp0                 = f41
+fRcp0n                = f42
+fRcp1                 = f43
+fRcp2                 = f44
+fRcp3                 = f45
+fN4Cvt                = f46
+fN                    = f47
+fY2                   = f48
+fLog2                 = f49
+fLogT                 = f50
+fLogT_N               = f51
+fX2                   = f52
+fX3                   = f53
+fX4                   = f54
+fX8                   = f55
+fP0                   = f56
+fP5                   = f57
+fP4                   = f58
+fP3                   = f59
+fP2                   = f60
+fP1                   = f61
+fNormX                = f62
+fC9                   = f63
+fC8                   = f64
+fC7                   = f65
+fC6                   = f66
+fC5                   = f67
+fC4                   = f68
+fC3                   = f69
+fC2                   = f70
+fC1                   = f71
+fC0                   = f72
+fP98                  = f73
+fP76                  = f74
+fP54                  = f75
+fP32                  = f76
+fP10                  = f77
+
+// Data tables
+//==============================================================
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(atanh_data)
+data8 0xBFC5555DA7212371              //   P5
+data8 0x3FC999A19EEF5826              //   P4
+data8 0xBFCFFFFFFFFEF009              //   P3
+data8 0x3FD555555554ECB2              //   P2
+data8 0xBFE0000000000000              //   P1 = -0.5
+data8 0x0000000000000000              //   pad
+data8 0xb17217f7d1cf79ac , 0x00003ffd //   0.5*log(2)
+data8 0x0000000000000000 , 0x00000000 //   pad to eliminate bank conflicts
+LOCAL_OBJECT_END(atanh_data)
+
+LOCAL_OBJECT_START(atanh_data_2)
+data8 0x8649FB89D3AD51FB , 0x00003FFB //   C9
+data8 0xCC10AABEF160077A , 0x00003FFA //   C8
+data8 0xF1EDB99AC0819CE2 , 0x00003FFA //   C7
+data8 0x8881E53A809AD24D , 0x00003FFB //   C6
+data8 0x9D8A116EF212F271 , 0x00003FFB //   C5
+data8 0xBA2E8A6D1D756453 , 0x00003FFB //   C4
+data8 0xE38E38E7A0945692 , 0x00003FFB //   C3
+data8 0x924924924536891A , 0x00003FFC //   C2
+data8 0xCCCCCCCCCCD08D51 , 0x00003FFC //   C1
+data8 0xAAAAAAAAAAAAAA0C , 0x00003FFD //   C0
+LOCAL_OBJECT_END(atanh_data_2)
+
+
+LOCAL_OBJECT_START(atanh_data_3)
+data8 0x80200aaeac44ef38 , 0x00003ff5 //   log(1/frcpa(1+0/2^-8))/2
+//
+data8 0xc09090a2c35aa070 , 0x00003ff6 //   log(1/frcpa(1+1/2^-8))/2
+data8 0xa0c94fcb41977c75 , 0x00003ff7 //   log(1/frcpa(1+2/2^-8))/2
+data8 0xe18b9c263af83301 , 0x00003ff7 //   log(1/frcpa(1+3/2^-8))/2
+data8 0x8d35c8d6399c30ea , 0x00003ff8 //   log(1/frcpa(1+4/2^-8))/2
+data8 0xadd4d2ecd601cbb8 , 0x00003ff8 //   log(1/frcpa(1+5/2^-8))/2
+//
+data8 0xce95403a192f9f01 , 0x00003ff8 //   log(1/frcpa(1+6/2^-8))/2
+data8 0xeb59392cbcc01096 , 0x00003ff8 //   log(1/frcpa(1+7/2^-8))/2
+data8 0x862c7d0cefd54c5d , 0x00003ff9 //   log(1/frcpa(1+8/2^-8))/2
+data8 0x94aa63c65e70d499 , 0x00003ff9 //   log(1/frcpa(1+9/2^-8))/2
+data8 0xa54a696d4b62b382 , 0x00003ff9 //   log(1/frcpa(1+10/2^-8))/2
+//
+data8 0xb3e4a796a5dac208 , 0x00003ff9 //   log(1/frcpa(1+11/2^-8))/2
+data8 0xc28c45b1878340a9 , 0x00003ff9 //   log(1/frcpa(1+12/2^-8))/2
+data8 0xd35c55f39d7a6235 , 0x00003ff9 //   log(1/frcpa(1+13/2^-8))/2
+data8 0xe220f037b954f1f5 , 0x00003ff9 //   log(1/frcpa(1+14/2^-8))/2
+data8 0xf0f3389b036834f3 , 0x00003ff9 //   log(1/frcpa(1+15/2^-8))/2
+//
+data8 0xffd3488d5c980465 , 0x00003ff9 //   log(1/frcpa(1+16/2^-8))/2
+data8 0x87609ce2ed300490 , 0x00003ffa //   log(1/frcpa(1+17/2^-8))/2
+data8 0x8ede9321e8c85927 , 0x00003ffa //   log(1/frcpa(1+18/2^-8))/2
+data8 0x96639427f2f8e2f4 , 0x00003ffa //   log(1/frcpa(1+19/2^-8))/2
+data8 0x9defad3e8f73217b , 0x00003ffa //   log(1/frcpa(1+20/2^-8))/2
+//
+data8 0xa582ebd50097029c , 0x00003ffa //   log(1/frcpa(1+21/2^-8))/2
+data8 0xac06dbe75ab80fee , 0x00003ffa //   log(1/frcpa(1+22/2^-8))/2
+data8 0xb3a78449b2d3ccca , 0x00003ffa //   log(1/frcpa(1+23/2^-8))/2
+data8 0xbb4f79635ab46bb2 , 0x00003ffa //   log(1/frcpa(1+24/2^-8))/2
+data8 0xc2fec93a83523f3f , 0x00003ffa //   log(1/frcpa(1+25/2^-8))/2
+//
+data8 0xc99af2eaca4c4571 , 0x00003ffa //   log(1/frcpa(1+26/2^-8))/2
+data8 0xd1581106472fa653 , 0x00003ffa //   log(1/frcpa(1+27/2^-8))/2
+data8 0xd8002560d4355f2e , 0x00003ffa //   log(1/frcpa(1+28/2^-8))/2
+data8 0xdfcb43b4fe508632 , 0x00003ffa //   log(1/frcpa(1+29/2^-8))/2
+data8 0xe67f6dff709d4119 , 0x00003ffa //   log(1/frcpa(1+30/2^-8))/2
+//
+data8 0xed393b1c22351280 , 0x00003ffa //   log(1/frcpa(1+31/2^-8))/2
+data8 0xf5192bff087bcc35 , 0x00003ffa //   log(1/frcpa(1+32/2^-8))/2
+data8 0xfbdf4ff6dfef2fa3 , 0x00003ffa //   log(1/frcpa(1+33/2^-8))/2
+data8 0x81559a97f92f9cc7 , 0x00003ffb //   log(1/frcpa(1+34/2^-8))/2
+data8 0x84be72bce90266e8 , 0x00003ffb //   log(1/frcpa(1+35/2^-8))/2
+//
+data8 0x88bc74113f23def2 , 0x00003ffb //   log(1/frcpa(1+36/2^-8))/2
+data8 0x8c2ba3edf6799d11 , 0x00003ffb //   log(1/frcpa(1+37/2^-8))/2
+data8 0x8f9dc92f92ea08b1 , 0x00003ffb //   log(1/frcpa(1+38/2^-8))/2
+data8 0x9312e8f36efab5a7 , 0x00003ffb //   log(1/frcpa(1+39/2^-8))/2
+data8 0x968b08643409ceb6 , 0x00003ffb //   log(1/frcpa(1+40/2^-8))/2
+//
+data8 0x9a062cba08a1708c , 0x00003ffb //   log(1/frcpa(1+41/2^-8))/2
+data8 0x9d845b3abf95485c , 0x00003ffb //   log(1/frcpa(1+42/2^-8))/2
+data8 0xa06fd841bc001bb4 , 0x00003ffb //   log(1/frcpa(1+43/2^-8))/2
+data8 0xa3f3a74652fbe0db , 0x00003ffb //   log(1/frcpa(1+44/2^-8))/2
+data8 0xa77a8fb2336f20f5 , 0x00003ffb //   log(1/frcpa(1+45/2^-8))/2
+//
+data8 0xab0497015d28b0a0 , 0x00003ffb //   log(1/frcpa(1+46/2^-8))/2
+data8 0xae91c2be6ba6a615 , 0x00003ffb //   log(1/frcpa(1+47/2^-8))/2
+data8 0xb189d1b99aebb20b , 0x00003ffb //   log(1/frcpa(1+48/2^-8))/2
+data8 0xb51cced5de9c1b2c , 0x00003ffb //   log(1/frcpa(1+49/2^-8))/2
+data8 0xb819bee9e720d42f , 0x00003ffb //   log(1/frcpa(1+50/2^-8))/2
+//
+data8 0xbbb2a0947b093a5d , 0x00003ffb //   log(1/frcpa(1+51/2^-8))/2
+data8 0xbf4ec1505811684a , 0x00003ffb //   log(1/frcpa(1+52/2^-8))/2
+data8 0xc2535bacfa8975ff , 0x00003ffb //   log(1/frcpa(1+53/2^-8))/2
+data8 0xc55a3eafad187eb8 , 0x00003ffb //   log(1/frcpa(1+54/2^-8))/2
+data8 0xc8ff2484b2c0da74 , 0x00003ffb //   log(1/frcpa(1+55/2^-8))/2
+//
+data8 0xcc0b1a008d53ab76 , 0x00003ffb //   log(1/frcpa(1+56/2^-8))/2
+data8 0xcfb6203844b3209b , 0x00003ffb //   log(1/frcpa(1+57/2^-8))/2
+data8 0xd2c73949a47a19f5 , 0x00003ffb //   log(1/frcpa(1+58/2^-8))/2
+data8 0xd5daae18b49d6695 , 0x00003ffb //   log(1/frcpa(1+59/2^-8))/2
+data8 0xd8f08248cf7e8019 , 0x00003ffb //   log(1/frcpa(1+60/2^-8))/2
+//
+data8 0xdca7749f1b3e540e , 0x00003ffb //   log(1/frcpa(1+61/2^-8))/2
+data8 0xdfc28e033aaaf7c7 , 0x00003ffb //   log(1/frcpa(1+62/2^-8))/2
+data8 0xe2e012a5f91d2f55 , 0x00003ffb //   log(1/frcpa(1+63/2^-8))/2
+data8 0xe600064ed9e292a8 , 0x00003ffb //   log(1/frcpa(1+64/2^-8))/2
+data8 0xe9226cce42b39f60 , 0x00003ffb //   log(1/frcpa(1+65/2^-8))/2
+//
+data8 0xec4749fd97a28360 , 0x00003ffb //   log(1/frcpa(1+66/2^-8))/2
+data8 0xef6ea1bf57780495 , 0x00003ffb //   log(1/frcpa(1+67/2^-8))/2
+data8 0xf29877ff38809091 , 0x00003ffb //   log(1/frcpa(1+68/2^-8))/2
+data8 0xf5c4d0b245cb89be , 0x00003ffb //   log(1/frcpa(1+69/2^-8))/2
+data8 0xf8f3afd6fcdef3aa , 0x00003ffb //   log(1/frcpa(1+70/2^-8))/2
+//
+data8 0xfc2519756be1abc7 , 0x00003ffb //   log(1/frcpa(1+71/2^-8))/2
+data8 0xff59119f503e6832 , 0x00003ffb //   log(1/frcpa(1+72/2^-8))/2
+data8 0x8147ce381ae0e146 , 0x00003ffc //   log(1/frcpa(1+73/2^-8))/2
+data8 0x82e45f06cb1ad0f2 , 0x00003ffc //   log(1/frcpa(1+74/2^-8))/2
+data8 0x842f5c7c573cbaa2 , 0x00003ffc //   log(1/frcpa(1+75/2^-8))/2
+//
+data8 0x85ce471968c8893a , 0x00003ffc //   log(1/frcpa(1+76/2^-8))/2
+data8 0x876e8305bc04066d , 0x00003ffc //   log(1/frcpa(1+77/2^-8))/2
+data8 0x891012678031fbb3 , 0x00003ffc //   log(1/frcpa(1+78/2^-8))/2
+data8 0x8a5f1493d766a05f , 0x00003ffc //   log(1/frcpa(1+79/2^-8))/2
+data8 0x8c030c778c56fa00 , 0x00003ffc //   log(1/frcpa(1+80/2^-8))/2
+//
+data8 0x8da85df17e31d9ae , 0x00003ffc //   log(1/frcpa(1+81/2^-8))/2
+data8 0x8efa663e7921687e , 0x00003ffc //   log(1/frcpa(1+82/2^-8))/2
+data8 0x90a22b6875c6a1f8 , 0x00003ffc //   log(1/frcpa(1+83/2^-8))/2
+data8 0x91f62cc8f5d24837 , 0x00003ffc //   log(1/frcpa(1+84/2^-8))/2
+data8 0x93a06cfc3857d980 , 0x00003ffc //   log(1/frcpa(1+85/2^-8))/2
+//
+data8 0x94f66d5e6fd01ced , 0x00003ffc //   log(1/frcpa(1+86/2^-8))/2
+data8 0x96a330156e6772f2 , 0x00003ffc //   log(1/frcpa(1+87/2^-8))/2
+data8 0x97fb3582754ea25b , 0x00003ffc //   log(1/frcpa(1+88/2^-8))/2
+data8 0x99aa8259aad1bbf2 , 0x00003ffc //   log(1/frcpa(1+89/2^-8))/2
+data8 0x9b0492f6227ae4a8 , 0x00003ffc //   log(1/frcpa(1+90/2^-8))/2
+//
+data8 0x9c5f8e199bf3a7a5 , 0x00003ffc //   log(1/frcpa(1+91/2^-8))/2
+data8 0x9e1293b9998c1daa , 0x00003ffc //   log(1/frcpa(1+92/2^-8))/2
+data8 0x9f6fa31e0b41f308 , 0x00003ffc //   log(1/frcpa(1+93/2^-8))/2
+data8 0xa0cda11eaf46390e , 0x00003ffc //   log(1/frcpa(1+94/2^-8))/2
+data8 0xa22c8f029cfa45aa , 0x00003ffc //   log(1/frcpa(1+95/2^-8))/2
+//
+data8 0xa3e48badb7856b34 , 0x00003ffc //   log(1/frcpa(1+96/2^-8))/2
+data8 0xa5459a0aa95849f9 , 0x00003ffc //   log(1/frcpa(1+97/2^-8))/2
+data8 0xa6a79c84480cfebd , 0x00003ffc //   log(1/frcpa(1+98/2^-8))/2
+data8 0xa80a946d0fcb3eb2 , 0x00003ffc //   log(1/frcpa(1+99/2^-8))/2
+data8 0xa96e831a3ea7b314 , 0x00003ffc //   log(1/frcpa(1+100/2^-8))/2
+//
+data8 0xaad369e3dc544e3b , 0x00003ffc //   log(1/frcpa(1+101/2^-8))/2
+data8 0xac92e9588952c815 , 0x00003ffc //   log(1/frcpa(1+102/2^-8))/2
+data8 0xadfa035aa1ed8fdc , 0x00003ffc //   log(1/frcpa(1+103/2^-8))/2
+data8 0xaf6219eae1ad6e34 , 0x00003ffc //   log(1/frcpa(1+104/2^-8))/2
+data8 0xb0cb2e6d8160f753 , 0x00003ffc //   log(1/frcpa(1+105/2^-8))/2
+//
+data8 0xb2354249ad950f72 , 0x00003ffc //   log(1/frcpa(1+106/2^-8))/2
+data8 0xb3a056e98ef4a3b4 , 0x00003ffc //   log(1/frcpa(1+107/2^-8))/2
+data8 0xb50c6dba52c6292a , 0x00003ffc //   log(1/frcpa(1+108/2^-8))/2
+data8 0xb679882c33876165 , 0x00003ffc //   log(1/frcpa(1+109/2^-8))/2
+data8 0xb78c07429785cedc , 0x00003ffc //   log(1/frcpa(1+110/2^-8))/2
+//
+data8 0xb8faeb8dc4a77d24 , 0x00003ffc //   log(1/frcpa(1+111/2^-8))/2
+data8 0xba6ad77eb36ae0d6 , 0x00003ffc //   log(1/frcpa(1+112/2^-8))/2
+data8 0xbbdbcc915e9bee50 , 0x00003ffc //   log(1/frcpa(1+113/2^-8))/2
+data8 0xbd4dcc44f8cf12ef , 0x00003ffc //   log(1/frcpa(1+114/2^-8))/2
+data8 0xbec0d81bf5b531fa , 0x00003ffc //   log(1/frcpa(1+115/2^-8))/2
+//
+data8 0xc034f19c139186f4 , 0x00003ffc //   log(1/frcpa(1+116/2^-8))/2
+data8 0xc14cb69f7c5e55ab , 0x00003ffc //   log(1/frcpa(1+117/2^-8))/2
+data8 0xc2c2abbb6e5fd56f , 0x00003ffc //   log(1/frcpa(1+118/2^-8))/2
+data8 0xc439b2c193e6771e , 0x00003ffc //   log(1/frcpa(1+119/2^-8))/2
+data8 0xc553acb9d5c67733 , 0x00003ffc //   log(1/frcpa(1+120/2^-8))/2
+//
+data8 0xc6cc96e441272441 , 0x00003ffc //   log(1/frcpa(1+121/2^-8))/2
+data8 0xc8469753eca88c30 , 0x00003ffc //   log(1/frcpa(1+122/2^-8))/2
+data8 0xc962cf3ce072b05c , 0x00003ffc //   log(1/frcpa(1+123/2^-8))/2
+data8 0xcadeba8771f694aa , 0x00003ffc //   log(1/frcpa(1+124/2^-8))/2
+data8 0xcc5bc08d1f72da94 , 0x00003ffc //   log(1/frcpa(1+125/2^-8))/2
+//
+data8 0xcd7a3f99ea035c29 , 0x00003ffc //   log(1/frcpa(1+126/2^-8))/2
+data8 0xcef93860c8a53c35 , 0x00003ffc //   log(1/frcpa(1+127/2^-8))/2
+data8 0xd0192f68a7ed23df , 0x00003ffc //   log(1/frcpa(1+128/2^-8))/2
+data8 0xd19a201127d3c645 , 0x00003ffc //   log(1/frcpa(1+129/2^-8))/2
+data8 0xd2bb92f4061c172c , 0x00003ffc //   log(1/frcpa(1+130/2^-8))/2
+//
+data8 0xd43e80b2ee8cc8fc , 0x00003ffc //   log(1/frcpa(1+131/2^-8))/2
+data8 0xd56173601fc4ade4 , 0x00003ffc //   log(1/frcpa(1+132/2^-8))/2
+data8 0xd6e6637efb54086f , 0x00003ffc //   log(1/frcpa(1+133/2^-8))/2
+data8 0xd80ad9f58f3c8193 , 0x00003ffc //   log(1/frcpa(1+134/2^-8))/2
+data8 0xd991d1d31aca41f8 , 0x00003ffc //   log(1/frcpa(1+135/2^-8))/2
+//
+data8 0xdab7d02231484a93 , 0x00003ffc //   log(1/frcpa(1+136/2^-8))/2
+data8 0xdc40d532cde49a54 , 0x00003ffc //   log(1/frcpa(1+137/2^-8))/2
+data8 0xdd685f79ed8b265e , 0x00003ffc //   log(1/frcpa(1+138/2^-8))/2
+data8 0xde9094bbc0e17b1d , 0x00003ffc //   log(1/frcpa(1+139/2^-8))/2
+data8 0xe01c91b78440c425 , 0x00003ffc //   log(1/frcpa(1+140/2^-8))/2
+//
+data8 0xe14658f26997e729 , 0x00003ffc //   log(1/frcpa(1+141/2^-8))/2
+data8 0xe270cdc2391e0d23 , 0x00003ffc //   log(1/frcpa(1+142/2^-8))/2
+data8 0xe3ffce3a2aa64922 , 0x00003ffc //   log(1/frcpa(1+143/2^-8))/2
+data8 0xe52bdb274ed82887 , 0x00003ffc //   log(1/frcpa(1+144/2^-8))/2
+data8 0xe6589852e75d7df6 , 0x00003ffc //   log(1/frcpa(1+145/2^-8))/2
+//
+data8 0xe786068c79937a7d , 0x00003ffc //   log(1/frcpa(1+146/2^-8))/2
+data8 0xe91903adad100911 , 0x00003ffc //   log(1/frcpa(1+147/2^-8))/2
+data8 0xea481236f7d35bb0 , 0x00003ffc //   log(1/frcpa(1+148/2^-8))/2
+data8 0xeb77d48c692e6b14 , 0x00003ffc //   log(1/frcpa(1+149/2^-8))/2
+data8 0xeca84b83d7297b87 , 0x00003ffc //   log(1/frcpa(1+150/2^-8))/2
+//
+data8 0xedd977f4962aa158 , 0x00003ffc //   log(1/frcpa(1+151/2^-8))/2
+data8 0xef7179a22f257754 , 0x00003ffc //   log(1/frcpa(1+152/2^-8))/2
+data8 0xf0a450d139366ca7 , 0x00003ffc //   log(1/frcpa(1+153/2^-8))/2
+data8 0xf1d7e0524ff9ffdb , 0x00003ffc //   log(1/frcpa(1+154/2^-8))/2
+data8 0xf30c29036a8b6cae , 0x00003ffc //   log(1/frcpa(1+155/2^-8))/2
+//
+data8 0xf4412bc411ea8d92 , 0x00003ffc //   log(1/frcpa(1+156/2^-8))/2
+data8 0xf576e97564c8619d , 0x00003ffc //   log(1/frcpa(1+157/2^-8))/2
+data8 0xf6ad62fa1b5f172f , 0x00003ffc //   log(1/frcpa(1+158/2^-8))/2
+data8 0xf7e499368b55c542 , 0x00003ffc //   log(1/frcpa(1+159/2^-8))/2
+data8 0xf91c8d10abaffe22 , 0x00003ffc //   log(1/frcpa(1+160/2^-8))/2
+//
+data8 0xfa553f7018c966f3 , 0x00003ffc //   log(1/frcpa(1+161/2^-8))/2
+data8 0xfb8eb13e185d802c , 0x00003ffc //   log(1/frcpa(1+162/2^-8))/2
+data8 0xfcc8e3659d9bcbed , 0x00003ffc //   log(1/frcpa(1+163/2^-8))/2
+data8 0xfe03d6d34d487fd2 , 0x00003ffc //   log(1/frcpa(1+164/2^-8))/2
+data8 0xff3f8c7581e9f0ae , 0x00003ffc //   log(1/frcpa(1+165/2^-8))/2
+//
+data8 0x803e029e280173ae , 0x00003ffd //   log(1/frcpa(1+166/2^-8))/2
+data8 0x80dca10cc52d0757 , 0x00003ffd //   log(1/frcpa(1+167/2^-8))/2
+data8 0x817ba200632755a1 , 0x00003ffd //   log(1/frcpa(1+168/2^-8))/2
+data8 0x821b05f3b01d6774 , 0x00003ffd //   log(1/frcpa(1+169/2^-8))/2
+data8 0x82bacd623ff19d06 , 0x00003ffd //   log(1/frcpa(1+170/2^-8))/2
+//
+data8 0x835af8c88e7a8f47 , 0x00003ffd //   log(1/frcpa(1+171/2^-8))/2
+data8 0x83c5f8299e2b4091 , 0x00003ffd //   log(1/frcpa(1+172/2^-8))/2
+data8 0x8466cb43f3d87300 , 0x00003ffd //   log(1/frcpa(1+173/2^-8))/2
+data8 0x850803a67c80ca4b , 0x00003ffd //   log(1/frcpa(1+174/2^-8))/2
+data8 0x85a9a1d11a23b461 , 0x00003ffd //   log(1/frcpa(1+175/2^-8))/2
+//
+data8 0x864ba644a18e6e05 , 0x00003ffd //   log(1/frcpa(1+176/2^-8))/2
+data8 0x86ee1182dcc432f7 , 0x00003ffd //   log(1/frcpa(1+177/2^-8))/2
+data8 0x875a925d7e48c316 , 0x00003ffd //   log(1/frcpa(1+178/2^-8))/2
+data8 0x87fdaa109d23aef7 , 0x00003ffd //   log(1/frcpa(1+179/2^-8))/2
+data8 0x88a129ed4becfaf2 , 0x00003ffd //   log(1/frcpa(1+180/2^-8))/2
+//
+data8 0x89451278ecd7f9cf , 0x00003ffd //   log(1/frcpa(1+181/2^-8))/2
+data8 0x89b29295f8432617 , 0x00003ffd //   log(1/frcpa(1+182/2^-8))/2
+data8 0x8a572ac5a5496882 , 0x00003ffd //   log(1/frcpa(1+183/2^-8))/2
+data8 0x8afc2d0ce3b2dadf , 0x00003ffd //   log(1/frcpa(1+184/2^-8))/2
+data8 0x8b6a69c608cfd3af , 0x00003ffd //   log(1/frcpa(1+185/2^-8))/2
+//
+data8 0x8c101e106e899a83 , 0x00003ffd //   log(1/frcpa(1+186/2^-8))/2
+data8 0x8cb63de258f9d626 , 0x00003ffd //   log(1/frcpa(1+187/2^-8))/2
+data8 0x8d2539c5bd19e2b1 , 0x00003ffd //   log(1/frcpa(1+188/2^-8))/2
+data8 0x8dcc0e064b29e6f1 , 0x00003ffd //   log(1/frcpa(1+189/2^-8))/2
+data8 0x8e734f45d88357ae , 0x00003ffd //   log(1/frcpa(1+190/2^-8))/2
+//
+data8 0x8ee30cef034a20db , 0x00003ffd //   log(1/frcpa(1+191/2^-8))/2
+data8 0x8f8b0515686d1d06 , 0x00003ffd //   log(1/frcpa(1+192/2^-8))/2
+data8 0x90336bba039bf32f , 0x00003ffd //   log(1/frcpa(1+193/2^-8))/2
+data8 0x90a3edd23d1c9d58 , 0x00003ffd //   log(1/frcpa(1+194/2^-8))/2
+data8 0x914d0de2f5d61b32 , 0x00003ffd //   log(1/frcpa(1+195/2^-8))/2
+//
+data8 0x91be0c20d28173b5 , 0x00003ffd //   log(1/frcpa(1+196/2^-8))/2
+data8 0x9267e737c06cd34a , 0x00003ffd //   log(1/frcpa(1+197/2^-8))/2
+data8 0x92d962ae6abb1237 , 0x00003ffd //   log(1/frcpa(1+198/2^-8))/2
+data8 0x9383fa6afbe2074c , 0x00003ffd //   log(1/frcpa(1+199/2^-8))/2
+data8 0x942f0421651c1c4e , 0x00003ffd //   log(1/frcpa(1+200/2^-8))/2
+//
+data8 0x94a14a3845bb985e , 0x00003ffd //   log(1/frcpa(1+201/2^-8))/2
+data8 0x954d133857f861e7 , 0x00003ffd //   log(1/frcpa(1+202/2^-8))/2
+data8 0x95bfd96468e604c4 , 0x00003ffd //   log(1/frcpa(1+203/2^-8))/2
+data8 0x9632d31cafafa858 , 0x00003ffd //   log(1/frcpa(1+204/2^-8))/2
+data8 0x96dfaabd86fa1647 , 0x00003ffd //   log(1/frcpa(1+205/2^-8))/2
+//
+data8 0x9753261fcbb2a594 , 0x00003ffd //   log(1/frcpa(1+206/2^-8))/2
+data8 0x9800c11b426b996d , 0x00003ffd //   log(1/frcpa(1+207/2^-8))/2
+data8 0x9874bf4d45ae663c , 0x00003ffd //   log(1/frcpa(1+208/2^-8))/2
+data8 0x99231f5ee9a74f79 , 0x00003ffd //   log(1/frcpa(1+209/2^-8))/2
+data8 0x9997a18a56bcad28 , 0x00003ffd //   log(1/frcpa(1+210/2^-8))/2
+//
+data8 0x9a46c873a3267e79 , 0x00003ffd //   log(1/frcpa(1+211/2^-8))/2
+data8 0x9abbcfc621eb6cb6 , 0x00003ffd //   log(1/frcpa(1+212/2^-8))/2
+data8 0x9b310cb0d354c990 , 0x00003ffd //   log(1/frcpa(1+213/2^-8))/2
+data8 0x9be14cf9e1b3515c , 0x00003ffd //   log(1/frcpa(1+214/2^-8))/2
+data8 0x9c5710b8cbb73a43 , 0x00003ffd //   log(1/frcpa(1+215/2^-8))/2
+//
+data8 0x9ccd0abd301f399c , 0x00003ffd //   log(1/frcpa(1+216/2^-8))/2
+data8 0x9d7e67f3bdce8888 , 0x00003ffd //   log(1/frcpa(1+217/2^-8))/2
+data8 0x9df4ea81a99daa01 , 0x00003ffd //   log(1/frcpa(1+218/2^-8))/2
+data8 0x9e6ba405a54514ba , 0x00003ffd //   log(1/frcpa(1+219/2^-8))/2
+data8 0x9f1e21c8c7bb62b3 , 0x00003ffd //   log(1/frcpa(1+220/2^-8))/2
+//
+data8 0x9f956593f6b6355c , 0x00003ffd //   log(1/frcpa(1+221/2^-8))/2
+data8 0xa00ce1092e5498c3 , 0x00003ffd //   log(1/frcpa(1+222/2^-8))/2
+data8 0xa0c08309c4b912c1 , 0x00003ffd //   log(1/frcpa(1+223/2^-8))/2
+data8 0xa1388a8c6faa2afa , 0x00003ffd //   log(1/frcpa(1+224/2^-8))/2
+data8 0xa1b0ca7095b5f985 , 0x00003ffd //   log(1/frcpa(1+225/2^-8))/2
+//
+data8 0xa22942eb47534a00 , 0x00003ffd //   log(1/frcpa(1+226/2^-8))/2
+data8 0xa2de62326449d0a3 , 0x00003ffd //   log(1/frcpa(1+227/2^-8))/2
+data8 0xa357690f88bfe345 , 0x00003ffd //   log(1/frcpa(1+228/2^-8))/2
+data8 0xa3d0a93f45169a4b , 0x00003ffd //   log(1/frcpa(1+229/2^-8))/2
+data8 0xa44a22f7ffe65f30 , 0x00003ffd //   log(1/frcpa(1+230/2^-8))/2
+//
+data8 0xa500c5e5b4c1aa36 , 0x00003ffd //   log(1/frcpa(1+231/2^-8))/2
+data8 0xa57ad064eb2ebbc2 , 0x00003ffd //   log(1/frcpa(1+232/2^-8))/2
+data8 0xa5f5152dedf4384e , 0x00003ffd //   log(1/frcpa(1+233/2^-8))/2
+data8 0xa66f9478856233ec , 0x00003ffd //   log(1/frcpa(1+234/2^-8))/2
+data8 0xa6ea4e7cca02c32e , 0x00003ffd //   log(1/frcpa(1+235/2^-8))/2
+//
+data8 0xa765437325341ccf , 0x00003ffd //   log(1/frcpa(1+236/2^-8))/2
+data8 0xa81e21e6c75b4020 , 0x00003ffd //   log(1/frcpa(1+237/2^-8))/2
+data8 0xa899ab333fe2b9ca , 0x00003ffd //   log(1/frcpa(1+238/2^-8))/2
+data8 0xa9157039c51ebe71 , 0x00003ffd //   log(1/frcpa(1+239/2^-8))/2
+data8 0xa991713433c2b999 , 0x00003ffd //   log(1/frcpa(1+240/2^-8))/2
+//
+data8 0xaa0dae5cbcc048b3 , 0x00003ffd //   log(1/frcpa(1+241/2^-8))/2
+data8 0xaa8a27ede5eb13ad , 0x00003ffd //   log(1/frcpa(1+242/2^-8))/2
+data8 0xab06de228a9e3499 , 0x00003ffd //   log(1/frcpa(1+243/2^-8))/2
+data8 0xab83d135dc633301 , 0x00003ffd //   log(1/frcpa(1+244/2^-8))/2
+data8 0xac3fb076adc7fe7a , 0x00003ffd //   log(1/frcpa(1+245/2^-8))/2
+//
+data8 0xacbd3cbbe47988f1 , 0x00003ffd //   log(1/frcpa(1+246/2^-8))/2
+data8 0xad3b06b1a5dc57c3 , 0x00003ffd //   log(1/frcpa(1+247/2^-8))/2
+data8 0xadb90e94af887717 , 0x00003ffd //   log(1/frcpa(1+248/2^-8))/2
+data8 0xae3754a218f7c816 , 0x00003ffd //   log(1/frcpa(1+249/2^-8))/2
+data8 0xaeb5d9175437afa2 , 0x00003ffd //   log(1/frcpa(1+250/2^-8))/2
+//
+data8 0xaf349c322e9c7cee , 0x00003ffd //   log(1/frcpa(1+251/2^-8))/2
+data8 0xafb39e30d1768d1c , 0x00003ffd //   log(1/frcpa(1+252/2^-8))/2
+data8 0xb032df51c2c93116 , 0x00003ffd //   log(1/frcpa(1+253/2^-8))/2
+data8 0xb0b25fd3e6035ad9 , 0x00003ffd //   log(1/frcpa(1+254/2^-8))/2
+data8 0xb1321ff67cba178c , 0x00003ffd //   log(1/frcpa(1+255/2^-8))/2
+LOCAL_OBJECT_END(atanh_data_3)
+
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(atanh)
+
+{ .mfi
+      getf.exp      rArgSExpb = f8                  // Must recompute if x unorm
+      fclass.m      p13,p0 = f8, 0x0b               // is arg denormal ?
+      mov           rExpbMask = 0x1ffff
+}
+{ .mfi
+      addl          DataPtr = @ltoff(atanh_data), gp
+      fnma.s1       fOneMx = f8, f1, f1             // fOneMx = 1 - x
+      mov           rBias = 0xffff
+}
+;;
+
+{ .mfi
+      mov           rNearZeroBound = 0xfffd         // biased exp of 1/4
+      fclass.m      p12,p0 = f8, 0xc7               // is arg NaN or +/-0 ?
+      nop.i         0
+}
+{ .mfi
+      ld8           DataPtr = [DataPtr]
+      fma.s1        fOnePx = f8, f1, f1             // fOnePx = 1 + x
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fcmp.lt.s1    p10,p11 = f8,f0                 // is x < 0 ?
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+      fnorm.s1      fNormX = f8                     // Normalize x
+(p13) br.cond.spnt  ATANH_UNORM                     // Branch if x=unorm
+}
+;;
+
+ATANH_COMMON:
+// Return here if x=unorm and not denorm
+{ .mfi
+      adds          Data2Ptr = 0x50, DataPtr
+      fma.s1        fX2 = f8, f8, f0                // x^2
+      nop.i         0
+}
+{ .mfb
+      adds          Data3Ptr = 0xC0, DataPtr
+(p12) fma.d.s0      f8 = f8,f1,f8                   // NaN or +/-0
+(p12) br.ret.spnt   b0                              // Exit for x Nan or zero
+}
+;;
+
+{ .mfi
+      ldfe          fC9 = [Data2Ptr], 16
+(p11) frcpa.s1      fRcp0, p0 = f1, fOneMx
+      nop.i         0
+}
+;;
+
+{ .mfi
+      ldfe          fC8 = [Data2Ptr], 16
+(p10) frcpa.s1      fRcp0n, p0 = f1, fOnePx
+      and           rArgExpb = rArgSExpb, rExpbMask // biased exponent
+}
+{ .mfi
+      nop.m         0
+(p10) fma.s1        fOneMx = fOnePx, f1, f0         // fOnePx = 1 - |x|
+      nop.i         0
+}
+;;
+
+{ .mfi
+      ldfe          fC7 = [Data2Ptr], 16
+(p10) fnma.s1       fOnePx = fNormX, f1, f1         // fOnePx = 1 + |x|
+      cmp.ge        p6,p0 = rArgExpb, rBias         // is Expb(Arg) >= Expb(1) ?
+}
+{ .mfb
+      nop.m         0
+      nop.f         0
+(p6)  br.cond.spnt  atanh_ge_one                    // Branch if |x| >=1.0
+}
+;;
+
+{ .mfi
+      ldfe          fC6 = [Data2Ptr], 16
+      nop.f         0
+      nop.i         0
+}
+;;
+
+{ .mfi
+      ldfe          fC5 = [Data2Ptr], 16
+      fma.s1        fX4 = fX2, fX2, f0              // x^4
+      cmp.gt        p8,p0 = rNearZeroBound, rArgExpb
+}
+{ .mfb
+      ldfe          fC2 = [Data3Ptr], 16
+      fma.s1        fX3 = fX2, fNormX, f0           // x^3
+(p8)  br.cond.spnt  atanh_near_zero                 // Exit if 0 < |x| < 0.25
+}
+;;
+
+// Main path: 0.25 <= |x| < 1.0
+// NR method: iteration #1
+.pred.rel "mutex",p11,p10
+{ .mfi
+      ldfpd         fP5, fP4 = [DataPtr], 16
+(p11) fnma.s1       fRcp1 = fRcp0, fOneMx, f1       // t = 1 - r0*x
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p10) fnma.s1       fRcp1 = fRcp0n, fOneMx, f1      // t = 1 - r0*x
+      nop.i         0
+}
+;;
+
+{ .mfi
+      ldfpd         fP3, fP2 = [DataPtr], 16
+      // r1 = r0 + r0*t = r0 + r0*(1 - r0*x)
+(p11) fma.s1        fRcp1 = fRcp0, fRcp1, fRcp0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      // r1 = r0 + r0*t = r0 + r0*(1 - r0*x)
+(p10) fma.s1        fRcp1 = fRcp0n, fRcp1, fRcp0n
+      nop.i         0
+}
+;;
+
+// NR method: iteration #2
+{ .mfi
+      ldfd          fP1 = [DataPtr], 16
+      fnma.s1       fRcp2 = fRcp1, fOneMx, f1       // t = 1 - r1*x
+      nop.i         0
+}
+;;
+
+{ .mfi
+      ldfe          fLog2 = [DataPtr], 16
+      // r2 = r1 + r1*t = r1 + r1*(1 - r1*x)
+      fma.s1        fRcp2 = fRcp1, fRcp2, fRcp1
+      nop.i         0
+}
+;;
+
+// NR method: iteration #3
+{ .mfi
+      adds          RcpTablePtr = 0xB0, DataPtr
+      fnma.s1       fRcp3 = fRcp2, fOneMx, f1       // t = 1 - r2*x
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        fY4Rcp = fRcp2, fOnePx, f0      // fY4Rcp = r2*(1 + x)
+      nop.i         0
+}
+;;
+
+// polynomial approximation & final reconstruction
+{ .mfi
+      nop.m         0
+      frcpa.s1      fRcp, p0 = f1, fY4Rcp
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      // y = r2 * (1 + x) + r2 * (1 + x) * t = (1 + x) * (r2 + r2*(1 - r2*x))
+      fma.s1        fY = fY4Rcp, fRcp3, fY4Rcp
+      nop.i         0
+}
+;;
+
+{ .mmi
+      getf.exp      rSExpb = fY4Rcp                 // biased exponent and sign
+;;
+      getf.sig      rSig = fY4Rcp                   // significand
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fms.s1        fR = fY, fRcp, f1               // fR = fY * fRcp - 1
+      nop.i         0
+}
+;;
+
+{ .mmi
+      and           rExpb = rSExpb, rExpbMask
+;;
+      sub           rN = rExpb, rBias               // exponent
+      extr.u        rInd = rSig,55,8                // Extract 8 bits
+}
+;;
+
+{ .mmi
+      setf.sig      fN4Cvt = rN
+      shladd        RcpTablePtr = rInd, 4, RcpTablePtr
+      nop.i         0
+}
+;;
+
+{ .mfi
+      ldfe          fLogT = [RcpTablePtr]
+      fma.s1        fR2 = fR, fR, f0                // r^2
+      nop.i         0
+}
+{
+      nop.m         0
+      fma.s1        fP54 = fP5, fR, fP4             // P5*r + P4
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.s1        fP32 = fP3, fR, fP2             // P3*r + P2
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.s1        fR3 = fR2, fR, f0               // r^3
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        fP10 = fP1, fR2, fR             // P1*r^2 + r
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fcvt.xf       fN = fN4Cvt
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        fP54 = fP54, fR2, fP32      // (P5*r + P4)*r^2 + P3*r + P2
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.s1        fLogT_N = fN, fLog2, fLogT      // N*Log2 + LogT
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      // ((P5*r + P4)*r^2 + P3*r + P2)*r^3 + P1*r^2 + r
+      fma.s1        fP54 = fP54, fR3, fP10
+      nop.i         0
+}
+;;
+
+.pred.rel "mutex",p11,p10
+{ .mfi
+      nop.m         0
+      // 0.5*(((P5*r + P4)*r^2 + P3*r + P2)*r^3 + P1*r^2 + r) + 0.5*(N*Log2 + T)
+(p11) fnma.d.s0     f8 = fP54, fP1, fLogT_N
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+     // -0.5*(((P5*r + P4)*r^2 + P3*r + P2)*r^3 + P1*r^2 + r) - 0.5*(N*Log2 + T)
+(p10) fms.d.s0      f8 = fP54, fP1, fLogT_N
+      br.ret.sptk   b0                          // Exit for 0.25 <= |x| < 1.0
+}
+;;
+
+// Here if 0 < |x| < 0.25
+atanh_near_zero:
+{ .mfi
+      ldfe          fC4 = [Data2Ptr], 16
+      fma.s1        fP98 = fC9, fX2, fC8           // C9*x^2 + C8
+      nop.i         0
+}
+{ .mfi
+      ldfe          fC1 = [Data3Ptr], 16
+      fma.s1        fP76 = fC7, fX2, fC6           // C7*x^2 + C6
+      nop.i         0
+}
+;;
+
+{ .mfi
+      ldfe          fC3 = [Data2Ptr], 16
+      fma.s1        fX8 = fX4, fX4, f0             // x^8
+      nop.i         0
+}
+{ .mfi
+      ldfe          fC0 = [Data3Ptr], 16
+      nop.f         0
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.s1        fP98 = fP98, fX4, fP76     // C9*x^6 + C8*x^4 + C7*x^2 + C6
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.s1        fP54 = fC5, fX2, fC4           // C5*x^2 + C4
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.s1        fP32 = fC3, fX2, fC2           // C3*x^2 + C2
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.s1        fP10 = fC1, fX2, fC0           // C1*x^2 + C0
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.s1        fP54 = fP54, fX4, fP32      // C5*x^6 + C4*x^4 + C3*x^2 + C2
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      // C9*x^14 + C8*x^12 + C7*x^10 + C6*x^8 + C5*x^6 + C4*x^4 + C3*x^2 + C2
+      fma.s1        fP98 = fP98, fX8, fP54
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      // C9*x^18 + C8*x^16 + C7*x^14 + C6*x^12 + C5*x^10 + C4*x^8 + C3*x^6 +
+      // C2*x^4 + C1*x^2 + C0
+      fma.s1        fP98 = fP98, fX4, fP10
+      nop.i         0
+}
+;;
+
+{ .mfb
+      nop.m         0
+      // C9*x^21 + C8*x^19 + C7*x^17 + C6*x^15 + C5*x^13 + C4*x^11 + C3*x^9 +
+      // C2*x^7 + C1*x^5 + C0*x^3 + x
+      fma.d.s0      f8 = fP98, fX3, fNormX
+      br.ret.sptk   b0                           // Exit for 0 < |x| < 0.25
+}
+;;
+
+ATANH_UNORM:
+// Here if x=unorm
+{ .mfi
+      getf.exp      rArgSExpb = fNormX           // Recompute if x unorm
+      fclass.m      p0,p13 = fNormX, 0x0b        // Test x denorm
+      nop.i         0
+}
+;;
+
+{ .mfb
+      nop.m         0
+      fcmp.eq.s0    p7,p0 = f8, f0        // Dummy to set denormal flag
+(p13) br.cond.sptk  ATANH_COMMON          // Continue if x unorm and not denorm
+}
+;;
+
+.pred.rel "mutex",p10,p11
+{ .mfi
+      nop.m         0
+(p10) fnma.d.s0     f8 = f8,f8,f8                // Result x-x^2 if x=-denorm
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p11) fma.d.s0      f8 = f8,f8,f8                // Result x+x^2 if x=+denorm
+      br.ret.spnt   b0                           // Exit if denorm
+}
+;;
+
+// Here if |x| >= 1.0
+atanh_ge_one:
+{ .mfi
+      alloc         r32 = ar.pfs,1,3,4,0
+      fmerge.s      fAbsX = f0, f8          // Form |x|
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fmerge.s      f10 = f8, f8            // Save input for error call
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fcmp.eq.s1    p6,p7 = fAbsX, f1       // Test for |x| = 1.0
+      nop.i         0
+}
+;;
+
+// Set error tag and result, and raise invalid flag if |x| > 1.0
+{ .mfi
+(p7)  mov           atanh_GR_tag = 131
+(p7)  frcpa.s0      f8, p0 = f0, f0         // Get QNaN, and raise invalid
+      nop.i         0
+}
+;;
+
+// Set error tag and result, and raise Z flag if |x| = 1.0
+{ .mfi
+      nop.m         0
+(p6)  frcpa.s0      fRcp, p0 = f1, f0       // Get inf, and raise Z flag
+      nop.i         0
+}
+;;
+
+{ .mfb
+(p6)  mov           atanh_GR_tag = 132
+(p6)  fmerge.s      f8 = f8, fRcp           // result is +-inf
+      br.cond.sptk  __libm_error_region     // Exit if |x| >= 1.0
+}
+;;
+
+GLOBAL_LIBM_END(atanh)
+libm_alias_double_other (atanh, atanh)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+
+{ .mfi
+      add           GR_Parameter_Y=-32,sp        // Parameter 2 value
+      nop.f         0
+.save   ar.pfs,GR_SAVE_PFS
+      mov           GR_SAVE_PFS=ar.pfs           // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+      add sp=-64,sp                              // Create new stack
+      nop.f 0
+      mov GR_SAVE_GP=gp                          // Save gp
+};;
+
+{ .mmi
+      stfd [GR_Parameter_Y] = f1,16              // STORE Parameter 2 on stack
+      add GR_Parameter_X = 16,sp                 // Parameter 1 address
+.save   b0, GR_SAVE_B0
+      mov GR_SAVE_B0=b0                          // Save b0
+};;
+
+.body
+{ .mib
+      stfd [GR_Parameter_X] = f10                // STORE Parameter 1 on stack
+      add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+      nop.b 0
+}
+{ .mib
+      stfd [GR_Parameter_Y] = f8                 // STORE Parameter 3 on stack
+      add   GR_Parameter_Y = -16,GR_Parameter_Y
+      br.call.sptk b0=__libm_error_support#      // Call error handling function
+};;
+
+{ .mmi
+      add   GR_Parameter_RESULT = 48,sp
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mmi
+      ldfd  f8 = [GR_Parameter_RESULT]           // Get return result off stack
+.restore sp
+      add   sp = 64,sp                           // Restore stack pointer
+      mov   b0 = GR_SAVE_B0                      // Restore return address
+};;
+
+{ .mib
+      mov   gp = GR_SAVE_GP                      // Restore gp
+      mov   ar.pfs = GR_SAVE_PFS                 // Restore ar.pfs
+      br.ret.sptk     b0                         // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_atanhf.S
@@ -0,0 +1,845 @@
+.file "atanhf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 05/22/01 Initial version
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 08/06/02 Improved Itanium 2 performance
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+// 05/26/03 Improved performance, fixed to handle unorms
+//
+// API
+//==============================================================
+// float atanhf(float)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+//
+// There are 7 paths:
+// 1. x = +/-0.0
+//    Return atanhf(x) = +/-0.0
+//
+// 2. 0.0 < |x| <= MAX_DENORMAL_ABS
+//    Return atanhf(x) = x + sign(x)*x^2
+//
+// 3. MAX_DENORMAL_ABS < |x| < 2^(-20)
+//    Return atanhf(x) = Pol3(x), where Pol3(x) = x + x^3
+//
+// 4. 2^(-20) <= |x| < 1
+//    Return atanhf(x) = 0.5 * (log(1 + x) - log(1 - x))
+//    Algorithm description for log function see below.
+//
+// 5. |x| = 1
+//    Return atanhf(x) = sign(x) * +INF
+//
+// 6. 1 < |x| <= +INF
+//    Return atanhf(x) = QNaN
+//
+// 7. x = [S,Q]NaN
+//    Return atanhf(x) = QNaN
+//
+//==============================================================
+// Algorithm Description for log(x) function
+//
+// Consider  x = 2^N * 1.f1 f2 f3 f4...f63
+// log(x) = log(x * frcpa(x) / frcpa(x))
+//        = log(x * frcpa(x)) + log(1/frcpa(x))
+//        = log(x * frcpa(x)) - log(frcpa(x))
+//
+// frcpa(x) = 2^(-N) * frcpa(1.f1 f2 ... f63)
+//
+// -log(frcpa(x)) = -log(C)
+//                = -log(2^(-N)) - log(frcpa(1.f1 f2 ... f63))
+//
+// -log(frcpa(x)) = -log(C)
+//                = N*log2 - log(frcpa(1.f1 f2 ... f63))
+//
+//
+// log(x) = log(1/frcpa(x)) + log(frcpa(x) x)
+//
+// log(x) = N*log2 + log(1./frcpa(1.f1 f2 ... f63)) + log(x * frcpa(x))
+// log(x) = N*log2 + T                              + log(frcpa(x) x)
+//
+// Log(x) = N*log2 + T                              + log(C * x)
+//
+// C * x = 1 + r
+//
+// log(x) = N*log2 + T + log(1 + r)
+// log(x) = N*log2 + T + Series(r)
+//
+// 1.f1 f2 ... f8 has 256 entries.
+// They are 1 + k/2^8, k = 0 ... 255
+// These 256 values are the table entries.
+//
+// Implementation
+//==============================================================
+// C = frcpa(x)
+// r = C * x - 1
+//
+// Form rseries = r + P1*r^2 + P2*r^3 + P3*r^4
+//
+// x = f * 2*N where f is 1.f_1f_2f_3...f_63
+// Nfloat = float(n)  where n is the true unbiased exponent
+// pre-index = f_1f_2....f_8
+// index = pre_index * 16
+// get the dxt table entry at index + offset = T
+//
+// result = (T + Nfloat * log(2)) + rseries
+//
+// The T table is calculated as follows
+// Form x_k = 1 + k/2^8 where k goes from 0... 255
+//      y_k = frcpa(x_k)
+//      log(1/y_k)  in quad and round to double-extended
+
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input
+// f32 -> f59
+
+// General registers used:
+// r14 -> r29, r32 -> r39
+
+// Predicate registers used:
+// p6 -> p9
+
+// p6           to filter out case when |x| >= 1
+// p7           to filter out case when x = [Q,S]NaN or +/-0
+// p8           to filter out case when |x| < 2^(-20)
+// p9           to filter out case when x = denormal
+
+
+// Assembly macros
+//==============================================================
+DataPtr               = r14
+RcpTablePtrM          = r15
+RcpTablePtrP          = r16
+rExpbMask             = r17
+rBias                 = r18
+rNearZeroBound        = r19
+rArgSExpb             = r20
+rArgExpb              = r21
+rExpbm                = r22
+rExpbp                = r23
+rSigm                 = r24
+rSigp                 = r25
+rNm                   = r26
+rNp                   = r27
+rIndm                 = r28
+rIndp                 = r29
+
+GR_SAVE_B0            = r33
+GR_SAVE_GP            = r34
+GR_SAVE_PFS           = r35
+
+GR_Parameter_X        = r36
+GR_Parameter_Y        = r37
+GR_Parameter_RESULT   = r38
+atanh_GR_tag          = r39
+
+//==============================================================
+fOneMx                = f33
+fOnePx                = f34
+fRm2                  = f35
+fRm3                  = f36
+fRp2                  = f37
+fRp3                  = f38
+fRcpM                 = f39
+fRcpP                 = f40
+fRp                   = f41
+fRm                   = f42
+fN4CvtM               = f43
+fN4CvtP               = f44
+fNm                   = f45
+fNp                   = f46
+fLogTm                = f47
+fLogTp                = f48
+fLog2                 = f49
+fArgAbs               = f50
+fNormX                = f50
+fP32m                 = f51
+fP32p                 = f52
+fP10m                 = f53
+fP10p                 = f54
+fX2                   = f55
+fP3                   = f56
+fP2                   = f57
+fP1                   = f58
+fHalf                 = f59
+
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(atanhf_data)
+data8 0xbfc0001008f39d59    // P3*0.5
+data8 0x3fc5556073e0c45a    // P2*0.5
+data8 0xbfcffffffffaea15    // P1*0.5
+data8 0x3fe0000000000000    // 0.5
+data8 0x3fd62e42fefa39ef    // 0.5*ln(2)
+data8 0x0000000000000000    // pad
+LOCAL_OBJECT_END(atanhf_data)
+
+LOCAL_OBJECT_START(atanhf_data2)
+data8 0x3f50040155d5889e    //log(1/frcpa(1+0/256))/2
+data8 0x3f68121214586b54    //log(1/frcpa(1+1/256))/2
+data8 0x3f741929f96832f0    //log(1/frcpa(1+2/256))/2
+data8 0x3f7c317384c75f06    //log(1/frcpa(1+3/256))/2
+data8 0x3f81a6b91ac73386    //log(1/frcpa(1+4/256))/2
+data8 0x3f85ba9a5d9ac039    //log(1/frcpa(1+5/256))/2
+data8 0x3f89d2a8074325f4    //log(1/frcpa(1+6/256))/2
+data8 0x3f8d6b2725979802    //log(1/frcpa(1+7/256))/2
+data8 0x3f90c58fa19dfaaa    //log(1/frcpa(1+8/256))/2
+data8 0x3f92954c78cbce1b    //log(1/frcpa(1+9/256))/2
+data8 0x3f94a94d2da96c56    //log(1/frcpa(1+10/256))/2
+data8 0x3f967c94f2d4bb58    //log(1/frcpa(1+11/256))/2
+data8 0x3f985188b630f068    //log(1/frcpa(1+12/256))/2
+data8 0x3f9a6b8abe73af4c    //log(1/frcpa(1+13/256))/2
+data8 0x3f9c441e06f72a9e    //log(1/frcpa(1+14/256))/2
+data8 0x3f9e1e6713606d07    //log(1/frcpa(1+15/256))/2
+data8 0x3f9ffa6911ab9301    //log(1/frcpa(1+16/256))/2
+data8 0x3fa0ec139c5da601    //log(1/frcpa(1+17/256))/2
+data8 0x3fa1dbd2643d190b    //log(1/frcpa(1+18/256))/2
+data8 0x3fa2cc7284fe5f1c    //log(1/frcpa(1+19/256))/2
+data8 0x3fa3bdf5a7d1ee64    //log(1/frcpa(1+20/256))/2
+data8 0x3fa4b05d7aa012e0    //log(1/frcpa(1+21/256))/2
+data8 0x3fa580db7ceb5702    //log(1/frcpa(1+22/256))/2
+data8 0x3fa674f089365a7a    //log(1/frcpa(1+23/256))/2
+data8 0x3fa769ef2c6b568d    //log(1/frcpa(1+24/256))/2
+data8 0x3fa85fd927506a48    //log(1/frcpa(1+25/256))/2
+data8 0x3fa9335e5d594989    //log(1/frcpa(1+26/256))/2
+data8 0x3faa2b0220c8e5f5    //log(1/frcpa(1+27/256))/2
+data8 0x3fab0004ac1a86ac    //log(1/frcpa(1+28/256))/2
+data8 0x3fabf968769fca11    //log(1/frcpa(1+29/256))/2
+data8 0x3faccfedbfee13a8    //log(1/frcpa(1+30/256))/2
+data8 0x3fada727638446a2    //log(1/frcpa(1+31/256))/2
+data8 0x3faea3257fe10f7a    //log(1/frcpa(1+32/256))/2
+data8 0x3faf7be9fedbfde6    //log(1/frcpa(1+33/256))/2
+data8 0x3fb02ab352ff25f4    //log(1/frcpa(1+34/256))/2
+data8 0x3fb097ce579d204d    //log(1/frcpa(1+35/256))/2
+data8 0x3fb1178e8227e47c    //log(1/frcpa(1+36/256))/2
+data8 0x3fb185747dbecf34    //log(1/frcpa(1+37/256))/2
+data8 0x3fb1f3b925f25d41    //log(1/frcpa(1+38/256))/2
+data8 0x3fb2625d1e6ddf57    //log(1/frcpa(1+39/256))/2
+data8 0x3fb2d1610c86813a    //log(1/frcpa(1+40/256))/2
+data8 0x3fb340c59741142e    //log(1/frcpa(1+41/256))/2
+data8 0x3fb3b08b6757f2a9    //log(1/frcpa(1+42/256))/2
+data8 0x3fb40dfb08378003    //log(1/frcpa(1+43/256))/2
+data8 0x3fb47e74e8ca5f7c    //log(1/frcpa(1+44/256))/2
+data8 0x3fb4ef51f6466de4    //log(1/frcpa(1+45/256))/2
+data8 0x3fb56092e02ba516    //log(1/frcpa(1+46/256))/2
+data8 0x3fb5d23857cd74d5    //log(1/frcpa(1+47/256))/2
+data8 0x3fb6313a37335d76    //log(1/frcpa(1+48/256))/2
+data8 0x3fb6a399dabbd383    //log(1/frcpa(1+49/256))/2
+data8 0x3fb70337dd3ce41b    //log(1/frcpa(1+50/256))/2
+data8 0x3fb77654128f6127    //log(1/frcpa(1+51/256))/2
+data8 0x3fb7e9d82a0b022d    //log(1/frcpa(1+52/256))/2
+data8 0x3fb84a6b759f512f    //log(1/frcpa(1+53/256))/2
+data8 0x3fb8ab47d5f5a310    //log(1/frcpa(1+54/256))/2
+data8 0x3fb91fe49096581b    //log(1/frcpa(1+55/256))/2
+data8 0x3fb981634011aa75    //log(1/frcpa(1+56/256))/2
+data8 0x3fb9f6c407089664    //log(1/frcpa(1+57/256))/2
+data8 0x3fba58e729348f43    //log(1/frcpa(1+58/256))/2
+data8 0x3fbabb55c31693ad    //log(1/frcpa(1+59/256))/2
+data8 0x3fbb1e104919efd0    //log(1/frcpa(1+60/256))/2
+data8 0x3fbb94ee93e367cb    //log(1/frcpa(1+61/256))/2
+data8 0x3fbbf851c067555f    //log(1/frcpa(1+62/256))/2
+data8 0x3fbc5c0254bf23a6    //log(1/frcpa(1+63/256))/2
+data8 0x3fbcc000c9db3c52    //log(1/frcpa(1+64/256))/2
+data8 0x3fbd244d99c85674    //log(1/frcpa(1+65/256))/2
+data8 0x3fbd88e93fb2f450    //log(1/frcpa(1+66/256))/2
+data8 0x3fbdedd437eaef01    //log(1/frcpa(1+67/256))/2
+data8 0x3fbe530effe71012    //log(1/frcpa(1+68/256))/2
+data8 0x3fbeb89a1648b971    //log(1/frcpa(1+69/256))/2
+data8 0x3fbf1e75fadf9bde    //log(1/frcpa(1+70/256))/2
+data8 0x3fbf84a32ead7c35    //log(1/frcpa(1+71/256))/2
+data8 0x3fbfeb2233ea07cd    //log(1/frcpa(1+72/256))/2
+data8 0x3fc028f9c7035c1c    //log(1/frcpa(1+73/256))/2
+data8 0x3fc05c8be0d9635a    //log(1/frcpa(1+74/256))/2
+data8 0x3fc085eb8f8ae797    //log(1/frcpa(1+75/256))/2
+data8 0x3fc0b9c8e32d1911    //log(1/frcpa(1+76/256))/2
+data8 0x3fc0edd060b78081    //log(1/frcpa(1+77/256))/2
+data8 0x3fc122024cf0063f    //log(1/frcpa(1+78/256))/2
+data8 0x3fc14be2927aecd4    //log(1/frcpa(1+79/256))/2
+data8 0x3fc180618ef18adf    //log(1/frcpa(1+80/256))/2
+data8 0x3fc1b50bbe2fc63b    //log(1/frcpa(1+81/256))/2
+data8 0x3fc1df4cc7cf242d    //log(1/frcpa(1+82/256))/2
+data8 0x3fc214456d0eb8d4    //log(1/frcpa(1+83/256))/2
+data8 0x3fc23ec5991eba49    //log(1/frcpa(1+84/256))/2
+data8 0x3fc2740d9f870afb    //log(1/frcpa(1+85/256))/2
+data8 0x3fc29ecdabcdfa04    //log(1/frcpa(1+86/256))/2
+data8 0x3fc2d46602adccee    //log(1/frcpa(1+87/256))/2
+data8 0x3fc2ff66b04ea9d4    //log(1/frcpa(1+88/256))/2
+data8 0x3fc335504b355a37    //log(1/frcpa(1+89/256))/2
+data8 0x3fc360925ec44f5d    //log(1/frcpa(1+90/256))/2
+data8 0x3fc38bf1c3337e75    //log(1/frcpa(1+91/256))/2
+data8 0x3fc3c25277333184    //log(1/frcpa(1+92/256))/2
+data8 0x3fc3edf463c1683e    //log(1/frcpa(1+93/256))/2
+data8 0x3fc419b423d5e8c7    //log(1/frcpa(1+94/256))/2
+data8 0x3fc44591e0539f49    //log(1/frcpa(1+95/256))/2
+data8 0x3fc47c9175b6f0ad    //log(1/frcpa(1+96/256))/2
+data8 0x3fc4a8b341552b09    //log(1/frcpa(1+97/256))/2
+data8 0x3fc4d4f3908901a0    //log(1/frcpa(1+98/256))/2
+data8 0x3fc501528da1f968    //log(1/frcpa(1+99/256))/2
+data8 0x3fc52dd06347d4f6    //log(1/frcpa(1+100/256))/2
+data8 0x3fc55a6d3c7b8a8a    //log(1/frcpa(1+101/256))/2
+data8 0x3fc5925d2b112a59    //log(1/frcpa(1+102/256))/2
+data8 0x3fc5bf406b543db2    //log(1/frcpa(1+103/256))/2
+data8 0x3fc5ec433d5c35ae    //log(1/frcpa(1+104/256))/2
+data8 0x3fc61965cdb02c1f    //log(1/frcpa(1+105/256))/2
+data8 0x3fc646a84935b2a2    //log(1/frcpa(1+106/256))/2
+data8 0x3fc6740add31de94    //log(1/frcpa(1+107/256))/2
+data8 0x3fc6a18db74a58c5    //log(1/frcpa(1+108/256))/2
+data8 0x3fc6cf31058670ec    //log(1/frcpa(1+109/256))/2
+data8 0x3fc6f180e852f0ba    //log(1/frcpa(1+110/256))/2
+data8 0x3fc71f5d71b894f0    //log(1/frcpa(1+111/256))/2
+data8 0x3fc74d5aefd66d5c    //log(1/frcpa(1+112/256))/2
+data8 0x3fc77b79922bd37e    //log(1/frcpa(1+113/256))/2
+data8 0x3fc7a9b9889f19e2    //log(1/frcpa(1+114/256))/2
+data8 0x3fc7d81b037eb6a6    //log(1/frcpa(1+115/256))/2
+data8 0x3fc8069e33827231    //log(1/frcpa(1+116/256))/2
+data8 0x3fc82996d3ef8bcb    //log(1/frcpa(1+117/256))/2
+data8 0x3fc85855776dcbfb    //log(1/frcpa(1+118/256))/2
+data8 0x3fc8873658327ccf    //log(1/frcpa(1+119/256))/2
+data8 0x3fc8aa75973ab8cf    //log(1/frcpa(1+120/256))/2
+data8 0x3fc8d992dc8824e5    //log(1/frcpa(1+121/256))/2
+data8 0x3fc908d2ea7d9512    //log(1/frcpa(1+122/256))/2
+data8 0x3fc92c59e79c0e56    //log(1/frcpa(1+123/256))/2
+data8 0x3fc95bd750ee3ed3    //log(1/frcpa(1+124/256))/2
+data8 0x3fc98b7811a3ee5b    //log(1/frcpa(1+125/256))/2
+data8 0x3fc9af47f33d406c    //log(1/frcpa(1+126/256))/2
+data8 0x3fc9df270c1914a8    //log(1/frcpa(1+127/256))/2
+data8 0x3fca0325ed14fda4    //log(1/frcpa(1+128/256))/2
+data8 0x3fca33440224fa79    //log(1/frcpa(1+129/256))/2
+data8 0x3fca57725e80c383    //log(1/frcpa(1+130/256))/2
+data8 0x3fca87d0165dd199    //log(1/frcpa(1+131/256))/2
+data8 0x3fcaac2e6c03f896    //log(1/frcpa(1+132/256))/2
+data8 0x3fcadccc6fdf6a81    //log(1/frcpa(1+133/256))/2
+data8 0x3fcb015b3eb1e790    //log(1/frcpa(1+134/256))/2
+data8 0x3fcb323a3a635948    //log(1/frcpa(1+135/256))/2
+data8 0x3fcb56fa04462909    //log(1/frcpa(1+136/256))/2
+data8 0x3fcb881aa659bc93    //log(1/frcpa(1+137/256))/2
+data8 0x3fcbad0bef3db165    //log(1/frcpa(1+138/256))/2
+data8 0x3fcbd21297781c2f    //log(1/frcpa(1+139/256))/2
+data8 0x3fcc039236f08819    //log(1/frcpa(1+140/256))/2
+data8 0x3fcc28cb1e4d32fd    //log(1/frcpa(1+141/256))/2
+data8 0x3fcc4e19b84723c2    //log(1/frcpa(1+142/256))/2
+data8 0x3fcc7ff9c74554c9    //log(1/frcpa(1+143/256))/2
+data8 0x3fcca57b64e9db05    //log(1/frcpa(1+144/256))/2
+data8 0x3fcccb130a5cebb0    //log(1/frcpa(1+145/256))/2
+data8 0x3fccf0c0d18f326f    //log(1/frcpa(1+146/256))/2
+data8 0x3fcd232075b5a201    //log(1/frcpa(1+147/256))/2
+data8 0x3fcd490246defa6b    //log(1/frcpa(1+148/256))/2
+data8 0x3fcd6efa918d25cd    //log(1/frcpa(1+149/256))/2
+data8 0x3fcd9509707ae52f    //log(1/frcpa(1+150/256))/2
+data8 0x3fcdbb2efe92c554    //log(1/frcpa(1+151/256))/2
+data8 0x3fcdee2f3445e4af    //log(1/frcpa(1+152/256))/2
+data8 0x3fce148a1a2726ce    //log(1/frcpa(1+153/256))/2
+data8 0x3fce3afc0a49ff40    //log(1/frcpa(1+154/256))/2
+data8 0x3fce6185206d516e    //log(1/frcpa(1+155/256))/2
+data8 0x3fce882578823d52    //log(1/frcpa(1+156/256))/2
+data8 0x3fceaedd2eac990c    //log(1/frcpa(1+157/256))/2
+data8 0x3fced5ac5f436be3    //log(1/frcpa(1+158/256))/2
+data8 0x3fcefc9326d16ab9    //log(1/frcpa(1+159/256))/2
+data8 0x3fcf2391a2157600    //log(1/frcpa(1+160/256))/2
+data8 0x3fcf4aa7ee03192d    //log(1/frcpa(1+161/256))/2
+data8 0x3fcf71d627c30bb0    //log(1/frcpa(1+162/256))/2
+data8 0x3fcf991c6cb3b379    //log(1/frcpa(1+163/256))/2
+data8 0x3fcfc07ada69a910    //log(1/frcpa(1+164/256))/2
+data8 0x3fcfe7f18eb03d3e    //log(1/frcpa(1+165/256))/2
+data8 0x3fd007c053c5002e    //log(1/frcpa(1+166/256))/2
+data8 0x3fd01b942198a5a1    //log(1/frcpa(1+167/256))/2
+data8 0x3fd02f74400c64eb    //log(1/frcpa(1+168/256))/2
+data8 0x3fd04360be7603ad    //log(1/frcpa(1+169/256))/2
+data8 0x3fd05759ac47fe34    //log(1/frcpa(1+170/256))/2
+data8 0x3fd06b5f1911cf52    //log(1/frcpa(1+171/256))/2
+data8 0x3fd078bf0533c568    //log(1/frcpa(1+172/256))/2
+data8 0x3fd08cd9687e7b0e    //log(1/frcpa(1+173/256))/2
+data8 0x3fd0a10074cf9019    //log(1/frcpa(1+174/256))/2
+data8 0x3fd0b5343a234477    //log(1/frcpa(1+175/256))/2
+data8 0x3fd0c974c89431ce    //log(1/frcpa(1+176/256))/2
+data8 0x3fd0ddc2305b9886    //log(1/frcpa(1+177/256))/2
+data8 0x3fd0eb524bafc918    //log(1/frcpa(1+178/256))/2
+data8 0x3fd0ffb54213a476    //log(1/frcpa(1+179/256))/2
+data8 0x3fd114253da97d9f    //log(1/frcpa(1+180/256))/2
+data8 0x3fd128a24f1d9aff    //log(1/frcpa(1+181/256))/2
+data8 0x3fd1365252bf0865    //log(1/frcpa(1+182/256))/2
+data8 0x3fd14ae558b4a92d    //log(1/frcpa(1+183/256))/2
+data8 0x3fd15f85a19c765b    //log(1/frcpa(1+184/256))/2
+data8 0x3fd16d4d38c119fa    //log(1/frcpa(1+185/256))/2
+data8 0x3fd18203c20dd133    //log(1/frcpa(1+186/256))/2
+data8 0x3fd196c7bc4b1f3b    //log(1/frcpa(1+187/256))/2
+data8 0x3fd1a4a738b7a33c    //log(1/frcpa(1+188/256))/2
+data8 0x3fd1b981c0c9653d    //log(1/frcpa(1+189/256))/2
+data8 0x3fd1ce69e8bb106b    //log(1/frcpa(1+190/256))/2
+data8 0x3fd1dc619de06944    //log(1/frcpa(1+191/256))/2
+data8 0x3fd1f160a2ad0da4    //log(1/frcpa(1+192/256))/2
+data8 0x3fd2066d7740737e    //log(1/frcpa(1+193/256))/2
+data8 0x3fd2147dba47a394    //log(1/frcpa(1+194/256))/2
+data8 0x3fd229a1bc5ebac3    //log(1/frcpa(1+195/256))/2
+data8 0x3fd237c1841a502e    //log(1/frcpa(1+196/256))/2
+data8 0x3fd24cfce6f80d9a    //log(1/frcpa(1+197/256))/2
+data8 0x3fd25b2c55cd5762    //log(1/frcpa(1+198/256))/2
+data8 0x3fd2707f4d5f7c41    //log(1/frcpa(1+199/256))/2
+data8 0x3fd285e0842ca384    //log(1/frcpa(1+200/256))/2
+data8 0x3fd294294708b773    //log(1/frcpa(1+201/256))/2
+data8 0x3fd2a9a2670aff0c    //log(1/frcpa(1+202/256))/2
+data8 0x3fd2b7fb2c8d1cc1    //log(1/frcpa(1+203/256))/2
+data8 0x3fd2c65a6395f5f5    //log(1/frcpa(1+204/256))/2
+data8 0x3fd2dbf557b0df43    //log(1/frcpa(1+205/256))/2
+data8 0x3fd2ea64c3f97655    //log(1/frcpa(1+206/256))/2
+data8 0x3fd3001823684d73    //log(1/frcpa(1+207/256))/2
+data8 0x3fd30e97e9a8b5cd    //log(1/frcpa(1+208/256))/2
+data8 0x3fd32463ebdd34ea    //log(1/frcpa(1+209/256))/2
+data8 0x3fd332f4314ad796    //log(1/frcpa(1+210/256))/2
+data8 0x3fd348d90e7464d0    //log(1/frcpa(1+211/256))/2
+data8 0x3fd35779f8c43d6e    //log(1/frcpa(1+212/256))/2
+data8 0x3fd36621961a6a99    //log(1/frcpa(1+213/256))/2
+data8 0x3fd37c299f3c366a    //log(1/frcpa(1+214/256))/2
+data8 0x3fd38ae2171976e7    //log(1/frcpa(1+215/256))/2
+data8 0x3fd399a157a603e7    //log(1/frcpa(1+216/256))/2
+data8 0x3fd3afccfe77b9d1    //log(1/frcpa(1+217/256))/2
+data8 0x3fd3be9d503533b5    //log(1/frcpa(1+218/256))/2
+data8 0x3fd3cd7480b4a8a3    //log(1/frcpa(1+219/256))/2
+data8 0x3fd3e3c43918f76c    //log(1/frcpa(1+220/256))/2
+data8 0x3fd3f2acb27ed6c7    //log(1/frcpa(1+221/256))/2
+data8 0x3fd4019c2125ca93    //log(1/frcpa(1+222/256))/2
+data8 0x3fd4181061389722    //log(1/frcpa(1+223/256))/2
+data8 0x3fd42711518df545    //log(1/frcpa(1+224/256))/2
+data8 0x3fd436194e12b6bf    //log(1/frcpa(1+225/256))/2
+data8 0x3fd445285d68ea69    //log(1/frcpa(1+226/256))/2
+data8 0x3fd45bcc464c893a    //log(1/frcpa(1+227/256))/2
+data8 0x3fd46aed21f117fc    //log(1/frcpa(1+228/256))/2
+data8 0x3fd47a1527e8a2d3    //log(1/frcpa(1+229/256))/2
+data8 0x3fd489445efffccc    //log(1/frcpa(1+230/256))/2
+data8 0x3fd4a018bcb69835    //log(1/frcpa(1+231/256))/2
+data8 0x3fd4af5a0c9d65d7    //log(1/frcpa(1+232/256))/2
+data8 0x3fd4bea2a5bdbe87    //log(1/frcpa(1+233/256))/2
+data8 0x3fd4cdf28f10ac46    //log(1/frcpa(1+234/256))/2
+data8 0x3fd4dd49cf994058    //log(1/frcpa(1+235/256))/2
+data8 0x3fd4eca86e64a684    //log(1/frcpa(1+236/256))/2
+data8 0x3fd503c43cd8eb68    //log(1/frcpa(1+237/256))/2
+data8 0x3fd513356667fc57    //log(1/frcpa(1+238/256))/2
+data8 0x3fd522ae0738a3d8    //log(1/frcpa(1+239/256))/2
+data8 0x3fd5322e26867857    //log(1/frcpa(1+240/256))/2
+data8 0x3fd541b5cb979809    //log(1/frcpa(1+241/256))/2
+data8 0x3fd55144fdbcbd62    //log(1/frcpa(1+242/256))/2
+data8 0x3fd560dbc45153c7    //log(1/frcpa(1+243/256))/2
+data8 0x3fd5707a26bb8c66    //log(1/frcpa(1+244/256))/2
+data8 0x3fd587f60ed5b900    //log(1/frcpa(1+245/256))/2
+data8 0x3fd597a7977c8f31    //log(1/frcpa(1+246/256))/2
+data8 0x3fd5a760d634bb8b    //log(1/frcpa(1+247/256))/2
+data8 0x3fd5b721d295f10f    //log(1/frcpa(1+248/256))/2
+data8 0x3fd5c6ea94431ef9    //log(1/frcpa(1+249/256))/2
+data8 0x3fd5d6bb22ea86f6    //log(1/frcpa(1+250/256))/2
+data8 0x3fd5e6938645d390    //log(1/frcpa(1+251/256))/2
+data8 0x3fd5f673c61a2ed2    //log(1/frcpa(1+252/256))/2
+data8 0x3fd6065bea385926    //log(1/frcpa(1+253/256))/2
+data8 0x3fd6164bfa7cc06b    //log(1/frcpa(1+254/256))/2
+data8 0x3fd62643fecf9743    //log(1/frcpa(1+255/256))/2
+LOCAL_OBJECT_END(atanhf_data2)
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(atanhf)
+
+{ .mfi
+      getf.exp      rArgSExpb = f8
+      fclass.m      p9,p0 = f8, 0x0b        // is arg denormal ?
+      mov           rExpbMask = 0x1ffff
+}
+{ .mfi
+      addl          DataPtr = @ltoff(atanhf_data), gp
+      fnma.s1       fOneMx = f8, f1, f1     // 1 - x
+      mov           rBias = 0xffff
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fclass.m      p7,p0 = f8, 0xc7        // is arg NaN or +/-0 ?
+      mov           rNearZeroBound = 0xffeb // 2^(-20)
+}
+{ .mfi
+      ld8           DataPtr = [DataPtr]
+      fma.s1        fOnePx = f8, f1, f1     // 1 + x
+      nop.i         0
+}
+;;
+
+{ .mfb
+      nop.m         0
+      fnorm.s1      fNormX = f8                     // Normalize x
+(p9)  br.cond.spnt  ATANH_UNORM                     // Branch if x=unorm
+}
+;;
+
+ATANH_COMMON:
+// Return here if x=unorm and not denorm
+{ .mfi
+      ldfpd         fP3, fP2 = [DataPtr], 16
+      fma.s1        fX2 = f8, f8, f0        // x^2
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p7)  fma.s.s0      f8 =  f8,f1,f8          // NaN or +/-0
+(p7)  br.ret.spnt   b0
+}
+;;
+
+{ .mfi
+      ldfpd         fP1, fHalf = [DataPtr], 16
+      frcpa.s1      fRcpM, p9 = f1, fOneMx  // rcpm = frcpa(1 - x)
+      nop.i         0
+}
+;;
+
+{ .mfi
+      getf.exp      rExpbm = fOneMx
+      frcpa.s1      fRcpP, p0 = f1, fOnePx  // rcpp = frcpa(1 + x)
+      // biased exponent
+      and           rArgExpb = rArgSExpb, rExpbMask
+}
+;;
+
+{ .mmi
+      getf.exp      rExpbp = fOnePx
+      // is |x| < 2^(-20) ?
+      cmp.gt        p8,p0 = rNearZeroBound, rArgExpb
+      cmp.ge        p6,p0 = rArgExpb, rBias // is |x| >= 1 ?
+}
+;;
+
+{ .mmb
+      getf.sig      rSigm = fOneMx
+      nop.m         0
+(p6)  br.cond.spnt  atanhf_ge_one
+}
+;;
+
+{ .mfb
+      getf.sig      rSigp = fOnePx
+(p8)  fma.s.s0      f8 =  fX2, f8, f8  // x + x^3
+(p8)  br.ret.spnt   b0                 // Exit for MAX_DENORM_ABS < |x| < 2^-20
+}
+;;
+
+{ .mfi
+      ldfd          fLog2 = [DataPtr], 16
+      fms.s1        fRm = fRcpM, fOneMx, f1 // rm = rcpm * (1 - x) - 1
+      nop.i         0
+}
+;;
+
+{ .mmf
+      // (1 - x) is always positive here and we need not mask sign bit
+      sub           rNm = rExpbm, rBias
+      // (1 + x) is always positive here and we need not mask sign bit
+      sub           rNp = rExpbp, rBias
+      fms.s1        fRp = fRcpP, fOnePx, f1 // rp = rcpp * (1 + x) - 1
+}
+;;
+
+{ .mmi
+      setf.sig      fN4CvtM = rNm
+      setf.sig      fN4CvtP = rNp
+      extr.u        rIndm = rSigm,55,8                // Extract 8 bits
+}
+;;
+
+{ .mmi
+      shladd        RcpTablePtrM = rIndm, 3, DataPtr
+      nop.m         0
+      extr.u        rIndp = rSigp,55,8                // Extract 8 bits
+}
+;;
+
+{ .mmi
+      ldfd          fLogTm = [RcpTablePtrM]
+      shladd        RcpTablePtrP = rIndp, 3, DataPtr
+      nop.i         0
+}
+;;
+
+{ .mfi
+      ldfd          fLogTp = [RcpTablePtrP]
+      fma.s1        fRm2 = fRm, fRm, f0     // rm^2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        fP32m = fP3, fRm, fP2   // P3*rm + P2
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.s1        fRp2 = fRp, fRp, f0     // rp^2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        fP10m = fP1, fRm, fHalf   // P1*rm + 1
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.s1        fP32p = fP3, fRp, fP2   // P3*rp + P2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        fP10p = fP1, fRp, fHalf   // P1*rp + 1
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fcvt.xf       fNm = fN4CvtM
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fcvt.xf       fNp = fN4CvtP
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      // (P3*rm + P2)*rm^2 + (P1*rm + 1)
+      fma.s1        fP32m = fP32m, fRm2, fP10m
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      // (P3*rp + P2)*rp^2 + (P1*rp + 1)
+      fma.s1        fP32p = fP32p, fRp2, fP10p
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      // Nm*ln(2)/2 + Tm/2
+      fma.s1        fLogTm = fNm, fLog2, fLogTm
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      // Np*ln(2)/2 + Tp/2
+      fma.s1        fLogTp = fNp, fLog2, fLogTp
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      // ((P3*rm + P2)*rm^2 + (P3*rm + 1))*0.5*rm + (Nm*ln(2)/2 + Tm/2)
+      fma.d.s1      fP32m = fP32m, fRm, fLogTm
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      // ((P3*rp + P2)*rp^2 + (P3*rp + 1))*0.5*rp + (Np*ln(2)/2 + Tp/2)
+      fma.d.s1      fP32p = fP32p, fRp, fLogTp
+      nop.i         0
+}
+;;
+
+{ .mfb
+      nop.m         0
+      // atanhf(x) = 0.5 * (log(1 + x) - log(1 - x))
+      fnma.s.s0     f8 = fP32m, f1, fP32p
+      br.ret.sptk   b0                      // Exit for 2^(-20) <= |x| < 1.0
+}
+;;
+
+
+ATANH_UNORM:
+// Here if x=unorm
+{ .mfi
+      getf.exp      rArgSExpb = fNormX           // Recompute if x unorm
+      fclass.m      p0,p9 = fNormX, 0x0b         // Test x denorm
+      nop.i         0
+}
+;;
+
+{ .mfb
+      nop.m         0
+      fcmp.lt.s0    p10,p11 = f8, f0      // Set denormal flag
+(p9)  br.cond.sptk  ATANH_COMMON          // Continue if x unorm and not denorm
+}
+;;
+
+.pred.rel "mutex",p6,p7
+{ .mfi
+      nop.m         0
+(p6)  fnma.s.s0     f8 = f8,f8,f8                // Result x-x^2 if x=-denorm
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p7)  fma.s.s0      f8 = f8,f8,f8                // Result x+x^2 if x=+denorm
+      br.ret.spnt   b0                           // Exit if denorm
+}
+;;
+
+// Here if |x| >= 1.0
+atanhf_ge_one:
+{ .mfi
+      alloc         r32 = ar.pfs,1,3,4,0
+      fmerge.s      fArgAbs = f0, f8        // Form |x|
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fmerge.s      f10 = f8, f8            // Save input for error call
+      nop.i         0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fcmp.eq.s1    p6,p7 = fArgAbs, f1     // Test for |x| = 1.0
+      nop.i         0
+}
+;;
+
+// Set error tag and result, and raise invalid flag if |x| > 1.0
+{ .mfi
+(p7)  mov           atanh_GR_tag = 133
+(p7)  frcpa.s0      f8, p0 = f0, f0         // Get QNaN, and raise invalid
+      nop.i         0
+}
+;;
+
+// Set error tag and result, and raise Z flag if |x| = 1.0
+{ .mfi
+      nop.m         0
+(p6)  frcpa.s0      fRm, p0 = f1, f0        // Get inf, and raise Z flag
+      nop.i         0
+}
+;;
+
+{ .mfb
+(p6)  mov           atanh_GR_tag = 134
+(p6)  fmerge.s      f8 = f8, fRm            // result is +-inf
+      br.cond.sptk  __libm_error_region     // Exit if |x| >= 1.0
+}
+;;
+
+GLOBAL_LIBM_END(atanhf)
+libm_alias_float_other (atanh, atanh)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+
+{ .mfi
+      add           GR_Parameter_Y=-32,sp   // Parameter 2 value
+      nop.f         0
+.save   ar.pfs,GR_SAVE_PFS
+      mov           GR_SAVE_PFS=ar.pfs      // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+      add sp=-64,sp                         // Create new stack
+      nop.f 0
+      mov GR_SAVE_GP=gp                     // Save gp
+};;
+
+{ .mmi
+      stfs [GR_Parameter_Y] = f1,16         // STORE Parameter 2 on stack
+      add GR_Parameter_X = 16,sp            // Parameter 1 address
+.save   b0, GR_SAVE_B0
+      mov GR_SAVE_B0=b0                     // Save b0
+};;
+
+.body
+{ .mib
+      stfs [GR_Parameter_X] = f10           // STORE Parameter 1 on stack
+      // Parameter 3 address
+      add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+      nop.b 0
+}
+{ .mib
+      stfs [GR_Parameter_Y] = f8            // STORE Parameter 3 on stack
+      add   GR_Parameter_Y = -16,GR_Parameter_Y
+      br.call.sptk b0=__libm_error_support# // Call error handling function
+};;
+
+{ .mmi
+      add   GR_Parameter_RESULT = 48,sp
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mmi
+      ldfs  f8 = [GR_Parameter_RESULT]      // Get return result off stack
+.restore sp
+      add   sp = 64,sp                      // Restore stack pointer
+      mov   b0 = GR_SAVE_B0                 // Restore return address
+};;
+
+{ .mib
+      mov   gp = GR_SAVE_GP                 // Restore gp
+      mov   ar.pfs = GR_SAVE_PFS            // Restore ar.pfs
+      br.ret.sptk     b0                    // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_atanhl.S
@@ -0,0 +1,1156 @@
+.file "atanhl.s"
+
+
+// Copyright (c) 2001 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,INCLUDING,BUT NOT
+// LIMITED TO,THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT,INDIRECT,INCIDENTAL,SPECIAL,
+// EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING,BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,DATA,OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY,WHETHER IN CONTRACT,STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE,EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code,and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 09/10/01  Initial version
+// 12/11/01  Corrected .restore syntax
+// 05/20/02  Cleaned up namespace and sf0 syntax
+// 02/10/03  Reordered header: .section, .global, .proc, .align;
+//           used data8 for long double table values
+//
+//*********************************************************************
+//
+//*********************************************************************
+//
+// Function: atanhl(x) computes the principle value of the inverse
+// hyperbolic tangent of x.
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8 (Input and Return Value)
+//                              f33-f73
+//
+//    General Purpose Registers:
+//      r32-r52
+//      r49-r52 (Used to pass arguments to error handling routine)
+//
+//    Predicate Registers:      p6-p15
+//
+//*********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    atanhl(inf) = QNaN
+//    atanhl(-inf) = QNaN
+//    atanhl(+/-0) = +/-0
+//    atanhl(1) =  +inf
+//    atanhl(-1) =  -inf
+//    atanhl(|x|>1) = QNaN
+//    atanhl(SNaN) = QNaN
+//    atanhl(QNaN) = QNaN
+//
+//*********************************************************************
+//
+// Overview
+//
+// The method consists of two cases.
+//
+// If      |x| < 1/32  use case atanhl_near_zero;
+// else                 use case atanhl_regular;
+//
+// Case atanhl_near_zero:
+//
+//   atanhl(x) can be approximated by the Taylor series expansion
+//   up to order 17.
+//
+// Case atanhl_regular:
+//
+//   Here we use formula atanhl(x) = sign(x)*log1pl(2*|x|/(1-|x|))/2 and
+//   calculation is subdivided into two stages. The first stage is
+//   calculating of X = 2*|x|/(1-|x|). The second one is calculating of
+//   sign(x)*log1pl(X)/2. To obtain required accuracy we use precise division
+//   algorithm output of which is a pair of two extended precision values those
+//   approximate result of division with accuracy higher than working
+//   precision. This pair is passed to modified log1pl function.
+//
+//
+//   1. calculating of X = 2*|x|/(1-|x|)
+//   ( based on Peter Markstein's "IA-64 and Elementary Functions" book )
+//   ********************************************************************
+//
+//     a = 2*|x|
+//     b = 1 - |x|
+//     b_lo = |x| - (1 - b)
+//
+//     y = frcpa(b)         initial approximation of 1/b
+//     q = a*y              initial approximation of a/b
+//
+//     e = 1 - b*y
+//     e2 = e + e^2
+//     e1 = e^2
+//     y1 = y + y*e2 = y + y*(e+e^2)
+//
+//     e3 = e + e1^2
+//     y2 = y + y1*e3 = y + y*(e+e^2+..+e^6)
+//
+//     r = a - b*q
+//     e = 1 - b*y2
+//     X = q + r*y2         high part of a/b
+//
+//     y3 = y2 + y2*e4
+//     r1 = a - b*X
+//     r1 = r1 - b_lo*X
+//     X_lo = r1*y3         low part of a/b
+//
+//   2. special log1p algorithm overview
+//   ***********************************
+//
+//    Here we use a table lookup method. The basic idea is that in
+//    order to compute logl(Arg) = log1pl (Arg-1) for an argument Arg in [1,2),
+//    we construct a value G such that G*Arg is close to 1 and that
+//    logl(1/G) is obtainable easily from a table of values calculated
+//    beforehand. Thus
+//
+//      logl(Arg) = logl(1/G) + logl(G*Arg)
+//           = logl(1/G) + logl(1 + (G*Arg - 1))
+//
+//    Because |G*Arg - 1| is small, the second term on the right hand
+//    side can be approximated by a short polynomial. We elaborate
+//    this method in several steps.
+//
+//    Step 0: Initialization
+//    ------
+//    We need to calculate logl(X + X_lo + 1). Obtain N, S_hi such that
+//
+//      X + X_lo + 1 = 2^N * ( S_hi + S_lo )   exactly
+//
+//    where S_hi in [1,2) and S_lo is a correction to S_hi in the sense
+//    that |S_lo| <= ulp(S_hi).
+//
+//    For the special version of log1p we add X_lo to S_lo (S_lo = S_lo + X_lo)
+//    !-----------------------------------------------------------------------!
+//
+//    Step 1: Argument Reduction
+//    ------
+//    Based on S_hi, obtain G_1, G_2, G_3 from a table and calculate
+//
+//      G := G_1 * G_2 * G_3
+//      r := (G * S_hi - 1) + G * S_lo
+//
+//    These G_j's have the property that the product is exactly
+//    representable and that |r| < 2^(-12) as a result.
+//
+//    Step 2: Approximation
+//    ------
+//    logl(1 + r) is approximated by a short polynomial poly(r).
+//
+//    Step 3: Reconstruction
+//    ------
+//    Finally, log1pl(X + X_lo) = logl(X + X_lo + 1) is given by
+//
+//    logl(X + X_lo + 1) =  logl(2^N * (S_hi + S_lo))
+//                      ~=~ N*logl(2) + logl(1/G) + logl(1 + r)
+//                      ~=~ N*logl(2) + logl(1/G) + poly(r).
+//
+//    For detailed description see log1p1 function, regular path.
+//
+//*********************************************************************
+
+RODATA
+.align 64
+
+// ************* DO NOT CHANGE THE ORDER OF THESE TABLES *************
+
+LOCAL_OBJECT_START(Constants_TaylorSeries)
+data8  0xF0F0F0F0F0F0F0F1,0x00003FFA // C17
+data8  0x8888888888888889,0x00003FFB // C15
+data8  0x9D89D89D89D89D8A,0x00003FFB // C13
+data8  0xBA2E8BA2E8BA2E8C,0x00003FFB // C11
+data8  0xE38E38E38E38E38E,0x00003FFB // C9
+data8  0x9249249249249249,0x00003FFC // C7
+data8  0xCCCCCCCCCCCCCCCD,0x00003FFC // C5
+data8  0xAAAAAAAAAAAAAAAA,0x00003FFD // C3
+data4  0x3f000000                    // 1/2
+data4  0x00000000                    // pad
+data4  0x00000000
+data4  0x00000000
+LOCAL_OBJECT_END(Constants_TaylorSeries)
+
+LOCAL_OBJECT_START(Constants_Q)
+data4  0x00000000,0xB1721800,0x00003FFE,0x00000000 // log2_hi
+data4  0x4361C4C6,0x82E30865,0x0000BFE2,0x00000000 // log2_lo
+data4  0x328833CB,0xCCCCCAF2,0x00003FFC,0x00000000 // Q4
+data4  0xA9D4BAFB,0x80000077,0x0000BFFD,0x00000000 // Q3
+data4  0xAAABE3D2,0xAAAAAAAA,0x00003FFD,0x00000000 // Q2
+data4  0xFFFFDAB7,0xFFFFFFFF,0x0000BFFD,0x00000000 // Q1
+LOCAL_OBJECT_END(Constants_Q)
+
+
+// Z1 - 16 bit fixed
+LOCAL_OBJECT_START(Constants_Z_1)
+data4  0x00008000
+data4  0x00007879
+data4  0x000071C8
+data4  0x00006BCB
+data4  0x00006667
+data4  0x00006187
+data4  0x00005D18
+data4  0x0000590C
+data4  0x00005556
+data4  0x000051EC
+data4  0x00004EC5
+data4  0x00004BDB
+data4  0x00004925
+data4  0x0000469F
+data4  0x00004445
+data4  0x00004211
+LOCAL_OBJECT_END(Constants_Z_1)
+
+// G1 and H1 - IEEE single and h1 - IEEE double
+LOCAL_OBJECT_START(Constants_G_H_h1)
+data4  0x3F800000,0x00000000
+data8  0x0000000000000000
+data4  0x3F70F0F0,0x3D785196
+data8  0x3DA163A6617D741C
+data4  0x3F638E38,0x3DF13843
+data8  0x3E2C55E6CBD3D5BB
+data4  0x3F579430,0x3E2FF9A0
+data8  0xBE3EB0BFD86EA5E7
+data4  0x3F4CCCC8,0x3E647FD6
+data8  0x3E2E6A8C86B12760
+data4  0x3F430C30,0x3E8B3AE7
+data8  0x3E47574C5C0739BA
+data4  0x3F3A2E88,0x3EA30C68
+data8  0x3E20E30F13E8AF2F
+data4  0x3F321640,0x3EB9CEC8
+data8  0xBE42885BF2C630BD
+data4  0x3F2AAAA8,0x3ECF9927
+data8  0x3E497F3497E577C6
+data4  0x3F23D708,0x3EE47FC5
+data8  0x3E3E6A6EA6B0A5AB
+data4  0x3F1D89D8,0x3EF8947D
+data8  0xBDF43E3CD328D9BE
+data4  0x3F17B420,0x3F05F3A1
+data8  0x3E4094C30ADB090A
+data4  0x3F124920,0x3F0F4303
+data8  0xBE28FBB2FC1FE510
+data4  0x3F0D3DC8,0x3F183EBF
+data8  0x3E3A789510FDE3FA
+data4  0x3F088888,0x3F20EC80
+data8  0x3E508CE57CC8C98F
+data4  0x3F042108,0x3F29516A
+data8  0xBE534874A223106C
+LOCAL_OBJECT_END(Constants_G_H_h1)
+
+// Z2 - 16 bit fixed
+LOCAL_OBJECT_START(Constants_Z_2)
+data4  0x00008000
+data4  0x00007F81
+data4  0x00007F02
+data4  0x00007E85
+data4  0x00007E08
+data4  0x00007D8D
+data4  0x00007D12
+data4  0x00007C98
+data4  0x00007C20
+data4  0x00007BA8
+data4  0x00007B31
+data4  0x00007ABB
+data4  0x00007A45
+data4  0x000079D1
+data4  0x0000795D
+data4  0x000078EB
+LOCAL_OBJECT_END(Constants_Z_2)
+
+// G2 and H2 - IEEE single and h2 - IEEE double
+LOCAL_OBJECT_START(Constants_G_H_h2)
+data4  0x3F800000,0x00000000
+data8  0x0000000000000000
+data4  0x3F7F00F8,0x3B7F875D
+data8  0x3DB5A11622C42273
+data4  0x3F7E03F8,0x3BFF015B
+data8  0x3DE620CF21F86ED3
+data4  0x3F7D08E0,0x3C3EE393
+data8  0xBDAFA07E484F34ED
+data4  0x3F7C0FC0,0x3C7E0586
+data8  0xBDFE07F03860BCF6
+data4  0x3F7B1880,0x3C9E75D2
+data8  0x3DEA370FA78093D6
+data4  0x3F7A2328,0x3CBDC97A
+data8  0x3DFF579172A753D0
+data4  0x3F792FB0,0x3CDCFE47
+data8  0x3DFEBE6CA7EF896B
+data4  0x3F783E08,0x3CFC15D0
+data8  0x3E0CF156409ECB43
+data4  0x3F774E38,0x3D0D874D
+data8  0xBE0B6F97FFEF71DF
+data4  0x3F766038,0x3D1CF49B
+data8  0xBE0804835D59EEE8
+data4  0x3F757400,0x3D2C531D
+data8  0x3E1F91E9A9192A74
+data4  0x3F748988,0x3D3BA322
+data8  0xBE139A06BF72A8CD
+data4  0x3F73A0D0,0x3D4AE46F
+data8  0x3E1D9202F8FBA6CF
+data4  0x3F72B9D0,0x3D5A1756
+data8  0xBE1DCCC4BA796223
+data4  0x3F71D488,0x3D693B9D
+data8  0xBE049391B6B7C239
+LOCAL_OBJECT_END(Constants_G_H_h2)
+
+// G3 and H3 - IEEE single and h3 - IEEE double
+LOCAL_OBJECT_START(Constants_G_H_h3)
+data4  0x3F7FFC00,0x38800100
+data8  0x3D355595562224CD
+data4  0x3F7FF400,0x39400480
+data8  0x3D8200A206136FF6
+data4  0x3F7FEC00,0x39A00640
+data8  0x3DA4D68DE8DE9AF0
+data4  0x3F7FE400,0x39E00C41
+data8  0xBD8B4291B10238DC
+data4  0x3F7FDC00,0x3A100A21
+data8  0xBD89CCB83B1952CA
+data4  0x3F7FD400,0x3A300F22
+data8  0xBDB107071DC46826
+data4  0x3F7FCC08,0x3A4FF51C
+data8  0x3DB6FCB9F43307DB
+data4  0x3F7FC408,0x3A6FFC1D
+data8  0xBD9B7C4762DC7872
+data4  0x3F7FBC10,0x3A87F20B
+data8  0xBDC3725E3F89154A
+data4  0x3F7FB410,0x3A97F68B
+data8  0xBD93519D62B9D392
+data4  0x3F7FAC18,0x3AA7EB86
+data8  0x3DC184410F21BD9D
+data4  0x3F7FA420,0x3AB7E101
+data8  0xBDA64B952245E0A6
+data4  0x3F7F9C20,0x3AC7E701
+data8  0x3DB4B0ECAABB34B8
+data4  0x3F7F9428,0x3AD7DD7B
+data8  0x3D9923376DC40A7E
+data4  0x3F7F8C30,0x3AE7D474
+data8  0x3DC6E17B4F2083D3
+data4  0x3F7F8438,0x3AF7CBED
+data8  0x3DAE314B811D4394
+data4  0x3F7F7C40,0x3B03E1F3
+data8  0xBDD46F21B08F2DB1
+data4  0x3F7F7448,0x3B0BDE2F
+data8  0xBDDC30A46D34522B
+data4  0x3F7F6C50,0x3B13DAAA
+data8  0x3DCB0070B1F473DB
+data4  0x3F7F6458,0x3B1BD766
+data8  0xBDD65DDC6AD282FD
+data4  0x3F7F5C68,0x3B23CC5C
+data8  0xBDCDAB83F153761A
+data4  0x3F7F5470,0x3B2BC997
+data8  0xBDDADA40341D0F8F
+data4  0x3F7F4C78,0x3B33C711
+data8  0x3DCD1BD7EBC394E8
+data4  0x3F7F4488,0x3B3BBCC6
+data8  0xBDC3532B52E3E695
+data4  0x3F7F3C90,0x3B43BAC0
+data8  0xBDA3961EE846B3DE
+data4  0x3F7F34A0,0x3B4BB0F4
+data8  0xBDDADF06785778D4
+data4  0x3F7F2CA8,0x3B53AF6D
+data8  0x3DCC3ED1E55CE212
+data4  0x3F7F24B8,0x3B5BA620
+data8  0xBDBA31039E382C15
+data4  0x3F7F1CC8,0x3B639D12
+data8  0x3D635A0B5C5AF197
+data4  0x3F7F14D8,0x3B6B9444
+data8  0xBDDCCB1971D34EFC
+data4  0x3F7F0CE0,0x3B7393BC
+data8  0x3DC7450252CD7ADA
+data4  0x3F7F04F0,0x3B7B8B6D
+data8  0xBDB68F177D7F2A42
+LOCAL_OBJECT_END(Constants_G_H_h3)
+
+
+
+// Floating Point Registers
+
+FR_C17              = f50
+FR_C15              = f51
+FR_C13              = f52
+FR_C11              = f53
+FR_C9               = f54
+FR_C7               = f55
+FR_C5               = f56
+FR_C3               = f57
+FR_x2               = f58
+FR_x3               = f59
+FR_x4               = f60
+FR_x8               = f61
+
+FR_Rcp              = f61
+
+FR_A                = f33
+FR_R1               = f33
+
+FR_E1               = f34
+FR_E3               = f34
+FR_Y2               = f34
+FR_Y3               = f34
+
+FR_E2               = f35
+FR_Y1               = f35
+
+FR_B                = f36
+FR_Y0               = f37
+FR_E0               = f38
+FR_E4               = f39
+FR_Q0               = f40
+FR_R0               = f41
+FR_B_lo             = f42
+
+FR_abs_x            = f43
+FR_Bp               = f44
+FR_Bn               = f45
+FR_Yp               = f46
+FR_Yn               = f47
+
+FR_X                = f48
+FR_BB               = f48
+FR_X_lo             = f49
+
+FR_G                = f50
+FR_Y_hi             = f51
+FR_H                = f51
+FR_h                = f52
+FR_G2               = f53
+FR_H2               = f54
+FR_h2               = f55
+FR_G3               = f56
+FR_H3               = f57
+FR_h3               = f58
+
+FR_Q4               = f59
+FR_poly_lo          = f59
+FR_Y_lo             = f59
+
+FR_Q3               = f60
+FR_Q2               = f61
+
+FR_Q1               = f62
+FR_poly_hi          = f62
+
+FR_float_N          = f63
+
+FR_AA               = f64
+FR_S_lo             = f64
+
+FR_S_hi             = f65
+FR_r                = f65
+
+FR_log2_hi          = f66
+FR_log2_lo          = f67
+FR_Z                = f68
+FR_2_to_minus_N     = f69
+FR_rcub             = f70
+FR_rsq              = f71
+FR_05r              = f72
+FR_Half             = f73
+
+FR_Arg_X            = f50
+FR_Arg_Y            = f0
+FR_RESULT           = f8
+
+
+
+// General Purpose Registers
+
+GR_ad_05            = r33
+GR_Index1           = r34
+GR_ArgExp           = r34
+GR_Index2           = r35
+GR_ExpMask          = r35
+GR_NearZeroBound    = r36
+GR_signif           = r36
+GR_X_0              = r37
+GR_X_1              = r37
+GR_X_2              = r38
+GR_Index3           = r38
+GR_minus_N          = r39
+GR_Z_1              = r40
+GR_Z_2              = r40
+GR_N                = r41
+GR_Bias             = r42
+GR_M                = r43
+GR_ad_taylor        = r44
+GR_ad_taylor_2      = r45
+GR_ad2_tbl_3        = r45
+GR_ad_tbl_1         = r46
+GR_ad_tbl_2         = r47
+GR_ad_tbl_3         = r48
+GR_ad_q             = r49
+GR_ad_z_1           = r50
+GR_ad_z_2           = r51
+GR_ad_z_3           = r52
+
+//
+// Added for unwind support
+//
+GR_SAVE_PFS         = r46
+GR_SAVE_B0          = r47
+GR_SAVE_GP          = r48
+GR_Parameter_X      = r49
+GR_Parameter_Y      = r50
+GR_Parameter_RESULT = r51
+GR_Parameter_TAG    = r52
+
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(atanhl)
+
+{ .mfi
+      alloc         r32 = ar.pfs,0,17,4,0
+      fnma.s1       FR_Bp = f8,f1,f1 // b = 1 - |arg| (for x>0)
+      mov           GR_ExpMask = 0x1ffff
+}
+{ .mfi
+      addl          GR_ad_taylor = @ltoff(Constants_TaylorSeries),gp
+      fma.s1        FR_Bn = f8,f1,f1 // b = 1 - |arg| (for x<0)
+      mov           GR_NearZeroBound = 0xfffa  // biased exp of 1/32
+};;
+{ .mfi
+      getf.exp      GR_ArgExp = f8
+      fcmp.lt.s1    p6,p7 = f8,f0 // is negative?
+      nop.i         0
+}
+{ .mfi
+      ld8           GR_ad_taylor = [GR_ad_taylor]
+      fmerge.s      FR_abs_x =  f1,f8
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fclass.m      p8,p0 = f8,0x1C7 // is arg NaT,Q/SNaN or +/-0 ?
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x2 = f8,f8,f0
+      nop.i         0
+};;
+{ .mfi
+      add           GR_ad_z_1 = 0x0F0,GR_ad_taylor
+      fclass.m      p9,p0 = f8,0x0a // is arg -denormal ?
+      add           GR_ad_taylor_2 = 0x010,GR_ad_taylor
+}
+{ .mfi
+      add           GR_ad_05 = 0x080,GR_ad_taylor
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      ldfe          FR_C17 = [GR_ad_taylor],32
+      fclass.m      p10,p0 = f8,0x09 // is arg +denormal ?
+      add           GR_ad_tbl_1 = 0x040,GR_ad_z_1 // point to Constants_G_H_h1
+}
+{ .mfb
+      add           GR_ad_z_2 = 0x140,GR_ad_z_1 // point to Constants_Z_2
+ (p8) fma.s0        f8 =  f8,f1,f0 // NaN or +/-0
+ (p8) br.ret.spnt   b0             // exit for Nan or +/-0
+};;
+{ .mfi
+      ldfe          FR_C15 = [GR_ad_taylor_2],32
+      fclass.m      p15,p0 = f8,0x23 // is +/-INF ?
+      add           GR_ad_tbl_2 = 0x180,GR_ad_z_1 // point to Constants_G_H_h2
+}
+{ .mfb
+      ldfe          FR_C13 = [GR_ad_taylor],32
+ (p9) fnma.s0       f8 =  f8,f8,f8 // -denormal
+ (p9) br.ret.spnt   b0             // exit for -denormal
+};;
+{ .mfi
+      ldfe          FR_C11 = [GR_ad_taylor_2],32
+      fcmp.eq.s0       p13,p0 = FR_abs_x,f1 // is |arg| = 1?
+      nop.i         0
+}
+{ .mfb
+      ldfe          FR_C9 = [GR_ad_taylor],32
+(p10) fma.s0        f8 =  f8,f8,f8 // +denormal
+(p10) br.ret.spnt   b0             // exit for +denormal
+};;
+{ .mfi
+      ldfe          FR_C7 = [GR_ad_taylor_2],32
+ (p6) frcpa.s1      FR_Yn,p11 = f1,FR_Bn // y = frcpa(b)
+      and           GR_ArgExp = GR_ArgExp,GR_ExpMask // biased exponent
+}
+{ .mfb
+      ldfe          FR_C5 = [GR_ad_taylor],32
+      fnma.s1       FR_B = FR_abs_x,f1,f1 // b = 1 - |arg|
+(p15) br.cond.spnt  atanhl_gt_one // |arg| > 1
+};;
+{ .mfb
+      cmp.gt        p14,p0 = GR_NearZeroBound,GR_ArgExp
+ (p7) frcpa.s1      FR_Yp,p12 = f1,FR_Bp // y = frcpa(b)
+(p13) br.cond.spnt  atanhl_eq_one // |arg| = 1/32
+}
+{ .mfb
+      ldfe          FR_C3 = [GR_ad_taylor_2],32
+      fma.s1        FR_A = FR_abs_x,f1,FR_abs_x // a = 2 * |arg|
+(p14) br.cond.spnt  atanhl_near_zero // |arg| < 1/32
+};;
+{ .mfi
+      nop.m         0
+      fcmp.gt.s0       p8,p0 = FR_abs_x,f1 // is |arg| > 1 ?
+      nop.i         0
+};;
+.pred.rel "mutex",p6,p7
+{ .mfi
+      nop.m         0
+ (p6) fnma.s1       FR_B_lo = FR_Bn,f1,f1 // argt = 1 - (1 - |arg|)
+      nop.i         0
+}
+{ .mfi
+      ldfs          FR_Half = [GR_ad_05]
+ (p7) fnma.s1       FR_B_lo = FR_Bp,f1,f1
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+ (p6) fnma.s1       FR_E0 = FR_Yn,FR_Bn,f1 // e = 1-b*y
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+ (p6) fma.s1        FR_Y0 = FR_Yn,f1,f0
+ (p8) br.cond.spnt  atanhl_gt_one // |arg| > 1
+};;
+{ .mfi
+      nop.m         0
+ (p7) fnma.s1       FR_E0 = FR_Yp,FR_Bp,f1
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+ (p6) fma.s1        FR_Q0 = FR_A,FR_Yn,f0 // q = a*y
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+ (p7) fma.s1        FR_Q0 = FR_A,FR_Yp,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+ (p7) fma.s1        FR_Y0 = FR_Yp,f1,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fclass.nm     p10,p0 = f8,0x1FF  // test for unsupported
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_E2 = FR_E0,FR_E0,FR_E0 // e2 = e+e^2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_E1 = FR_E0,FR_E0,f0 // e1 = e^2
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+//    Return generated NaN or other value for unsupported values.
+(p10) fma.s0        f8 = f8, f0, f0
+(p10) br.ret.spnt   b0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Y1 = FR_Y0,FR_E2,FR_Y0 // y1 = y+y*e2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_E3 = FR_E1,FR_E1,FR_E0 // e3 = e+e1^2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_B_lo = FR_abs_x,f1,FR_B_lo // b_lo = argt-|arg|
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Y2 = FR_Y1,FR_E3,FR_Y0 // y2 = y+y1*e3
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_R0 = FR_B,FR_Q0,FR_A // r = a-b*q
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_E4 = FR_B,FR_Y2,f1 // e4 = 1-b*y2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_X = FR_R0,FR_Y2,FR_Q0 // x = q+r*y2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Z = FR_X,f1,f1 // x+1
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+ (p6) fnma.s1       FR_Half = FR_Half,f1,f0 // sign(arg)/2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Y3 = FR_Y2,FR_E4,FR_Y2 // y3 = y2+y2*e4
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_R1 = FR_B,FR_X,FR_A // r1 = a-b*x
+      nop.i         0
+};;
+{ .mfi
+      getf.sig      GR_signif = FR_Z // get significand of x+1
+      nop.f         0
+      nop.i         0
+};;
+
+
+{ .mfi
+      add           GR_ad_q = -0x060,GR_ad_z_1
+      nop.f         0
+      extr.u        GR_Index1 = GR_signif,59,4 // get high 4 bits of signif
+}
+{ .mfi
+      add           GR_ad_tbl_3 = 0x280,GR_ad_z_1 // point to Constants_G_H_h3
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      shladd        GR_ad_z_1 = GR_Index1,2,GR_ad_z_1 // point to Z_1
+      nop.f         0
+      extr.u        GR_X_0 = GR_signif,49,15 // get high 15 bits of significand
+};;
+{ .mfi
+      ld4           GR_Z_1 = [GR_ad_z_1] // load Z_1
+      fmax.s1       FR_AA = FR_X,f1 // for S_lo,form AA = max(X,1.0)
+      nop.i         0
+}
+{ .mfi
+      shladd        GR_ad_tbl_1 = GR_Index1,4,GR_ad_tbl_1 // point to G_1
+      nop.f         0
+      mov           GR_Bias = 0x0FFFF // exponent bias
+};;
+{ .mfi
+      ldfps         FR_G,FR_H = [GR_ad_tbl_1],8  // load G_1,H_1
+      fmerge.se     FR_S_hi =  f1,FR_Z // form |x+1|
+      nop.i         0
+};;
+{ .mfi
+      getf.exp      GR_N =  FR_Z // get N = exponent of x+1
+      nop.f         0
+      nop.i         0
+}
+{ .mfi
+      ldfd          FR_h = [GR_ad_tbl_1] // load h_1
+      fnma.s1       FR_R1 = FR_B_lo,FR_X,FR_R1 // r1 = r1-b_lo*x
+      nop.i         0
+};;
+{ .mfi
+      ldfe          FR_log2_hi = [GR_ad_q],16 // load log2_hi
+      nop.f         0
+      pmpyshr2.u    GR_X_1 = GR_X_0,GR_Z_1,15 // get bits 30-15 of X_0 * Z_1
+};;
+//
+//    For performance,don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      ldfe          FR_log2_lo = [GR_ad_q],16 // load log2_lo
+      nop.f         0
+      sub           GR_N = GR_N,GR_Bias
+};;
+{ .mfi
+      ldfe          FR_Q4 = [GR_ad_q],16  // load Q4
+      fms.s1        FR_S_lo = FR_AA,f1,FR_Z // form S_lo = AA - Z
+      sub           GR_minus_N = GR_Bias,GR_N // form exponent of 2^(-N)
+};;
+{ .mmf
+      ldfe          FR_Q3 = [GR_ad_q],16 // load Q3
+      // put integer N into rightmost significand
+      setf.sig      FR_float_N = GR_N
+      fmin.s1       FR_BB = FR_X,f1 // for S_lo,form BB = min(X,1.0)
+};;
+{ .mfi
+      ldfe          FR_Q2 = [GR_ad_q],16 // load Q2
+      nop.f         0
+      extr.u        GR_Index2 = GR_X_1,6,4 // extract bits 6-9 of X_1
+};;
+{ .mmi
+      ldfe          FR_Q1 = [GR_ad_q] // load Q1
+      shladd        GR_ad_z_2 = GR_Index2,2,GR_ad_z_2 // point to Z_2
+      nop.i         0
+};;
+{ .mmi
+      ld4           GR_Z_2 = [GR_ad_z_2] // load Z_2
+      shladd        GR_ad_tbl_2 = GR_Index2,4,GR_ad_tbl_2 // point to G_2
+      nop.i         0
+};;
+{ .mfi
+      ldfps         FR_G2,FR_H2 = [GR_ad_tbl_2],8 // load G_2,H_2
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      ldfd          FR_h2 = [GR_ad_tbl_2] // load h_2
+      fma.s1        FR_S_lo = FR_S_lo,f1,FR_BB // S_lo = S_lo + BB
+      nop.i         0
+}
+{ .mfi
+      setf.exp      FR_2_to_minus_N = GR_minus_N // form 2^(-N)
+      fma.s1        FR_X_lo = FR_R1,FR_Y3,f0 // x_lo = r1*y3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      nop.f         0
+      pmpyshr2.u    GR_X_2 = GR_X_1,GR_Z_2,15 // get bits 30-15 of X_1 * Z_2
+};;
+//
+//    For performance,don't use result of pmpyshr2.u for 4 cycles
+//
+{ .mfi
+      add           GR_ad2_tbl_3 = 8,GR_ad_tbl_3
+      nop.f         0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      nop.f         0
+      nop.i         0
+};;
+
+//
+//    Now GR_X_2 can be used
+//
+{ .mfi
+      nop.m         0
+      nop.f         0
+      extr.u        GR_Index3 = GR_X_2,1,5 // extract bits 1-5 of X_2
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S_lo = FR_S_lo,f1,FR_X_lo // S_lo = S_lo + Arg_lo
+      nop.i         0
+};;
+
+{ .mfi
+      shladd        GR_ad_tbl_3 = GR_Index3,4,GR_ad_tbl_3 // point to G_3
+      fcvt.xf       FR_float_N = FR_float_N
+      nop.i         0
+}
+{ .mfi
+      shladd        GR_ad2_tbl_3 = GR_Index3,4,GR_ad2_tbl_3 // point to h_3
+      fma.s1        FR_Q1 = FR_Q1,FR_Half,f0 // sign(arg)*Q1/2
+      nop.i         0
+};;
+{ .mmi
+      ldfps         FR_G3,FR_H3 = [GR_ad_tbl_3],8 // load G_3,H_3
+      ldfd          FR_h3 = [GR_ad2_tbl_3] // load h_3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fmpy.s1       FR_G = FR_G,FR_G2 // G = G_1 * G_2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fadd.s1       FR_H = FR_H,FR_H2 // H = H_1 + H_2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fadd.s1       FR_h = FR_h,FR_h2 // h = h_1 + h_2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      // S_lo = S_lo * 2^(-N)
+      fma.s1        FR_S_lo = FR_S_lo,FR_2_to_minus_N,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fmpy.s1       FR_G = FR_G,FR_G3 // G = (G_1 * G_2) * G_3
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fadd.s1       FR_H = FR_H,FR_H3 // H = (H_1 + H_2) + H_3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fadd.s1       FR_h = FR_h,FR_h3 // h = (h_1 + h_2) + h_3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fms.s1        FR_r = FR_G,FR_S_hi,f1 // r = G * S_hi - 1
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      // Y_hi = N * log2_hi + H
+      fma.s1        FR_Y_hi = FR_float_N,FR_log2_hi,FR_H
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_h = FR_float_N,FR_log2_lo,FR_h // h = N * log2_lo + h
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_r = FR_G,FR_S_lo,FR_r // r = G * S_lo + (G * S_hi - 1)
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_poly_lo = FR_r,FR_Q4,FR_Q3 // poly_lo = r * Q4 + Q3
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fmpy.s1       FR_rsq = FR_r,FR_r // rsq = r * r
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_05r = FR_r,FR_Half,f0 // sign(arg)*r/2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      // poly_lo = poly_lo * r + Q2
+      fma.s1        FR_poly_lo = FR_poly_lo,FR_r,FR_Q2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_rcub = FR_rsq,FR_r,f0 // rcub = r^3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      // poly_hi = sing(arg)*(Q1*r^2 + r)/2
+      fma.s1        FR_poly_hi = FR_Q1,FR_rsq,FR_05r
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      // poly_lo = poly_lo*r^3 + h
+      fma.s1        FR_poly_lo = FR_poly_lo,FR_rcub,FR_h
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      // Y_lo = poly_hi + poly_lo/2
+      fma.s0        FR_Y_lo = FR_poly_lo,FR_Half,FR_poly_hi
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+     // Result = arctanh(x) = Y_hi/2 + Y_lo
+      fma.s0        f8 = FR_Y_hi,FR_Half,FR_Y_lo
+      br.ret.sptk   b0
+};;
+
+// Taylor's series
+atanhl_near_zero:
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x3 = FR_x2,f8,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x4 = FR_x2,FR_x2,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C17 = FR_C17,FR_x2,FR_C15
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C13 = FR_C13,FR_x2,FR_C11
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C9 = FR_C9,FR_x2,FR_C7
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C5 = FR_C5,FR_x2,FR_C3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x8 = FR_x4,FR_x4,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C17 = FR_C17,FR_x4,FR_C13
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C9 = FR_C9,FR_x4,FR_C5
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C17 = FR_C17,FR_x8,FR_C9
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+      fma.s0        f8 = FR_C17,FR_x3,f8
+      br.ret.sptk   b0
+};;
+
+atanhl_eq_one:
+{ .mfi
+      nop.m         0
+      frcpa.s0      FR_Rcp,p0 = f1,f0 // get inf,and raise Z flag
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fmerge.s      FR_Arg_X = f8, f8
+      nop.i         0
+};;
+{ .mfb
+      mov           GR_Parameter_TAG = 130
+      fmerge.s      FR_RESULT = f8,FR_Rcp // result is +-inf
+      br.cond.sptk  __libm_error_region // exit if |x| = 1.0
+};;
+
+atanhl_gt_one:
+{ .mfi
+      nop.m         0
+      fmerge.s      FR_Arg_X = f8, f8
+      nop.i         0
+};;
+{ .mfb
+      mov           GR_Parameter_TAG = 129
+      frcpa.s0      FR_RESULT,p0 = f0,f0 // get QNaN,and raise invalid
+      br.cond.sptk  __libm_error_region // exit if |x| > 1.0
+};;
+
+GLOBAL_LIBM_END(atanhl)
+libm_alias_ldouble_other (atanh, atanh)
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfe [GR_Parameter_Y] = FR_Arg_Y,16     // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0,GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfe [GR_Parameter_X] = FR_Arg_X        // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfe [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#  // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region#)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_cosh.S
@@ -0,0 +1,866 @@
+.file "cosh.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 05/07/01 Reworked to improve speed of all paths
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 11/15/02 Improved speed with new algorithm
+// 03/31/05 Reformatted delimiters between data tables
+
+// API
+//==============================================================
+// double cosh(double)
+
+// Overview of operation
+//==============================================================
+// Case 1:  0 < |x| < 0.25
+//  Evaluate cosh(x) by a 12th order polynomial
+//  Care is take for the order of multiplication; and A2 is not exactly 1/4!,
+//  A3 is not exactly 1/6!, etc.
+//  cosh(x) = 1 + (A1*x^2 + A2*x^4 + A3*x^6 + A4*x^8 + A5*x^10 + A6*x^12)
+//
+// Case 2:  0.25 < |x| < 710.47586
+//  Algorithm is based on the identity cosh(x) = ( exp(x) + exp(-x) ) / 2.
+//  The algorithm for exp is described as below.  There are a number of
+//  economies from evaluating both exp(x) and exp(-x).  Although we
+//  are evaluating both quantities, only where the quantities diverge do we
+//  duplicate the computations.  The basic algorithm for exp(x) is described
+//  below.
+//
+// Take the input x. w is "how many log2/128 in x?"
+//  w = x * 128/log2
+//  n = int(w)
+//  x = n log2/128 + r + delta
+
+//  n = 128M + index_1 + 2^4 index_2
+//  x = M log2 + (log2/128) index_1 + (log2/8) index_2 + r + delta
+
+//  exp(x) = 2^M  2^(index_1/128)  2^(index_2/8) exp(r) exp(delta)
+//       Construct 2^M
+//       Get 2^(index_1/128) from table_1;
+//       Get 2^(index_2/8)   from table_2;
+//       Calculate exp(r) by 5th order polynomial
+//          r = x - n (log2/128)_high
+//          delta = - n (log2/128)_low
+//       Calculate exp(delta) as 1 + delta
+
+
+// Special values
+//==============================================================
+// cosh(+0)    = 1.0
+// cosh(-0)    = 1.0
+
+// cosh(+qnan) = +qnan
+// cosh(-qnan) = -qnan
+// cosh(+snan) = +qnan
+// cosh(-snan) = -qnan
+
+// cosh(-inf)  = +inf
+// cosh(+inf)  = +inf
+
+// Overflow and Underflow
+//=======================
+// cosh(x) = largest double normal when
+//     x = 710.47586 = 0x408633ce8fb9f87d
+//
+// There is no underflow.
+
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input, output
+// f6 -> f15,  f32 -> f61
+
+// General registers used:
+// r14 -> r40
+
+// Predicate registers used:
+// p6 -> p15
+
+// Assembly macros
+//==============================================================
+
+rRshf                 = r14
+rN_neg                = r14
+rAD_TB1               = r15
+rAD_TB2               = r16
+rAD_P                 = r17
+rN                    = r18
+rIndex_1              = r19
+rIndex_2_16           = r20
+rM                    = r21
+rBiased_M             = r21
+rSig_inv_ln2          = r22
+rIndex_1_neg          = r22
+rExp_bias             = r23
+rExp_bias_minus_1     = r23
+rExp_mask             = r24
+rTmp                  = r24
+rGt_ln                = r24
+rIndex_2_16_neg       = r24
+rM_neg                = r25
+rBiased_M_neg         = r25
+rRshf_2to56           = r26
+rAD_T1_neg            = r26
+rExp_2tom56           = r28
+rAD_T2_neg            = r28
+rAD_T1                = r29
+rAD_T2                = r30
+rSignexp_x            = r31
+rExp_x                = r31
+
+GR_SAVE_B0            = r33
+GR_SAVE_PFS           = r34
+GR_SAVE_GP            = r35
+GR_SAVE_SP            = r36
+
+GR_Parameter_X        = r37
+GR_Parameter_Y        = r38
+GR_Parameter_RESULT   = r39
+GR_Parameter_TAG      = r40
+
+
+FR_X                  = f10
+FR_Y                  = f1
+FR_RESULT             = f8
+
+fRSHF_2TO56           = f6
+fINV_LN2_2TO63        = f7
+fW_2TO56_RSH          = f9
+f2TOM56               = f11
+fP5                   = f12
+fP4                   = f13
+fP3                   = f14
+fP2                   = f15
+
+fLn2_by_128_hi        = f33
+fLn2_by_128_lo        = f34
+
+fRSHF                 = f35
+fNfloat               = f36
+fNormX                = f37
+fR                    = f38
+fF                    = f39
+
+fRsq                  = f40
+f2M                   = f41
+fS1                   = f42
+fT1                   = f42
+fS2                   = f43
+fT2                   = f43
+fS                    = f43
+fWre_urm_f8           = f44
+fAbsX                 = f44
+
+fMIN_DBL_OFLOW_ARG    = f45
+fMAX_DBL_NORM_ARG     = f46
+fXsq                  = f47
+fX4                   = f48
+fGt_pln               = f49
+fTmp                  = f49
+
+fP54                  = f50
+fP5432                = f50
+fP32                  = f51
+fP                    = f52
+fP54_neg              = f53
+fP5432_neg            = f53
+fP32_neg              = f54
+fP_neg                = f55
+fF_neg                = f56
+
+f2M_neg               = f57
+fS1_neg               = f58
+fT1_neg               = f58
+fS2_neg               = f59
+fT2_neg               = f59
+fS_neg                = f59
+fExp                  = f60
+fExp_neg              = f61
+
+fA6                   = f50
+fA65                  = f50
+fA6543                = f50
+fA654321              = f50
+fA5                   = f51
+fA4                   = f52
+fA43                  = f52
+fA3                   = f53
+fA2                   = f54
+fA21                  = f54
+fA1                   = f55
+
+// Data tables
+//==============================================================
+
+RODATA
+.align 16
+
+// ************* DO NOT CHANGE ORDER OF THESE TABLES ********************
+
+// double-extended 1/ln(2)
+// 3fff b8aa 3b29 5c17 f0bb be87fed0691d3e88
+// 3fff b8aa 3b29 5c17 f0bc
+// For speed the significand will be loaded directly with a movl and setf.sig
+//   and the exponent will be bias+63 instead of bias+0.  Thus subsequent
+//   computations need to scale appropriately.
+// The constant 128/ln(2) is needed for the computation of w.  This is also
+//   obtained by scaling the computations.
+//
+// Two shifting constants are loaded directly with movl and setf.d.
+//   1. fRSHF_2TO56 = 1.1000..00 * 2^(63-7)
+//        This constant is added to x*1/ln2 to shift the integer part of
+//        x*128/ln2 into the rightmost bits of the significand.
+//        The result of this fma is fW_2TO56_RSH.
+//   2. fRSHF       = 1.1000..00 * 2^(63)
+//        This constant is subtracted from fW_2TO56_RSH * 2^(-56) to give
+//        the integer part of w, n, as a floating-point number.
+//        The result of this fms is fNfloat.
+
+
+LOCAL_OBJECT_START(exp_table_1)
+data8 0x408633ce8fb9f87e // smallest dbl overflow arg
+data8 0x408633ce8fb9f87d // largest dbl arg to give normal dbl result
+data8 0xb17217f7d1cf79ab , 0x00003ff7 // ln2/128 hi
+data8 0xc9e3b39803f2f6af , 0x00003fb7 // ln2/128 lo
+//
+// Table 1 is 2^(index_1/128) where
+// index_1 goes from 0 to 15
+//
+data8 0x8000000000000000 , 0x00003FFF
+data8 0x80B1ED4FD999AB6C , 0x00003FFF
+data8 0x8164D1F3BC030773 , 0x00003FFF
+data8 0x8218AF4373FC25EC , 0x00003FFF
+data8 0x82CD8698AC2BA1D7 , 0x00003FFF
+data8 0x8383594EEFB6EE37 , 0x00003FFF
+data8 0x843A28C3ACDE4046 , 0x00003FFF
+data8 0x84F1F656379C1A29 , 0x00003FFF
+data8 0x85AAC367CC487B15 , 0x00003FFF
+data8 0x8664915B923FBA04 , 0x00003FFF
+data8 0x871F61969E8D1010 , 0x00003FFF
+data8 0x87DB357FF698D792 , 0x00003FFF
+data8 0x88980E8092DA8527 , 0x00003FFF
+data8 0x8955EE03618E5FDD , 0x00003FFF
+data8 0x8A14D575496EFD9A , 0x00003FFF
+data8 0x8AD4C6452C728924 , 0x00003FFF
+LOCAL_OBJECT_END(exp_table_1)
+
+// Table 2 is 2^(index_1/8) where
+// index_2 goes from 0 to 7
+LOCAL_OBJECT_START(exp_table_2)
+data8 0x8000000000000000 , 0x00003FFF
+data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
+data8 0x9837F0518DB8A96F , 0x00003FFF
+data8 0xA5FED6A9B15138EA , 0x00003FFF
+data8 0xB504F333F9DE6484 , 0x00003FFF
+data8 0xC5672A115506DADD , 0x00003FFF
+data8 0xD744FCCAD69D6AF4 , 0x00003FFF
+data8 0xEAC0C6E7DD24392F , 0x00003FFF
+LOCAL_OBJECT_END(exp_table_2)
+
+LOCAL_OBJECT_START(exp_p_table)
+data8 0x3f8111116da21757 //P5
+data8 0x3fa55555d787761c //P4
+data8 0x3fc5555555555414 //P3
+data8 0x3fdffffffffffd6a //P2
+LOCAL_OBJECT_END(exp_p_table)
+
+LOCAL_OBJECT_START(cosh_p_table)
+data8 0x8FA02AC65BCBD5BC, 0x00003FE2  // A6
+data8 0xD00D00D1021D7370, 0x00003FEF  // A4
+data8 0xAAAAAAAAAAAAAB80, 0x00003FFA  // A2
+data8 0x93F27740C0C2F1CC, 0x00003FE9  // A5
+data8 0xB60B60B60B4FE884, 0x00003FF5  // A3
+data8 0x8000000000000000, 0x00003FFE  // A1
+LOCAL_OBJECT_END(cosh_p_table)
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(cosh)
+
+{ .mlx
+      getf.exp        rSignexp_x = f8  // Must recompute if x unorm
+      movl            rSig_inv_ln2 = 0xb8aa3b295c17f0bc  // significand of 1/ln2
+}
+{ .mlx
+      addl            rAD_TB1    = @ltoff(exp_table_1), gp
+      movl            rRshf_2to56 = 0x4768000000000000   // 1.10000 2^(63+56)
+}
+;;
+
+{ .mfi
+      ld8             rAD_TB1    = [rAD_TB1]
+      fclass.m        p6,p0 = f8,0x0b  // Test for x=unorm
+      mov             rExp_mask = 0x1ffff
+}
+{ .mfi
+      mov             rExp_bias = 0xffff
+      fnorm.s1        fNormX   = f8
+      mov             rExp_2tom56 = 0xffff-56
+}
+;;
+
+// Form two constants we need
+//  1/ln2 * 2^63  to compute  w = x * 1/ln2 * 128
+//  1.1000..000 * 2^(63+63-7) to right shift int(w) into the significand
+
+{ .mfi
+      setf.sig        fINV_LN2_2TO63 = rSig_inv_ln2 // form 1/ln2 * 2^63
+      fclass.m        p8,p0 = f8,0x07  // Test for x=0
+      nop.i 999
+}
+{ .mlx
+      setf.d          fRSHF_2TO56 = rRshf_2to56 // Form const 1.100 * 2^(63+56)
+      movl            rRshf = 0x43e8000000000000 // 1.10000 2^63 for right shift
+}
+;;
+
+{ .mfi
+      ldfpd           fMIN_DBL_OFLOW_ARG, fMAX_DBL_NORM_ARG = [rAD_TB1],16
+      fclass.m        p10,p0 = f8,0x1e3  // Test for x=inf, nan, NaT
+      nop.i           0
+}
+{ .mfb
+      setf.exp        f2TOM56 = rExp_2tom56 // form 2^-56 for scaling Nfloat
+      nop.f           0
+(p6)  br.cond.spnt    COSH_UNORM            // Branch if x=unorm
+}
+;;
+
+COSH_COMMON:
+{ .mfi
+      ldfe            fLn2_by_128_hi  = [rAD_TB1],16
+      nop.f           0
+      nop.i           0
+}
+{ .mfb
+      setf.d          fRSHF = rRshf // Form right shift const 1.100 * 2^63
+(p8)  fma.d.s0        f8 = f1,f1,f0           // quick exit for x=0
+(p8)  br.ret.spnt     b0
+}
+;;
+
+{ .mfi
+      ldfe            fLn2_by_128_lo  = [rAD_TB1],16
+      nop.f           0
+      nop.i           0
+}
+{ .mfb
+      and             rExp_x = rExp_mask, rSignexp_x // Biased exponent of x
+(p10) fma.d.s0        f8 = f8,f8,f0  // Result if x=inf, nan, NaT
+(p10) br.ret.spnt     b0               // quick exit for x=inf, nan, NaT
+}
+;;
+
+// After that last load rAD_TB1 points to the beginning of table 1
+{ .mfi
+      nop.m           0
+      fcmp.eq.s0      p6,p0 = f8, f0       // Dummy to set D
+      sub             rExp_x = rExp_x, rExp_bias // True exponent of x
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fmerge.s        fAbsX = f0, fNormX   // Form |x|
+      nop.i           0
+}
+{ .mfb
+      cmp.gt          p7, p0 = -2, rExp_x      // Test |x| < 2^(-2)
+      fma.s1          fXsq = fNormX, fNormX, f0  // x*x for small path
+(p7)  br.cond.spnt    COSH_SMALL               // Branch if 0 < |x| < 2^-2
+}
+;;
+
+// W = X * Inv_log2_by_128
+// By adding 1.10...0*2^63 we shift and get round_int(W) in significand.
+// We actually add 1.10...0*2^56 to X * Inv_log2 to do the same thing.
+
+{ .mfi
+      add             rAD_P = 0x180, rAD_TB1
+      fma.s1          fW_2TO56_RSH  = fNormX, fINV_LN2_2TO63, fRSHF_2TO56
+      add             rAD_TB2 = 0x100, rAD_TB1
+}
+;;
+
+// Divide arguments into the following categories:
+//  Certain Safe                - 0.25 <= |x| <= MAX_DBL_NORM_ARG
+//  Possible Overflow       p14 - MAX_DBL_NORM_ARG < |x| < MIN_DBL_OFLOW_ARG
+//  Certain Overflow        p15 - MIN_DBL_OFLOW_ARG <= |x| < +inf
+//
+// If the input is really a double arg, then there will never be
+// "Possible Overflow" arguments.
+//
+
+{ .mfi
+      ldfpd           fP5, fP4  = [rAD_P] ,16
+      fcmp.ge.s1      p15,p14 = fAbsX,fMIN_DBL_OFLOW_ARG
+      nop.i           0
+}
+;;
+
+// Nfloat = round_int(W)
+// The signficand of fW_2TO56_RSH contains the rounded integer part of W,
+// as a twos complement number in the lower bits (that is, it may be negative).
+// That twos complement number (called N) is put into rN.
+
+// Since fW_2TO56_RSH is scaled by 2^56, it must be multiplied by 2^-56
+// before the shift constant 1.10000 * 2^63 is subtracted to yield fNfloat.
+// Thus, fNfloat contains the floating point version of N
+
+{ .mfi
+      ldfpd           fP3, fP2  = [rAD_P]
+(p14) fcmp.gt.unc.s1  p14,p0 = fAbsX,fMAX_DBL_NORM_ARG
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+      fms.s1          fNfloat = fW_2TO56_RSH, f2TOM56, fRSHF
+(p15) br.cond.spnt    COSH_CERTAIN_OVERFLOW
+}
+;;
+
+{ .mfi
+      getf.sig        rN        = fW_2TO56_RSH
+      nop.f           0
+      mov             rExp_bias_minus_1 = 0xfffe
+}
+;;
+
+// rIndex_1 has index_1
+// rIndex_2_16 has index_2 * 16
+// rBiased_M has M
+
+// rM has true M
+// r = x - Nfloat * ln2_by_128_hi
+// f = 1 - Nfloat * ln2_by_128_lo
+{ .mfi
+      and             rIndex_1 = 0x0f, rN
+      fnma.s1         fR   = fNfloat, fLn2_by_128_hi, fNormX
+      shr             rM = rN,  0x7
+}
+{ .mfi
+      and             rIndex_2_16 = 0x70, rN
+      fnma.s1         fF   = fNfloat, fLn2_by_128_lo, f1
+      sub             rN_neg = r0, rN
+}
+;;
+
+{ .mmi
+      and             rIndex_1_neg = 0x0f, rN_neg
+      add             rBiased_M = rExp_bias_minus_1, rM
+      shr             rM_neg = rN_neg,  0x7
+}
+{ .mmi
+      and             rIndex_2_16_neg = 0x70, rN_neg
+      add             rAD_T2 = rAD_TB2, rIndex_2_16
+      shladd          rAD_T1 = rIndex_1, 4, rAD_TB1
+}
+;;
+
+// rAD_T1 has address of T1
+// rAD_T2 has address if T2
+
+{ .mmi
+      setf.exp        f2M = rBiased_M
+      ldfe            fT2  = [rAD_T2]
+      nop.i           0
+}
+{ .mmi
+      add             rBiased_M_neg = rExp_bias_minus_1, rM_neg
+      add             rAD_T2_neg = rAD_TB2, rIndex_2_16_neg
+      shladd          rAD_T1_neg = rIndex_1_neg, 4, rAD_TB1
+}
+;;
+
+// Create Scale = 2^M
+// Load T1 and T2
+{ .mmi
+      ldfe            fT1  = [rAD_T1]
+      nop.m           0
+      nop.i           0
+}
+{ .mmf
+      setf.exp        f2M_neg = rBiased_M_neg
+      ldfe            fT2_neg  = [rAD_T2_neg]
+      fma.s1          fF_neg   = fNfloat, fLn2_by_128_lo, f1
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fRsq = fR, fR, f0
+      nop.i           0
+}
+{ .mfi
+      ldfe            fT1_neg  = [rAD_T1_neg]
+      fma.s1          fP54 = fR, fP5, fP4
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fP32 = fR, fP3, fP2
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fnma.s1         fP54_neg = fR, fP5, fP4
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fnma.s1         fP32_neg = fR, fP3, fP2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fP5432  = fRsq, fP54, fP32
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fS2  = fF,fT2,f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fS1  = f2M,fT1,f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fP5432_neg  = fRsq, fP54_neg, fP32_neg
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fS1_neg  = f2M_neg,fT1_neg,f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fS2_neg  = fF_neg,fT2_neg,f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fP     = fRsq, fP5432, fR
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fS   = fS1,fS2,f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fms.s1          fP_neg     = fRsq, fP5432_neg, fR
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fS_neg   = fS1_neg,fS2_neg,f0
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fmpy.s0         fTmp = fLn2_by_128_lo, fLn2_by_128_lo // Force inexact
+(p14) br.cond.spnt    COSH_POSSIBLE_OVERFLOW
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fExp = fS, fP, fS
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fExp_neg = fS_neg, fP_neg, fS_neg
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fma.d.s0        f8 = fExp, f1, fExp_neg
+      br.ret.sptk     b0                  // Normal path exit
+}
+;;
+
+// Here if 0 < |x| < 0.25
+COSH_SMALL:
+{ .mmf
+      add             rAD_T1 = 0x1a0, rAD_TB1
+      add             rAD_T2 = 0x1d0, rAD_TB1
+}
+;;
+
+{ .mmf
+      ldfe            fA6 = [rAD_T1],16
+      ldfe            fA5 = [rAD_T2],16
+      nop.f           0
+}
+;;
+
+{ .mmi
+      ldfe            fA4 = [rAD_T1],16
+      ldfe            fA3 = [rAD_T2],16
+      nop.i           0
+}
+;;
+
+{ .mmi
+      ldfe            fA2 = [rAD_T1],16
+      ldfe            fA1 = [rAD_T2],16
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fX4 = fXsq, fXsq, f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA65 = fXsq, fA6, fA5
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fA43 = fXsq, fA4, fA3
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA21 = fXsq, fA2, fA1
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA6543 = fX4, fA65, fA43
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA654321 = fX4, fA6543, fA21
+      nop.i           0
+}
+;;
+
+// Dummy multiply to generate inexact
+{ .mfi
+      nop.m           0
+      fmpy.s0         fTmp = fA6, fA6
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+      fma.d.s0        f8 = fA654321, fXsq, f1
+      br.ret.sptk     b0                // Exit if 0 < |x| < 0.25
+}
+;;
+
+
+COSH_POSSIBLE_OVERFLOW:
+
+// Here if fMAX_DBL_NORM_ARG < |x| < fMIN_DBL_OFLOW_ARG
+// This cannot happen if input is a double, only if input higher precision.
+// Overflow is a possibility, not a certainty.
+
+// Recompute result using status field 2 with user's rounding mode,
+// and wre set.  If result is larger than largest double, then we have
+// overflow
+
+{ .mfi
+      mov             rGt_ln  = 0x103ff // Exponent for largest dbl + 1 ulp
+      fsetc.s2        0x7F,0x42         // Get user's round mode, set wre
+      nop.i           0
+}
+;;
+
+{ .mfi
+      setf.exp        fGt_pln = rGt_ln  // Create largest double + 1 ulp
+      fma.d.s2        fWre_urm_f8 = fS, fP, fS    // Result with wre set
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fsetc.s2        0x7F,0x40                   // Turn off wre in sf2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.ge.s1      p6, p0 =  fWre_urm_f8, fGt_pln // Test for overflow
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      nop.f           0
+(p6)  br.cond.spnt    COSH_CERTAIN_OVERFLOW // Branch if overflow
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fma.d.s0        f8 = fS, fP, fS
+      br.ret.sptk     b0                     // Exit if really no overflow
+}
+;;
+
+COSH_CERTAIN_OVERFLOW:
+{ .mmi
+      sub             rTmp = rExp_mask, r0, 1
+;;
+      setf.exp        fTmp = rTmp
+      nop.i           0
+}
+;;
+
+{ .mfi
+      alloc           r32=ar.pfs,1,4,4,0
+      fmerge.s        FR_X = f8,f8
+      nop.i           0
+}
+{ .mfb
+      mov             GR_Parameter_TAG = 64
+      fma.d.s0        FR_RESULT = fTmp, fTmp, f0    // Set I,O and +INF result
+      br.cond.sptk    __libm_error_region
+}
+;;
+
+// Here if x unorm
+COSH_UNORM:
+{ .mfb
+      getf.exp        rSignexp_x = fNormX    // Must recompute if x unorm
+      fcmp.eq.s0      p6, p0 = f8, f0        // Set D flag
+      br.cond.sptk    COSH_COMMON
+}
+;;
+
+GLOBAL_IEEE754_END(cosh)
+libm_alias_double_other (__cosh, cosh)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfd [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfd [GR_Parameter_X] = FR_X            // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = FR_RESULT       // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_coshf.S
@@ -0,0 +1,711 @@
+.file "coshf.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+
+// History
+//*********************************************************************
+// 02/02/00 Initial version
+// 02/16/00 The error tag for coshf overflow changed to 65 (from 64).
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 05/07/01 Reworked to improve speed of all paths
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 11/15/02 Improved algorithm based on expf
+// 03/31/05 Reformatted delimiters between data tables
+//
+// API
+//*********************************************************************
+// float coshf(float)
+//
+// Overview of operation
+//*********************************************************************
+// Case 1:  0 < |x| < 0.25
+//  Evaluate cosh(x) by a 8th order polynomial
+//  Care is take for the order of multiplication; and A2 is not exactly 1/4!,
+//  A3 is not exactly 1/6!, etc.
+//  cosh(x) = 1 + (A1*x^2 + A2*x^4 + A3*x^6 + A4*x^8)
+//
+// Case 2:  0.25 < |x| < 89.41598
+//  Algorithm is based on the identity cosh(x) = ( exp(x) + exp(-x) ) / 2.
+//  The algorithm for exp is described as below.  There are a number of
+//  economies from evaluating both exp(x) and exp(-x).  Although we
+//  are evaluating both quantities, only where the quantities diverge do we
+//  duplicate the computations.  The basic algorithm for exp(x) is described
+//  below.
+//
+// Take the input x. w is "how many log2/128 in x?"
+//  w = x * 64/log2
+//  NJ = int(w)
+//  x = NJ*log2/64 + R
+
+//  NJ = 64*n + j
+//  x = n*log2 + (log2/64)*j + R
+//
+//  So, exp(x) = 2^n * 2^(j/64)* exp(R)
+//
+//  T =  2^n * 2^(j/64)
+//       Construct 2^n
+//       Get 2^(j/64) table
+//           actually all the entries of 2^(j/64) table are stored in DP and
+//           with exponent bits set to 0 -> multiplication on 2^n can be
+//           performed by doing logical "or" operation with bits presenting 2^n
+
+//  exp(R) = 1 + (exp(R) - 1)
+//  P = exp(R) - 1 approximated by Taylor series of 3rd degree
+//      P = A3*R^3 + A2*R^2 + R, A3 = 1/6, A2 = 1/2
+//
+
+//  The final result is reconstructed as follows
+//  exp(x) = T + T*P
+
+// Special values
+//*********************************************************************
+// coshf(+0)    = 1.0
+// coshf(-0)    = 1.0
+
+// coshf(+qnan) = +qnan
+// coshf(-qnan) = -qnan
+// coshf(+snan) = +qnan
+// coshf(-snan) = -qnan
+
+// coshf(-inf)  = +inf
+// coshf(+inf)  = +inf
+
+// Overflow and Underflow
+//*********************************************************************
+// coshf(x) = largest single normal when
+//     x = 89.41598 = 0x42b2d4fc
+//
+// There is no underflow.
+
+// Registers used
+//*********************************************************************
+// Floating Point registers used:
+// f8 input, output
+// f6,f7, f9 -> f15,  f32 -> f45
+
+// General registers used:
+// r2, r3, r16 -> r38
+
+// Predicate registers used:
+// p6 -> p15
+
+// Assembly macros
+//*********************************************************************
+// integer registers used
+// scratch
+rNJ                   = r2
+rNJ_neg               = r3
+
+rJ_neg                = r16
+rN_neg                = r17
+rSignexp_x            = r18
+rExp_x                = r18
+rExp_mask             = r19
+rExp_bias             = r20
+rAd1                  = r21
+rAd2                  = r22
+rJ                    = r23
+rN                    = r24
+rTblAddr              = r25
+rA3                   = r26
+rExpHalf              = r27
+rLn2Div64             = r28
+rGt_ln                = r29
+r17ones_m1            = r29
+rRightShifter         = r30
+rJ_mask               = r30
+r64DivLn2             = r31
+rN_mask               = r31
+// stacked
+GR_SAVE_PFS           = r32
+GR_SAVE_B0            = r33
+GR_SAVE_GP            = r34
+GR_Parameter_X        = r35
+GR_Parameter_Y        = r36
+GR_Parameter_RESULT   = r37
+GR_Parameter_TAG      = r38
+
+// floating point registers used
+FR_X                  = f10
+FR_Y                  = f1
+FR_RESULT             = f8
+// scratch
+fRightShifter         = f6
+f64DivLn2             = f7
+fNormX                = f9
+fNint                 = f10
+fN                    = f11
+fR                    = f12
+fLn2Div64             = f13
+fA2                   = f14
+fA3                   = f15
+// stacked
+fP                    = f32
+fT                    = f33
+fMIN_SGL_OFLOW_ARG    = f34
+fMAX_SGL_NORM_ARG     = f35
+fRSqr                 = f36
+fA1                   = f37
+fA21                  = f37
+fA4                   = f38
+fA43                  = f38
+fA4321                = f38
+fX4                   = f39
+fTmp                  = f39
+fGt_pln               = f39
+fWre_urm_f8           = f40
+fXsq                  = f40
+fP_neg                = f41
+fT_neg                = f42
+fExp                  = f43
+fExp_neg              = f44
+fAbsX                 = f45
+
+
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(_coshf_table)
+data4 0x42b2d4fd         // Smallest single arg to overflow single result
+data4 0x42b2d4fc         // Largest single arg to give normal single result
+data4 0x00000000         // pad
+data4 0x00000000         // pad
+//
+// 2^(j/64) table, j goes from 0 to 63
+data8 0x0000000000000000 // 2^(0/64)
+data8 0x00002C9A3E778061 // 2^(1/64)
+data8 0x000059B0D3158574 // 2^(2/64)
+data8 0x0000874518759BC8 // 2^(3/64)
+data8 0x0000B5586CF9890F // 2^(4/64)
+data8 0x0000E3EC32D3D1A2 // 2^(5/64)
+data8 0x00011301D0125B51 // 2^(6/64)
+data8 0x0001429AAEA92DE0 // 2^(7/64)
+data8 0x000172B83C7D517B // 2^(8/64)
+data8 0x0001A35BEB6FCB75 // 2^(9/64)
+data8 0x0001D4873168B9AA // 2^(10/64)
+data8 0x0002063B88628CD6 // 2^(11/64)
+data8 0x0002387A6E756238 // 2^(12/64)
+data8 0x00026B4565E27CDD // 2^(13/64)
+data8 0x00029E9DF51FDEE1 // 2^(14/64)
+data8 0x0002D285A6E4030B // 2^(15/64)
+data8 0x000306FE0A31B715 // 2^(16/64)
+data8 0x00033C08B26416FF // 2^(17/64)
+data8 0x000371A7373AA9CB // 2^(18/64)
+data8 0x0003A7DB34E59FF7 // 2^(19/64)
+data8 0x0003DEA64C123422 // 2^(20/64)
+data8 0x0004160A21F72E2A // 2^(21/64)
+data8 0x00044E086061892D // 2^(22/64)
+data8 0x000486A2B5C13CD0 // 2^(23/64)
+data8 0x0004BFDAD5362A27 // 2^(24/64)
+data8 0x0004F9B2769D2CA7 // 2^(25/64)
+data8 0x0005342B569D4F82 // 2^(26/64)
+data8 0x00056F4736B527DA // 2^(27/64)
+data8 0x0005AB07DD485429 // 2^(28/64)
+data8 0x0005E76F15AD2148 // 2^(29/64)
+data8 0x0006247EB03A5585 // 2^(30/64)
+data8 0x0006623882552225 // 2^(31/64)
+data8 0x0006A09E667F3BCD // 2^(32/64)
+data8 0x0006DFB23C651A2F // 2^(33/64)
+data8 0x00071F75E8EC5F74 // 2^(34/64)
+data8 0x00075FEB564267C9 // 2^(35/64)
+data8 0x0007A11473EB0187 // 2^(36/64)
+data8 0x0007E2F336CF4E62 // 2^(37/64)
+data8 0x00082589994CCE13 // 2^(38/64)
+data8 0x000868D99B4492ED // 2^(39/64)
+data8 0x0008ACE5422AA0DB // 2^(40/64)
+data8 0x0008F1AE99157736 // 2^(41/64)
+data8 0x00093737B0CDC5E5 // 2^(42/64)
+data8 0x00097D829FDE4E50 // 2^(43/64)
+data8 0x0009C49182A3F090 // 2^(44/64)
+data8 0x000A0C667B5DE565 // 2^(45/64)
+data8 0x000A5503B23E255D // 2^(46/64)
+data8 0x000A9E6B5579FDBF // 2^(47/64)
+data8 0x000AE89F995AD3AD // 2^(48/64)
+data8 0x000B33A2B84F15FB // 2^(49/64)
+data8 0x000B7F76F2FB5E47 // 2^(50/64)
+data8 0x000BCC1E904BC1D2 // 2^(51/64)
+data8 0x000C199BDD85529C // 2^(52/64)
+data8 0x000C67F12E57D14B // 2^(53/64)
+data8 0x000CB720DCEF9069 // 2^(54/64)
+data8 0x000D072D4A07897C // 2^(55/64)
+data8 0x000D5818DCFBA487 // 2^(56/64)
+data8 0x000DA9E603DB3285 // 2^(57/64)
+data8 0x000DFC97337B9B5F // 2^(58/64)
+data8 0x000E502EE78B3FF6 // 2^(59/64)
+data8 0x000EA4AFA2A490DA // 2^(60/64)
+data8 0x000EFA1BEE615A27 // 2^(61/64)
+data8 0x000F50765B6E4540 // 2^(62/64)
+data8 0x000FA7C1819E90D8 // 2^(63/64)
+LOCAL_OBJECT_END(_coshf_table)
+
+LOCAL_OBJECT_START(cosh_p_table)
+data8 0x3efa3001dcf5905b // A4
+data8 0x3f56c1437543543e // A3
+data8 0x3fa5555572601504 // A2
+data8 0x3fdfffffffe2f097 // A1
+LOCAL_OBJECT_END(cosh_p_table)
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(coshf)
+
+{ .mlx
+      getf.exp        rSignexp_x = f8  // Must recompute if x unorm
+      movl            r64DivLn2 = 0x40571547652B82FE // 64/ln(2)
+}
+{ .mlx
+      addl            rTblAddr = @ltoff(_coshf_table),gp
+      movl            rRightShifter = 0x43E8000000000000 // DP Right Shifter
+}
+;;
+
+{ .mfi
+      // point to the beginning of the table
+      ld8             rTblAddr = [rTblAddr]
+      fclass.m        p6, p0 = f8, 0x0b   // Test for x=unorm
+      addl            rA3 = 0x3E2AA, r0   // high bits of 1.0/6.0 rounded to SP
+}
+{ .mfi
+      nop.m           0
+      fnorm.s1        fNormX = f8 // normalized x
+      addl            rExpHalf = 0xFFFE, r0 // exponent of 1/2
+}
+;;
+
+{ .mfi
+      setf.d          f64DivLn2 = r64DivLn2 // load 64/ln(2) to FP reg
+      fclass.m        p15, p0 = f8, 0x1e3   // test for NaT,NaN,Inf
+      nop.i           0
+}
+{ .mlx
+      // load Right Shifter to FP reg
+      setf.d          fRightShifter = rRightShifter
+      movl            rLn2Div64 = 0x3F862E42FEFA39EF // DP ln(2)/64 in GR
+}
+;;
+
+{ .mfi
+      mov             rExp_mask = 0x1ffff
+      fcmp.eq.s1      p13, p0 = f0, f8 // test for x = 0.0
+      shl             rA3 = rA3, 12    // 0x3E2AA000, approx to 1.0/6.0 in SP
+}
+{ .mfb
+      nop.m           0
+      nop.f           0
+(p6)  br.cond.spnt    COSH_UNORM            // Branch if x=unorm
+}
+;;
+
+COSH_COMMON:
+{ .mfi
+      setf.exp        fA2 = rExpHalf        // load A2 to FP reg
+      nop.f           0
+      mov             rExp_bias = 0xffff
+}
+{ .mfb
+      setf.d          fLn2Div64 = rLn2Div64 // load ln(2)/64 to FP reg
+(p15) fma.s.s0        f8 = f8, f8, f0       // result if x = NaT,NaN,Inf
+(p15) br.ret.spnt     b0                    // exit here if x = NaT,NaN,Inf
+}
+;;
+
+{ .mfi
+      // min overflow and max normal threshold
+      ldfps           fMIN_SGL_OFLOW_ARG, fMAX_SGL_NORM_ARG = [rTblAddr], 8
+      nop.f           0
+      and             rExp_x = rExp_mask, rSignexp_x // Biased exponent of x
+}
+{ .mfb
+      setf.s          fA3 = rA3                  // load A3 to FP reg
+(p13) fma.s.s0        f8 = f1, f1, f0            // result if x = 0.0
+(p13) br.ret.spnt     b0                         // exit here if x =0.0
+}
+;;
+
+{ .mfi
+      sub             rExp_x = rExp_x, rExp_bias // True exponent of x
+      fmerge.s        fAbsX = f0, fNormX         // Form |x|
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      // x*(64/ln(2)) + Right Shifter
+      fma.s1          fNint = fNormX, f64DivLn2, fRightShifter
+      add             rTblAddr = 8, rTblAddr
+}
+{ .mfb
+      cmp.gt          p7, p0 = -2, rExp_x        // Test |x| < 2^(-2)
+      fma.s1          fXsq = fNormX, fNormX, f0  // x*x for small path
+(p7)  br.cond.spnt    COSH_SMALL                 // Branch if 0 < |x| < 2^-2
+}
+;;
+
+{ .mfi
+      nop.m           0
+      // check for overflow
+      fcmp.ge.s1      p12, p13 = fAbsX, fMIN_SGL_OFLOW_ARG
+      mov             rJ_mask = 0x3f             // 6-bit mask for J
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fms.s1          fN = fNint, f1, fRightShifter // n in FP register
+      // branch out if overflow
+(p12) br.cond.spnt    COSH_CERTAIN_OVERFLOW
+}
+;;
+
+{ .mfi
+      getf.sig        rNJ = fNint                   // bits of n, j
+      // check for possible overflow
+      fcmp.gt.s1      p13, p0 = fAbsX, fMAX_SGL_NORM_ARG
+      nop.i           0
+}
+;;
+
+{ .mfi
+      addl            rN = 0xFFBF - 63, rNJ      // biased and shifted n-1,j
+      fnma.s1         fR = fLn2Div64, fN, fNormX // R = x - N*ln(2)/64
+      and             rJ = rJ_mask, rNJ          // bits of j
+}
+{ .mfi
+      sub             rNJ_neg = r0, rNJ          // bits of n, j for -x
+      nop.f           0
+      andcm           rN_mask = -1, rJ_mask      // 0xff...fc0 to mask N
+}
+;;
+
+{ .mfi
+      shladd          rJ = rJ, 3, rTblAddr // address in the 2^(j/64) table
+      nop.f           0
+      and             rN = rN_mask, rN     // biased, shifted n-1
+}
+{ .mfi
+      addl            rN_neg = 0xFFBF - 63, rNJ_neg // -x biased, shifted n-1,j
+      nop.f           0
+      and             rJ_neg = rJ_mask, rNJ_neg     // bits of j for -x
+}
+;;
+
+{ .mfi
+      ld8             rJ = [rJ]                    // Table value
+      nop.f           0
+      shl             rN = rN, 46 // 2^(n-1) bits in DP format
+}
+{ .mfi
+      shladd          rJ_neg = rJ_neg, 3, rTblAddr // addr in 2^(j/64) table -x
+      nop.f           0
+      and             rN_neg = rN_mask, rN_neg     // biased, shifted n-1 for -x
+}
+;;
+
+{ .mfi
+      ld8             rJ_neg = [rJ_neg]            // Table value for -x
+      nop.f           0
+      shl             rN_neg = rN_neg, 46 // 2^(n-1) bits in DP format for -x
+}
+;;
+
+{ .mfi
+      or              rN = rN, rJ // bits of 2^n * 2^(j/64) in DP format
+      nop.f           0
+      nop.i           0
+}
+;;
+
+{ .mmf
+      setf.d          fT = rN            // 2^(n-1) * 2^(j/64)
+      or              rN_neg = rN_neg, rJ_neg // -x bits of 2^n * 2^(j/64) in DP
+      fma.s1          fRSqr = fR, fR, f0 // R^2
+}
+;;
+
+{ .mfi
+      setf.d          fT_neg = rN_neg    // 2^(n-1) * 2^(j/64) for -x
+      fma.s1          fP = fA3, fR, fA2  // A3*R + A2
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fnma.s1         fP_neg = fA3, fR, fA2  // A3*R + A2 for -x
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fP = fP, fRSqr, fR // P = (A3*R + A2)*R^2 + R
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fms.s1          fP_neg = fP_neg, fRSqr, fR // P = (A3*R + A2)*R^2 + R, -x
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fmpy.s0         fTmp = fLn2Div64, fLn2Div64       // Force inexact
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fExp = fP, fT, fT                 // exp(x)/2
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+      fma.s1          fExp_neg = fP_neg, fT_neg, fT_neg // exp(-x)/2
+      // branch out if possible overflow result
+(p13) br.cond.spnt    COSH_POSSIBLE_OVERFLOW
+}
+;;
+
+{ .mfb
+      nop.m           0
+      // final result in the absence of overflow
+      fma.s.s0        f8 = fExp, f1, fExp_neg  // result = (exp(x)+exp(-x))/2
+      // exit here in the absence of overflow
+      br.ret.sptk     b0              // Exit main path, 0.25 <= |x| < 89.41598
+}
+;;
+
+// Here if 0 < |x| < 0.25.  Evaluate 8th order polynomial.
+COSH_SMALL:
+{ .mmi
+      add             rAd1 = 0x200, rTblAddr
+      add             rAd2 = 0x210, rTblAddr
+      nop.i           0
+}
+;;
+
+{ .mmi
+      ldfpd           fA4, fA3 = [rAd1]
+      ldfpd           fA2, fA1 = [rAd2]
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fX4 = fXsq, fXsq, f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA43 = fXsq, fA4, fA3
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fA21 = fXsq, fA2, fA1
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA4321 = fX4, fA43, fA21
+      nop.i           0
+}
+;;
+
+// Dummy multiply to generate inexact
+{ .mfi
+      nop.m           0
+      fmpy.s0         fTmp = fA4, fA4
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+      fma.s.s0        f8 = fA4321, fXsq, f1
+      br.ret.sptk     b0                // Exit if 0 < |x| < 0.25
+}
+;;
+
+COSH_POSSIBLE_OVERFLOW:
+
+// Here if fMAX_SGL_NORM_ARG < x < fMIN_SGL_OFLOW_ARG
+// This cannot happen if input is a single, only if input higher precision.
+// Overflow is a possibility, not a certainty.
+
+// Recompute result using status field 2 with user's rounding mode,
+// and wre set.  If result is larger than largest single, then we have
+// overflow
+
+{ .mfi
+      mov             rGt_ln  = 0x1007f // Exponent for largest single + 1 ulp
+      fsetc.s2        0x7F,0x42         // Get user's round mode, set wre
+      nop.i           0
+}
+;;
+
+{ .mfi
+      setf.exp        fGt_pln = rGt_ln  // Create largest single + 1 ulp
+      fma.s.s2        fWre_urm_f8 = fP, fT, fT    // Result with wre set
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fsetc.s2        0x7F,0x40                   // Turn off wre in sf2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.ge.s1      p6, p0 =  fWre_urm_f8, fGt_pln // Test for overflow
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      nop.f           0
+(p6)  br.cond.spnt    COSH_CERTAIN_OVERFLOW // Branch if overflow
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fma.s.s0        f8 = fP, fT, fT
+      br.ret.sptk     b0                     // Exit if really no overflow
+}
+;;
+
+// here if overflow
+COSH_CERTAIN_OVERFLOW:
+{ .mmi
+      addl            r17ones_m1 = 0x1FFFE, r0
+;;
+      setf.exp        fTmp = r17ones_m1
+      nop.i           0
+}
+;;
+
+{ .mfi
+      alloc           r32 = ar.pfs, 0, 3, 4, 0 // get some registers
+      fmerge.s        FR_X = f8,f8
+      nop.i           0
+}
+{ .mfb
+      mov             GR_Parameter_TAG = 65
+      fma.s.s0        FR_RESULT = fTmp, fTmp, f0 // Set I,O and +INF result
+      br.cond.sptk    __libm_error_region
+}
+;;
+
+// Here if x unorm
+COSH_UNORM:
+{ .mfb
+      getf.exp        rSignexp_x = fNormX    // Must recompute if x unorm
+      fcmp.eq.s0      p6, p0 = f8, f0        // Set D flag
+      br.cond.sptk    COSH_COMMON            // Return to main path
+}
+;;
+
+GLOBAL_IEEE754_END(coshf)
+libm_alias_float_other (__cosh, cosh)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+      add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+      nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+      mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+      add sp=-64,sp                           // Create new stack
+      nop.f 0
+      mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+      stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
+      add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+      mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mfi
+      stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+      nop.f 0
+      add   GR_Parameter_RESULT = 0,GR_Parameter_Y // Parameter 3 address
+}
+{ .mib
+      stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
+      add   GR_Parameter_Y = -16,GR_Parameter_Y
+      br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+
+{ .mmi
+      add   GR_Parameter_RESULT = 48,sp
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mmi
+      ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+      add   sp = 64,sp                       // Restore stack pointer
+      mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+      mov   gp = GR_SAVE_GP                  // Restore gp
+      mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+      br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_coshl.S
@@ -0,0 +1,1095 @@
+.file "coshl.s"
+
+
+// Copyright (c) 2000 - 2002, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 01/23/01 Set inexact flag for large args.
+// 05/07/01 Reworked to improve speed of all paths
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 12/06/02 Improved performance
+//
+// API
+//==============================================================
+// long double = coshl(long double)
+// input  floating point f8
+// output floating point f8
+//
+// Registers used
+//==============================================================
+// general registers:
+// r14 -> r40
+// predicate registers used:
+// p6 -> p11
+// floating-point registers used:
+// f9 -> f15; f32 -> f90;
+// f8 has input, then output
+//
+// Overview of operation
+//==============================================================
+// There are seven paths
+// 1. 0 < |x| < 0.25          COSH_BY_POLY
+// 2. 0.25 <=|x| < 32         COSH_BY_TBL
+// 3. 32 <= |x| < 11357.21655 COSH_BY_EXP (merged path with COSH_BY_TBL)
+// 4. |x| >= 11357.21655      COSH_HUGE
+// 5. x=0                     Done with early exit
+// 6. x=inf,nan               Done with early exit
+// 7. x=denormal              COSH_DENORM
+//
+// For double extended we get overflow for x >= 400c b174 ddc0 31ae c0ea
+//                                           >= 11357.21655
+//
+//
+// 1. COSH_BY_POLY   0 < |x| < 0.25
+// ===============
+// Evaluate cosh(x) by a 12th order polynomial
+// Care is take for the order of multiplication; and P2 is not exactly 1/4!,
+// P3 is not exactly 1/6!, etc.
+// cosh(x) = 1 + (P1*x^2 + P2*x^4 + P3*x^6 + P4*x^8 + P5*x^10 + P6*x^12)
+//
+// 2. COSH_BY_TBL   0.25 <= |x| < 32.0
+// =============
+// cosh(x) = cosh(B+R)
+//         = cosh(B)cosh(R) + sinh(B)sinh(R)
+//
+// ax = |x| = M*log2/64 + R
+// B = M*log2/64
+// M = 64*N + j
+//   We will calculate M and get N as (M-j)/64
+//   The division is a shift.
+// exp(B)  = exp(N*log2 + j*log2/64)
+//         = 2^N * 2^(j*log2/64)
+// cosh(B) = 1/2(e^B + e^-B)
+//         = 1/2(2^N * 2^(j*log2/64) + 2^-N * 2^(-j*log2/64))
+// cosh(B) = (2^(N-1) * 2^(j*log2/64) + 2^(-N-1) * 2^(-j*log2/64))
+// sinh(B) = (2^(N-1) * 2^(j*log2/64) - 2^(-N-1) * 2^(-j*log2/64))
+// 2^(j*log2/64) is stored as Tjhi + Tjlo , j= -32,....,32
+// Tjhi is double-extended (80-bit) and Tjlo is single(32-bit)
+//
+// R = ax - M*log2/64
+// R = ax - M*log2_by_64_hi - M*log2_by_64_lo
+// exp(R) = 1 + R +R^2(1/2! + R(1/3! + R(1/4! + ... + R(1/n!)...)
+//        = 1 + p_odd + p_even
+//        where the p_even uses the A coefficients and the p_even uses
+//        the B coefficients
+//
+// So sinh(R) = 1 + p_odd + p_even -(1 -p_odd -p_even)/2 = p_odd
+//    cosh(R) = 1 + p_even
+//    cosh(B) = C_hi + C_lo
+//    sinh(B) = S_hi
+// cosh(x) = cosh(B)cosh(R) + sinh(B)sinh(R)
+//
+// 3. COSH_BY_EXP   32.0 <= |x| < 11357.21655  ( 400c b174 ddc0 31ae c0ea )
+// ==============
+// Can approximate result by exp(x)/2 in this region.
+// Y_hi = Tjhi
+// Y_lo = Tjhi * (p_odd + p_even) + Tjlo
+// cosh(x) = Y_hi + Y_lo
+//
+// 4. COSH_HUGE     |x| >= 11357.21655  ( 400c b174 ddc0 31ae c0ea )
+// ============
+// Set error tag and call error support
+//
+//
+// Assembly macros
+//==============================================================
+r_ad5                 = r14
+r_rshf_2to57          = r15
+r_exp_denorm          = r15
+r_ad_mJ_lo            = r15
+r_ad_J_lo             = r16
+r_2Nm1                = r17
+r_2mNm1               = r18
+r_exp_x               = r18
+r_ad_J_hi             = r19
+r_ad2o                = r19
+r_ad_mJ_hi            = r20
+r_mj                  = r21
+r_ad2e                = r22
+r_ad3                 = r23
+r_ad1                 = r24
+r_Mmj                 = r24
+r_rshf                = r25
+r_M                   = r25
+r_N                   = r25
+r_jshf                = r26
+r_exp_2tom57          = r26
+r_j                   = r26
+r_exp_mask            = r27
+r_signexp_x           = r28
+r_signexp_0_5         = r28
+r_exp_0_25            = r29
+r_sig_inv_ln2         = r30
+r_exp_32              = r30
+r_exp_huge            = r30
+r_ad4                 = r31
+
+GR_SAVE_PFS           = r34
+GR_SAVE_B0            = r35
+GR_SAVE_GP            = r36
+
+GR_Parameter_X        = r37
+GR_Parameter_Y        = r38
+GR_Parameter_RESULT   = r39
+GR_Parameter_TAG      = r40
+
+
+f_ABS_X               = f9
+f_X2                  = f10
+f_X4                  = f11
+f_tmp                 = f14
+f_RSHF                = f15
+
+f_Inv_log2by64        = f32
+f_log2by64_lo         = f33
+f_log2by64_hi         = f34
+f_A1                  = f35
+
+f_A2                  = f36
+f_A3                  = f37
+f_Rcub                = f38
+f_M_temp              = f39
+f_R_temp              = f40
+
+f_Rsq                 = f41
+f_R                   = f42
+f_M                   = f43
+f_B1                  = f44
+f_B2                  = f45
+
+f_B3                  = f46
+f_peven_temp1         = f47
+f_peven_temp2         = f48
+f_peven               = f49
+f_podd_temp1          = f50
+
+f_podd_temp2          = f51
+f_podd                = f52
+f_poly65              = f53
+f_poly6543            = f53
+f_poly6to1            = f53
+f_poly43              = f54
+f_poly21              = f55
+
+f_X3                  = f56
+f_INV_LN2_2TO63       = f57
+f_RSHF_2TO57          = f58
+f_2TOM57              = f59
+f_smlst_oflow_input   = f60
+
+f_pre_result          = f61
+f_huge                = f62
+f_spos                = f63
+f_sneg                = f64
+f_Tjhi                = f65
+
+f_Tjlo                = f66
+f_Tmjhi               = f67
+f_Tmjlo               = f68
+f_S_hi                = f69
+f_SC_hi_temp          = f70
+
+f_C_lo_temp1          = f71
+f_C_lo_temp2          = f72
+f_C_lo_temp3          = f73
+f_C_lo_temp4          = f73
+f_C_lo                = f74
+f_C_hi                = f75
+
+f_Y_hi                = f77
+f_Y_lo_temp           = f78
+f_Y_lo                = f79
+f_NORM_X              = f80
+
+f_P1                  = f81
+f_P2                  = f82
+f_P3                  = f83
+f_P4                  = f84
+f_P5                  = f85
+
+f_P6                  = f86
+f_Tjhi_spos           = f87
+f_Tjlo_spos           = f88
+f_huge                = f89
+f_signed_hi_lo        = f90
+
+
+// Data tables
+//==============================================================
+
+// DO NOT CHANGE ORDER OF THESE TABLES
+RODATA
+
+.align 16
+LOCAL_OBJECT_START(cosh_arg_reduction)
+//   data8 0xB8AA3B295C17F0BC, 0x00004005  // 64/log2 -- signif loaded with setf
+   data8 0xB17217F7D1000000, 0x00003FF8  // log2/64 high part
+   data8 0xCF79ABC9E3B39804, 0x00003FD0  // log2/64 low part
+   data8 0xb174ddc031aec0ea, 0x0000400c  // Smallest x to overflow (11357.21655)
+LOCAL_OBJECT_END(cosh_arg_reduction)
+
+LOCAL_OBJECT_START(cosh_p_table)
+   data8 0x8FA02AC65BCBD5BC, 0x00003FE2  // P6
+   data8 0xD00D00D1021D7370, 0x00003FEF  // P4
+   data8 0xAAAAAAAAAAAAAB80, 0x00003FFA  // P2
+   data8 0x93F27740C0C2F1CC, 0x00003FE9  // P5
+   data8 0xB60B60B60B4FE884, 0x00003FF5  // P3
+   data8 0x8000000000000000, 0x00003FFE  // P1
+LOCAL_OBJECT_END(cosh_p_table)
+
+LOCAL_OBJECT_START(cosh_ab_table)
+   data8 0xAAAAAAAAAAAAAAAC, 0x00003FFC  // A1
+   data8 0x88888888884ECDD5, 0x00003FF8  // A2
+   data8 0xD00D0C6DCC26A86B, 0x00003FF2  // A3
+   data8 0x8000000000000002, 0x00003FFE  // B1
+   data8 0xAAAAAAAAAA402C77, 0x00003FFA  // B2
+   data8 0xB60B6CC96BDB144D, 0x00003FF5  // B3
+LOCAL_OBJECT_END(cosh_ab_table)
+
+LOCAL_OBJECT_START(cosh_j_hi_table)
+   data8 0xB504F333F9DE6484, 0x00003FFE
+   data8 0xB6FD91E328D17791, 0x00003FFE
+   data8 0xB8FBAF4762FB9EE9, 0x00003FFE
+   data8 0xBAFF5AB2133E45FB, 0x00003FFE
+   data8 0xBD08A39F580C36BF, 0x00003FFE
+   data8 0xBF1799B67A731083, 0x00003FFE
+   data8 0xC12C4CCA66709456, 0x00003FFE
+   data8 0xC346CCDA24976407, 0x00003FFE
+   data8 0xC5672A115506DADD, 0x00003FFE
+   data8 0xC78D74C8ABB9B15D, 0x00003FFE
+   data8 0xC9B9BD866E2F27A3, 0x00003FFE
+   data8 0xCBEC14FEF2727C5D, 0x00003FFE
+   data8 0xCE248C151F8480E4, 0x00003FFE
+   data8 0xD06333DAEF2B2595, 0x00003FFE
+   data8 0xD2A81D91F12AE45A, 0x00003FFE
+   data8 0xD4F35AABCFEDFA1F, 0x00003FFE
+   data8 0xD744FCCAD69D6AF4, 0x00003FFE
+   data8 0xD99D15C278AFD7B6, 0x00003FFE
+   data8 0xDBFBB797DAF23755, 0x00003FFE
+   data8 0xDE60F4825E0E9124, 0x00003FFE
+   data8 0xE0CCDEEC2A94E111, 0x00003FFE
+   data8 0xE33F8972BE8A5A51, 0x00003FFE
+   data8 0xE5B906E77C8348A8, 0x00003FFE
+   data8 0xE8396A503C4BDC68, 0x00003FFE
+   data8 0xEAC0C6E7DD24392F, 0x00003FFE
+   data8 0xED4F301ED9942B84, 0x00003FFE
+   data8 0xEFE4B99BDCDAF5CB, 0x00003FFE
+   data8 0xF281773C59FFB13A, 0x00003FFE
+   data8 0xF5257D152486CC2C, 0x00003FFE
+   data8 0xF7D0DF730AD13BB9, 0x00003FFE
+   data8 0xFA83B2DB722A033A, 0x00003FFE
+   data8 0xFD3E0C0CF486C175, 0x00003FFE
+   data8 0x8000000000000000, 0x00003FFF // Center of table
+   data8 0x8164D1F3BC030773, 0x00003FFF
+   data8 0x82CD8698AC2BA1D7, 0x00003FFF
+   data8 0x843A28C3ACDE4046, 0x00003FFF
+   data8 0x85AAC367CC487B15, 0x00003FFF
+   data8 0x871F61969E8D1010, 0x00003FFF
+   data8 0x88980E8092DA8527, 0x00003FFF
+   data8 0x8A14D575496EFD9A, 0x00003FFF
+   data8 0x8B95C1E3EA8BD6E7, 0x00003FFF
+   data8 0x8D1ADF5B7E5BA9E6, 0x00003FFF
+   data8 0x8EA4398B45CD53C0, 0x00003FFF
+   data8 0x9031DC431466B1DC, 0x00003FFF
+   data8 0x91C3D373AB11C336, 0x00003FFF
+   data8 0x935A2B2F13E6E92C, 0x00003FFF
+   data8 0x94F4EFA8FEF70961, 0x00003FFF
+   data8 0x96942D3720185A00, 0x00003FFF
+   data8 0x9837F0518DB8A96F, 0x00003FFF
+   data8 0x99E0459320B7FA65, 0x00003FFF
+   data8 0x9B8D39B9D54E5539, 0x00003FFF
+   data8 0x9D3ED9A72CFFB751, 0x00003FFF
+   data8 0x9EF5326091A111AE, 0x00003FFF
+   data8 0xA0B0510FB9714FC2, 0x00003FFF
+   data8 0xA27043030C496819, 0x00003FFF
+   data8 0xA43515AE09E6809E, 0x00003FFF
+   data8 0xA5FED6A9B15138EA, 0x00003FFF
+   data8 0xA7CD93B4E965356A, 0x00003FFF
+   data8 0xA9A15AB4EA7C0EF8, 0x00003FFF
+   data8 0xAB7A39B5A93ED337, 0x00003FFF
+   data8 0xAD583EEA42A14AC6, 0x00003FFF
+   data8 0xAF3B78AD690A4375, 0x00003FFF
+   data8 0xB123F581D2AC2590, 0x00003FFF
+   data8 0xB311C412A9112489, 0x00003FFF
+   data8 0xB504F333F9DE6484, 0x00003FFF
+LOCAL_OBJECT_END(cosh_j_hi_table)
+
+LOCAL_OBJECT_START(cosh_j_lo_table)
+   data4 0x1EB2FB13
+   data4 0x1CE2CBE2
+   data4 0x1DDC3CBC
+   data4 0x1EE9AA34
+   data4 0x9EAEFDC1
+   data4 0x9DBF517B
+   data4 0x1EF88AFB
+   data4 0x1E03B216
+   data4 0x1E78AB43
+   data4 0x9E7B1747
+   data4 0x9EFE3C0E
+   data4 0x9D36F837
+   data4 0x9DEE53E4
+   data4 0x9E24AE8E
+   data4 0x1D912473
+   data4 0x1EB243BE
+   data4 0x1E669A2F
+   data4 0x9BBC610A
+   data4 0x1E761035
+   data4 0x9E0BE175
+   data4 0x1CCB12A1
+   data4 0x1D1BFE90
+   data4 0x1DF2F47A
+   data4 0x1EF22F22
+   data4 0x9E3F4A29
+   data4 0x1EC01A5B
+   data4 0x1E8CAC3A
+   data4 0x9DBB3FAB
+   data4 0x1EF73A19
+   data4 0x9BB795B5
+   data4 0x1EF84B76
+   data4 0x9EF5818B
+   data4 0x00000000 // Center of table
+   data4 0x1F77CACA
+   data4 0x1EF8A91D
+   data4 0x1E57C976
+   data4 0x9EE8DA92
+   data4 0x1EE85C9F
+   data4 0x1F3BF1AF
+   data4 0x1D80CA1E
+   data4 0x9D0373AF
+   data4 0x9F167097
+   data4 0x1EB70051
+   data4 0x1F6EB029
+   data4 0x1DFD6D8E
+   data4 0x9EB319B0
+   data4 0x1EBA2BEB
+   data4 0x1F11D537
+   data4 0x1F0D5A46
+   data4 0x9E5E7BCA
+   data4 0x9F3AAFD1
+   data4 0x9E86DACC
+   data4 0x9F3EDDC2
+   data4 0x1E496E3D
+   data4 0x9F490BF6
+   data4 0x1DD1DB48
+   data4 0x1E65EBFB
+   data4 0x9F427496
+   data4 0x1F283C4A
+   data4 0x1F4B0047
+   data4 0x1F130152
+   data4 0x9E8367C0
+   data4 0x9F705F90
+   data4 0x1EFB3C53
+   data4 0x1F32FB13
+LOCAL_OBJECT_END(cosh_j_lo_table)
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(coshl)
+
+{ .mlx
+      getf.exp        r_signexp_x = f8   // Get signexp of x, must redo if unorm
+      movl            r_sig_inv_ln2 = 0xb8aa3b295c17f0bc // significand of 1/ln2
+}
+{ .mlx
+      addl            r_ad1 = @ltoff(cosh_arg_reduction), gp
+      movl            r_rshf_2to57 = 0x4778000000000000 // 1.10000 2^(63+57)
+}
+;;
+
+{ .mfi
+      ld8             r_ad1 = [r_ad1]
+      fmerge.s        f_ABS_X    = f0,f8
+      mov             r_exp_0_25 = 0x0fffd    // Form exponent for 0.25
+}
+{ .mfi
+      nop.m           0
+      fnorm.s1        f_NORM_X = f8
+      mov             r_exp_2tom57 = 0xffff-57
+}
+;;
+
+{ .mfi
+      setf.d          f_RSHF_2TO57 = r_rshf_2to57 // Form const 1.100 * 2^120
+      fclass.m        p10,p0 = f8, 0x0b           // Test for denorm
+      mov             r_exp_mask = 0x1ffff
+}
+{ .mlx
+      setf.sig        f_INV_LN2_2TO63 = r_sig_inv_ln2 // Form 1/ln2 * 2^63
+      movl            r_rshf = 0x43e8000000000000 // 1.1000 2^63 for right shift
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fclass.m        p7,p0 = f8, 0x07  // Test if x=0
+      nop.i           0
+}
+{ .mfi
+      setf.exp        f_2TOM57 = r_exp_2tom57 // Form 2^-57 for scaling
+      nop.f           0
+      add             r_ad3 = 0x90, r_ad1  // Point to ab_table
+}
+;;
+
+{ .mfi
+      setf.d          f_RSHF = r_rshf     // Form right shift const 1.100 * 2^63
+      fclass.m        p6,p0 = f8, 0xe3     // Test if x nan, inf
+      add             r_ad4 = 0x2f0, r_ad1 // Point to j_hi_table midpoint
+}
+{ .mib
+      add             r_ad2e = 0x20, r_ad1 // Point to p_table
+      nop.i           0
+(p10) br.cond.spnt    COSH_DENORM          // Branch if x denorm
+}
+;;
+
+// Common path -- return here from COSH_DENORM if x is unnorm
+COSH_COMMON:
+{ .mfi
+      ldfe            f_smlst_oflow_input = [r_ad2e],16
+(p7)  fma.s0          f8 = f1, f1, f0      // Result = 1.0 if x=0
+      add             r_ad5 = 0x580, r_ad1 // Point to j_lo_table midpoint
+}
+{ .mib
+      ldfe            f_log2by64_hi  = [r_ad1],16
+      and             r_exp_x = r_exp_mask, r_signexp_x
+(p7)  br.ret.spnt     b0                  // Exit if x=0
+}
+;;
+
+// Get the A coefficients for COSH_BY_TBL
+{ .mfi
+      ldfe            f_A1 = [r_ad3],16
+      fcmp.lt.s1      p8,p9 = f8,f0           // Test for x<0
+      cmp.lt          p7,p0 = r_exp_x, r_exp_0_25  // Test x < 0.25
+}
+{ .mfb
+      add             r_ad2o = 0x30, r_ad2e  // Point to p_table odd coeffs
+(p6)  fma.s0          f8 = f8,f8,f0          // Result for x nan, inf
+(p6)  br.ret.spnt     b0                     // Exit for x nan, inf
+}
+;;
+
+// Calculate X2 = ax*ax for COSH_BY_POLY
+{ .mfi
+      ldfe            f_log2by64_lo  = [r_ad1],16
+      nop.f           0
+      nop.i           0
+}
+{ .mfb
+      ldfe            f_A2 = [r_ad3],16
+      fma.s1          f_X2 = f_NORM_X, f_NORM_X, f0
+(p7)  br.cond.spnt    COSH_BY_POLY
+}
+;;
+
+// Here if |x| >= 0.25
+COSH_BY_TBL:
+// ******************************************************
+// STEP 1 (TBL and EXP) - Argument reduction
+// ******************************************************
+// Get the following constants.
+// Inv_log2by64
+// log2by64_hi
+// log2by64_lo
+
+
+// We want 2^(N-1) and 2^(-N-1). So bias N-1 and -N-1 and
+// put them in an exponent.
+// f_spos = 2^(N-1) and f_sneg = 2^(-N-1)
+// 0xffff + (N-1)  = 0xffff +N -1
+// 0xffff - (N +1) = 0xffff -N -1
+
+
+// Calculate M and keep it as integer and floating point.
+// M = round-to-integer(x*Inv_log2by64)
+// f_M = M = truncate(ax/(log2/64))
+// Put the integer representation of M in r_M
+//    and the floating point representation of M in f_M
+
+// Get the remaining A,B coefficients
+{ .mmi
+      ldfe            f_A3 = [r_ad3],16
+      nop.m           0
+      nop.i           0
+}
+;;
+
+// Use constant (1.100*2^(63-6)) to get rounded M into rightmost significand
+// |x| * 64 * 1/ln2 * 2^(63-6) + 1.1000 * 2^(63+(63-6))
+{ .mfi
+      nop.m           0
+      fma.s1          f_M_temp = f_ABS_X, f_INV_LN2_2TO63, f_RSHF_2TO57
+      mov             r_signexp_0_5 = 0x0fffe // signexp of +0.5
+}
+;;
+
+// Test for |x| >= overflow limit
+{ .mfi
+      ldfe            f_B1 = [r_ad3],16
+      fcmp.ge.s1      p6,p0 = f_ABS_X, f_smlst_oflow_input
+      nop.i           0
+}
+;;
+
+{ .mfi
+      ldfe            f_B2 = [r_ad3],16
+      nop.f           0
+      mov             r_exp_32 = 0x10004
+}
+;;
+
+// Subtract RSHF constant to get rounded M as a floating point value
+// M_temp * 2^(63-6) - 2^63
+{ .mfb
+      ldfe            f_B3 = [r_ad3],16
+      fms.s1          f_M = f_M_temp, f_2TOM57, f_RSHF
+(p6)  br.cond.spnt    COSH_HUGE  // Branch if result will overflow
+}
+;;
+
+{ .mfi
+      getf.sig        r_M = f_M_temp
+      nop.f           0
+      cmp.ge          p7,p6 = r_exp_x, r_exp_32 // Test if x >= 32
+}
+;;
+
+// Calculate j. j is the signed extension of the six lsb of M. It
+// has a range of -32 thru 31.
+
+// Calculate R
+// ax - M*log2by64_hi
+// R = (ax - M*log2by64_hi) - M*log2by64_lo
+
+{ .mfi
+      nop.m           0
+      fnma.s1         f_R_temp = f_M, f_log2by64_hi, f_ABS_X
+      and             r_j = 0x3f, r_M
+}
+;;
+
+{ .mii
+      nop.m           0
+      shl             r_jshf = r_j, 0x2 // Shift j so can sign extend it
+;;
+      sxt1            r_jshf = r_jshf
+}
+;;
+
+{ .mii
+      nop.m           0
+      shr             r_j = r_jshf, 0x2    // Now j has range -32 to 31
+      nop.i           0
+}
+;;
+
+{ .mmi
+      shladd          r_ad_J_hi = r_j, 4, r_ad4 // pointer to Tjhi
+      sub             r_Mmj = r_M, r_j          // M-j
+      sub             r_mj = r0, r_j            // Form -j
+}
+;;
+
+// The TBL and EXP branches are merged and predicated
+// If TBL, p6 true, 0.25 <= |x| < 32
+// If EXP, p7 true, 32 <= |x| < overflow_limit
+//
+// N = (M-j)/64
+{ .mfi
+      ldfe            f_Tjhi = [r_ad_J_hi]
+      fnma.s1         f_R = f_M, f_log2by64_lo, f_R_temp
+      shr             r_N = r_Mmj, 0x6            // N = (M-j)/64
+}
+{ .mfi
+      shladd          r_ad_mJ_hi = r_mj, 4, r_ad4 // pointer to Tmjhi
+      nop.f           0
+      shladd          r_ad_mJ_lo = r_mj, 2, r_ad5 // pointer to Tmjlo
+}
+;;
+
+{ .mfi
+      sub             r_2mNm1 = r_signexp_0_5, r_N // signexp 2^(-N-1)
+      nop.f           0
+      shladd          r_ad_J_lo = r_j, 2, r_ad5   // pointer to Tjlo
+}
+{ .mfi
+      ldfe            f_Tmjhi = [r_ad_mJ_hi]
+      nop.f           0
+      add             r_2Nm1 = r_signexp_0_5, r_N // signexp 2^(N-1)
+}
+;;
+
+{ .mmf
+      ldfs            f_Tmjlo = [r_ad_mJ_lo]
+      setf.exp        f_sneg = r_2mNm1            // Form 2^(-N-1)
+      nop.f           0
+}
+;;
+
+{ .mmf
+      ldfs            f_Tjlo  = [r_ad_J_lo]
+      setf.exp        f_spos = r_2Nm1             // Form 2^(N-1)
+      nop.f           0
+}
+;;
+
+// ******************************************************
+// STEP 2 (TBL and EXP)
+// ******************************************************
+// Calculate Rsquared and Rcubed in preparation for p_even and p_odd
+
+{ .mmf
+      nop.m           0
+      nop.m           0
+      fma.s1          f_Rsq  = f_R, f_R, f0
+}
+;;
+
+
+// Calculate p_even
+// B_2 + Rsq *B_3
+// B_1 + Rsq * (B_2 + Rsq *B_3)
+// p_even = Rsq * (B_1 + Rsq * (B_2 + Rsq *B_3))
+{ .mfi
+      nop.m           0
+      fma.s1          f_peven_temp1 = f_Rsq, f_B3, f_B2
+      nop.i           0
+}
+// Calculate p_odd
+// A_2 + Rsq *A_3
+// A_1 + Rsq * (A_2 + Rsq *A_3)
+// podd = R + Rcub * (A_1 + Rsq * (A_2 + Rsq *A_3))
+{ .mfi
+      nop.m           0
+      fma.s1          f_podd_temp1 = f_Rsq, f_A3, f_A2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_Rcub = f_Rsq, f_R, f0
+      nop.i           0
+}
+;;
+
+//
+// If TBL,
+// Calculate S_hi and S_lo, and C_hi
+// SC_hi_temp = sneg * Tmjhi
+// S_hi = spos * Tjhi - SC_hi_temp
+// S_hi = spos * Tjhi - (sneg * Tmjhi)
+// C_hi = spos * Tjhi + SC_hi_temp
+// C_hi = spos * Tjhi + (sneg * Tmjhi)
+
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_SC_hi_temp = f_sneg, f_Tmjhi, f0
+      nop.i           0
+}
+;;
+
+// If TBL,
+// C_lo_temp3 = sneg * Tmjlo
+// C_lo_temp4 = spos * Tjlo + C_lo_temp3
+// C_lo_temp4 = spos * Tjlo + (sneg * Tmjlo)
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_C_lo_temp3 =  f_sneg, f_Tmjlo, f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_peven_temp2 = f_Rsq, f_peven_temp1, f_B1
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          f_podd_temp2 = f_Rsq, f_podd_temp1, f_A1
+      nop.i           0
+}
+;;
+
+// If EXP,
+// Compute 2^(N-1) * Tjhi and 2^(N-1) * Tjlo
+{ .mfi
+      nop.m           0
+(p7)  fma.s1          f_Tjhi_spos = f_Tjhi, f_spos, f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+(p7)  fma.s1          f_Tjlo_spos = f_Tjlo, f_spos, f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_C_hi = f_spos, f_Tjhi, f_SC_hi_temp
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+(p6)  fms.s1          f_S_hi = f_spos, f_Tjhi, f_SC_hi_temp
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_C_lo_temp4 = f_spos, f_Tjlo, f_C_lo_temp3
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_peven = f_Rsq, f_peven_temp2, f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          f_podd = f_podd_temp2, f_Rcub, f_R
+      nop.i           0
+}
+;;
+
+// If TBL,
+// C_lo_temp1 =  spos * Tjhi - C_hi
+// C_lo_temp2 =  sneg * Tmjlo + C_lo_temp1
+// C_lo_temp2 =  sneg * Tmjlo + (spos * Tjhi - C_hi)
+
+{ .mfi
+      nop.m           0
+(p6)  fms.s1          f_C_lo_temp1 =  f_spos, f_Tjhi,  f_C_hi
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_C_lo_temp2 = f_sneg, f_Tmjhi, f_C_lo_temp1
+      nop.i           0
+}
+;;
+
+// If EXP,
+// Y_hi = 2^(N-1) * Tjhi
+// Y_lo = 2^(N-1) * Tjhi * (p_odd + p_even) + 2^(N-1) * Tjlo
+{ .mfi
+      nop.m           0
+(p7)  fma.s1          f_Y_lo_temp =  f_peven, f1, f_podd
+      nop.i           0
+}
+;;
+
+// If TBL,
+// C_lo = C_lo_temp4 + C_lo_temp2
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_C_lo = f_C_lo_temp4, f1, f_C_lo_temp2
+      nop.i           0
+}
+;;
+
+// If TBL,
+// Y_hi = C_hi
+// Y_lo = S_hi*p_odd + (C_hi*p_even + C_lo)
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_Y_lo_temp = f_C_hi, f_peven, f_C_lo
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+(p7)  fma.s1          f_Y_lo = f_Tjhi_spos, f_Y_lo_temp, f_Tjlo_spos
+      nop.i           0
+}
+;;
+
+// Dummy multiply to generate inexact
+{ .mfi
+      nop.m           0
+      fmpy.s0         f_tmp = f_B2, f_B2
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_Y_lo = f_S_hi, f_podd, f_Y_lo_temp
+      nop.i           0
+}
+;;
+
+// f8 = answer = Y_hi + Y_lo
+{ .mfi
+      nop.m           0
+(p7)  fma.s0          f8 = f_Y_lo,  f1, f_Tjhi_spos
+      nop.i           0
+}
+;;
+
+// f8 = answer = Y_hi + Y_lo
+{ .mfb
+      nop.m           0
+(p6)  fma.s0          f8 = f_Y_lo, f1, f_C_hi
+      br.ret.sptk     b0      // Exit for COSH_BY_TBL and COSH_BY_EXP
+}
+;;
+
+
+// Here if 0 < |x| < 0.25
+COSH_BY_POLY:
+{ .mmf
+      ldfe            f_P6 = [r_ad2e],16
+      ldfe            f_P5 = [r_ad2o],16
+      nop.f           0
+}
+;;
+
+{ .mmi
+      ldfe            f_P4 = [r_ad2e],16
+      ldfe            f_P3 = [r_ad2o],16
+      nop.i           0
+}
+;;
+
+{ .mmi
+      ldfe            f_P2 = [r_ad2e],16
+      ldfe            f_P1 = [r_ad2o],16
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_X3 = f_NORM_X, f_X2, f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          f_X4 = f_X2, f_X2, f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_poly65 = f_X2, f_P6, f_P5
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          f_poly43 = f_X2, f_P4, f_P3
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_poly21 = f_X2, f_P2, f_P1
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_poly6543 = f_X4, f_poly65, f_poly43
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_poly6to1 = f_X4, f_poly6543, f_poly21
+      nop.i           0
+}
+;;
+
+// Dummy multiply to generate inexact
+{ .mfi
+      nop.m           0
+      fmpy.s0         f_tmp = f_P6, f_P6
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+      fma.s0          f8 = f_poly6to1, f_X2, f1
+      br.ret.sptk     b0                // Exit COSH_BY_POLY
+}
+;;
+
+
+// Here if x denorm or unorm
+COSH_DENORM:
+// Determine if x really a denorm and not a unorm
+{ .mmf
+      getf.exp        r_signexp_x = f_NORM_X
+      mov             r_exp_denorm = 0x0c001   // Real denorms have exp < this
+      fmerge.s        f_ABS_X = f0, f_NORM_X
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.eq.s0      p10,p0 = f8, f0  // Set denorm flag
+      nop.i           0
+}
+;;
+
+// Set p8 if really a denorm
+{ .mmi
+      and             r_exp_x = r_exp_mask, r_signexp_x
+;;
+      cmp.lt          p8,p9 = r_exp_x, r_exp_denorm
+      nop.i           0
+}
+;;
+
+// Identify denormal operands.
+{ .mfb
+      nop.m           0
+(p8)  fma.s0          f8 =  f8,f8,f1 // If x denorm, result=1+x^2
+(p9)  br.cond.sptk    COSH_COMMON    // Return to main path if x unorm
+}
+;;
+
+{ .mfb
+      nop.m           0
+      nop.f           0
+      br.ret.sptk     b0            // Exit if x denorm
+}
+;;
+
+
+// Here if |x| >= overflow limit
+COSH_HUGE:
+// for COSH_HUGE, put 24000 in exponent; take sign from input
+{ .mmi
+      mov             r_exp_huge = 0x15dbf
+;;
+      setf.exp        f_huge  = r_exp_huge
+      nop.i           0
+}
+;;
+
+{ .mfi
+      alloc           r32 = ar.pfs,0,5,4,0
+      fma.s1          f_signed_hi_lo = f_huge, f1, f1
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s0          f_pre_result = f_signed_hi_lo, f_huge, f0
+      mov             GR_Parameter_TAG = 63
+}
+;;
+
+GLOBAL_IEEE754_END(coshl)
+libm_alias_ldouble_other (__cosh, cosh)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+
+{ .mfi
+        add   GR_Parameter_Y=-32,sp              // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                  // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                            // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                        // Save gp
+};;
+
+{ .mmi
+        stfe [GR_Parameter_Y] = f0,16            // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp               // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                        // Save b0
+};;
+
+.body
+{ .mib
+        stfe [GR_Parameter_X] = f8               // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y   // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfe [GR_Parameter_Y] = f_pre_result     // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#    // Call error handling function
+};;
+
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]         // Get return result off stack
+.restore sp
+        add   sp = 64,sp                         // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                    // Restore return address
+};;
+
+{ .mib
+        mov   gp = GR_SAVE_GP                    // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS               // Restore ar.pfs
+        br.ret.sptk     b0                       // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_exp.S
@@ -0,0 +1,799 @@
+.file "exp.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 2/02/00  Initial version
+// 3/07/00  exp(inf)  = inf but now does NOT call error support
+//          exp(-inf) = 0   but now does NOT call error support
+// 4/04/00  Unwind support added
+// 8/15/00  Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 11/30/00 Reworked to shorten main path, widen main path to include all
+//          args in normal range, and add quick exit for 0, nan, inf.
+// 12/05/00 Loaded constants earlier with setf to save 2 cycles.
+// 02/05/02 Corrected uninitialize predicate in POSSIBLE_UNDERFLOW path
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 09/07/02 Force inexact flag
+// 11/15/02 Split underflow path into zero/nonzero; eliminated fma in main path
+// 05/30/03 Set inexact flag on unmasked overflow/underflow
+// 03/31/05 Reformatted delimiters between data tables
+
+// API
+//==============================================================
+// double exp(double)
+
+// Overview of operation
+//==============================================================
+// Take the input x. w is "how many log2/128 in x?"
+//  w = x * 128/log2
+//  n = int(w)
+//  x = n log2/128 + r + delta
+
+//  n = 128M + index_1 + 2^4 index_2
+//  x = M log2 + (log2/128) index_1 + (log2/8) index_2 + r + delta
+
+//  exp(x) = 2^M  2^(index_1/128)  2^(index_2/8) exp(r) exp(delta)
+//       Construct 2^M
+//       Get 2^(index_1/128) from table_1;
+//       Get 2^(index_2/8)   from table_2;
+//       Calculate exp(r) by 5th order polynomial
+//          r = x - n (log2/128)_high
+//          delta = - n (log2/128)_low
+//       Calculate exp(delta) as 1 + delta
+
+
+// Special values
+//==============================================================
+// exp(+0)    = 1.0
+// exp(-0)    = 1.0
+
+// exp(+qnan) = +qnan
+// exp(-qnan) = -qnan
+// exp(+snan) = +qnan
+// exp(-snan) = -qnan
+
+// exp(-inf)  = +0
+// exp(+inf)  = +inf
+
+// Overflow and Underflow
+//=======================
+// exp(x) = largest double normal when
+//     x = 709.7827 = 0x40862e42fefa39ef
+
+// exp(x) = smallest double normal when
+//     x = -708.396 = 0xc086232bdd7abcd2
+
+// exp(x) = largest round-to-nearest single zero when
+//     x = -745.1332 = 0xc0874910d52d3052
+
+
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input, output
+// f6 -> f15,  f32 -> f49
+
+// General registers used:
+// r14 -> r40
+
+// Predicate registers used:
+// p6 -> p15
+
+// Assembly macros
+//==============================================================
+
+rRshf                 = r14
+rAD_TB1               = r15
+rAD_T1                = r15
+rAD_TB2               = r16
+rAD_T2                = r16
+rAD_P                 = r17
+rN                    = r18
+rIndex_1              = r19
+rIndex_2_16           = r20
+rM                    = r21
+rBiased_M             = r21
+rIndex_1_16           = r21
+rSig_inv_ln2          = r22
+rExp_bias             = r23
+rExp_mask             = r24
+rTmp                  = r25
+rRshf_2to56           = r26
+rGt_ln                = r27
+rExp_2tom56           = r28
+
+
+GR_SAVE_B0            = r33
+GR_SAVE_PFS           = r34
+GR_SAVE_GP            = r35
+GR_SAVE_SP            = r36
+
+GR_Parameter_X        = r37
+GR_Parameter_Y        = r38
+GR_Parameter_RESULT   = r39
+GR_Parameter_TAG      = r40
+
+
+FR_X                  = f10
+FR_Y                  = f1
+FR_RESULT             = f8
+
+fRSHF_2TO56           = f6
+fINV_LN2_2TO63        = f7
+fW_2TO56_RSH          = f9
+f2TOM56               = f11
+fP5                   = f12
+fP54                  = f12
+fP5432                = f12
+fP4                   = f13
+fP3                   = f14
+fP32                  = f14
+fP2                   = f15
+fP                    = f15
+
+fLn2_by_128_hi        = f33
+fLn2_by_128_lo        = f34
+
+fRSHF                 = f35
+fNfloat               = f36
+fNormX                = f37
+fR                    = f38
+fF                    = f39
+
+fRsq                  = f40
+f2M                   = f41
+fS1                   = f42
+fT1                   = f42
+fS2                   = f43
+fT2                   = f43
+fS                    = f43
+fWre_urm_f8           = f44
+fFtz_urm_f8           = f44
+
+fMIN_DBL_OFLOW_ARG    = f45
+fMAX_DBL_ZERO_ARG     = f46
+fMAX_DBL_NORM_ARG     = f47
+fMIN_DBL_NORM_ARG     = f48
+fGt_pln               = f49
+fTmp                  = f49
+
+
+// Data tables
+//==============================================================
+
+RODATA
+.align 16
+
+// ************* DO NOT CHANGE ORDER OF THESE TABLES ********************
+
+// double-extended 1/ln(2)
+// 3fff b8aa 3b29 5c17 f0bb be87fed0691d3e88
+// 3fff b8aa 3b29 5c17 f0bc
+// For speed the significand will be loaded directly with a movl and setf.sig
+//   and the exponent will be bias+63 instead of bias+0.  Thus subsequent
+//   computations need to scale appropriately.
+// The constant 128/ln(2) is needed for the computation of w.  This is also
+//   obtained by scaling the computations.
+//
+// Two shifting constants are loaded directly with movl and setf.d.
+//   1. fRSHF_2TO56 = 1.1000..00 * 2^(63-7)
+//        This constant is added to x*1/ln2 to shift the integer part of
+//        x*128/ln2 into the rightmost bits of the significand.
+//        The result of this fma is fW_2TO56_RSH.
+//   2. fRSHF       = 1.1000..00 * 2^(63)
+//        This constant is subtracted from fW_2TO56_RSH * 2^(-56) to give
+//        the integer part of w, n, as a floating-point number.
+//        The result of this fms is fNfloat.
+
+
+LOCAL_OBJECT_START(exp_table_1)
+data8 0x40862e42fefa39f0 // smallest dbl overflow arg, +709.7827
+data8 0xc0874910d52d3052 // largest arg for rnd-to-nearest 0 result, -745.133
+data8 0x40862e42fefa39ef // largest dbl arg to give normal dbl result, +709.7827
+data8 0xc086232bdd7abcd2 // smallest dbl arg to give normal dbl result, -708.396
+data8 0xb17217f7d1cf79ab , 0x00003ff7 // ln2/128 hi
+data8 0xc9e3b39803f2f6af , 0x00003fb7 // ln2/128 lo
+//
+// Table 1 is 2^(index_1/128) where
+// index_1 goes from 0 to 15
+//
+data8 0x8000000000000000 , 0x00003FFF
+data8 0x80B1ED4FD999AB6C , 0x00003FFF
+data8 0x8164D1F3BC030773 , 0x00003FFF
+data8 0x8218AF4373FC25EC , 0x00003FFF
+data8 0x82CD8698AC2BA1D7 , 0x00003FFF
+data8 0x8383594EEFB6EE37 , 0x00003FFF
+data8 0x843A28C3ACDE4046 , 0x00003FFF
+data8 0x84F1F656379C1A29 , 0x00003FFF
+data8 0x85AAC367CC487B15 , 0x00003FFF
+data8 0x8664915B923FBA04 , 0x00003FFF
+data8 0x871F61969E8D1010 , 0x00003FFF
+data8 0x87DB357FF698D792 , 0x00003FFF
+data8 0x88980E8092DA8527 , 0x00003FFF
+data8 0x8955EE03618E5FDD , 0x00003FFF
+data8 0x8A14D575496EFD9A , 0x00003FFF
+data8 0x8AD4C6452C728924 , 0x00003FFF
+LOCAL_OBJECT_END(exp_table_1)
+
+// Table 2 is 2^(index_1/8) where
+// index_2 goes from 0 to 7
+LOCAL_OBJECT_START(exp_table_2)
+data8 0x8000000000000000 , 0x00003FFF
+data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
+data8 0x9837F0518DB8A96F , 0x00003FFF
+data8 0xA5FED6A9B15138EA , 0x00003FFF
+data8 0xB504F333F9DE6484 , 0x00003FFF
+data8 0xC5672A115506DADD , 0x00003FFF
+data8 0xD744FCCAD69D6AF4 , 0x00003FFF
+data8 0xEAC0C6E7DD24392F , 0x00003FFF
+LOCAL_OBJECT_END(exp_table_2)
+
+
+LOCAL_OBJECT_START(exp_p_table)
+data8 0x3f8111116da21757 //P5
+data8 0x3fa55555d787761c //P4
+data8 0x3fc5555555555414 //P3
+data8 0x3fdffffffffffd6a //P2
+LOCAL_OBJECT_END(exp_p_table)
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(exp)
+
+{ .mlx
+      nop.m           0
+      movl            rSig_inv_ln2 = 0xb8aa3b295c17f0bc  // significand of 1/ln2
+}
+{ .mlx
+      addl            rAD_TB1    = @ltoff(exp_table_1), gp
+      movl            rRshf_2to56 = 0x4768000000000000   // 1.10000 2^(63+56)
+}
+;;
+
+{ .mfi
+      ld8             rAD_TB1    = [rAD_TB1]
+      fclass.m        p8,p0 = f8,0x07  // Test for x=0
+      mov             rExp_mask = 0x1ffff
+}
+{ .mfi
+      mov             rExp_bias = 0xffff
+      fnorm.s1        fNormX   = f8
+      mov             rExp_2tom56 = 0xffff-56
+}
+;;
+
+// Form two constants we need
+//  1/ln2 * 2^63  to compute  w = x * 1/ln2 * 128
+//  1.1000..000 * 2^(63+63-7) to right shift int(w) into the significand
+
+{ .mfi
+      setf.sig        fINV_LN2_2TO63 = rSig_inv_ln2 // form 1/ln2 * 2^63
+      fclass.m        p9,p0 = f8,0x22  // Test for x=-inf
+      nop.i           0
+}
+{ .mlx
+      setf.d          fRSHF_2TO56 = rRshf_2to56 // Form const 1.100 * 2^(63+56)
+      movl            rRshf = 0x43e8000000000000 // 1.10000 2^63 for right shift
+}
+;;
+
+{ .mfi
+      ldfpd           fMIN_DBL_OFLOW_ARG, fMAX_DBL_ZERO_ARG = [rAD_TB1],16
+      fclass.m        p10,p0 = f8,0x1e1  // Test for x=+inf, nan, NaT
+      nop.i           0
+}
+{ .mfb
+      setf.exp        f2TOM56 = rExp_2tom56 // form 2^-56 for scaling Nfloat
+(p9)  fma.d.s0        f8 = f0,f0,f0           // quick exit for x=-inf
+(p9)  br.ret.spnt     b0
+}
+;;
+
+{ .mfi
+      ldfpd           fMAX_DBL_NORM_ARG, fMIN_DBL_NORM_ARG = [rAD_TB1],16
+      nop.f           0
+      nop.i           0
+}
+{ .mfb
+      setf.d          fRSHF = rRshf // Form right shift const 1.100 * 2^63
+(p8)  fma.d.s0        f8 = f1,f1,f0           // quick exit for x=0
+(p8)  br.ret.spnt     b0
+}
+;;
+
+{ .mfb
+      ldfe            fLn2_by_128_hi  = [rAD_TB1],16
+(p10) fma.d.s0        f8 = f8,f8,f0  // Result if x=+inf, nan, NaT
+(p10) br.ret.spnt     b0               // quick exit for x=+inf, nan, NaT
+}
+;;
+
+{ .mfi
+      ldfe            fLn2_by_128_lo  = [rAD_TB1],16
+      fcmp.eq.s0      p6,p0 = f8, f0       // Dummy to set D
+      nop.i           0
+}
+;;
+
+// After that last load, rAD_TB1 points to the beginning of table 1
+
+// W = X * Inv_log2_by_128
+// By adding 1.10...0*2^63 we shift and get round_int(W) in significand.
+// We actually add 1.10...0*2^56 to X * Inv_log2 to do the same thing.
+
+{ .mfi
+      nop.m           0
+      fma.s1          fW_2TO56_RSH  = fNormX, fINV_LN2_2TO63, fRSHF_2TO56
+      nop.i           0
+}
+;;
+
+// Divide arguments into the following categories:
+//  Certain Underflow       p11 - -inf < x <= MAX_DBL_ZERO_ARG
+//  Possible Underflow      p13 - MAX_DBL_ZERO_ARG < x < MIN_DBL_NORM_ARG
+//  Certain Safe                - MIN_DBL_NORM_ARG <= x <= MAX_DBL_NORM_ARG
+//  Possible Overflow       p14 - MAX_DBL_NORM_ARG < x < MIN_DBL_OFLOW_ARG
+//  Certain Overflow        p15 - MIN_DBL_OFLOW_ARG <= x < +inf
+//
+// If the input is really a double arg, then there will never be
+// "Possible Overflow" arguments.
+//
+
+{ .mfi
+      add             rAD_TB2 = 0x100, rAD_TB1
+      fcmp.ge.s1      p15,p0 = fNormX,fMIN_DBL_OFLOW_ARG
+      nop.i           0
+}
+;;
+
+{ .mfi
+      add             rAD_P = 0x80, rAD_TB2
+      fcmp.le.s1      p11,p0 = fNormX,fMAX_DBL_ZERO_ARG
+      nop.i           0
+}
+;;
+
+{ .mfb
+      ldfpd           fP5, fP4  = [rAD_P] ,16
+      fcmp.gt.s1      p14,p0 = fNormX,fMAX_DBL_NORM_ARG
+(p15) br.cond.spnt    EXP_CERTAIN_OVERFLOW
+}
+;;
+
+// Nfloat = round_int(W)
+// The signficand of fW_2TO56_RSH contains the rounded integer part of W,
+// as a twos complement number in the lower bits (that is, it may be negative).
+// That twos complement number (called N) is put into rN.
+
+// Since fW_2TO56_RSH is scaled by 2^56, it must be multiplied by 2^-56
+// before the shift constant 1.10000 * 2^63 is subtracted to yield fNfloat.
+// Thus, fNfloat contains the floating point version of N
+
+{ .mfb
+      ldfpd           fP3, fP2  = [rAD_P]
+      fms.s1          fNfloat = fW_2TO56_RSH, f2TOM56, fRSHF
+(p11) br.cond.spnt    EXP_CERTAIN_UNDERFLOW
+}
+;;
+
+{ .mfi
+      getf.sig        rN        = fW_2TO56_RSH
+      nop.f           0
+      nop.i           0
+}
+;;
+
+// rIndex_1 has index_1
+// rIndex_2_16 has index_2 * 16
+// rBiased_M has M
+// rIndex_1_16 has index_1 * 16
+
+// rM has true M
+// r = x - Nfloat * ln2_by_128_hi
+// f = 1 - Nfloat * ln2_by_128_lo
+{ .mfi
+      and             rIndex_1 = 0x0f, rN
+      fnma.s1         fR   = fNfloat, fLn2_by_128_hi, fNormX
+      shr             rM = rN,  0x7
+}
+{ .mfi
+      and             rIndex_2_16 = 0x70, rN
+      fnma.s1         fF   = fNfloat, fLn2_by_128_lo, f1
+      nop.i           0
+}
+;;
+
+// rAD_T1 has address of T1
+// rAD_T2 has address if T2
+
+{ .mmi
+      add             rBiased_M = rExp_bias, rM
+      add             rAD_T2 = rAD_TB2, rIndex_2_16
+      shladd          rAD_T1 = rIndex_1, 4, rAD_TB1
+}
+;;
+
+// Create Scale = 2^M
+{ .mmi
+      setf.exp        f2M = rBiased_M
+      ldfe            fT2  = [rAD_T2]
+      nop.i           0
+}
+;;
+
+// Load T1 and T2
+{ .mfi
+      ldfe            fT1  = [rAD_T1]
+      fmpy.s0         fTmp = fLn2_by_128_lo, fLn2_by_128_lo // Force inexact
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fRsq = fR, fR, f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fP54 = fR, fP5, fP4
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.lt.s1      p13,p0 = fNormX,fMIN_DBL_NORM_ARG
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fP32 = fR, fP3, fP2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fP5432  = fRsq, fP54, fP32
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fS1  = f2M,fT1,f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fS2  = fF,fT2,f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fP     = fRsq, fP5432, fR
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fS   = fS1,fS2,f0
+      nop.i           0
+}
+;;
+
+{ .mbb
+      nop.m           0
+(p13) br.cond.spnt    EXP_POSSIBLE_UNDERFLOW
+(p14) br.cond.spnt    EXP_POSSIBLE_OVERFLOW
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fma.d.s0        f8 = fS, fP, fS
+      br.ret.sptk     b0                  // Normal path exit
+}
+;;
+
+
+EXP_POSSIBLE_OVERFLOW:
+
+// Here if fMAX_DBL_NORM_ARG < x < fMIN_DBL_OFLOW_ARG
+// This cannot happen if input is a double, only if input higher precision.
+// Overflow is a possibility, not a certainty.
+
+// Recompute result using status field 2 with user's rounding mode,
+// and wre set.  If result is larger than largest double, then we have
+// overflow
+
+{ .mfi
+      mov             rGt_ln  = 0x103ff // Exponent for largest dbl + 1 ulp
+      fsetc.s2        0x7F,0x42         // Get user's round mode, set wre
+      nop.i           0
+}
+;;
+
+{ .mfi
+      setf.exp        fGt_pln = rGt_ln  // Create largest double + 1 ulp
+      fma.d.s2        fWre_urm_f8 = fS, fP, fS    // Result with wre set
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fsetc.s2        0x7F,0x40                   // Turn off wre in sf2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.ge.s1      p6, p0 =  fWre_urm_f8, fGt_pln // Test for overflow
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      nop.f           0
+(p6)  br.cond.spnt    EXP_CERTAIN_OVERFLOW // Branch if overflow
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fma.d.s0        f8 = fS, fP, fS
+      br.ret.sptk     b0                     // Exit if really no overflow
+}
+;;
+
+EXP_CERTAIN_OVERFLOW:
+{ .mmi
+      sub             rTmp = rExp_mask, r0, 1
+;;
+      setf.exp        fTmp = rTmp
+      nop.i           0
+}
+;;
+
+{ .mfi
+      alloc           r32=ar.pfs,1,4,4,0
+      fmerge.s        FR_X = f8,f8
+      nop.i           0
+}
+{ .mfb
+      mov             GR_Parameter_TAG = 14
+      fma.d.s0        FR_RESULT = fTmp, fTmp, fTmp    // Set I,O and +INF result
+      br.cond.sptk    __libm_error_region
+}
+;;
+
+EXP_POSSIBLE_UNDERFLOW:
+
+// Here if fMAX_DBL_ZERO_ARG < x < fMIN_DBL_NORM_ARG
+// Underflow is a possibility, not a certainty
+
+// We define an underflow when the answer with
+//    ftz set
+// is zero (tiny numbers become zero)
+
+// Notice (from below) that if we have an unlimited exponent range,
+// then there is an extra machine number E between the largest denormal and
+// the smallest normal.
+
+// So if with unbounded exponent we round to E or below, then we are
+// tiny and underflow has occurred.
+
+// But notice that you can be in a situation where we are tiny, namely
+// rounded to E, but when the exponent is bounded we round to smallest
+// normal. So the answer can be the smallest normal with underflow.
+
+//                           E
+// -----+--------------------+--------------------+-----
+//      |                    |                    |
+//   1.1...10 2^-3fff    1.1...11 2^-3fff    1.0...00 2^-3ffe
+//   0.1...11 2^-3ffe                                   (biased, 1)
+//    largest dn                               smallest normal
+
+{ .mfi
+      nop.m           0
+      fsetc.s2        0x7F,0x41                // Get user's round mode, set ftz
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.d.s2        fFtz_urm_f8 = fS, fP, fS // Result with ftz set
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fsetc.s2        0x7F,0x40                // Turn off ftz in sf2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.eq.s1      p6, p7 = fFtz_urm_f8, f0 // Test for underflow
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.d.s0        f8 = fS, fP, fS          // Compute result, set I, maybe U
+      nop.i           0
+}
+;;
+
+{ .mbb
+      nop.m           0
+(p6)  br.cond.spnt    EXP_UNDERFLOW_COMMON     // Branch if really underflow
+(p7)  br.ret.sptk     b0                       // Exit if really no underflow
+}
+;;
+
+EXP_CERTAIN_UNDERFLOW:
+// Here if  x < fMAX_DBL_ZERO_ARG
+// Result will be zero (or smallest denorm if round to +inf) with I, U set
+{ .mmi
+      mov             rTmp = 1
+;;
+      setf.exp        fTmp = rTmp               // Form small normal
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fmerge.se       fTmp = fTmp, fLn2_by_128_lo // Small with signif lsb 1
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fma.d.s0        f8 = fTmp, fTmp, f0 // Set I,U, tiny (+0.0) result
+      br.cond.sptk    EXP_UNDERFLOW_COMMON
+}
+;;
+
+EXP_UNDERFLOW_COMMON:
+// Determine if underflow result is zero or nonzero
+{ .mfi
+      alloc           r32=ar.pfs,1,4,4,0
+      fcmp.eq.s1      p6, p0 =  f8, f0
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fmerge.s        FR_X = fNormX,fNormX
+(p6)  br.cond.spnt    EXP_UNDERFLOW_ZERO
+}
+;;
+
+EXP_UNDERFLOW_NONZERO:
+// Here if  x < fMIN_DBL_NORM_ARG and result nonzero;
+// I, U are set
+{ .mfb
+      mov             GR_Parameter_TAG = 15
+      nop.f           0                         // FR_RESULT already set
+      br.cond.sptk    __libm_error_region
+}
+;;
+
+EXP_UNDERFLOW_ZERO:
+// Here if x < fMIN_DBL_NORM_ARG and result zero;
+// I, U are set
+{ .mfb
+      mov             GR_Parameter_TAG = 15
+      nop.f           0                         // FR_RESULT already set
+      br.cond.sptk    __libm_error_region
+}
+;;
+
+GLOBAL_IEEE754_END(exp)
+libm_alias_double_other (__exp, exp)
+#ifdef SHARED
+.symver exp,exp@@GLIBC_2.29
+.weak __exp_compat
+.set __exp_compat,__exp
+.symver __exp_compat,exp@GLIBC_2.2
+#endif
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfd [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfd [GR_Parameter_X] = FR_X            // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+	nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = FR_RESULT       // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_exp10.S
@@ -0,0 +1,609 @@
+.file "exp10.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 08/25/00 Initial version
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 09/06/02 Improved performance; no inexact flags on exact cases
+// 01/29/03 Added missing } to bundle templates
+// 12/16/04 Call error handling on underflow.
+// 03/31/05 Reformatted delimiters between data tables
+//
+// API
+//==============================================================
+// double exp10(double)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// Let x= (K + fh + fl + r)/log2(10), where
+// K is an integer, fh= 0.b1 b2 b3 b4 b5,
+// fl= 2^{-5}* 0.b6 b7 b8 b8 b10 (fh, fl >= 0),
+// and |r|<2^{-11}
+// Th is a table that stores 2^fh (32 entries) rounded to
+// double extended precision (only mantissa is stored)
+// Tl is a table that stores 2^fl (32 entries) rounded to
+// double extended precision (only mantissa is stored)
+//
+// 10^x is approximated as
+// 2^K * Th [ f ] * Tl [ f ] * (1+c1*e+c1*r+c2*r^2+c3*r^3+c4*r^4),
+// where e= (x*log2(10)_hi-RN(x*log2(10)_hi))+log2(10)_lo*x
+
+// Note there are only 22 non-zero values that produce an exact result:
+//  1.0, 2.0, ... 22.0.
+// We test for these cases and use s1 to avoid setting the inexact flag.
+
+// Special values
+//==============================================================
+// exp10(0)= 1
+// exp10(+inf)= inf
+// exp10(-inf)= 0
+//
+
+// Registers used
+//==============================================================
+// r2-r3, r14-r40
+// f6-f15, f32-f52
+// p6-p12
+//
+
+#include <shlib-compat.h>
+
+
+GR_TBL_START        = r2
+GR_LOG_TBL          = r3
+
+GR_OF_LIMIT         = r14
+GR_UF_LIMIT         = r15
+GR_EXP_CORR         = r16
+GR_F_low            = r17
+GR_F_high           = r18
+GR_K                = r19
+GR_Flow_ADDR        = r20
+
+GR_BIAS             = r21
+GR_Fh               = r22
+GR_Fh_ADDR          = r23
+GR_EXPMAX           = r24
+GR_BIAS53           = r25
+
+GR_ROUNDVAL         = r26
+GR_SNORM_LIMIT      = r26
+GR_MASK             = r27
+GR_KF0              = r28
+GR_MASK_low         = r29
+GR_COEFF_START      = r30
+GR_exact_limit      = r31
+
+GR_SAVE_B0          = r33
+GR_SAVE_PFS         = r34
+GR_SAVE_GP          = r35
+GR_SAVE_SP          = r36
+
+GR_Parameter_X      = r37
+GR_Parameter_Y      = r38
+GR_Parameter_RESULT = r39
+GR_Parameter_TAG    = r40
+
+
+FR_X                = f10
+FR_Y                = f1
+FR_RESULT           = f8
+
+
+FR_COEFF1           = f6
+FR_COEFF2           = f7
+FR_R                = f9
+FR_LOG2_10          = f10
+
+FR_2P53             = f11
+FR_KF0              = f12
+FR_COEFF3           = f13
+FR_COEFF4           = f14
+FR_UF_LIMIT         = f15
+
+FR_OF_LIMIT         = f32
+FR_DX_L210          = f33
+FR_ROUNDVAL         = f34
+FR_KF               = f35
+
+FR_2_TO_K           = f36
+FR_T_low            = f37
+FR_T_high           = f38
+FR_P34              = f39
+FR_R2               = f40
+
+FR_P12              = f41
+FR_T_low_K          = f42
+FR_P14              = f43
+FR_T                = f44
+FR_P                = f45
+
+FR_L2_10_low        = f46
+FR_L2_10_high       = f47
+FR_E0               = f48
+FR_E                = f49
+FR_exact_limit      = f50
+
+FR_int_x            = f51
+FR_SNORM_LIMIT      = f52
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+
+data8 0xd49a784bcd1b8afe, 0x00003fcb // log2(10)*2^(10-63)
+data8 0x9257edfe9b5fb698, 0x3fbf // log2(10)_low (bits 64...127)
+data8 0x3fac6b08d704a0c0, 0x3f83b2ab6fba4e77 // C_3 and C_4
+data8 0xb17217f7d1cf79ab, 0x00003ffe // C_1
+data8 0xf5fdeffc162c7541, 0x00003ffc // C_2
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+LOCAL_OBJECT_START(T_table)
+
+// 2^{0.00000 b6 b7 b8 b9 b10}
+data8 0x8000000000000000, 0x8016302f17467628
+data8 0x802c6436d0e04f50, 0x80429c17d77c18ed
+data8 0x8058d7d2d5e5f6b0, 0x806f17687707a7af
+data8 0x80855ad965e88b83, 0x809ba2264dada76a
+data8 0x80b1ed4fd999ab6c, 0x80c83c56b50cf77f
+data8 0x80de8f3b8b85a0af, 0x80f4e5ff089f763e
+data8 0x810b40a1d81406d4, 0x81219f24a5baa59d
+data8 0x813801881d886f7b, 0x814e67cceb90502c
+data8 0x8164d1f3bc030773, 0x817b3ffd3b2f2e47
+data8 0x8191b1ea15813bfd, 0x81a827baf7838b78
+data8 0x81bea1708dde6055, 0x81d51f0b8557ec1c
+data8 0x81eba08c8ad4536f, 0x820225f44b55b33b
+data8 0x8218af4373fc25eb, 0x822f3c7ab205c89a
+data8 0x8245cd9ab2cec048, 0x825c62a423d13f0c
+data8 0x8272fb97b2a5894c, 0x828998760d01faf3
+data8 0x82a0393fe0bb0ca8, 0x82b6ddf5dbc35906
+//
+// 2^{0.b1 b2 b3 b4 b5}
+data8 0x8000000000000000, 0x82cd8698ac2ba1d7
+data8 0x85aac367cc487b14, 0x88980e8092da8527
+data8 0x8b95c1e3ea8bd6e6, 0x8ea4398b45cd53c0
+data8 0x91c3d373ab11c336, 0x94f4efa8fef70961
+data8 0x9837f0518db8a96f, 0x9b8d39b9d54e5538
+data8 0x9ef5326091a111ad, 0xa27043030c496818
+data8 0xa5fed6a9b15138ea, 0xa9a15ab4ea7c0ef8
+data8 0xad583eea42a14ac6, 0xb123f581d2ac258f
+data8 0xb504f333f9de6484, 0xb8fbaf4762fb9ee9
+data8 0xbd08a39f580c36be, 0xc12c4cca66709456
+data8 0xc5672a115506dadd, 0xc9b9bd866e2f27a2
+data8 0xce248c151f8480e3, 0xd2a81d91f12ae45a
+data8 0xd744fccad69d6af4, 0xdbfbb797daf23755
+data8 0xe0ccdeec2a94e111, 0xe5b906e77c8348a8
+data8 0xeac0c6e7dd24392e, 0xefe4b99bdcdaf5cb
+data8 0xf5257d152486cc2c, 0xfa83b2db722a033a
+LOCAL_OBJECT_END(T_table)
+
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(exp10)
+
+
+{.mfi
+       alloc r32= ar.pfs, 1, 4, 4, 0
+       // will continue only for non-zero normal/denormal numbers
+       fclass.nm.unc p12, p7= f8, 0x1b
+       mov GR_BIAS53= 0xffff+63-10
+}
+{.mlx
+       // GR_TBL_START= pointer to log2(10), C_1...C_4 followed by T_table
+       addl GR_TBL_START= @ltoff(poly_coeffs), gp
+       movl GR_ROUNDVAL= 0x3fc00000             // 1.5 (SP)
+}
+;;
+
+{.mfi
+       ld8 GR_COEFF_START= [ GR_TBL_START ]     // Load pointer to coeff table
+       fcmp.lt.s1 p6, p8= f8, f0                // X<0 ?
+       nop.i 0
+}
+;;
+
+{.mlx
+       setf.exp FR_2P53= GR_BIAS53              // 2^{63-10}
+       movl GR_UF_LIMIT= 0xc07439b746e36b52     // (-2^10-51) / log2(10)
+}
+{.mlx
+       setf.s FR_ROUNDVAL= GR_ROUNDVAL
+       movl GR_OF_LIMIT= 0x40734413509f79fe     // Overflow threshold
+}
+;;
+
+{.mlx
+       ldfe FR_LOG2_10= [ GR_COEFF_START ], 16  // load log2(10)*2^(10-63)
+       movl GR_SNORM_LIMIT= 0xc0733a7146f72a41  // Smallest normal threshold
+}
+{.mib
+       nop.m 0
+       nop.i 0
+ (p12) br.cond.spnt SPECIAL_exp10               // Branch if nan, inf, zero
+}
+;;
+
+{.mmf
+       ldfe FR_L2_10_low= [ GR_COEFF_START ], 16 // load log2(10)_low
+       setf.d FR_OF_LIMIT= GR_OF_LIMIT           // Set overflow limit
+       fma.s0 f8= f8, f1, f0                     // normalize x
+}
+;;
+
+{.mfi
+       ldfpd FR_COEFF3, FR_COEFF4= [ GR_COEFF_START ], 16 // load C_3, C_4
+ (p8)  fcvt.fx.s1 FR_int_x = f8                   // Convert x to integer
+       nop.i 0
+}
+{.mfi
+       setf.d FR_UF_LIMIT= GR_UF_LIMIT            // Set underflow limit
+       fma.s1 FR_KF0= f8, FR_LOG2_10, FR_ROUNDVAL // y= (x*log2(10)*2^10 +
+                                                  //    1.5*2^63) * 2^(-63)
+       mov GR_EXP_CORR= 0xffff-126
+}
+;;
+
+{.mfi
+       setf.d FR_SNORM_LIMIT= GR_SNORM_LIMIT      // Set smallest normal limit
+       fma.s1 FR_L2_10_high= FR_LOG2_10, FR_2P53, f0 // FR_LOG2_10= log2(10)_hi
+       nop.i 0
+}
+;;
+
+{.mfi
+       ldfe FR_COEFF1= [ GR_COEFF_START ], 16    // load C_1
+       fms.s1 FR_KF= FR_KF0, f1, FR_ROUNDVAL     // (K+f)*2^(10-63)
+       mov GR_MASK= 1023
+}
+;;
+
+{.mfi
+       ldfe FR_COEFF2= [ GR_COEFF_START ], 16    // load C_2
+       fma.s1 FR_LOG2_10= f8, FR_L2_10_high, f0  // y0= x*log2(10)_hi
+       mov GR_MASK_low= 31
+}
+;;
+
+{.mlx
+       getf.sig GR_KF0= FR_KF0                   // (K+f)*2^10= round_to_int(y)
+ (p8)  movl GR_exact_limit= 0x41b00000           // Largest x for exact result,
+                                                 //  +22.0
+}
+;;
+
+{.mfi
+       add GR_LOG_TBL= 256, GR_COEFF_START       // Pointer to high T_table
+       fcmp.gt.s1 p12, p7= f8, FR_OF_LIMIT       // x>overflow threshold ?
+       nop.i 0
+}
+;;
+
+{.mfi
+ (p8)  setf.s FR_exact_limit = GR_exact_limit    // Largest x for exact result
+ (p8)  fcvt.xf FR_int_x = FR_int_x               // Integral part of x
+       shr GR_K= GR_KF0, 10                      // K
+}
+{.mfi
+       and GR_F_high= GR_MASK, GR_KF0            // f_high*32
+       fnma.s1 FR_R= FR_KF, FR_2P53, FR_LOG2_10  // r= x*log2(10)-2^{63-10}*
+                                                 //    [ (K+f)*2^{10-63} ]
+       and GR_F_low= GR_KF0, GR_MASK_low         // f_low
+}
+;;
+
+{.mmi
+       shladd GR_Flow_ADDR= GR_F_low, 3, GR_COEFF_START // address of 2^{f_low}
+       add GR_BIAS= GR_K, GR_EXP_CORR            // K= bias-2*63
+       shr GR_Fh= GR_F_high, 5                   // f_high
+}
+;;
+
+{.mfi
+       setf.exp FR_2_TO_K= GR_BIAS               // 2^{K-126}
+ (p7)  fcmp.lt.s1 p12, p7= f8, FR_UF_LIMIT       // x<underflow threshold ?
+       shladd GR_Fh_ADDR= GR_Fh, 3, GR_LOG_TBL   // address of 2^{f_high}
+}
+{.mfi
+       ldf8 FR_T_low= [ GR_Flow_ADDR ]           // load T_low= 2^{f_low}
+       fms.s1 FR_DX_L210= f8, FR_L2_10_high, FR_LOG2_10 // x*log2(10)_hi-
+                                                 //        RN(x*log2(10)_hi)
+       nop.i 0
+}
+;;
+
+{.mfi
+       ldf8 FR_T_high= [ GR_Fh_ADDR ]            // load T_high= 2^{f_high}
+       fma.s1 FR_P34= FR_COEFF4, FR_R, FR_COEFF3 // P34= C_3+C_4*r
+       nop.i 0
+}
+{.mfb
+       nop.m 0
+       fma.s1 FR_R2= FR_R, FR_R, f0              // r*r
+ (p12) br.cond.spnt OUT_RANGE_exp10
+}
+;;
+
+{.mfi
+       nop.m 0
+       // e= (x*log2(10)_hi-RN(x*log2(10)_hi))+log2(10)_lo*x
+       fma.s1 FR_E0= f8, FR_L2_10_low, FR_DX_L210
+       cmp.eq p7,p9= r0,r0                       // Assume inexact result
+}
+{.mfi
+       nop.m 0
+       fma.s1 FR_P12= FR_COEFF2, FR_R, FR_COEFF1 // P12= C_1+C_2*r
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+ (p8)  fcmp.eq.s1 p9,p7= FR_int_x, f8            // Test x positive integer
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       fma.s1 FR_T_low_K= FR_T_low, FR_2_TO_K, f0 // T= 2^{K-126}*T_low
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fcmp.ge.s1 p11,p0= f8, FR_SNORM_LIMIT      // Test x for normal range
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fma.s1 FR_E= FR_E0, FR_COEFF1, f0          // E= C_1*e
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       fma.s1 FR_P14= FR_R2, FR_P34, FR_P12       // P14= P12+r2*P34
+       nop.i 0
+}
+;;
+
+// If x a positive integer, will it produce an exact result?
+//   p7 result will be inexact
+//   p9 result will be exact
+{.mfi
+       nop.m 0
+ (p9)  fcmp.le.s1 p9,p7= f8, FR_exact_limit       // Test x gives exact result
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       fma.s1 FR_T= FR_T_low_K, FR_T_high, f0     // T= T*T_high
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fma.s1 FR_P= FR_P14, FR_R, FR_E            // P= P14*r+E
+       nop.i 0
+}
+;;
+
+.pred.rel "mutex",p7,p9
+{.mfi
+       nop.m 0
+ (p7)  fma.d.s0 f8= FR_P, FR_T, FR_T              // result= T+T*P, inexact set
+       nop.i 0
+}
+{.mfb
+       nop.m 0
+ (p9)  fma.d.s1 f8= FR_P, FR_T, FR_T              // result= T+T*P, exact use s1
+ (p11) br.ret.sptk b0                             // return, if result normal
+}
+;;
+
+// Here if result in denormal range (and not zero)
+{.mib
+       nop.m 0
+       mov GR_Parameter_TAG= 265
+       br.cond.sptk __libm_error_region           // Branch to error handling
+}
+;;
+
+SPECIAL_exp10:
+{.mfi
+       nop.m 0
+       fclass.m p6, p0= f8, 0x22                  // x= -Infinity ?
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fclass.m p7, p0= f8, 0x21                  // x= +Infinity ?
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fclass.m p8, p0= f8, 0x7                   // x= +/-Zero ?
+       nop.i 0
+}
+{.mfb
+       nop.m 0
+ (p6)  mov f8= f0                                 // exp10(-Infinity)= 0
+ (p6)  br.ret.spnt b0
+}
+;;
+
+{.mfb
+       nop.m 0
+       nop.f 0
+ (p7)  br.ret.spnt b0                             // exp10(+Infinity)= +Infinity
+}
+;;
+
+{.mfb
+       nop.m 0
+ (p8)  mov f8= f1                                 // exp10(+/-0)= 1
+ (p8)  br.ret.spnt b0
+}
+;;
+
+{.mfb
+       nop.m 0
+       fma.d.s0 f8= f8, f1, f0                    // Remaining cases: NaNs
+       br.ret.sptk b0
+}
+;;
+
+
+OUT_RANGE_exp10:
+
+// underflow: p6= 1
+// overflow: p8= 1
+
+.pred.rel "mutex",p6,p8
+{.mmi
+ (p8)  mov GR_EXPMAX= 0x1fffe
+ (p6)  mov GR_EXPMAX= 1
+       nop.i 0
+}
+;;
+
+{.mii
+       setf.exp FR_R= GR_EXPMAX
+ (p8)  mov GR_Parameter_TAG= 166
+ (p6)  mov GR_Parameter_TAG= 265
+}
+;;
+
+{.mfb
+       nop.m 0
+       fma.d.s0 f8= FR_R, FR_R, f0                // Create overflow/underflow
+       br.cond.sptk __libm_error_region           // Branch to error handling
+}
+;;
+
+GLOBAL_IEEE754_END(exp10)
+libm_alias_double_other (__exp10, exp10)
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_27)
+compat_symbol (libm, exp10, pow10, GLIBC_2_2)
+#endif
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+
+.prologue
+{.mfi
+       add GR_Parameter_Y= -32, sp                // Parameter 2 value
+       nop.f 0
+.save ar.pfs, GR_SAVE_PFS
+       mov GR_SAVE_PFS= ar.pfs                    // Save ar.pfs
+}
+
+{.mfi
+.fframe 64
+       add sp= -64, sp                            // Create new stack
+       nop.f 0
+       mov GR_SAVE_GP= gp                         // Save gp
+}
+;;
+
+{.mmi
+       stfd [ GR_Parameter_Y ]= FR_Y, 16          // STORE Parameter 2 on stack
+       add GR_Parameter_X= 16, sp                 // Parameter 1 address
+.save b0, GR_SAVE_B0
+       mov GR_SAVE_B0= b0                         // Save b0
+}
+;;
+
+.body
+{.mib
+       stfd [ GR_Parameter_X ]= FR_X              // STORE Parameter 1 on stack
+       add GR_Parameter_RESULT= 0, GR_Parameter_Y // Parameter 3 address
+       nop.b 0
+}
+{.mib
+       stfd [ GR_Parameter_Y ]= FR_RESULT         // STORE Parameter 3 on stack
+       add GR_Parameter_Y= -16, GR_Parameter_Y
+       br.call.sptk b0= __libm_error_support#    // Call error handling function
+}
+;;
+
+{.mmi
+       add GR_Parameter_RESULT= 48, sp
+       nop.m 0
+       nop.i 0
+}
+;;
+
+{.mmi
+       ldfd f8= [ GR_Parameter_RESULT ]          // Get return result off stack
+.restore sp
+       add sp= 64, sp                            // Restore stack pointer
+       mov b0= GR_SAVE_B0                        // Restore return address
+}
+;;
+
+{.mib
+       mov gp= GR_SAVE_GP                        // Restore gp
+       mov ar.pfs= GR_SAVE_PFS                   // Restore ar.pfs
+       br.ret.sptk b0                            // Return
+}
+;;
+
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type __libm_error_support#, @function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_exp10f.c
@@ -0,0 +1,5 @@
+/* IA64 does not provided the finite symbol alias.  */
+#include <libm-alias-finite.h>
+#undef libm_alias_finite
+#define libm_alias_finite(a, b)
+#include <sysdeps/ieee754/flt-32/e_exp10f.c>
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_exp10l.S
@@ -0,0 +1,814 @@
+.file "exp10l.s"
+
+
+// Copyright (c) 2000 - 2004, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 08/25/00 Initial version
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+// 05/08/03 Reformatted assembly source; corrected overflow result for round to
+//          -inf and round to zero; exact results now don't set inexact flag
+// 12/16/04 Call error handling on underflow.
+//
+// API
+//==============================================================
+// long double exp10l(long double)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// Let x= (K + f + r)/log2(10), where
+// K is an integer, f= 0.b1 b2... b8 (f>= 0),
+// and |r|<2^{-9}
+// T is a table that stores 2^f (256 entries) rounded to
+// double extended precision (only mantissa is stored)
+// D stores (2^f/T [ f ] - 1), rounded to single precision
+//
+// 10^x is approximated as
+// 2^K * T [ f ] * ((1+c1*r+c2*r^2+...+c6*r^6)*(1+c1*e)+D [ f ] ),
+// where e= log2(10)_lo*x+(log2(10)_hi*x-RN(log2(10)_hi*x))
+//
+
+
+
+// Special values
+//==============================================================
+// exp10(0)= 1
+// exp10(+inf)= inf
+// exp10(-inf)= 0
+//
+
+
+// Registers used
+//==============================================================
+// f6-f15, f32-f63
+// r14-r30, r32-r40
+// p6-p8, p11-p14
+//
+
+#include <shlib-compat.h>
+
+
+       FR_X        = f10
+       FR_Y        = f1
+       FR_RESULT   = f8
+
+       FR_COEFF1   = f6
+       FR_COEFF2   = f7
+       FR_KF0      = f9
+       FR_LOG10    = f10
+       FR_CONST1   = f11
+       FR_XL10     = f12
+       FR_COEFF3   = f13
+       FR_COEFF4   = f14
+       FR_UF_TEST  = f15
+       FR_OF_TEST  = f32
+       FR_L10_LOW  = f33
+       FR_COEFF5   = f34
+       FR_COEFF6   = f35
+       FR_L10      = f36
+       FR_C_L10    = f37
+       FR_XL10_H   = f38
+       FR_XL10_L   = f39
+       FR_KF       = f40
+       FR_E        = f41
+       FR_T        = f42
+       FR_D        = f43
+       FR_EXP_M_63 = f44
+       FR_R        = f45
+       FR_E1       = f46
+       FR_COEFF2   = f47
+       FR_P34      = f48
+       FR_P56      = f49
+       FR_R2       = f50
+       FR_RE       = f51
+       FR_D1       = f52
+       FR_P36      = f53
+       FR_R3E      = f54
+       FR_P1       = f55
+       FR_P        = f56
+       FR_T1       = f57
+       FR_XINT     = f58
+       FR_XINTF    = f59
+       FR_4        = f60
+       FR_28       = f61
+       FR_32       = f62
+       FR_SNORM_LIMIT = f63
+
+
+       GR_ADDR0    = r14
+       GR_D_ADDR   = r15
+       GR_ADDR     = r16
+       GR_B63      = r17
+       GR_KBITS    = r18
+       GR_F        = r19
+       GR_K        = r20
+       GR_D        = r21
+       GR_BM63     = r22
+       GR_T        = r23
+       GR_CONST1   = r24
+       GR_EMIN     = r25
+       GR_CONST2   = r26
+       GR_BM8      = r27
+       GR_SREG     = r28
+       GR_4_BIAS   = r29
+       GR_32_BIAS  = r30
+
+       GR_SAVE_B0  = r33
+       GR_SAVE_PFS = r34
+       GR_SAVE_GP  = r35
+       GR_SAVE_SP  = r36
+
+       GR_Parameter_X     = r37
+       GR_Parameter_Y     = r38
+       GR_Parameter_RESULT= r39
+       GR_Parameter_TAG   = r40
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+
+       data8 0xd49a784bcd1b8afe, 0x00004008 // log2(10)*2^8
+       data8 0x9a209a84fbcff798, 0x0000400b // overflow threshold
+       data8 0xb17217f7d1cf79ab, 0x00003ffe // C_1
+       data8 0xf5fdeffc162c7541, 0x00003ffc // C_2
+       data8 0x3fac6b08d704a0c0 // C_3
+       data8 0x3f83b2ab6fba4e77 // C_4
+       data8 0x3f55d87fe78a6731 // C_5
+       data8 0x3f2430912f86c787 // C_6
+       data8 0x9257edfe9b5fb698, 0x00003fbf // log2(10)_low (bits 64...127)
+       data8 0x9a1bc98027a81918, 0x0000c00b // Smallest normal threshold
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+LOCAL_OBJECT_START(T_table)
+
+       // 2^{0.b1 b2 b3 b4 b5 b6 b7 b8}
+       data8 0x8000000000000000, 0x8058d7d2d5e5f6b1
+       data8 0x80b1ed4fd999ab6c, 0x810b40a1d81406d4
+       data8 0x8164d1f3bc030773, 0x81bea1708dde6056
+       data8 0x8218af4373fc25ec, 0x8272fb97b2a5894c
+       data8 0x82cd8698ac2ba1d7, 0x83285071e0fc4547
+       data8 0x8383594eefb6ee37, 0x83dea15b9541b132
+       data8 0x843a28c3acde4046, 0x8495efb3303efd30
+       data8 0x84f1f656379c1a29, 0x854e3cd8f9c8c95d
+       data8 0x85aac367cc487b15, 0x86078a2f23642a9f
+       data8 0x8664915b923fba04, 0x86c1d919caef5c88
+       data8 0x871f61969e8d1010, 0x877d2afefd4e256c
+       data8 0x87db357ff698d792, 0x88398146b919f1d4
+       data8 0x88980e8092da8527, 0x88f6dd5af155ac6b
+       data8 0x8955ee03618e5fdd, 0x89b540a7902557a4
+       data8 0x8a14d575496efd9a, 0x8a74ac9a79896e47
+       data8 0x8ad4c6452c728924, 0x8b3522a38e1e1032
+       data8 0x8b95c1e3ea8bd6e7, 0x8bf6a434adde0085
+       data8 0x8c57c9c4646f4dde, 0x8cb932c1bae97a95
+       data8 0x8d1adf5b7e5ba9e6, 0x8d7ccfc09c50e2f8
+       data8 0x8ddf042022e69cd6, 0x8e417ca940e35a01
+       data8 0x8ea4398b45cd53c0, 0x8f073af5a2013520
+       data8 0x8f6a8117e6c8e5c4, 0x8fce0c21c6726481
+       data8 0x9031dc431466b1dc, 0x9095f1abc540ca6b
+       data8 0x90fa4c8beee4b12b, 0x915eed13c89689d3
+       data8 0x91c3d373ab11c336, 0x9228ffdc10a051ad
+       data8 0x928e727d9531f9ac, 0x92f42b88f673aa7c
+       data8 0x935a2b2f13e6e92c, 0x93c071a0eef94bc1
+       data8 0x9426ff0fab1c04b6, 0x948dd3ac8ddb7ed3
+       data8 0x94f4efa8fef70961, 0x955c5336887894d5
+       data8 0x95c3fe86d6cc7fef, 0x962bf1cbb8d97560
+       data8 0x96942d3720185a00, 0x96fcb0fb20ac4ba3
+       data8 0x97657d49f17ab08e, 0x97ce9255ec4357ab
+       data8 0x9837f0518db8a96f, 0x98a1976f7597e996
+       data8 0x990b87e266c189aa, 0x9975c1dd47518c77
+       data8 0x99e0459320b7fa65, 0x9a4b13371fd166ca
+       data8 0x9ab62afc94ff864a, 0x9b218d16f441d63d
+       data8 0x9b8d39b9d54e5539, 0x9bf93118f3aa4cc1
+       data8 0x9c6573682ec32c2d, 0x9cd200db8a0774cb
+       data8 0x9d3ed9a72cffb751, 0x9dabfdff6367a2aa
+       data8 0x9e196e189d472420, 0x9e872a276f0b98ff
+       data8 0x9ef5326091a111ae, 0x9f6386f8e28ba651
+       data8 0x9fd228256400dd06, 0xa041161b3d0121be
+       data8 0xa0b0510fb9714fc2, 0xa11fd9384a344cf7
+       data8 0xa18faeca8544b6e4, 0xa1ffd1fc25cea188
+       data8 0xa27043030c496819, 0xa2e102153e918f9e
+       data8 0xa3520f68e802bb93, 0xa3c36b345991b47c
+       data8 0xa43515ae09e6809e, 0xa4a70f0c95768ec5
+       data8 0xa5195786be9ef339, 0xa58bef536dbeb6ee
+       data8 0xa5fed6a9b15138ea, 0xa6720dc0be08a20c
+       data8 0xa6e594cfeee86b1e, 0xa7596c0ec55ff55b
+       data8 0xa7cd93b4e965356a, 0xa8420bfa298f70d1
+       data8 0xa8b6d5167b320e09, 0xa92bef41fa77771b
+       data8 0xa9a15ab4ea7c0ef8, 0xaa1717a7b5693979
+       data8 0xaa8d2652ec907629, 0xab0386ef48868de1
+       data8 0xab7a39b5a93ed337, 0xabf13edf162675e9
+       data8 0xac6896a4be3fe929, 0xace0413ff83e5d04
+       data8 0xad583eea42a14ac6, 0xadd08fdd43d01491
+       data8 0xae493452ca35b80e, 0xaec22c84cc5c9465
+       data8 0xaf3b78ad690a4375, 0xafb51906e75b8661
+       data8 0xb02f0dcbb6e04584, 0xb0a957366fb7a3c9
+       data8 0xb123f581d2ac2590, 0xb19ee8e8c94feb09
+       data8 0xb21a31a66618fe3b, 0xb295cff5e47db4a4
+       data8 0xb311c412a9112489, 0xb38e0e38419fae18
+       data8 0xb40aaea2654b9841, 0xb487a58cf4a9c180
+       data8 0xb504f333f9de6484, 0xb58297d3a8b9f0d2
+       data8 0xb60093a85ed5f76c, 0xb67ee6eea3b22b8f
+       data8 0xb6fd91e328d17791, 0xb77c94c2c9d725e9
+       data8 0xb7fbefca8ca41e7c, 0xb87ba337a1743834
+       data8 0xb8fbaf4762fb9ee9, 0xb97c143756844dbf
+       data8 0xb9fcd2452c0b9deb, 0xba7de9aebe5fea09
+       data8 0xbaff5ab2133e45fb, 0xbb81258d5b704b6f
+       data8 0xbc034a7ef2e9fb0d, 0xbc85c9c560e7b269
+       data8 0xbd08a39f580c36bf, 0xbd8bd84bb67ed483
+       data8 0xbe0f6809860993e2, 0xbe935317fc378238
+       data8 0xbf1799b67a731083, 0xbf9c3c248e2486f8
+       data8 0xc0213aa1f0d08db0, 0xc0a6956e8836ca8d
+       data8 0xc12c4cca66709456, 0xc1b260f5ca0fbb33
+       data8 0xc238d2311e3d6673, 0xc2bfa0bcfad907c9
+       data8 0xc346ccda24976407, 0xc3ce56c98d21b15d
+       data8 0xc4563ecc5334cb33, 0xc4de8523c2c07baa
+       data8 0xc5672a115506dadd, 0xc5f02dd6b0bbc3d9
+       data8 0xc67990b5aa245f79, 0xc70352f04336c51e
+       data8 0xc78d74c8abb9b15d, 0xc817f681416452b2
+       data8 0xc8a2d85c8ffe2c45, 0xc92e1a9d517f0ecc
+       data8 0xc9b9bd866e2f27a3, 0xca45c15afcc72624
+       data8 0xcad2265e4290774e, 0xcb5eecd3b38597c9
+       data8 0xcbec14fef2727c5d, 0xcc799f23d11510e5
+       data8 0xcd078b86503dcdd2, 0xcd95da6a9ff06445
+       data8 0xce248c151f8480e4, 0xceb3a0ca5dc6a55d
+       data8 0xcf4318cf191918c1, 0xcfd2f4683f94eeb5
+       data8 0xd06333daef2b2595, 0xd0f3d76c75c5db8d
+       data8 0xd184df6251699ac6, 0xd2164c023056bcab
+       data8 0xd2a81d91f12ae45a, 0xd33a5457a3029054
+       data8 0xd3ccf099859ac379, 0xd45ff29e0972c561
+       data8 0xd4f35aabcfedfa1f, 0xd5872909ab75d18a
+       data8 0xd61b5dfe9f9bce07, 0xd6aff9d1e13ba2fe
+       data8 0xd744fccad69d6af4, 0xd7da67311797f56a
+       data8 0xd870394c6db32c84, 0xd9067364d44a929c
+       data8 0xd99d15c278afd7b6, 0xda3420adba4d8704
+       data8 0xdacb946f2ac9cc72, 0xdb63714f8e295255
+       data8 0xdbfbb797daf23755, 0xdc9467913a4f1c92
+       data8 0xdd2d818508324c20, 0xddc705bcd378f7f0
+       data8 0xde60f4825e0e9124, 0xdefb4e1f9d1037f2
+       data8 0xdf9612deb8f04420, 0xe031430a0d99e627
+       data8 0xe0ccdeec2a94e111, 0xe168e6cfd3295d23
+       data8 0xe2055afffe83d369, 0xe2a23bc7d7d91226
+       data8 0xe33f8972be8a5a51, 0xe3dd444c46499619
+       data8 0xe47b6ca0373da88d, 0xe51a02ba8e26d681
+       data8 0xe5b906e77c8348a8, 0xe658797368b3a717
+       data8 0xe6f85aaaee1fce22, 0xe798aadadd5b9cbf
+       data8 0xe8396a503c4bdc68, 0xe8da9958464b42ab
+       data8 0xe97c38406c4f8c57, 0xea1e4756550eb27b
+       data8 0xeac0c6e7dd24392f, 0xeb63b74317369840
+       data8 0xec0718b64c1cbddc, 0xecaaeb8ffb03ab41
+       data8 0xed4f301ed9942b84, 0xedf3e6b1d418a491
+       data8 0xee990f980da3025b, 0xef3eab20e032bc6b
+       data8 0xefe4b99bdcdaf5cb, 0xf08b3b58cbe8b76a
+       data8 0xf13230a7ad094509, 0xf1d999d8b7708cc1
+       data8 0xf281773c59ffb13a, 0xf329c9233b6bae9c
+       data8 0xf3d28fde3a641a5b, 0xf47bcbbe6db9fddf
+       data8 0xf5257d152486cc2c, 0xf5cfa433e6537290
+       data8 0xf67a416c733f846e, 0xf7255510c4288239
+       data8 0xf7d0df730ad13bb9, 0xf87ce0e5b2094d9c
+       data8 0xf92959bb5dd4ba74, 0xf9d64a46eb939f35
+       data8 0xfa83b2db722a033a, 0xfb3193cc4227c3f4
+       data8 0xfbdfed6ce5f09c49, 0xfc8ec01121e447bb
+       data8 0xfd3e0c0cf486c175, 0xfdedd1b496a89f35
+       data8 0xfe9e115c7b8f884c, 0xff4ecb59511ec8a5
+LOCAL_OBJECT_END(T_table)
+
+
+LOCAL_OBJECT_START(D_table)
+       data4 0x00000000, 0x9f55c08f, 0x1e93ffa3, 0x1dcd43a8
+       data4 0x1f751f79, 0x9f3cdd88, 0x9f43d155, 0x1eda222c
+       data4 0x1ef35513, 0x9f597895, 0x9e698881, 0x1ec71073
+       data4 0x1e50e371, 0x9dc01e19, 0x1de74133, 0x1e2f028c
+       data4 0x9edefb47, 0x1ebbac48, 0x9e8b0330, 0x9e9e9314
+       data4 0x1edc1d11, 0x1f098529, 0x9f52827c, 0x1f50050d
+       data4 0x1f301e8e, 0x1f5b64d1, 0x9f45e3ee, 0x9ef64d6d
+       data4 0x1d6ec5e8, 0x9e61ad9a, 0x1d44ccbb, 0x9e4a8bbb
+       data4 0x9cf11576, 0x9dcce7e7, 0x9d02ac90, 0x1f26ccf0
+       data4 0x9f0877c6, 0x9ddd62ae, 0x9f4b7fc3, 0x1ea8ef6b
+       data4 0x1ea4378d, 0x1ef6fc38, 0x1db99fd9, 0x1f22bf6f
+       data4 0x1f53e172, 0x1e85504a, 0x9f37cc75, 0x1f0c5e17
+       data4 0x1dde8aac, 0x9cb42bb2, 0x1e153cd7, 0x1eb62bba
+       data4 0x9e9b941b, 0x9ea80e3c, 0x1f508823, 0x1ec3fd36
+       data4 0x1e9ffaa1, 0x1e21e2eb, 0x9d948b1d, 0x9e8ac93a
+       data4 0x1ef7ee6f, 0x9e80dda3, 0x1f0814be, 0x1dc5ddfe
+       data4 0x1eedb9d1, 0x9f2aaa26, 0x9ea5b0fc, 0x1edf702e
+       data4 0x9e391201, 0x1f1316bb, 0x1ea27fb7, 0x9e05ed18
+       data4 0x9f199ed2, 0x1ee7fd7c, 0x1f003db6, 0x9eac3793
+       data4 0x9e5b8c10, 0x9f3af17c, 0x1bc9a8be, 0x1ee3c004
+       data4 0x9f19b1b2, 0x9f242ce9, 0x9ce67dd1, 0x9e4f6275
+       data4 0x1e20742c, 0x1eb9328a, 0x9f477153, 0x1d969718
+       data4 0x9f1e6c43, 0x1f2f67f4, 0x9f39c7e4, 0x9e3c4feb
+       data4 0x1da3956b, 0x9e7c685d, 0x1f280911, 0x9f0d8afb
+       data4 0x1e314b40, 0x9eb4f250, 0x9f1a34ad, 0x1ef5d5e7
+       data4 0x9f145496, 0x1e604827, 0x9f1e5195, 0x1e9c1fc0
+       data4 0x1efde521, 0x1e69b385, 0x1f316830, 0x9f244eae
+       data4 0x1f1787ec, 0x9e939971, 0x1f0bb393, 0x9f0511d6
+       data4 0x1ed919de, 0x1d8b7b28, 0x1e5ca4a9, 0x1e7c357b
+       data4 0x9e3ff8e8, 0x1eef53b5, 0x9ed22ed7, 0x1f16659b
+       data4 0x9f2db102, 0x9e2c6a78, 0x1f328d7d, 0x9f2fec3c
+       data4 0x1eb395bd, 0x9f242b84, 0x9e2683e6, 0x1ed71e68
+       data4 0x1efd1df5, 0x9e9eeafd, 0x9ed2249c, 0x1eef129a
+       data4 0x1d1ea44c, 0x9e81f7ff, 0x1eaf77c9, 0x9ee7a285
+       data4 0x1e1864ed, 0x9ee7edbb, 0x9e15a27d, 0x9ae61655
+       data4 0x1f1ff1a2, 0x1da29755, 0x9e5f46fb, 0x1e901236
+       data4 0x9eecfb9b, 0x9f204d2f, 0x1ec64685, 0x9eb809bd
+       data4 0x9e0026c5, 0x1d9f1da1, 0x1f142b49, 0x9f20f22e
+       data4 0x1f24b067, 0x1f185a4c, 0x9f09765c, 0x9ece902f
+       data4 0x1e2ca5db, 0x1e6de464, 0x9f071f67, 0x1f1518c3
+       data4 0x1ea13ded, 0x1f0b8414, 0x1edb6ad4, 0x9e548740
+       data4 0x9ea10efb, 0x1ee48a60, 0x1e7954c5, 0x9edad013
+       data4 0x9f21517d, 0x9e9b6e0c, 0x9ee7f9a6, 0x9ebd4298
+       data4 0x9d65b24e, 0x1eed751f, 0x9f1573ea, 0x9d430377
+       data4 0x9e13fc0c, 0x1e47008a, 0x1e3d5c1d, 0x1ef41a91
+       data4 0x9e4a4ef7, 0x9e952f18, 0x1d620566, 0x1d9b8d33
+       data4 0x1db06247, 0x1e94b31e, 0x1f0730ad, 0x9d79ffb4
+       data4 0x1ed64d51, 0x9e91fd11, 0x9e28d35a, 0x9dea0ed9
+       data4 0x1e891def, 0x9ee28ac0, 0x1e1db99b, 0x9ee1ce38
+       data4 0x9bdd9bca, 0x1eb72cb9, 0x9e8c53c6, 0x1e0df6ca
+       data4 0x1e8f2ccd, 0x9e9b0886, 0x1eeb3bc7, 0x1ec7e772
+       data4 0x9e210776, 0x9daf246c, 0x1ea1f151, 0x1ece4dc6
+       data4 0x1ce741c8, 0x1ed3c88f, 0x9ec9a4fd, 0x9e0c8d30
+       data4 0x1d2fbb26, 0x9ef212a7, 0x1ee44f1c, 0x9e445550
+       data4 0x1e075f77, 0x9d9291a3, 0x1f09c2ee, 0x9e012c88
+       data4 0x1f057d62, 0x9e7bb0dc, 0x9d8758ee, 0x1ee8d6c1
+       data4 0x9e509a57, 0x9e4ca7b7, 0x1e2cb341, 0x9ec35106
+       data4 0x1ecf3baf, 0x1e11781c, 0x1ea0cc78, 0x1eb75ca6
+       data4 0x1e961e1a, 0x1eb88853, 0x1e7abf50, 0x1ee38704
+       data4 0x9dc5ab0f, 0x1afe197b, 0x9ec07523, 0x9d9b7f78
+       data4 0x1f011618, 0x1ed43b0b, 0x9f035945, 0x9e3fd014
+       data4 0x9bbda5cd, 0x9e83f8ab, 0x1e58a928, 0x1e392d61
+       data4 0x1efdbb52, 0x1ee310a8, 0x9ec7ecc1, 0x1e8c9ed6
+       data4 0x9ef82dee, 0x9e70545b, 0x9ea53fc4, 0x1e40f419
+LOCAL_OBJECT_END(D_table)
+
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(exp10l)
+
+{.mfi
+       alloc GR_SREG = ar.pfs, 1, 4, 4, 0
+       // will continue only for normal/denormal numbers
+       fclass.nm.unc p12, p7 = f8, 0x1b
+       // GR_ADDR0 = pointer to log2(10), C_1...C_6 followed by T_table
+       addl GR_ADDR0 = @ltoff(poly_coeffs), gp ;;
+}
+
+{.mfi
+       // load start address for C_1...C_6 followed by T_table
+       ld8 GR_ADDR0 = [ GR_ADDR0 ]
+       // X<0 ?
+       fcmp.lt.s1 p6, p8 = f8, f0
+       // GR_BM8 = bias-8
+       mov GR_BM8 = 0xffff-8
+}
+{.mlx
+       nop.m 0
+       // GR_EMIN = (-2^14-62)*2^{8}
+       movl GR_EMIN = 0xca807c00 ;;
+}
+
+{.mmb
+       // FR_CONST1 = 2^{-8}
+       setf.exp FR_CONST1 = GR_BM8
+       // load log2(10)*2^8
+       ldfe FR_LOG10 = [ GR_ADDR0 ], 16
+ (p12) br.cond.spnt SPECIAL_EXP10 ;;
+}
+
+{.mmf
+       setf.s FR_UF_TEST = GR_EMIN
+       // load overflow threshold
+       ldfe FR_OF_TEST = [ GR_ADDR0 ], 16
+       // normalize x
+       fma.s0 f8 = f8, f1, f0 ;;
+}
+
+{.mmi
+       // load C_1
+       ldfe FR_COEFF1 = [ GR_ADDR0 ], 16 ;;
+       // load C_2
+       ldfe FR_COEFF2 = [ GR_ADDR0 ], 16
+       nop.i 0 ;;
+}
+
+{.mmf
+       // GR_D_ADDR = pointer to D table
+       add GR_D_ADDR = 2048-64+96+32, GR_ADDR0
+       // load C_3, C_4
+       ldfpd FR_COEFF3, FR_COEFF4 = [ GR_ADDR0 ], 16
+       // y = x*log2(10)*2^8
+       fma.s1 FR_XL10 = f8, FR_LOG10, f0 ;;
+}
+
+{.mfi
+       // load C_5, C_6
+       ldfpd FR_COEFF5, FR_COEFF6 = [ GR_ADDR0 ], 16
+       // get int(x)
+       fcvt.fx.trunc.s1 FR_XINT = f8
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // FR_LOG10 = log2(10)
+       fma.s1 FR_L10 = FR_LOG10, FR_CONST1, f0
+       nop.i 0 ;;
+}
+
+{.mfi
+       // load log2(10)_low
+       ldfe FR_L10_LOW = [ GR_ADDR0 ], 16
+       // y0 = x*log2(10) = x*log2(10)_hi
+       fma.s1 FR_LOG10 = f8, FR_L10, f0
+       mov GR_EMIN = 0xffff-63
+}
+{.mfi
+       mov GR_32_BIAS = 0xffff + 5
+       // (K+f)*2^8 = round_to_int(y)
+       fcvt.fx.s1 FR_KF0 = FR_XL10
+       mov GR_4_BIAS = 0xffff + 2;;
+}
+
+{.mfi
+       // load smallest normal limit
+       ldfe FR_SNORM_LIMIT = [ GR_ADDR0 ], 16
+       // x>overflow threshold ?
+       fcmp.gt.s1 p12, p7 = f8, FR_OF_TEST
+       nop.i 0 ;;
+}
+
+{.mfi
+       setf.exp FR_32 = GR_32_BIAS
+       // x<underflow threshold ?
+  (p7) fcmp.lt.s1 p12, p7 = FR_XL10, FR_UF_TEST
+       nop.i 0 ;;
+}
+
+{.mfi
+       setf.exp FR_4 = GR_4_BIAS
+       fcvt.xf FR_XINTF = FR_XINT
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // FR_L10 = log2(10)_h*x-RN(log2(10)_h*x)
+       fms.s1 FR_L10 = f8, FR_L10, FR_LOG10
+       nop.i 0 ;;
+}
+
+{.mfi
+       getf.sig GR_BM8 = FR_KF0
+       fcvt.xf FR_KF0 = FR_KF0
+       mov GR_CONST2 = 255 ;;
+}
+
+{.mfi
+       // GR_CONST2 = f
+       and GR_CONST2 = GR_CONST2, GR_BM8
+       // FR_L10_LOW = e = log2(10)_l*x+(log2(10)_h*x-RN(log2(10)_h*x))
+       fma.s1 FR_L10_LOW = FR_L10_LOW, f8, FR_L10
+       // GR_BM8 = K
+       shr GR_BM8 = GR_BM8, 8 ;;
+}
+
+{.mmi
+       // address of D
+       shladd GR_D_ADDR = GR_CONST2, 2, GR_D_ADDR
+       // K+ = bias-63
+       add GR_BM8 = GR_BM8, GR_EMIN
+       // address of T
+       shladd GR_ADDR0 = GR_CONST2, 3, GR_ADDR0 ;;
+}
+
+{.mfb
+       // load D
+       ldfs FR_OF_TEST = [ GR_D_ADDR ]
+       // is input an integer ?
+       fcmp.eq.s1 p13, p14 = f8, FR_XINTF
+ (p12) br.cond.spnt OUT_RANGE_EXP10 ;;
+}
+
+{.mmf
+       // load T
+       ldf8 FR_UF_TEST = [ GR_ADDR0 ]
+       // FR_XL10 = 2^{K-63}
+       setf.exp FR_XL10 = GR_BM8
+       // r = x*log2(10)_hi-2^{-10}* [ (K+f)*2^{10} ]
+       fnma.s1 FR_KF0 = FR_KF0, FR_CONST1, FR_LOG10 ;;
+}
+
+{.mfi
+       nop.m 0
+       // get 28.0
+       fms.s1 FR_28 = FR_32, f1, FR_4
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // E = 1+C_1*e
+       fma.s1 FR_L10 = FR_L10_LOW, FR_COEFF1, f1
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // P12 = C_1+C_2*r
+       fma.s1 FR_COEFF2 = FR_COEFF2, FR_KF0, FR_COEFF1
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // P34 = C_3+C_4*r
+       fma.s1 FR_COEFF4 = FR_COEFF4, FR_KF0, FR_COEFF3
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // P56 = C_5+C_6*r
+       fma.s1 FR_COEFF5 = FR_COEFF6, FR_KF0, FR_COEFF5
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // GR_ADDR0 = r*r
+       fma.s1 FR_COEFF3 = FR_KF0, FR_KF0, f0
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // if input is integer, is it positive ?
+ (p13) fcmp.ge.s1 p13, p14 = f8, f0
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // r' = r*E
+       fma.s1 FR_KF0 = FR_KF0, FR_L10, f0
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // D' = D+C_1*e
+       fma.s1 FR_OF_TEST = FR_L10_LOW, FR_COEFF1, FR_OF_TEST
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // test if x >= smallest normal limit
+       fcmp.ge.s1 p11, p0 = f8, FR_SNORM_LIMIT
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // P36 = P34+r2*P56
+       fma.s1 FR_COEFF4 = FR_COEFF5, FR_COEFF3, FR_COEFF4
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // GR_D_ADDR = r'*r2
+       fma.s1 FR_COEFF3 = FR_COEFF3, FR_KF0, f0
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // is input below 28.0 ?
+ (p13) fcmp.lt.s1 p13, p14 = f8, FR_28
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // P' = P12*r'+D'
+       fma.s1 FR_COEFF2 = FR_COEFF2, FR_KF0, FR_OF_TEST
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // P = P'+r3*P36
+       fma.s1 FR_COEFF3 = FR_COEFF3, FR_COEFF4, FR_COEFF2
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // T = 2^{K-63}*T
+       fma.s1 FR_UF_TEST = FR_UF_TEST, FR_XL10, f0
+       nop.i 0 ;;
+}
+
+.pred.rel "mutex",p13,p14
+{.mfi
+       nop.m 0
+ (p13) fma.s1 f8 = FR_COEFF3, FR_UF_TEST, FR_UF_TEST
+       nop.i 0
+}
+{.mfb
+       nop.m 0
+       // result = T+T*P
+ (p14) fma.s0 f8 = FR_COEFF3, FR_UF_TEST, FR_UF_TEST
+       // return
+ (p11) br.ret.sptk b0 ;;                  // return, if result normal
+}
+
+// Here if result in denormal range (and not zero)
+{.mib
+       nop.m 0
+       mov GR_Parameter_TAG= 264
+       br.cond.sptk __libm_error_region           // Branch to error handling
+}
+;;
+
+SPECIAL_EXP10:
+
+{.mfi
+       nop.m 0
+       // x = -Infinity ?
+       fclass.m p6, p0 = f8, 0x22
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // x = +Infinity ?
+       fclass.m p7, p0 = f8, 0x21
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // x = +/-Zero ?
+       fclass.m p8, p0 = f8, 0x7
+       nop.i 0
+}
+{.mfb
+       nop.m 0
+       // exp10(-Infinity) = 0
+  (p6) mov f8 = f0
+  (p6) br.ret.spnt b0 ;;
+}
+
+{.mfb
+       nop.m 0
+       // exp10(+Infinity) = +Infinity
+       nop.f 0
+  (p7) br.ret.spnt b0 ;;
+}
+
+{.mfb
+       nop.m 0
+       // exp10(+/-0) = 1
+  (p8) mov f8 = f1
+  (p8) br.ret.spnt b0 ;;
+}
+
+{.mfb
+       nop.m 0
+       // Remaining cases: NaNs
+       fma.s0 f8 = f8, f1, f0
+       br.ret.sptk b0 ;;
+}
+
+
+OUT_RANGE_EXP10:
+
+// underflow: p6 = 1
+// overflow: p8 = 1
+
+.pred.rel "mutex",p6,p8
+{.mmi
+  (p8) mov GR_CONST1 = 0x1fffe
+  (p6) mov GR_CONST1 = 1
+       nop.i 0
+}
+;;
+
+{.mii
+       setf.exp FR_KF0 = GR_CONST1
+  (p8) mov GR_Parameter_TAG = 165
+  (p6) mov GR_Parameter_TAG = 264
+}
+;;
+
+{.mfb
+       nop.m 999
+       fma.s0 f8 = FR_KF0, FR_KF0, f0             // Create overflow/underflow
+       br.cond.sptk __libm_error_region           // Branch to error handling
+}
+;;
+
+GLOBAL_IEEE754_END(exp10l)
+libm_alias_ldouble_other (__exp10, exp10)
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_27)
+compat_symbol (libm, exp10l, pow10l, GLIBC_2_2)
+#endif
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{.mfi
+       add GR_Parameter_Y = -32, sp // Parameter 2 value
+       nop.f 0
+.save ar.pfs, GR_SAVE_PFS
+       mov GR_SAVE_PFS = ar.pfs // Save ar.pfs
+}
+
+{.mfi
+.fframe 64
+       add sp = -64, sp // Create new stack
+       nop.f 0
+       mov GR_SAVE_GP = gp ;; // Save gp
+}
+
+{.mmi
+       stfe [ GR_Parameter_Y ] = FR_Y, 16 // STORE Parameter 2 on stack
+       add GR_Parameter_X = 16, sp // Parameter 1 address
+.save b0, GR_SAVE_B0
+       mov GR_SAVE_B0 = b0 ;; // Save b0
+}
+
+.body
+{.mib
+       stfe [ GR_Parameter_X ] = FR_X // STORE Parameter 1 on stack
+       add GR_Parameter_RESULT = 0, GR_Parameter_Y // Parameter 3 address
+       nop.b 0
+}
+{.mib
+       stfe [ GR_Parameter_Y ] = FR_RESULT // STORE Parameter 3 on stack
+       add GR_Parameter_Y = -16, GR_Parameter_Y
+       br.call.sptk b0 = __libm_error_support# ;; // Call error handling function
+}
+
+{.mmi
+       add GR_Parameter_RESULT = 48, sp
+       nop.m 0
+       nop.i 0 ;;
+}
+
+{.mmi
+       ldfe f8 = [ GR_Parameter_RESULT ] // Get return result off stack
+.restore sp
+       add sp = 64, sp // Restore stack pointer
+       mov b0 = GR_SAVE_B0 ;; // Restore return address
+}
+
+{.mib
+       mov gp = GR_SAVE_GP // Restore gp
+       mov ar.pfs = GR_SAVE_PFS // Restore ar.pfs
+       br.ret.sptk b0 ;; // Return
+}
+
+
+LOCAL_LIBM_END(__libm_error_region)
+.type __libm_error_support#, @function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_exp2.S
@@ -0,0 +1,570 @@
+.file "exp2.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 08/25/00  Initial version
+// 05/20/02  Cleaned up namespace and sf0 syntax
+// 09/05/02  Improved performance
+// 01/17/03  Fixed to call error support when x=1024.0
+// 03/31/05  Reformatted delimiters between data tables
+//
+// API
+//==============================================================
+// double exp2(double)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// Let x= (K + fh + fl + r), where
+// K is an integer, fh= 0.b1 b2 b3 b4 b5,
+// fl= 2^{-5}* 0.b6 b7 b8 b8 b10 (fh, fl >= 0),
+// and |r|<2^{-11}
+// Th is a table that stores 2^fh (32 entries) rounded to
+// double extended precision (only mantissa is stored)
+// Tl is a table that stores 2^fl (32 entries) rounded to
+// double extended precision (only mantissa is stored)
+//
+// 2^x is approximated as
+// 2^K * Th [ f ] * Tl [ f ] * (1+c1*r+c2*r^2+c3*r^3+c4*r^4)
+
+// Note: We use the following trick to speed up conversion from FP to integer:
+//
+// Let  x = K + r, where K is an integer, and  |r| <= 0.5
+// Let N be the number of significand bits for the FP format used
+//   ( N=64 for double-extended, N=53 for double)
+//
+// Then let y = 1.5 * 2^(N-1)  +  x    for RN mode
+//          K = y -  1.5 * 2^(N-1)
+//          r  = x - K
+//
+// If we want to obtain the integer part and the first m fractional bits of x,
+// we can use the same trick, but with a constant of  1.5 * 2^(N-1-m):
+//
+// Let x = K + f + r
+// f = 0.b_1 b_2 ... b_m
+// |r| <= 2^(-m-1)
+//
+// Then let y = 1.5 * 2^(N-1-m)  +  x    for RN mode
+//          (K+f) = y -  1.5 * 2^(N-1-m)
+//          r  = x - K
+
+
+// Special values
+//==============================================================
+// exp2(0)= 1
+// exp2(+inf)= inf
+// exp2(-inf)= 0
+//
+
+// Registers used
+//==============================================================
+// r2-r3, r14-r40
+// f6-f15, f32-f45
+// p6-p8, p12
+//
+
+
+GR_TBL_START        = r2
+GR_LOG_TBL          = r3
+
+GR_OF_LIMIT         = r14
+GR_UF_LIMIT         = r15
+GR_EXP_CORR         = r16
+GR_F_low            = r17
+GR_F_high           = r18
+GR_K                = r19
+GR_Flow_ADDR        = r20
+
+GR_BIAS             = r21
+GR_Fh               = r22
+GR_Fh_ADDR          = r23
+GR_EXPMAX           = r24
+GR_EMIN             = r25
+
+GR_ROUNDVAL         = r26
+GR_MASK             = r27
+GR_KF0              = r28
+GR_MASK_low         = r29
+GR_COEFF_START      = r30
+
+GR_SAVE_B0          = r33
+GR_SAVE_PFS         = r34
+GR_SAVE_GP          = r35
+GR_SAVE_SP          = r36
+
+GR_Parameter_X      = r37
+GR_Parameter_Y      = r38
+GR_Parameter_RESULT = r39
+GR_Parameter_TAG    = r40
+
+
+FR_X                = f10
+FR_Y                = f1
+FR_RESULT           = f8
+
+
+FR_COEFF1           = f6
+FR_COEFF2           = f7
+FR_R                = f9
+
+FR_KF0              = f12
+FR_COEFF3           = f13
+FR_COEFF4           = f14
+FR_UF_LIMIT         = f15
+
+FR_OF_LIMIT         = f32
+FR_EXPMIN           = f33
+FR_ROUNDVAL         = f34
+FR_KF               = f35
+
+FR_2_TO_K           = f36
+FR_T_low            = f37
+FR_T_high           = f38
+FR_P34              = f39
+FR_R2               = f40
+
+FR_P12              = f41
+FR_T_low_K          = f42
+FR_P14              = f43
+FR_T                = f44
+FR_P                = f45
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+
+data8 0x3fac6b08d704a0c0, 0x3f83b2ab6fba4e77 // C_3 and C_4
+data8 0xb17217f7d1cf79ab, 0x00003ffe // C_1
+data8 0xf5fdeffc162c7541, 0x00003ffc // C_2
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+LOCAL_OBJECT_START(T_table)
+
+// 2^{0.00000 b6 b7 b8 b9 b10}
+data8 0x8000000000000000, 0x8016302f17467628
+data8 0x802c6436d0e04f50, 0x80429c17d77c18ed
+data8 0x8058d7d2d5e5f6b0, 0x806f17687707a7af
+data8 0x80855ad965e88b83, 0x809ba2264dada76a
+data8 0x80b1ed4fd999ab6c, 0x80c83c56b50cf77f
+data8 0x80de8f3b8b85a0af, 0x80f4e5ff089f763e
+data8 0x810b40a1d81406d4, 0x81219f24a5baa59d
+data8 0x813801881d886f7b, 0x814e67cceb90502c
+data8 0x8164d1f3bc030773, 0x817b3ffd3b2f2e47
+data8 0x8191b1ea15813bfd, 0x81a827baf7838b78
+data8 0x81bea1708dde6055, 0x81d51f0b8557ec1c
+data8 0x81eba08c8ad4536f, 0x820225f44b55b33b
+data8 0x8218af4373fc25eb, 0x822f3c7ab205c89a
+data8 0x8245cd9ab2cec048, 0x825c62a423d13f0c
+data8 0x8272fb97b2a5894c, 0x828998760d01faf3
+data8 0x82a0393fe0bb0ca8, 0x82b6ddf5dbc35906
+//
+// 2^{0.b1 b2 b3 b4 b5}
+data8 0x8000000000000000, 0x82cd8698ac2ba1d7
+data8 0x85aac367cc487b14, 0x88980e8092da8527
+data8 0x8b95c1e3ea8bd6e6, 0x8ea4398b45cd53c0
+data8 0x91c3d373ab11c336, 0x94f4efa8fef70961
+data8 0x9837f0518db8a96f, 0x9b8d39b9d54e5538
+data8 0x9ef5326091a111ad, 0xa27043030c496818
+data8 0xa5fed6a9b15138ea, 0xa9a15ab4ea7c0ef8
+data8 0xad583eea42a14ac6, 0xb123f581d2ac258f
+data8 0xb504f333f9de6484, 0xb8fbaf4762fb9ee9
+data8 0xbd08a39f580c36be, 0xc12c4cca66709456
+data8 0xc5672a115506dadd, 0xc9b9bd866e2f27a2
+data8 0xce248c151f8480e3, 0xd2a81d91f12ae45a
+data8 0xd744fccad69d6af4, 0xdbfbb797daf23755
+data8 0xe0ccdeec2a94e111, 0xe5b906e77c8348a8
+data8 0xeac0c6e7dd24392e, 0xefe4b99bdcdaf5cb
+data8 0xf5257d152486cc2c, 0xfa83b2db722a033a
+LOCAL_OBJECT_END(T_table)
+
+
+
+.section .text
+WEAK_LIBM_ENTRY(exp2)
+
+
+{.mfi
+       alloc r32= ar.pfs, 1, 4, 4, 0
+       // will continue only for non-zero normal/denormal numbers
+       fclass.nm p12, p0= f8, 0x1b
+       // GR_TBL_START= pointer to C_1...C_4 followed by T_table
+       addl GR_TBL_START= @ltoff(poly_coeffs), gp
+}
+{.mlx
+       mov GR_OF_LIMIT= 0xffff + 10              // Exponent of overflow limit
+       movl GR_ROUNDVAL= 0x5a400000              // 1.5*2^(63-10) (SP)
+}
+;;
+
+// Form special constant 1.5*2^(63-10) to give integer part and first 10
+// fractional bits of x
+{.mfi
+       setf.s FR_ROUNDVAL= GR_ROUNDVAL           // Form special constant
+       fcmp.lt.s1 p6, p8= f8, f0                 // X<0 ?
+       nop.i 0
+}
+{.mfb
+       ld8 GR_COEFF_START= [ GR_TBL_START ]      // Load pointer to coeff table
+       nop.f 0
+ (p12) br.cond.spnt SPECIAL_exp2                 // Branch if nan, inf, zero
+}
+;;
+
+{.mlx
+       setf.exp FR_OF_LIMIT= GR_OF_LIMIT         // Set overflow limit
+       movl GR_UF_LIMIT= 0xc4866000              // (-2^10-51) = -1075
+}
+;;
+
+{.mfi
+       ldfpd FR_COEFF3, FR_COEFF4= [ GR_COEFF_START ], 16 // load C_3, C_4
+       fma.s0 f8= f8, f1, f0                     // normalize x
+       nop.i 0
+}
+;;
+
+{.mmi
+       setf.s FR_UF_LIMIT= GR_UF_LIMIT           // Set underflow limit
+       ldfe FR_COEFF1= [ GR_COEFF_START ], 16    // load C_1
+       mov GR_EXP_CORR= 0xffff-126
+}
+;;
+
+{.mfi
+       ldfe FR_COEFF2= [ GR_COEFF_START ], 16    // load C_2
+       fma.s1 FR_KF0= f8, f1, FR_ROUNDVAL        // y= x + 1.5*2^(63-10)
+       nop.i 0
+}
+;;
+
+{.mfi
+       mov GR_MASK= 1023
+       fms.s1 FR_KF= FR_KF0, f1, FR_ROUNDVAL     // (K+f)
+       mov GR_MASK_low= 31
+}
+;;
+
+{.mfi
+       getf.sig GR_KF0= FR_KF0                   // (K+f)*2^10= round_to_int(y)
+       fcmp.ge.s1 p12, p7= f8, FR_OF_LIMIT       // x >= overflow threshold ?
+       add GR_LOG_TBL= 256, GR_COEFF_START       // Pointer to high T_table
+}
+;;
+
+{.mmi
+       and GR_F_low= GR_KF0, GR_MASK_low         // f_low
+       and GR_F_high= GR_MASK, GR_KF0            // f_high*32
+       shr GR_K= GR_KF0, 10                      // K
+}
+;;
+
+{.mmi
+       shladd GR_Flow_ADDR= GR_F_low, 3, GR_COEFF_START // address of 2^{f_low}
+       add GR_BIAS= GR_K, GR_EXP_CORR            // K= bias-2*63
+       shr GR_Fh= GR_F_high, 5                   // f_high
+}
+;;
+
+{.mfi
+       setf.exp FR_2_TO_K= GR_BIAS               // 2^{K-126}
+       fnma.s1 FR_R= FR_KF, f1, f8               // r= x - (K+f)
+       shladd GR_Fh_ADDR= GR_Fh, 3, GR_LOG_TBL   // address of 2^{f_high}
+}
+{.mlx
+       ldf8 FR_T_low= [ GR_Flow_ADDR ]           // load T_low= 2^{f_low}
+       movl GR_EMIN= 0xc47f8000                  // EMIN= -1022
+}
+;;
+
+{.mfi
+       ldf8 FR_T_high= [ GR_Fh_ADDR ]            // load T_high= 2^{f_high}
+ (p7)  fcmp.lt.s1 p12, p7= f8, FR_UF_LIMIT       // x<underflow threshold ?
+       nop.i 0
+}
+;;
+
+{.mfi
+       setf.s FR_EXPMIN= GR_EMIN                 // FR_EXPMIN= EMIN
+       fma.s1 FR_P34= FR_COEFF4, FR_R, FR_COEFF3 // P34= C_3+C_4*r
+       nop.i 0
+}
+{.mfb
+       nop.m 0
+       fma.s1 FR_R2= FR_R, FR_R, f0              // r*r
+ (p12) br.cond.spnt OUT_RANGE_exp2
+}
+;;
+
+{.mfi
+       nop.m 0
+       fma.s1 FR_P12= FR_COEFF2, FR_R, FR_COEFF1 // P12= C_1+C_2*r
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fma.s1 FR_T_low_K= FR_T_low, FR_2_TO_K, f0 // T= 2^{K-126}*T_low
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fma.s1 FR_P14= FR_R2, FR_P34, FR_P12       // P14= P12+r2*P34
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fma.s1 FR_T= FR_T_low_K, FR_T_high, f0     // T= T*T_high
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fcmp.lt.s0 p6, p8= f8, FR_EXPMIN           // underflow (x<EMIN) ?
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fma.s1 FR_P= FR_P14, FR_R, f0              // P= P14*r
+       nop.i 0
+}
+;;
+
+{.mfb
+       nop.m 0
+       fma.d.s0 f8= FR_P, FR_T, FR_T              // result= T+T*P
+ (p8)  br.ret.sptk b0                             // return
+}
+;;
+
+{.mfb
+ (p6)  mov GR_Parameter_TAG= 162
+       nop.f 0
+ (p6)  br.cond.sptk __libm_error_region
+}
+;;
+
+
+SPECIAL_exp2:
+{.mfi
+       nop.m 0
+       fclass.m p6, p0= f8, 0x22                  // x= -Infinity ?
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fclass.m p7, p0= f8, 0x21                  // x= +Infinity ?
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fclass.m p8, p0= f8, 0x7                   // x= +/-Zero ?
+       nop.i 0
+}
+{.mfb
+       nop.m 0
+ (p6)  mov f8= f0                                 // exp2(-Infinity)= 0
+ (p6)  br.ret.spnt b0
+}
+;;
+
+{.mfb
+       nop.m 0
+       nop.f 0
+ (p7)  br.ret.spnt b0                             // exp2(+Infinity)= +Infinity
+}
+;;
+
+{.mfb
+       nop.m 0
+ (p8)  mov f8= f1                                 // exp2(+/-0)= 1
+ (p8)  br.ret.spnt b0
+}
+;;
+
+{.mfb
+       nop.m 0
+       fma.d.s0 f8= f8, f1, f0                    // Remaining cases: NaNs
+       br.ret.sptk b0
+}
+;;
+
+
+OUT_RANGE_exp2:
+
+// overflow: p8= 1
+
+{.mii
+ (p8)  mov GR_EXPMAX= 0x1fffe
+       nop.i 0
+       nop.i 0
+}
+;;
+
+{.mmb
+ (p8)  mov GR_Parameter_TAG= 161
+ (p8)  setf.exp FR_R= GR_EXPMAX
+       nop.b 999
+}
+;;
+
+{.mfi
+       nop.m 999
+ (p8)  fma.d.s0 f8= FR_R, FR_R, f0                // Create overflow
+       nop.i 999
+}
+// underflow: p6= 1
+{.mii
+ (p6)  mov GR_Parameter_TAG= 162
+ (p6)  mov GR_EXPMAX= 1
+       nop.i 0
+}
+;;
+
+{.mmb
+       nop.m 0
+ (p6)  setf.exp FR_R= GR_EXPMAX
+       nop.b 999
+}
+;;
+
+{.mfb
+       nop.m 999
+ (p6)  fma.d.s0 f8= FR_R, FR_R, f0                // Create underflow
+       nop.b 0
+}
+;;
+
+WEAK_LIBM_END(exp2)
+libm_alias_double_other (__exp2, exp2)
+#ifdef SHARED
+.symver exp2,exp2@@GLIBC_2.29
+.weak __exp2_compat
+.set __exp2_compat,__exp2
+.symver __exp2_compat,exp2@GLIBC_2.2
+#endif
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+
+.prologue
+{.mfi
+       add GR_Parameter_Y= -32, sp                // Parameter 2 value
+       nop.f 0
+.save ar.pfs, GR_SAVE_PFS
+       mov GR_SAVE_PFS= ar.pfs                    // Save ar.pfs
+}
+
+{.mfi
+.fframe 64
+       add sp= -64, sp                            // Create new stack
+       nop.f 0
+       mov GR_SAVE_GP= gp                         // Save gp
+}
+;;
+
+{.mmi
+       stfd [ GR_Parameter_Y ]= FR_Y, 16          // STORE Parameter 2 on stack
+       add GR_Parameter_X= 16, sp                 // Parameter 1 address
+.save b0, GR_SAVE_B0
+       mov GR_SAVE_B0= b0                         // Save b0
+}
+;;
+
+.body
+{.mib
+       stfd [ GR_Parameter_X ]= FR_X              // STORE Parameter 1 on stack
+       add GR_Parameter_RESULT= 0, GR_Parameter_Y // Parameter 3 address
+       nop.b 0
+}
+{.mib
+       stfd [ GR_Parameter_Y ]= FR_RESULT         // STORE Parameter 3 on stack
+       add GR_Parameter_Y= -16, GR_Parameter_Y
+       br.call.sptk b0= __libm_error_support#    // Call error handling function
+}
+;;
+
+{.mmi
+       add GR_Parameter_RESULT= 48, sp
+       nop.m 0
+       nop.i 0
+}
+;;
+
+{.mmi
+       ldfd f8= [ GR_Parameter_RESULT ]          // Get return result off stack
+.restore sp
+       add sp= 64, sp                            // Restore stack pointer
+       mov b0= GR_SAVE_B0                        // Restore return address
+}
+;;
+
+{.mib
+       mov gp= GR_SAVE_GP                        // Restore gp
+       mov ar.pfs= GR_SAVE_PFS                   // Restore ar.pfs
+       br.ret.sptk b0                            // Return
+}
+;;
+
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type __libm_error_support#, @function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_exp2f.S
@@ -0,0 +1,545 @@
+.file "exp2f.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 08/25/00  Initial version
+// 05/20/02  Cleaned up namespace and sf0 syntax
+// 09/05/02  Improved performance and accuracy
+// 01/17/03  Fixed to call error support when x=128.0
+// 03/31/05  Reformatted delimiters between data tables
+//
+// API
+//==============================================================
+// float exp2f(float)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// Let x= (K + fh + fl + r), where
+// K is an integer, fh= 0.b1 b2 b3 b4 b5,
+// fl= 2^{-5}* 0.b6 b7 b8 b8 b10 (fh, fl >= 0),
+// and |r|<2^{-11}
+// Th is a table that stores 2^fh (32 entries) rounded to
+// double extended precision (only mantissa is stored)
+// Tl is a table that stores 2^fl (32 entries) rounded to
+// double extended precision (only mantissa is stored)
+//
+// 2^x is approximated as
+// 2^K * Th [ f ] * Tl [ f ] * (1+c1*r+c2*r^2)
+
+// Note: We use the following trick to speed up conversion from FP to integer:
+//
+// Let  x = K + r, where K is an integer, and  |r| <= 0.5
+// Let N be the number of significand bits for the FP format used
+//   ( N=64 for double-extended, N=53 for double)
+//
+// Then let y = 1.5 * 2^(N-1)  +  x    for RN mode
+//          K = y -  1.5 * 2^(N-1)
+//          r  = x - K
+//
+// If we want to obtain the integer part and the first m fractional bits of x,
+// we can use the same trick, but with a constant of  1.5 * 2^(N-1-m):
+//
+// Let x = K + f + r
+// f = 0.b_1 b_2 ... b_m
+// |r| <= 2^(-m-1)
+//
+// Then let y = 1.5 * 2^(N-1-m)  +  x    for RN mode
+//          (K+f) = y -  1.5 * 2^(N-1-m)
+//          r  = x - K
+
+
+// Special values
+//==============================================================
+// exp2(0)= 1
+// exp2(+inf)= inf
+// exp2(-inf)= 0
+//
+
+// Registers used
+//==============================================================
+// r2-r3, r14-r40
+// f6-f15, f32-f45
+// p6-p8, p12
+//
+
+
+GR_TBL_START        = r2
+GR_LOG_TBL          = r3
+
+GR_OF_LIMIT         = r14
+GR_UF_LIMIT         = r15
+GR_EXP_CORR         = r16
+GR_F_low            = r17
+GR_F_high           = r18
+GR_K                = r19
+GR_Flow_ADDR        = r20
+
+GR_BIAS             = r21
+GR_Fh               = r22
+GR_Fh_ADDR          = r23
+GR_EXPMAX           = r24
+GR_EMIN             = r25
+
+GR_ROUNDVAL         = r26
+GR_MASK             = r27
+GR_KF0              = r28
+GR_MASK_low         = r29
+GR_COEFF_START      = r30
+
+GR_SAVE_B0          = r33
+GR_SAVE_PFS         = r34
+GR_SAVE_GP          = r35
+GR_SAVE_SP          = r36
+
+GR_Parameter_X      = r37
+GR_Parameter_Y      = r38
+GR_Parameter_RESULT = r39
+GR_Parameter_TAG    = r40
+
+
+FR_X                = f10
+FR_Y                = f1
+FR_RESULT           = f8
+
+
+FR_COEFF1           = f6
+FR_COEFF2           = f7
+FR_R                = f9
+
+FR_KF0              = f12
+FR_UF_LIMIT         = f15
+
+FR_OF_LIMIT         = f32
+FR_EXPMIN           = f33
+FR_ROUNDVAL         = f34
+FR_KF               = f35
+
+FR_2_TO_K           = f36
+FR_T_low            = f37
+FR_T_high           = f38
+
+FR_P12              = f41
+FR_T_low_K          = f42
+FR_T                = f44
+FR_P                = f45
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+
+data8 0xb17217f7d1cf79ab, 0x00003ffe // C_1
+data8 0xf5fdeffc162c7541, 0x00003ffc // C_2
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+LOCAL_OBJECT_START(T_table)
+
+// 2^{0.00000 b6 b7 b8 b9 b10}
+data8 0x8000000000000000, 0x8016302f17467628
+data8 0x802c6436d0e04f50, 0x80429c17d77c18ed
+data8 0x8058d7d2d5e5f6b0, 0x806f17687707a7af
+data8 0x80855ad965e88b83, 0x809ba2264dada76a
+data8 0x80b1ed4fd999ab6c, 0x80c83c56b50cf77f
+data8 0x80de8f3b8b85a0af, 0x80f4e5ff089f763e
+data8 0x810b40a1d81406d4, 0x81219f24a5baa59d
+data8 0x813801881d886f7b, 0x814e67cceb90502c
+data8 0x8164d1f3bc030773, 0x817b3ffd3b2f2e47
+data8 0x8191b1ea15813bfd, 0x81a827baf7838b78
+data8 0x81bea1708dde6055, 0x81d51f0b8557ec1c
+data8 0x81eba08c8ad4536f, 0x820225f44b55b33b
+data8 0x8218af4373fc25eb, 0x822f3c7ab205c89a
+data8 0x8245cd9ab2cec048, 0x825c62a423d13f0c
+data8 0x8272fb97b2a5894c, 0x828998760d01faf3
+data8 0x82a0393fe0bb0ca8, 0x82b6ddf5dbc35906
+//
+// 2^{0.b1 b2 b3 b4 b5}
+data8 0x8000000000000000, 0x82cd8698ac2ba1d7
+data8 0x85aac367cc487b14, 0x88980e8092da8527
+data8 0x8b95c1e3ea8bd6e6, 0x8ea4398b45cd53c0
+data8 0x91c3d373ab11c336, 0x94f4efa8fef70961
+data8 0x9837f0518db8a96f, 0x9b8d39b9d54e5538
+data8 0x9ef5326091a111ad, 0xa27043030c496818
+data8 0xa5fed6a9b15138ea, 0xa9a15ab4ea7c0ef8
+data8 0xad583eea42a14ac6, 0xb123f581d2ac258f
+data8 0xb504f333f9de6484, 0xb8fbaf4762fb9ee9
+data8 0xbd08a39f580c36be, 0xc12c4cca66709456
+data8 0xc5672a115506dadd, 0xc9b9bd866e2f27a2
+data8 0xce248c151f8480e3, 0xd2a81d91f12ae45a
+data8 0xd744fccad69d6af4, 0xdbfbb797daf23755
+data8 0xe0ccdeec2a94e111, 0xe5b906e77c8348a8
+data8 0xeac0c6e7dd24392e, 0xefe4b99bdcdaf5cb
+data8 0xf5257d152486cc2c, 0xfa83b2db722a033a
+LOCAL_OBJECT_END(T_table)
+
+
+
+.section .text
+WEAK_LIBM_ENTRY(exp2f)
+
+
+{.mfi
+       alloc r32= ar.pfs, 1, 4, 4, 0
+       // will continue only for non-zero normal/denormal numbers
+       fclass.nm p12, p0= f8, 0x1b
+       // GR_TBL_START= pointer to C_1...C_2 followed by T_table
+       addl GR_TBL_START= @ltoff(poly_coeffs), gp
+}
+{.mlx
+       mov GR_OF_LIMIT= 0xffff + 7               // Exponent of overflow limit
+       movl GR_ROUNDVAL= 0x5a400000              // 1.5*2^(63-10) (SP)
+}
+;;
+
+// Form special constant 1.5*2^(63-10) to give integer part and first 10
+// fractional bits of x
+{.mfi
+       setf.s FR_ROUNDVAL= GR_ROUNDVAL           // Form special constant
+       fcmp.lt.s1 p6, p8= f8, f0                 // X<0 ?
+       nop.i 0
+}
+{.mfb
+       ld8 GR_COEFF_START= [ GR_TBL_START ]      // Load pointer to coeff table
+       nop.f 0
+ (p12) br.cond.spnt SPECIAL_exp2                 // Branch if nan, inf, zero
+}
+;;
+
+{.mlx
+       setf.exp FR_OF_LIMIT= GR_OF_LIMIT         // Set overflow limit
+       movl GR_UF_LIMIT= 0xc3160000              // (-2^7-22) = -150
+}
+;;
+
+{.mfi
+       ldfe FR_COEFF1= [ GR_COEFF_START ], 16    // load C_1
+       fma.s0 f8= f8, f1, f0                     // normalize x
+       nop.i 0
+}
+;;
+
+{.mmi
+       ldfe FR_COEFF2= [ GR_COEFF_START ], 16    // load C_2
+       setf.s FR_UF_LIMIT= GR_UF_LIMIT           // Set underflow limit
+       mov GR_EXP_CORR= 0xffff-126
+}
+;;
+
+{.mfi
+       nop.m 0
+       fma.s1 FR_KF0= f8, f1, FR_ROUNDVAL        // y= x + 1.5*2^(63-10)
+       nop.i 0
+}
+;;
+
+{.mfi
+       mov GR_MASK= 1023
+       fms.s1 FR_KF= FR_KF0, f1, FR_ROUNDVAL     // (K+f)
+       mov GR_MASK_low= 31
+}
+;;
+
+{.mfi
+       getf.sig GR_KF0= FR_KF0                   // (K+f)*2^10= round_to_int(y)
+       fcmp.ge.s1 p12, p7= f8, FR_OF_LIMIT       // x >= overflow threshold ?
+       add GR_LOG_TBL= 256, GR_COEFF_START       // Pointer to high T_table
+}
+;;
+
+{.mmi
+       and GR_F_low= GR_KF0, GR_MASK_low         // f_low
+       and GR_F_high= GR_MASK, GR_KF0            // f_high*32
+       shr GR_K= GR_KF0, 10                      // K
+}
+;;
+
+{.mmi
+       shladd GR_Flow_ADDR= GR_F_low, 3, GR_COEFF_START // address of 2^{f_low}
+       add GR_BIAS= GR_K, GR_EXP_CORR            // K= bias-2*63
+       shr GR_Fh= GR_F_high, 5                   // f_high
+}
+;;
+
+{.mfi
+       setf.exp FR_2_TO_K= GR_BIAS               // 2^{K-126}
+       fnma.s1 FR_R= FR_KF, f1, f8               // r= x - (K+f)
+       shladd GR_Fh_ADDR= GR_Fh, 3, GR_LOG_TBL   // address of 2^{f_high}
+}
+{.mlx
+       ldf8 FR_T_low= [ GR_Flow_ADDR ]           // load T_low= 2^{f_low}
+       movl GR_EMIN= 0xc2fc0000                  // EMIN= -126
+}
+;;
+
+{.mfi
+       ldf8 FR_T_high= [ GR_Fh_ADDR ]            // load T_high= 2^{f_high}
+ (p7)  fcmp.lt.s1 p12, p7= f8, FR_UF_LIMIT       // x<underflow threshold ?
+       nop.i 0
+}
+;;
+
+{.mfb
+       setf.s FR_EXPMIN= GR_EMIN                 // FR_EXPMIN= EMIN
+       fma.s1 FR_P12= FR_COEFF2, FR_R, FR_COEFF1 // P12= C_1+C_2*r
+ (p12) br.cond.spnt OUT_RANGE_exp2
+}
+;;
+
+{.mfi
+       nop.m 0
+       fma.s1 FR_T_low_K= FR_T_low, FR_2_TO_K, f0 // T= 2^{K-126}*T_low
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fma.s1 FR_P= FR_R, FR_P12, f0              // P= P12+r
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fma.s1 FR_T= FR_T_low_K, FR_T_high, f0     // T= T*T_high
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fcmp.lt.s0 p6, p8= f8, FR_EXPMIN           // underflow (x<EMIN) ?
+       nop.i 0
+}
+;;
+
+{.mfb
+       nop.m 0
+       fma.s.s0 f8= FR_P, FR_T, FR_T              // result= T+T*P
+ (p8)  br.ret.sptk b0                             // return
+}
+;;
+
+{.mfb
+ (p6)  mov GR_Parameter_TAG= 164
+       nop.f 0
+ (p6)  br.cond.sptk __libm_error_region
+}
+;;
+
+
+SPECIAL_exp2:
+{.mfi
+       nop.m 0
+       fclass.m p6, p0= f8, 0x22                  // x= -Infinity ?
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fclass.m p7, p0= f8, 0x21                  // x= +Infinity ?
+       nop.i 0
+}
+;;
+
+{.mfi
+       nop.m 0
+       fclass.m p8, p0= f8, 0x7                   // x= +/-Zero ?
+       nop.i 0
+}
+{.mfb
+       nop.m 0
+ (p6)  mov f8= f0                                 // exp2(-Infinity)= 0
+ (p6)  br.ret.spnt b0
+}
+;;
+
+{.mfb
+       nop.m 0
+       nop.f 0
+ (p7)  br.ret.spnt b0                             // exp2(+Infinity)= +Infinity
+}
+;;
+
+{.mfb
+       nop.m 0
+ (p8)  mov f8= f1                                 // exp2(+/-0)= 1
+ (p8)  br.ret.spnt b0
+}
+;;
+
+{.mfb
+       nop.m 0
+       fma.s.s0 f8= f8, f1, f0                    // Remaining cases: NaNs
+       br.ret.sptk b0
+}
+;;
+
+
+OUT_RANGE_exp2:
+
+// overflow: p8= 1
+
+{.mii
+ (p8)  mov GR_EXPMAX= 0x1fffe
+       nop.i 0
+       nop.i 0
+}
+;;
+
+{.mmb
+ (p8)  mov GR_Parameter_TAG= 163
+ (p8)  setf.exp FR_R= GR_EXPMAX
+       nop.b 999
+}
+;;
+
+{.mfi
+       nop.m 999
+ (p8)  fma.s.s0 f8= FR_R, FR_R, f0                // Create overflow
+       nop.i 999
+}
+// underflow: p6= 1
+{.mii
+ (p6)  mov GR_Parameter_TAG= 164
+ (p6)  mov GR_EXPMAX= 1
+       nop.i 0
+}
+;;
+
+{.mmb
+       nop.m 0
+ (p6)  setf.exp FR_R= GR_EXPMAX
+       nop.b 999
+}
+;;
+
+{.mfb
+       nop.m 999
+ (p6)  fma.s.s0 f8= FR_R, FR_R, f0                // Create underflow
+       nop.b 0
+}
+;;
+
+WEAK_LIBM_END(exp2f)
+libm_alias_float_other (__exp2, exp2)
+#ifdef SHARED
+.symver exp2f,exp2f@@GLIBC_2.27
+.weak __exp2f_compat
+.set __exp2f_compat,__exp2f
+.symver __exp2f_compat,exp2f@GLIBC_2.2
+#endif
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+
+.prologue
+{.mfi
+       add GR_Parameter_Y= -32, sp                // Parameter 2 value
+       nop.f 0
+.save ar.pfs, GR_SAVE_PFS
+       mov GR_SAVE_PFS= ar.pfs                    // Save ar.pfs
+}
+
+{.mfi
+.fframe 64
+       add sp= -64, sp                            // Create new stack
+       nop.f 0
+       mov GR_SAVE_GP= gp                         // Save gp
+}
+;;
+
+{.mmi
+       stfs [ GR_Parameter_Y ]= FR_Y, 16          // STORE Parameter 2 on stack
+       add GR_Parameter_X= 16, sp                 // Parameter 1 address
+.save b0, GR_SAVE_B0
+       mov GR_SAVE_B0= b0                         // Save b0
+}
+;;
+
+.body
+{.mib
+       stfs [ GR_Parameter_X ]= FR_X              // STORE Parameter 1 on stack
+       add GR_Parameter_RESULT= 0, GR_Parameter_Y // Parameter 3 address
+       nop.b 0
+}
+{.mib
+       stfs [ GR_Parameter_Y ]= FR_RESULT         // STORE Parameter 3 on stack
+       add GR_Parameter_Y= -16, GR_Parameter_Y
+       br.call.sptk b0= __libm_error_support#    // Call error handling function
+}
+;;
+
+{.mmi
+       add GR_Parameter_RESULT= 48, sp
+       nop.m 0
+       nop.i 0
+}
+;;
+
+{.mmi
+       ldfs f8= [ GR_Parameter_RESULT ]          // Get return result off stack
+.restore sp
+       add sp= 64, sp                            // Restore stack pointer
+       mov b0= GR_SAVE_B0                        // Restore return address
+}
+;;
+
+{.mib
+       mov gp= GR_SAVE_GP                        // Restore gp
+       mov ar.pfs= GR_SAVE_PFS                   // Restore ar.pfs
+       br.ret.sptk b0                            // Return
+}
+;;
+
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type __libm_error_support#, @function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_exp2l.S
@@ -0,0 +1,807 @@
+.file "exp2l.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 07/27/00 Initial version
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+// set [ the previously overwritten ] GR_Parameter_RESULT.
+// 02/02/01 Added libm_error_support calls for underflow
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+// 05/07/03 Reformatted assembly source
+//
+// API
+//==============================================================
+// long double exp2l(long double)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// Let x= K + f + r, where
+// K is an integer, f= 0.b1 b2... b8 (f>= 0),
+// and |r|<2^{-8}
+// T is a table that stores 2^f (256 entries) rounded to
+// double extended precision (only mantissa is stored)
+// D stores (2^f/T [ f ] - 1), rounded to single precision
+//
+// 2^x is approximated as
+// 2^K * T [ f ] * (1+D [ f ] +c1*r+c2*r^2+...+c6*r^6)
+//
+
+
+
+// Special values
+//==============================================================
+// exp2(0)= 1
+// exp2(+inf)= inf
+// exp2(-inf)= 0
+//
+
+
+// Registers used
+//==============================================================
+// f6-f15, f32-f46
+// r2-r3, r8-r11, r14-r40
+// p6, p7, p8, p12
+
+       FR_X        = f10
+       FR_Y        = f1
+       FR_RESULT   = f8
+
+       FR_KF0      = f6
+       FR_EXP63    = f7
+       FR_T        = f9
+       FR_COEFF3   = f10
+       FR_COEFF4   = f11
+       FR_COEFF5   = f12
+       FR_COEFF6   = f13
+       FR_COEFF1   = f14
+       FR_COEFF2   = f15
+       FR_2P14     = f32
+       FR_UF_TEST  = f33
+       FR_D        = f34
+       FR_R        = f35
+       FR_2EXP     = f36
+       FR_EMIN     = f37
+       FR_P34      = f38
+       FR_P56      = f39
+       FR_R2       = f40
+       FR_P12      = f41
+       FR_TS       = f42
+       FR_P36      = f43
+       FR_P02      = f44
+       FR_R3       = f45
+       FR_P06      = f46
+
+
+       GR_ADDR0    = r2
+       GR_ADDR     = r2
+       GR_D_ADDR0  = r3
+       GR_D_ADDR   = r3
+       GR_LEADBITS = r8
+       GR_256      = r9
+       GR_EM63     = r10
+       GR_255      = r11
+       GR_EXPON    = r14
+       GR_BM63     = r15
+       GR_UF_TEST  = r16
+       GR_INDEX    = r17
+       GR_K        = r18
+       GR_KF       = r19
+       GR_2P14     = r19
+       GR_EMIN     = r20
+       GR_IT       = r21
+       GR_ID       = r22
+       GR_63       = r23
+       GR_CONST1   = r24
+       GR_EBIAS    = r25
+       GR_CONST2   = r26
+       GR_CONST3   = r27
+       GR_SIGNIF   = r28
+       GR_ARGEXP   = r29
+       GR_SGN      = r30
+       GR_EMIN1    = r31
+       GR_SREG     = r32
+
+       GR_SAVE_B0  = r33
+       GR_SAVE_PFS = r34
+       GR_SAVE_GP  = r35
+       GR_SAVE_SP  = r36
+
+       GR_Parameter_X     = r37
+       GR_Parameter_Y     = r38
+       GR_Parameter_RESULT= r39
+       GR_Parameter_TAG   = r40
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+
+       data8 0x3fac6b08d704a0c0 // C_3
+       data8 0x3f83b2ab6fba4e77 // C_4
+       data8 0x3f55d87fe78a6731 // C_5
+       data8 0x3f2430912f86c787 // C_6
+       data8 0xb17217f7d1cf79ab, 0x00003ffe // C_1
+       data8 0xf5fdeffc162c7541, 0x00003ffc // C_2
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+LOCAL_OBJECT_START(T_table)
+
+       data8 0x8000000000000000, 0x8058d7d2d5e5f6b1
+       data8 0x80b1ed4fd999ab6c, 0x810b40a1d81406d4
+       data8 0x8164d1f3bc030773, 0x81bea1708dde6056
+       data8 0x8218af4373fc25ec, 0x8272fb97b2a5894c
+       data8 0x82cd8698ac2ba1d7, 0x83285071e0fc4547
+       data8 0x8383594eefb6ee37, 0x83dea15b9541b132
+       data8 0x843a28c3acde4046, 0x8495efb3303efd30
+       data8 0x84f1f656379c1a29, 0x854e3cd8f9c8c95d
+       data8 0x85aac367cc487b15, 0x86078a2f23642a9f
+       data8 0x8664915b923fba04, 0x86c1d919caef5c88
+       data8 0x871f61969e8d1010, 0x877d2afefd4e256c
+       data8 0x87db357ff698d792, 0x88398146b919f1d4
+       data8 0x88980e8092da8527, 0x88f6dd5af155ac6b
+       data8 0x8955ee03618e5fdd, 0x89b540a7902557a4
+       data8 0x8a14d575496efd9a, 0x8a74ac9a79896e47
+       data8 0x8ad4c6452c728924, 0x8b3522a38e1e1032
+       data8 0x8b95c1e3ea8bd6e7, 0x8bf6a434adde0085
+       data8 0x8c57c9c4646f4dde, 0x8cb932c1bae97a95
+       data8 0x8d1adf5b7e5ba9e6, 0x8d7ccfc09c50e2f8
+       data8 0x8ddf042022e69cd6, 0x8e417ca940e35a01
+       data8 0x8ea4398b45cd53c0, 0x8f073af5a2013520
+       data8 0x8f6a8117e6c8e5c4, 0x8fce0c21c6726481
+       data8 0x9031dc431466b1dc, 0x9095f1abc540ca6b
+       data8 0x90fa4c8beee4b12b, 0x915eed13c89689d3
+       data8 0x91c3d373ab11c336, 0x9228ffdc10a051ad
+       data8 0x928e727d9531f9ac, 0x92f42b88f673aa7c
+       data8 0x935a2b2f13e6e92c, 0x93c071a0eef94bc1
+       data8 0x9426ff0fab1c04b6, 0x948dd3ac8ddb7ed3
+       data8 0x94f4efa8fef70961, 0x955c5336887894d5
+       data8 0x95c3fe86d6cc7fef, 0x962bf1cbb8d97560
+       data8 0x96942d3720185a00, 0x96fcb0fb20ac4ba3
+       data8 0x97657d49f17ab08e, 0x97ce9255ec4357ab
+       data8 0x9837f0518db8a96f, 0x98a1976f7597e996
+       data8 0x990b87e266c189aa, 0x9975c1dd47518c77
+       data8 0x99e0459320b7fa65, 0x9a4b13371fd166ca
+       data8 0x9ab62afc94ff864a, 0x9b218d16f441d63d
+       data8 0x9b8d39b9d54e5539, 0x9bf93118f3aa4cc1
+       data8 0x9c6573682ec32c2d, 0x9cd200db8a0774cb
+       data8 0x9d3ed9a72cffb751, 0x9dabfdff6367a2aa
+       data8 0x9e196e189d472420, 0x9e872a276f0b98ff
+       data8 0x9ef5326091a111ae, 0x9f6386f8e28ba651
+       data8 0x9fd228256400dd06, 0xa041161b3d0121be
+       data8 0xa0b0510fb9714fc2, 0xa11fd9384a344cf7
+       data8 0xa18faeca8544b6e4, 0xa1ffd1fc25cea188
+       data8 0xa27043030c496819, 0xa2e102153e918f9e
+       data8 0xa3520f68e802bb93, 0xa3c36b345991b47c
+       data8 0xa43515ae09e6809e, 0xa4a70f0c95768ec5
+       data8 0xa5195786be9ef339, 0xa58bef536dbeb6ee
+       data8 0xa5fed6a9b15138ea, 0xa6720dc0be08a20c
+       data8 0xa6e594cfeee86b1e, 0xa7596c0ec55ff55b
+       data8 0xa7cd93b4e965356a, 0xa8420bfa298f70d1
+       data8 0xa8b6d5167b320e09, 0xa92bef41fa77771b
+       data8 0xa9a15ab4ea7c0ef8, 0xaa1717a7b5693979
+       data8 0xaa8d2652ec907629, 0xab0386ef48868de1
+       data8 0xab7a39b5a93ed337, 0xabf13edf162675e9
+       data8 0xac6896a4be3fe929, 0xace0413ff83e5d04
+       data8 0xad583eea42a14ac6, 0xadd08fdd43d01491
+       data8 0xae493452ca35b80e, 0xaec22c84cc5c9465
+       data8 0xaf3b78ad690a4375, 0xafb51906e75b8661
+       data8 0xb02f0dcbb6e04584, 0xb0a957366fb7a3c9
+       data8 0xb123f581d2ac2590, 0xb19ee8e8c94feb09
+       data8 0xb21a31a66618fe3b, 0xb295cff5e47db4a4
+       data8 0xb311c412a9112489, 0xb38e0e38419fae18
+       data8 0xb40aaea2654b9841, 0xb487a58cf4a9c180
+       data8 0xb504f333f9de6484, 0xb58297d3a8b9f0d2
+       data8 0xb60093a85ed5f76c, 0xb67ee6eea3b22b8f
+       data8 0xb6fd91e328d17791, 0xb77c94c2c9d725e9
+       data8 0xb7fbefca8ca41e7c, 0xb87ba337a1743834
+       data8 0xb8fbaf4762fb9ee9, 0xb97c143756844dbf
+       data8 0xb9fcd2452c0b9deb, 0xba7de9aebe5fea09
+       data8 0xbaff5ab2133e45fb, 0xbb81258d5b704b6f
+       data8 0xbc034a7ef2e9fb0d, 0xbc85c9c560e7b269
+       data8 0xbd08a39f580c36bf, 0xbd8bd84bb67ed483
+       data8 0xbe0f6809860993e2, 0xbe935317fc378238
+       data8 0xbf1799b67a731083, 0xbf9c3c248e2486f8
+       data8 0xc0213aa1f0d08db0, 0xc0a6956e8836ca8d
+       data8 0xc12c4cca66709456, 0xc1b260f5ca0fbb33
+       data8 0xc238d2311e3d6673, 0xc2bfa0bcfad907c9
+       data8 0xc346ccda24976407, 0xc3ce56c98d21b15d
+       data8 0xc4563ecc5334cb33, 0xc4de8523c2c07baa
+       data8 0xc5672a115506dadd, 0xc5f02dd6b0bbc3d9
+       data8 0xc67990b5aa245f79, 0xc70352f04336c51e
+       data8 0xc78d74c8abb9b15d, 0xc817f681416452b2
+       data8 0xc8a2d85c8ffe2c45, 0xc92e1a9d517f0ecc
+       data8 0xc9b9bd866e2f27a3, 0xca45c15afcc72624
+       data8 0xcad2265e4290774e, 0xcb5eecd3b38597c9
+       data8 0xcbec14fef2727c5d, 0xcc799f23d11510e5
+       data8 0xcd078b86503dcdd2, 0xcd95da6a9ff06445
+       data8 0xce248c151f8480e4, 0xceb3a0ca5dc6a55d
+       data8 0xcf4318cf191918c1, 0xcfd2f4683f94eeb5
+       data8 0xd06333daef2b2595, 0xd0f3d76c75c5db8d
+       data8 0xd184df6251699ac6, 0xd2164c023056bcab
+       data8 0xd2a81d91f12ae45a, 0xd33a5457a3029054
+       data8 0xd3ccf099859ac379, 0xd45ff29e0972c561
+       data8 0xd4f35aabcfedfa1f, 0xd5872909ab75d18a
+       data8 0xd61b5dfe9f9bce07, 0xd6aff9d1e13ba2fe
+       data8 0xd744fccad69d6af4, 0xd7da67311797f56a
+       data8 0xd870394c6db32c84, 0xd9067364d44a929c
+       data8 0xd99d15c278afd7b6, 0xda3420adba4d8704
+       data8 0xdacb946f2ac9cc72, 0xdb63714f8e295255
+       data8 0xdbfbb797daf23755, 0xdc9467913a4f1c92
+       data8 0xdd2d818508324c20, 0xddc705bcd378f7f0
+       data8 0xde60f4825e0e9124, 0xdefb4e1f9d1037f2
+       data8 0xdf9612deb8f04420, 0xe031430a0d99e627
+       data8 0xe0ccdeec2a94e111, 0xe168e6cfd3295d23
+       data8 0xe2055afffe83d369, 0xe2a23bc7d7d91226
+       data8 0xe33f8972be8a5a51, 0xe3dd444c46499619
+       data8 0xe47b6ca0373da88d, 0xe51a02ba8e26d681
+       data8 0xe5b906e77c8348a8, 0xe658797368b3a717
+       data8 0xe6f85aaaee1fce22, 0xe798aadadd5b9cbf
+       data8 0xe8396a503c4bdc68, 0xe8da9958464b42ab
+       data8 0xe97c38406c4f8c57, 0xea1e4756550eb27b
+       data8 0xeac0c6e7dd24392f, 0xeb63b74317369840
+       data8 0xec0718b64c1cbddc, 0xecaaeb8ffb03ab41
+       data8 0xed4f301ed9942b84, 0xedf3e6b1d418a491
+       data8 0xee990f980da3025b, 0xef3eab20e032bc6b
+       data8 0xefe4b99bdcdaf5cb, 0xf08b3b58cbe8b76a
+       data8 0xf13230a7ad094509, 0xf1d999d8b7708cc1
+       data8 0xf281773c59ffb13a, 0xf329c9233b6bae9c
+       data8 0xf3d28fde3a641a5b, 0xf47bcbbe6db9fddf
+       data8 0xf5257d152486cc2c, 0xf5cfa433e6537290
+       data8 0xf67a416c733f846e, 0xf7255510c4288239
+       data8 0xf7d0df730ad13bb9, 0xf87ce0e5b2094d9c
+       data8 0xf92959bb5dd4ba74, 0xf9d64a46eb939f35
+       data8 0xfa83b2db722a033a, 0xfb3193cc4227c3f4
+       data8 0xfbdfed6ce5f09c49, 0xfc8ec01121e447bb
+       data8 0xfd3e0c0cf486c175, 0xfdedd1b496a89f35
+       data8 0xfe9e115c7b8f884c, 0xff4ecb59511ec8a5
+LOCAL_OBJECT_END(T_table)
+
+
+LOCAL_OBJECT_START(D_table)
+
+       data4 0x00000000, 0x9f55c08f, 0x1e93ffa3, 0x1dcd43a8
+       data4 0x1f751f79, 0x9f3cdd88, 0x9f43d155, 0x1eda222c
+       data4 0x1ef35513, 0x9f597895, 0x9e698881, 0x1ec71073
+       data4 0x1e50e371, 0x9dc01e19, 0x1de74133, 0x1e2f028c
+       data4 0x9edefb47, 0x1ebbac48, 0x9e8b0330, 0x9e9e9314
+       data4 0x1edc1d11, 0x1f098529, 0x9f52827c, 0x1f50050d
+       data4 0x1f301e8e, 0x1f5b64d1, 0x9f45e3ee, 0x9ef64d6d
+       data4 0x1d6ec5e8, 0x9e61ad9a, 0x1d44ccbb, 0x9e4a8bbb
+       data4 0x9cf11576, 0x9dcce7e7, 0x9d02ac90, 0x1f26ccf0
+       data4 0x9f0877c6, 0x9ddd62ae, 0x9f4b7fc3, 0x1ea8ef6b
+       data4 0x1ea4378d, 0x1ef6fc38, 0x1db99fd9, 0x1f22bf6f
+       data4 0x1f53e172, 0x1e85504a, 0x9f37cc75, 0x1f0c5e17
+       data4 0x1dde8aac, 0x9cb42bb2, 0x1e153cd7, 0x1eb62bba
+       data4 0x9e9b941b, 0x9ea80e3c, 0x1f508823, 0x1ec3fd36
+       data4 0x1e9ffaa1, 0x1e21e2eb, 0x9d948b1d, 0x9e8ac93a
+       data4 0x1ef7ee6f, 0x9e80dda3, 0x1f0814be, 0x1dc5ddfe
+       data4 0x1eedb9d1, 0x9f2aaa26, 0x9ea5b0fc, 0x1edf702e
+       data4 0x9e391201, 0x1f1316bb, 0x1ea27fb7, 0x9e05ed18
+       data4 0x9f199ed2, 0x1ee7fd7c, 0x1f003db6, 0x9eac3793
+       data4 0x9e5b8c10, 0x9f3af17c, 0x1bc9a8be, 0x1ee3c004
+       data4 0x9f19b1b2, 0x9f242ce9, 0x9ce67dd1, 0x9e4f6275
+       data4 0x1e20742c, 0x1eb9328a, 0x9f477153, 0x1d969718
+       data4 0x9f1e6c43, 0x1f2f67f4, 0x9f39c7e4, 0x9e3c4feb
+       data4 0x1da3956b, 0x9e7c685d, 0x1f280911, 0x9f0d8afb
+       data4 0x1e314b40, 0x9eb4f250, 0x9f1a34ad, 0x1ef5d5e7
+       data4 0x9f145496, 0x1e604827, 0x9f1e5195, 0x1e9c1fc0
+       data4 0x1efde521, 0x1e69b385, 0x1f316830, 0x9f244eae
+       data4 0x1f1787ec, 0x9e939971, 0x1f0bb393, 0x9f0511d6
+       data4 0x1ed919de, 0x1d8b7b28, 0x1e5ca4a9, 0x1e7c357b
+       data4 0x9e3ff8e8, 0x1eef53b5, 0x9ed22ed7, 0x1f16659b
+       data4 0x9f2db102, 0x9e2c6a78, 0x1f328d7d, 0x9f2fec3c
+       data4 0x1eb395bd, 0x9f242b84, 0x9e2683e6, 0x1ed71e68
+       data4 0x1efd1df5, 0x9e9eeafd, 0x9ed2249c, 0x1eef129a
+       data4 0x1d1ea44c, 0x9e81f7ff, 0x1eaf77c9, 0x9ee7a285
+       data4 0x1e1864ed, 0x9ee7edbb, 0x9e15a27d, 0x9ae61655
+       data4 0x1f1ff1a2, 0x1da29755, 0x9e5f46fb, 0x1e901236
+       data4 0x9eecfb9b, 0x9f204d2f, 0x1ec64685, 0x9eb809bd
+       data4 0x9e0026c5, 0x1d9f1da1, 0x1f142b49, 0x9f20f22e
+       data4 0x1f24b067, 0x1f185a4c, 0x9f09765c, 0x9ece902f
+       data4 0x1e2ca5db, 0x1e6de464, 0x9f071f67, 0x1f1518c3
+       data4 0x1ea13ded, 0x1f0b8414, 0x1edb6ad4, 0x9e548740
+       data4 0x9ea10efb, 0x1ee48a60, 0x1e7954c5, 0x9edad013
+       data4 0x9f21517d, 0x9e9b6e0c, 0x9ee7f9a6, 0x9ebd4298
+       data4 0x9d65b24e, 0x1eed751f, 0x9f1573ea, 0x9d430377
+       data4 0x9e13fc0c, 0x1e47008a, 0x1e3d5c1d, 0x1ef41a91
+       data4 0x9e4a4ef7, 0x9e952f18, 0x1d620566, 0x1d9b8d33
+       data4 0x1db06247, 0x1e94b31e, 0x1f0730ad, 0x9d79ffb4
+       data4 0x1ed64d51, 0x9e91fd11, 0x9e28d35a, 0x9dea0ed9
+       data4 0x1e891def, 0x9ee28ac0, 0x1e1db99b, 0x9ee1ce38
+       data4 0x9bdd9bca, 0x1eb72cb9, 0x9e8c53c6, 0x1e0df6ca
+       data4 0x1e8f2ccd, 0x9e9b0886, 0x1eeb3bc7, 0x1ec7e772
+       data4 0x9e210776, 0x9daf246c, 0x1ea1f151, 0x1ece4dc6
+       data4 0x1ce741c8, 0x1ed3c88f, 0x9ec9a4fd, 0x9e0c8d30
+       data4 0x1d2fbb26, 0x9ef212a7, 0x1ee44f1c, 0x9e445550
+       data4 0x1e075f77, 0x9d9291a3, 0x1f09c2ee, 0x9e012c88
+       data4 0x1f057d62, 0x9e7bb0dc, 0x9d8758ee, 0x1ee8d6c1
+       data4 0x9e509a57, 0x9e4ca7b7, 0x1e2cb341, 0x9ec35106
+       data4 0x1ecf3baf, 0x1e11781c, 0x1ea0cc78, 0x1eb75ca6
+       data4 0x1e961e1a, 0x1eb88853, 0x1e7abf50, 0x1ee38704
+       data4 0x9dc5ab0f, 0x1afe197b, 0x9ec07523, 0x9d9b7f78
+       data4 0x1f011618, 0x1ed43b0b, 0x9f035945, 0x9e3fd014
+       data4 0x9bbda5cd, 0x9e83f8ab, 0x1e58a928, 0x1e392d61
+       data4 0x1efdbb52, 0x1ee310a8, 0x9ec7ecc1, 0x1e8c9ed6
+       data4 0x9ef82dee, 0x9e70545b, 0x9ea53fc4, 0x1e40f419
+LOCAL_OBJECT_END(D_table)
+
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(exp2l)
+
+{.mii
+       // get exponent
+       getf.exp GR_EBIAS = f8
+       // GR_D_ADDR0 = pointer to D_table
+       addl GR_D_ADDR0 = @ltoff(D_table), gp
+       // GR_ADDR0 = pointer to C_1...C_6 followed by T_table
+       addl GR_ADDR0 = @ltoff(poly_coeffs), gp ;;
+}
+
+{.mfi
+       // get significand
+       getf.sig GR_SIGNIF = f8
+       // will continue only for normal/denormal numbers
+       fclass.nm.unc p12, p7 = f8, 0x1b
+       mov GR_63 = 63 ;;
+}
+
+{.mfi
+       nop.m 0
+       nop.f 0
+       // GR_CONST2 = bias+63-8
+       mov GR_CONST2 = 0xffff+55
+}
+{.mfi
+       // GR_CONST1 = bias+15
+       mov GR_CONST1 = 0xffff+15
+       nop.f 0
+       mov GR_CONST3 = 0x1ffff ;;
+}
+
+{.mfi
+       // load start address for C_1...C_6 followed by T_table
+       ld8 GR_ADDR = [ GR_ADDR0 ]
+       nop.f 0
+       // get sign of argument
+       andcm GR_SGN = GR_EBIAS, GR_CONST3
+}
+{.mfi
+       // GR_D_ADDR = pointer to D_table
+       ld8 GR_D_ADDR = [ GR_D_ADDR0 ]
+       nop.f 0
+       // get argument exponent
+       and GR_ARGEXP = GR_CONST3, GR_EBIAS ;;
+}
+
+{.mfi
+       alloc GR_SREG = ar.pfs, 1, 4, 4, 0
+       nop.f 0
+       // p6 = 1 if sign = 1
+       cmp.ne p6, p8 = GR_SGN, r0
+}
+{.mfi
+       // p7 = 1 if exponent> = 15 (argument out of range)
+       cmp.ge p7, p0 = GR_ARGEXP, GR_CONST1
+       nop.f 0
+       sub GR_EXPON = GR_CONST2, GR_ARGEXP ;;
+}
+
+{.mib
+       // load C_3, C_4
+       ldfpd FR_COEFF3, FR_COEFF4 = [ GR_ADDR ], 16
+       // get first exponent+8 bits
+       shr.u GR_LEADBITS = GR_SIGNIF, GR_EXPON
+ (p12) br.cond.spnt SPECIAL_exp2l
+}
+{.mib
+       mov GR_256 = 256
+       // exponent- = 63
+       sub GR_EM63 = GR_EBIAS, GR_63
+  (p7) br.cond.spnt OUT_RANGE_exp2l ;;
+}
+
+{.mlx
+       // load C_5, C_6
+       ldfpd FR_COEFF5, FR_COEFF6 = [ GR_ADDR ], 16
+       // GR_2P14 = 2^14
+       movl GR_2P14 = 0x46800000 ;;
+}
+
+{.mfi
+       // load C_1
+       ldfe FR_COEFF1 = [ GR_ADDR ], 16
+       fma.s0 f8 = f8, f1, f0
+       // GR_BM63 = bias-63
+       mov GR_BM63 = 0xffff-63 ;;
+}
+
+{.mlx
+       setf.s FR_2P14 = GR_2P14
+       // GR_UF_TEST = -2^14-62
+       movl GR_UF_TEST = 0xc6807c00
+}
+{.mfi
+       // load C_2
+       ldfe FR_COEFF2 = [ GR_ADDR ], 16
+       nop.f 0
+       mov GR_255 = 255 ;;
+}
+
+{.mib
+       // get 8-bit index
+       and GR_INDEX = GR_255, GR_LEADBITS
+       // get K = integer part
+       shr.u GR_K = GR_LEADBITS, 8
+       nop.b 0 ;;
+}
+
+{.mmi
+       // if sign = 1 && f>0, set p7 = 1
+  (p6) cmp.gt.unc p7, p0 = GR_INDEX, r0
+       setf.s FR_UF_TEST = GR_UF_TEST
+       shl GR_KF = GR_LEADBITS, GR_EXPON ;;
+}
+
+{.mfi
+       // if sign = 1 && f>0, set f = 1-f
+  (p7) sub GR_INDEX = GR_256, GR_INDEX
+       nop.f 0
+       // if sign = 1 && f>0, set K = K+1
+  (p7) add GR_K = GR_K, r0, 1 ;;
+}
+
+{.mfi
+       // FR_EXP63 = 2^{expon-63}
+       setf.exp FR_EXP63 = GR_EM63
+       nop.f 0
+       nop.i 0 ;;
+}
+
+.pred.rel "mutex", p6, p8
+{.mfi
+       // if sign = 0, set scale factor exponent S = K+bias-63
+  (p8) add GR_K = GR_K, GR_BM63
+       nop.f 0
+       // if sign = 1, set scale factor exponent S = -K+bias-63
+  (p6) sub GR_K = GR_BM63, GR_K ;;
+}
+
+{.mmi
+       // FR_KF0 = 2^{63-expon}*(K+f)
+       setf.sig FR_KF0 = GR_KF
+       nop.m 0
+       // GR_EMIN = EMIN = 2-2^14
+       mov GR_EMIN = 0x18cfff ;;
+}
+
+{.mfi
+       // get T_table index
+       shladd GR_IT = GR_INDEX, 3, GR_ADDR
+       // p7 = 1 if x> = 2^10
+       fcmp.ge.s1 p7, p12 = f8, FR_2P14
+       // get D_table index
+       shladd GR_ID = GR_INDEX, 2, GR_D_ADDR ;;
+}
+
+{.mfi
+       // load T_table value
+       ldf8 FR_T = [ GR_IT ]
+       // p7 = 1 if x<-2^10-50
+ (p12) fcmp.lt.s1 p7, p0 = f8, FR_UF_TEST
+       // GR_EMIN1 = EMIN = 2-2^14
+       shl GR_EMIN1 = GR_EMIN, 11 ;;
+}
+
+{.mmb
+       // f50 = scale factor = 2^{K-63}
+       setf.exp FR_2EXP = GR_K
+       // load D_table value
+       ldfs FR_D = [ GR_ID ]
+  (p7) br.cond.spnt OUT_RANGE_exp2l ;;
+}
+
+{.mfi
+       nop.m 0
+       // get r = x-(K+f)
+       fnma.s1 FR_R = FR_KF0, FR_EXP63, f8
+       nop.i 0 ;;
+}
+
+{.mfi
+       // FR_EMIN = EMIN
+       setf.s FR_EMIN = GR_EMIN1
+       // P34 = C_4*r+C_3
+       fma.s1 FR_P34 = FR_COEFF4, FR_R, FR_COEFF3
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // P56 = C_6*r+C_5
+       fma.s1 FR_P56 = FR_COEFF6, FR_R, FR_COEFF5
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       //  r*r
+       fma.s1 FR_R2 = FR_R, FR_R, f0
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // P12 = C_2*r+C_1
+       fma.s1 FR_P12 = FR_COEFF2, FR_R, FR_COEFF1
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // T* = scaling factor
+       fma.s1 FR_TS = FR_T, FR_2EXP, f0
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // P36 = P34+r2*P56
+       fma.s1 FR_P36 = FR_P56, FR_R2, FR_P34
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // P02 = D+r*P12
+       fma.s1 FR_P02 = FR_P12, FR_R, FR_D
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // GR_ID = r*r2
+       fma.s1 FR_R3 = FR_R2, FR_R, f0
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // P06 = P02+r3*P36
+       fma.s1 FR_P06 = FR_P36, FR_R3, FR_P02
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // underflow (x<EMIN) ?
+       fcmp.lt.s0 p6, p8 = f8, FR_EMIN
+       nop.i 0 ;;
+}
+
+{.mfb
+       nop.m 0
+       // result = T+T*P06
+       fma.s0 f8 = FR_TS, FR_P06, FR_TS
+       // return
+  (p8) br.ret.sptk b0
+}
+{.mfb
+  (p6) mov GR_Parameter_TAG = 160
+       nop.f 0
+  (p6) br.cond.sptk __libm_error_region ;;
+}
+
+
+SPECIAL_exp2l:
+
+{.mfi
+       nop.m 0
+       // x = -Infinity ?
+       fclass.m p6, p0 = f8, 0x22
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // x = +Infinity ?
+       fclass.m p7, p0 = f8, 0x21
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // x = +/-Zero ?
+       fclass.m p8, p0 = f8, 0x7
+       nop.i 0
+}
+{.mfb
+       nop.m 0
+       // exp2l(-Infinity) = 0
+  (p6) mov f8 = f0
+  (p6) br.ret.spnt b0 ;;
+}
+
+{.mfb
+       nop.m 0
+       // exp2l(+Infinity) = +Infinity
+       nop.f 0
+  (p7) br.ret.spnt b0 ;;
+}
+
+{.mfb
+       nop.m 0
+       // exp2l(+/-0) = 1
+  (p8) mov f8 = f1
+  (p8) br.ret.spnt b0 ;;
+}
+
+{.mfb
+       nop.m 0
+       // Remaining cases: NaNs
+       fma.s0 f8 = f8, f1, f0
+       br.ret.sptk b0 ;;
+}
+
+
+OUT_RANGE_exp2l:
+
+
+{.mfi
+       // overflow: p8 = 1
+  (p8) mov GR_EM63 = 0x1fffe
+       // normalize input, to detect pseudo-zeroes
+       fma.s0 f8 = f8, f1, f0
+       nop.i 0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // f8 = 0?
+       fcmp.eq.s1 p7, p0 = f8, f0
+       nop.i 0 ;;
+}
+
+{.mmb
+  (p8) mov GR_Parameter_TAG = 159
+  (p8) setf.exp FR_TS = GR_EM63
+       nop.b 999 ;;
+}
+
+{.mfb
+       nop.m 0
+       // pseudo-zero
+  (p7) mov f8 = f1
+  (p7) br.ret.sptk b0 ;;
+}
+
+{.mfi
+       nop.m 999
+  (p8) fma.s0 f8 = FR_TS, FR_TS, f0
+       nop.i 999
+}
+{.mii
+       nop.m 0
+       // underflow: p6 = 1
+  (p6) mov GR_EM63 = 1
+       nop.i 0 ;;
+}
+
+{.mmb
+  (p6) mov GR_Parameter_TAG = 160
+  (p6) setf.exp FR_TS = GR_EM63
+       nop.b 999 ;;
+}
+
+{.mfb
+       nop.m 999
+  (p6) fma.s0 f8 = FR_TS, FR_TS, f0
+       nop.b 0 ;;
+}
+
+
+GLOBAL_LIBM_END(exp2l)
+libm_alias_ldouble_other (exp2, exp2)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{.mfi
+       add GR_Parameter_Y = -32, sp // Parameter 2 value
+       nop.f 0
+.save ar.pfs, GR_SAVE_PFS
+       mov GR_SAVE_PFS = ar.pfs // Save ar.pfs
+}
+{.mfi
+.fframe 64
+       add sp = -64, sp // Create new stack
+       nop.f 0
+       mov GR_SAVE_GP = gp ;; // Save gp
+}
+
+{.mmi
+       stfe [ GR_Parameter_Y ] = FR_Y, 16 // STORE Parameter 2 on stack
+       add GR_Parameter_X = 16, sp // Parameter 1 address
+.save b0, GR_SAVE_B0
+       mov GR_SAVE_B0 = b0 ;; // Save b0
+}
+
+.body
+{.mib
+       stfe [ GR_Parameter_X ] = FR_X // STORE Parameter 1 on stack
+       add GR_Parameter_RESULT = 0, GR_Parameter_Y // Parameter 3 address
+       nop.b 0
+}
+{.mib
+       stfe [ GR_Parameter_Y ] = FR_RESULT // STORE Parameter 3 on stack
+       add GR_Parameter_Y = -16, GR_Parameter_Y
+       br.call.sptk b0 = __libm_error_support# ;; // Call error handling function
+}
+
+{.mmi
+       add GR_Parameter_RESULT = 48, sp
+       nop.m 0
+       nop.i 0 ;;
+}
+
+{.mmi
+       ldfe f8 = [ GR_Parameter_RESULT ] // Get return result off stack
+.restore sp
+       add sp = 64, sp // Restore stack pointer
+       mov b0 = GR_SAVE_B0 ;; // Restore return address
+}
+
+{.mib
+       mov gp = GR_SAVE_GP // Restore gp
+       mov ar.pfs = GR_SAVE_PFS // Restore ar.pfs
+       br.ret.sptk b0 ;; // Return
+}
+
+
+LOCAL_LIBM_END(__libm_error_region)
+.type __libm_error_support#, @function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_exp_data.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_expf.S
@@ -0,0 +1,722 @@
+.file "expf.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+
+// History
+//*********************************************************************
+// 02/02/00 Original version
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 08/21/00 Improvements to save 2 cycles on main path, and shorten x=0 case
+// 12/07/00 Widen main path, shorten x=inf, nan paths
+// 03/15/01 Fix monotonicity problem around x=0 for round to +inf
+// 02/05/02 Corrected uninitialize predicate in POSSIBLE_UNDERFLOW path
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 07/26/02 Algorithm changed, accuracy improved
+// 09/26/02 support of higher precision inputs added, underflow threshold
+//          corrected
+// 11/15/02 Improved performance on Itanium 2, added possible over/under paths
+// 05/30/03 Set inexact flag on unmasked overflow/underflow
+// 03/31/05 Reformatted delimiters between data tables
+//
+//
+// API
+//*********************************************************************
+// float expf(float)
+//
+// Overview of operation
+//*********************************************************************
+// Take the input x. w is "how many log2/128 in x?"
+//  w = x * 64/log2
+//  NJ = int(w)
+//  x = NJ*log2/64 + R
+
+//  NJ = 64*n + j
+//  x = n*log2 + (log2/64)*j + R
+//
+//  So, exp(x) = 2^n * 2^(j/64)* exp(R)
+//
+//  T =  2^n * 2^(j/64)
+//       Construct 2^n
+//       Get 2^(j/64) table
+//           actually all the entries of 2^(j/64) table are stored in DP and
+//           with exponent bits set to 0 -> multiplication on 2^n can be
+//           performed by doing logical "or" operation with bits presenting 2^n
+
+//  exp(R) = 1 + (exp(R) - 1)
+//  P = exp(R) - 1 approximated by Taylor series of 3rd degree
+//      P = A3*R^3 + A2*R^2 + R, A3 = 1/6, A2 = 1/2
+//
+
+//  The final result is reconstructed as follows
+//  exp(x) = T + T*P
+
+// Special values
+//*********************************************************************
+// expf(+0)    = 1.0
+// expf(-0)    = 1.0
+
+// expf(+qnan) = +qnan
+// expf(-qnan) = -qnan
+// expf(+snan) = +qnan
+// expf(-snan) = -qnan
+
+// expf(-inf)  = +0
+// expf(+inf)  = +inf
+
+// Overflow and Underflow
+//*********************************************************************
+// expf(x) = largest single normal when
+//     x = 88.72283 = 0x42b17217
+
+// expf(x) = smallest single normal when
+//     x = -87.33654 = 0xc2aeac4f
+
+// expf(x) = largest round-to-nearest single zero when
+//     x = -103.97208 = 0xc2cff1b5
+
+
+// Registers used
+//*********************************************************************
+// Floating Point registers used:
+// f8, input
+// f6,f7, f9 -> f15,  f32 -> f40
+
+// General registers used:
+// r3, r23 -> r38
+
+// Predicate registers used:
+// p10 -> p15
+
+// Assembly macros
+//*********************************************************************
+// integer registers used
+// scratch
+rNJ                   = r3
+
+rTmp                  = r23
+rJ                    = r23
+rN                    = r24
+rTblAddr              = r25
+rA3                   = r26
+rExpHalf              = r27
+rLn2Div64             = r28
+r17ones_m1            = r29
+rGt_ln                = r29
+rRightShifter         = r30
+r64DivLn2             = r31
+// stacked
+GR_SAVE_PFS           = r32
+GR_SAVE_B0            = r33
+GR_SAVE_GP            = r34
+GR_Parameter_X        = r35
+GR_Parameter_Y        = r36
+GR_Parameter_RESULT   = r37
+GR_Parameter_TAG      = r38
+
+// floating point registers used
+FR_X                  = f10
+FR_Y                  = f1
+FR_RESULT             = f8
+// scratch
+fRightShifter         = f6
+f64DivLn2             = f7
+fNormX                = f9
+fNint                 = f10
+fN                    = f11
+fR                    = f12
+fLn2Div64             = f13
+fA2                   = f14
+fA3                   = f15
+// stacked
+fP                    = f32
+fT                    = f33
+fMIN_SGL_OFLOW_ARG    = f34
+fMAX_SGL_ZERO_ARG     = f35
+fMAX_SGL_NORM_ARG     = f36
+fMIN_SGL_NORM_ARG     = f37
+fRSqr                 = f38
+fTmp                  = f39
+fGt_pln               = f39
+fWre_urm_f8           = f40
+fFtz_urm_f8           = f40
+
+
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(_expf_table)
+data4 0x42b17218         // Smallest sgl arg to overflow sgl result, +88.7228
+data4 0xc2cff1b5         // Largest sgl for rnd-to-nearest 0 result, -103.9720
+data4 0x42b17217         // Largest sgl arg to give normal sgl result, +88.7228
+data4 0xc2aeac4f         // Smallest sgl arg to give normal sgl result, -87.3365
+//
+// 2^(j/64) table, j goes from 0 to 63
+data8 0x0000000000000000 // 2^(0/64)
+data8 0x00002C9A3E778061 // 2^(1/64)
+data8 0x000059B0D3158574 // 2^(2/64)
+data8 0x0000874518759BC8 // 2^(3/64)
+data8 0x0000B5586CF9890F // 2^(4/64)
+data8 0x0000E3EC32D3D1A2 // 2^(5/64)
+data8 0x00011301D0125B51 // 2^(6/64)
+data8 0x0001429AAEA92DE0 // 2^(7/64)
+data8 0x000172B83C7D517B // 2^(8/64)
+data8 0x0001A35BEB6FCB75 // 2^(9/64)
+data8 0x0001D4873168B9AA // 2^(10/64)
+data8 0x0002063B88628CD6 // 2^(11/64)
+data8 0x0002387A6E756238 // 2^(12/64)
+data8 0x00026B4565E27CDD // 2^(13/64)
+data8 0x00029E9DF51FDEE1 // 2^(14/64)
+data8 0x0002D285A6E4030B // 2^(15/64)
+data8 0x000306FE0A31B715 // 2^(16/64)
+data8 0x00033C08B26416FF // 2^(17/64)
+data8 0x000371A7373AA9CB // 2^(18/64)
+data8 0x0003A7DB34E59FF7 // 2^(19/64)
+data8 0x0003DEA64C123422 // 2^(20/64)
+data8 0x0004160A21F72E2A // 2^(21/64)
+data8 0x00044E086061892D // 2^(22/64)
+data8 0x000486A2B5C13CD0 // 2^(23/64)
+data8 0x0004BFDAD5362A27 // 2^(24/64)
+data8 0x0004F9B2769D2CA7 // 2^(25/64)
+data8 0x0005342B569D4F82 // 2^(26/64)
+data8 0x00056F4736B527DA // 2^(27/64)
+data8 0x0005AB07DD485429 // 2^(28/64)
+data8 0x0005E76F15AD2148 // 2^(29/64)
+data8 0x0006247EB03A5585 // 2^(30/64)
+data8 0x0006623882552225 // 2^(31/64)
+data8 0x0006A09E667F3BCD // 2^(32/64)
+data8 0x0006DFB23C651A2F // 2^(33/64)
+data8 0x00071F75E8EC5F74 // 2^(34/64)
+data8 0x00075FEB564267C9 // 2^(35/64)
+data8 0x0007A11473EB0187 // 2^(36/64)
+data8 0x0007E2F336CF4E62 // 2^(37/64)
+data8 0x00082589994CCE13 // 2^(38/64)
+data8 0x000868D99B4492ED // 2^(39/64)
+data8 0x0008ACE5422AA0DB // 2^(40/64)
+data8 0x0008F1AE99157736 // 2^(41/64)
+data8 0x00093737B0CDC5E5 // 2^(42/64)
+data8 0x00097D829FDE4E50 // 2^(43/64)
+data8 0x0009C49182A3F090 // 2^(44/64)
+data8 0x000A0C667B5DE565 // 2^(45/64)
+data8 0x000A5503B23E255D // 2^(46/64)
+data8 0x000A9E6B5579FDBF // 2^(47/64)
+data8 0x000AE89F995AD3AD // 2^(48/64)
+data8 0x000B33A2B84F15FB // 2^(49/64)
+data8 0x000B7F76F2FB5E47 // 2^(50/64)
+data8 0x000BCC1E904BC1D2 // 2^(51/64)
+data8 0x000C199BDD85529C // 2^(52/64)
+data8 0x000C67F12E57D14B // 2^(53/64)
+data8 0x000CB720DCEF9069 // 2^(54/64)
+data8 0x000D072D4A07897C // 2^(55/64)
+data8 0x000D5818DCFBA487 // 2^(56/64)
+data8 0x000DA9E603DB3285 // 2^(57/64)
+data8 0x000DFC97337B9B5F // 2^(58/64)
+data8 0x000E502EE78B3FF6 // 2^(59/64)
+data8 0x000EA4AFA2A490DA // 2^(60/64)
+data8 0x000EFA1BEE615A27 // 2^(61/64)
+data8 0x000F50765B6E4540 // 2^(62/64)
+data8 0x000FA7C1819E90D8 // 2^(63/64)
+LOCAL_OBJECT_END(_expf_table)
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(expf)
+
+{ .mlx
+      addl            rTblAddr = @ltoff(_expf_table),gp
+      movl            r64DivLn2 = 0x40571547652B82FE // 64/ln(2)
+}
+{ .mlx
+      addl            rA3 = 0x3E2AA, r0 // high bits of 1.0/6.0 rounded to SP
+      movl            rRightShifter = 0x43E8000000000000 // DP Right Shifter
+}
+;;
+
+{ .mfi
+      // point to the beginning of the table
+      ld8             rTblAddr = [rTblAddr]
+      fclass.m        p14, p0 = f8, 0x22    // test for -INF
+      shl             rA3 = rA3, 12  // 0x3E2AA000, approx to 1.0/6.0 in SP
+}
+{ .mfi
+      nop.m           0
+      fnorm.s1        fNormX = f8           // normalized x
+      addl            rExpHalf = 0xFFFE, r0 // exponent of 1/2
+}
+;;
+
+{ .mfi
+      setf.d          f64DivLn2 = r64DivLn2 // load 64/ln(2) to FP reg
+      fclass.m        p15, p0 = f8, 0x1e1   // test for NaT,NaN,+Inf
+      nop.i           0
+}
+{ .mlx
+      // load Right Shifter to FP reg
+      setf.d          fRightShifter = rRightShifter
+      movl            rLn2Div64 = 0x3F862E42FEFA39EF // DP ln(2)/64 in GR
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.eq.s1      p13, p0 = f0, f8      // test for x = 0.0
+      nop.i           0
+}
+{ .mfb
+      setf.s          fA3 = rA3             // load A3 to FP reg
+(p14) fma.s.s0        f8 = f0, f1, f0       // result if x = -inf
+(p14) br.ret.spnt     b0                    // exit here if x = -inf
+}
+;;
+
+{ .mfi
+      setf.exp        fA2 = rExpHalf        // load A2 to FP reg
+      fcmp.eq.s0      p6, p0 = f8, f0       // Dummy to flag denorm
+      nop.i           0
+}
+{ .mfb
+      setf.d          fLn2Div64 = rLn2Div64 // load ln(2)/64 to FP reg
+(p15) fma.s.s0        f8 = f8, f1, f0       // result if x = NaT,NaN,+Inf
+(p15) br.ret.spnt     b0                    // exit here if x = NaT,NaN,+Inf
+}
+;;
+
+{ .mfb
+      // overflow and underflow_zero threshold
+      ldfps           fMIN_SGL_OFLOW_ARG, fMAX_SGL_ZERO_ARG = [rTblAddr], 8
+(p13) fma.s.s0        f8 = f1, f1, f0       // result if x = 0.0
+(p13) br.ret.spnt     b0                    // exit here if x =0.0
+}
+;;
+
+      // max normal and underflow_denorm threshold
+{ .mfi
+      ldfps           fMAX_SGL_NORM_ARG, fMIN_SGL_NORM_ARG = [rTblAddr], 8
+      nop.f           0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      // x*(64/ln(2)) + Right Shifter
+      fma.s1          fNint = fNormX, f64DivLn2, fRightShifter
+      nop.i           0
+}
+;;
+
+// Divide arguments into the following categories:
+//  Certain Underflow       p11 - -inf < x <= MAX_SGL_ZERO_ARG
+//  Possible Underflow      p13 - MAX_SGL_ZERO_ARG < x < MIN_SGL_NORM_ARG
+//  Certain Safe                - MIN_SGL_NORM_ARG <= x <= MAX_SGL_NORM_ARG
+//  Possible Overflow       p14 - MAX_SGL_NORM_ARG < x < MIN_SGL_OFLOW_ARG
+//  Certain Overflow        p15 - MIN_SGL_OFLOW_ARG <= x < +inf
+//
+// If the input is really a single arg, then there will never be
+// "Possible Overflow" arguments.
+//
+
+{ .mfi
+      nop.m           0
+      // check for overflow
+      fcmp.ge.s1      p15, p0 = fNormX, fMIN_SGL_OFLOW_ARG
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      // check for underflow and tiny (+0) result
+      fcmp.le.s1      p11, p0 = fNormX, fMAX_SGL_ZERO_ARG
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+      fms.s1          fN = fNint, f1, fRightShifter // n in FP register
+      // branch out if overflow
+(p15) br.cond.spnt    EXP_CERTAIN_OVERFLOW
+}
+;;
+
+{ .mfb
+      getf.sig        rNJ = fNint           // bits of n, j
+      // check for underflow and deno result
+      fcmp.lt.s1      p13, p0 = fNormX, fMIN_SGL_NORM_ARG
+      // branch out if underflow and tiny (+0) result
+(p11) br.cond.spnt    EXP_CERTAIN_UNDERFLOW
+}
+;;
+
+{ .mfi
+      nop.m           0
+      // check for possible overflow
+      fcmp.gt.s1      p14, p0 = fNormX, fMAX_SGL_NORM_ARG
+      extr.u          rJ = rNJ, 0, 6        // bits of j
+}
+{ .mfi
+      addl            rN = 0xFFFF - 63, rNJ // biased and shifted n
+      fnma.s1         fR = fLn2Div64, fN, fNormX // R = x - N*ln(2)/64
+      nop.i           0
+}
+;;
+
+{ .mfi
+      shladd          rJ = rJ, 3, rTblAddr  // address in the 2^(j/64) table
+      nop.f           0
+      shr             rN = rN, 6            // biased n
+}
+;;
+
+{ .mfi
+      ld8             rJ = [rJ]
+      nop.f           0
+      shl             rN = rN, 52           // 2^n bits in DP format
+}
+;;
+
+{ .mfi
+      or              rN = rN, rJ // bits of 2^n * 2^(j/64) in DP format
+      nop.f           0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      setf.d          fT = rN               // 2^n * 2^(j/64)
+      fma.s1          fP = fA3, fR, fA2     // A3*R + A2
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fRSqr = fR, fR, f0    // R^2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fP = fP, fRSqr, fR    // P = (A3*R + A2)*R^2 + R
+      nop.i           0
+}
+;;
+
+{ .mbb
+      nop.m           0
+      // branch out if possible underflow
+(p13) br.cond.spnt    EXP_POSSIBLE_UNDERFLOW
+      // branch out if possible overflow result
+(p14) br.cond.spnt    EXP_POSSIBLE_OVERFLOW
+}
+;;
+
+{ .mfb
+      nop.m           0
+      // final result in the absence of over- and underflow
+      fma.s.s0        f8 = fP, fT, fT
+      // exit here in the absence of over- and underflow
+      br.ret.sptk     b0
+}
+;;
+
+EXP_POSSIBLE_OVERFLOW:
+
+// Here if fMAX_SGL_NORM_ARG < x < fMIN_SGL_OFLOW_ARG
+// This cannot happen if input is a single, only if input higher precision.
+// Overflow is a possibility, not a certainty.
+
+// Recompute result using status field 2 with user's rounding mode,
+// and wre set.  If result is larger than largest single, then we have
+// overflow
+
+{ .mfi
+      mov             rGt_ln  = 0x1007f // Exponent for largest single + 1 ulp
+      fsetc.s2        0x7F,0x42         // Get user's round mode, set wre
+      nop.i           0
+}
+;;
+
+{ .mfi
+      setf.exp        fGt_pln = rGt_ln  // Create largest single + 1 ulp
+      fma.s.s2        fWre_urm_f8 = fP, fT, fT    // Result with wre set
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fsetc.s2        0x7F,0x40                   // Turn off wre in sf2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.ge.s1      p6, p0 =  fWre_urm_f8, fGt_pln // Test for overflow
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      nop.f           0
+(p6)  br.cond.spnt    EXP_CERTAIN_OVERFLOW // Branch if overflow
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fma.s.s0        f8 = fP, fT, fT
+      br.ret.sptk     b0                     // Exit if really no overflow
+}
+;;
+
+// here if overflow
+EXP_CERTAIN_OVERFLOW:
+{ .mmi
+      addl            r17ones_m1 = 0x1FFFE, r0
+;;
+      setf.exp        fTmp = r17ones_m1
+      nop.i           0
+}
+;;
+
+{ .mfi
+      alloc           r32=ar.pfs,0,3,4,0
+      fmerge.s        FR_X = f8,f8
+      nop.i           0
+}
+{ .mfb
+      mov             GR_Parameter_TAG = 16
+      fma.s.s0        FR_RESULT = fTmp, fTmp, fTmp // Set I,O and +INF result
+      br.cond.sptk    __libm_error_region
+}
+;;
+
+EXP_POSSIBLE_UNDERFLOW:
+
+// Here if fMAX_SGL_ZERO_ARG < x < fMIN_SGL_NORM_ARG
+// Underflow is a possibility, not a certainty
+
+// We define an underflow when the answer with
+//    ftz set
+// is zero (tiny numbers become zero)
+
+// Notice (from below) that if we have an unlimited exponent range,
+// then there is an extra machine number E between the largest denormal and
+// the smallest normal.
+
+// So if with unbounded exponent we round to E or below, then we are
+// tiny and underflow has occurred.
+
+// But notice that you can be in a situation where we are tiny, namely
+// rounded to E, but when the exponent is bounded we round to smallest
+// normal. So the answer can be the smallest normal with underflow.
+
+//                           E
+// -----+--------------------+--------------------+-----
+//      |                    |                    |
+//   1.1...10 2^-3fff    1.1...11 2^-3fff    1.0...00 2^-3ffe
+//   0.1...11 2^-3ffe                                   (biased, 1)
+//    largest dn                               smallest normal
+
+{ .mfi
+      nop.m           0
+      fsetc.s2        0x7F,0x41                // Get user's round mode, set ftz
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s.s2        fFtz_urm_f8 = fP, fT, fT // Result with ftz set
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fsetc.s2        0x7F,0x40                // Turn off ftz in sf2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.eq.s1      p6, p7 = fFtz_urm_f8, f0 // Test for underflow
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s.s0        f8 = fP, fT, fT          // Compute result, set I, maybe U
+      nop.i           0
+}
+;;
+
+{ .mbb
+      nop.m           0
+(p6)  br.cond.spnt    EXP_UNDERFLOW_COMMON     // Branch if really underflow
+(p7)  br.ret.sptk     b0                       // Exit if really no underflow
+}
+;;
+
+EXP_CERTAIN_UNDERFLOW:
+// Here if  x < fMAX_SGL_ZERO_ARG
+// Result will be zero (or smallest denorm if round to +inf) with I, U set
+{ .mmi
+      mov             rTmp = 1
+;;
+      setf.exp        fTmp = rTmp               // Form small normal
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fmerge.se       fTmp = fTmp, f64DivLn2    // Small with non-trial signif
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fma.s.s0        f8 = fTmp, fTmp, f0 // Set I,U, tiny (+0.0) result
+      br.cond.sptk    EXP_UNDERFLOW_COMMON
+}
+;;
+
+EXP_UNDERFLOW_COMMON:
+// Determine if underflow result is zero or nonzero
+{ .mfi
+      alloc           r32=ar.pfs,0,3,4,0
+      fcmp.eq.s1      p6, p0 =  f8, f0
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fmerge.s        FR_X = fNormX,fNormX
+(p6)  br.cond.spnt    EXP_UNDERFLOW_ZERO
+}
+;;
+
+EXP_UNDERFLOW_NONZERO:
+// Here if  x < fMIN_SGL_NORM_ARG and result nonzero;
+// I, U are set
+{ .mfb
+      mov             GR_Parameter_TAG = 17
+      nop.f           0                         // FR_RESULT already set
+      br.cond.sptk    __libm_error_region
+}
+;;
+
+EXP_UNDERFLOW_ZERO:
+// Here if x < fMIN_SGL_NORM_ARG and result zero;
+// I, U are set
+{ .mfb
+      mov             GR_Parameter_TAG = 17
+      nop.f           0                         // FR_RESULT already set
+      br.cond.sptk    __libm_error_region
+}
+;;
+
+GLOBAL_IEEE754_END(expf)
+libm_alias_float_other (__exp, exp)
+#ifdef SHARED
+.symver expf,expf@@GLIBC_2.27
+.weak __expf_compat
+.set __expf_compat,__expf
+.symver __expf_compat,expf@GLIBC_2.2
+#endif
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+      add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+      nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+      mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+      add sp=-64,sp                           // Create new stack
+      nop.f 0
+      mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+      stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
+      add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+      mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mfi
+      stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+      nop.f 0
+      add   GR_Parameter_RESULT = 0,GR_Parameter_Y // Parameter 3 address
+}
+{ .mib
+      stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
+      add   GR_Parameter_Y = -16,GR_Parameter_Y
+      br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+
+{ .mmi
+      add   GR_Parameter_RESULT = 48,sp
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mmi
+      ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+      add   sp = 64,sp                       // Restore stack pointer
+      mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+      mov   gp = GR_SAVE_GP                  // Restore gp
+      mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+      br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_expl.c
@@ -0,0 +1 @@
+/* Not needed. */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_fmod.S
@@ -0,0 +1,555 @@
+.file "fmod.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//====================================================================
+// 02/02/00 Initial version
+// 03/02/00 New Algorithm
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 11/28/00 Set FR_Y to f9
+// 03/11/02 Fixed flags for fmod(qnan,zero)
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 04/28/03 Fix: fmod(sNaN,0) no longer sets errno
+//
+// API
+//====================================================================
+// double fmod(double,double);
+//
+// Overview of operation
+//====================================================================
+//  fmod(a,b)=a-i*b,
+//  where i is an integer such that, if b!=0,
+//  |i|<|a/b| and |a/b-i|<1
+//
+// Algorithm
+//====================================================================
+// a). if |a|<|b|, return a
+// b). get quotient and reciprocal overestimates accurate to
+//     33 bits (q2,y2)
+// c). if the exponent difference (exponent(a)-exponent(b))
+//     is less than 32, truncate quotient to integer and
+//     finish in one iteration
+// d). if exponent(a)-exponent(b)>=32 (q2>=2^32)
+//     round quotient estimate to single precision (k=RN(q2)),
+//     calculate partial remainder (a'=a-k*b),
+//     get quotient estimate (a'*y2), and repeat from c).
+//
+// Special cases
+//====================================================================
+// b=+/-0: return NaN, call libm_error_support
+// a=+/-Inf, a=NaN or b=NaN: return NaN
+//
+// Registers used
+//====================================================================
+// Predicate registers: p6-p11
+// General registers:   r2,r29,r32 (ar.pfs), r33-r39
+// Floating point registers: f6-f15
+
+GR_SAVE_B0                    = r33
+GR_SAVE_PFS                   = r34
+GR_SAVE_GP                    = r35
+GR_SAVE_SP                    = r36
+
+GR_Parameter_X                = r37
+GR_Parameter_Y                = r38
+GR_Parameter_RESULT           = r39
+GR_Parameter_TAG              = r40
+
+FR_X             = f10
+FR_Y             = f9
+FR_RESULT        = f8
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(fmod)
+
+// inputs in f8, f9
+// result in f8
+
+{ .mfi
+  alloc r32=ar.pfs,1,4,4,0
+  // f6=|a|
+  fmerge.s f6=f0,f8
+  mov r2 = 0x0ffdd
+}
+  {.mfi
+  nop.m 0
+  // f7=|b|
+  fmerge.s f7=f0,f9
+  nop.i 0;;
+}
+
+{ .mfi
+  setf.exp f11 = r2
+  // (1) y0
+  frcpa.s1 f10,p6=f6,f7
+  nop.i 0
+}
+
+// Y +-NAN, +-inf, +-0?     p7
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p7,p0 = f9, 0xe7
+      nop.i 999;;
+}
+
+// qnan snan inf norm     unorm 0 -+
+// 1    1    1   0        0     0 11
+// e                      3
+// X +-NAN, +-inf, ?        p9
+
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p0 = f8, 0xe3
+      nop.i 999
+}
+
+// |x| < |y|? Return x p8
+{ .mfi
+      nop.m 999
+      fcmp.lt.unc.s1 p8,p0 = f6,f7
+      nop.i 999 ;;
+}
+
+{ .mfi
+  nop.m 0
+  // normalize y (if |x|<|y|)
+  (p8) fma.s0 f9=f9,f1,f0
+  nop.i 0;;
+}
+
+  { .mfi
+  mov r2=0x1001f
+  // (2) q0=a*y0
+  (p6) fma.s1 f13=f6,f10,f0
+  nop.i 0
+}
+{ .mfi
+  nop.m 0
+  // (3) e0 = 1 - b * y0
+  (p6) fnma.s1 f12=f7,f10,f1
+  nop.i 0;;
+}
+
+  {.mfi
+  nop.m 0
+  // normalize x (if |x|<|y|)
+  (p8) fma.d.s0 f8=f8,f1,f0
+  nop.i 0
+}
+{.bbb
+  (p9) br.cond.spnt FMOD_X_NAN_INF
+  (p7) br.cond.spnt FMOD_Y_NAN_INF_ZERO
+  // if |x|<|y|, return
+  (p8) br.ret.spnt    b0;;
+}
+
+  {.mfi
+  nop.m 0
+  // normalize x
+  fma.s0 f6=f6,f1,f0
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // normalize y
+  fma.s0 f7=f7,f1,f0
+  nop.i 0;;
+}
+
+  {.mfi
+  // f15=2^32
+  setf.exp f15=r2
+  // (4) q1=q0+e0*q0
+  (p6) fma.s1 f13=f12,f13,f13
+  nop.i 0
+}
+{ .mfi
+  nop.m 0
+  // (5) e1 = e0 * e0 + 2^-34
+  (p6) fma.s1 f14=f12,f12,f11
+  nop.i 0;;
+}
+{.mlx
+  nop.m 0
+  movl r2=0x33a00000;;
+}
+{ .mfi
+  nop.m 0
+  // (6) y1 = y0 + e0 * y0
+  (p6) fma.s1 f10=f12,f10,f10
+  nop.i 0;;
+}
+{.mfi
+  // set f12=1.25*2^{-24}
+  setf.s f12=r2
+  // (7) q2=q1+e1*q1
+  (p6) fma.s1 f13=f13,f14,f13
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  fmerge.s f9=f8,f9
+  nop.i 0
+}
+{ .mfi
+  nop.m 0
+  // (8) y2 = y1 + e1 * y1
+  (p6) fma.s1 f10=f14,f10,f10
+  // set p6=0, p10=0
+  cmp.ne.and p6,p10=r0,r0;;
+}
+
+.align 32
+loop53:
+  {.mfi
+  nop.m 0
+  // compare q2, 2^32
+  fcmp.lt.unc.s1 p8,p7=f13,f15
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // will truncate quotient to integer, if exponent<32 (in advance)
+  fcvt.fx.trunc.s1 f11=f13
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // if exponent>32, round quotient to single precision (perform in advance)
+  fma.s.s1 f13=f13,f1,f0
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // set f12=sgn(a)
+  (p8) fmerge.s f12=f8,f1
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // normalize truncated quotient
+  (p8) fcvt.xf f13=f11
+  nop.i 0;;
+}
+  { .mfi
+  nop.m 0
+  // calculate remainder (assuming f13=RZ(Q))
+  (p7) fnma.s1 f14=f13,f7,f6
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // also if exponent>32, round quotient to single precision
+  // and subtract 1 ulp: q=q-q*(1.25*2^{-24})
+  (p7) fnma.s.s1 f11=f13,f12,f13
+  nop.i 0;;
+}
+
+  {.mfi
+  nop.m 0
+  // (p8) calculate remainder (82-bit format)
+  (p8) fnma.s1 f11=f13,f7,f6
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // (p7) calculate remainder (assuming f11=RZ(Q))
+  (p7) fnma.s1 f6=f11,f7,f6
+  nop.i 0;;
+}
+
+
+  {.mfi
+  nop.m 0
+  // Final iteration (p8): is f6 the correct remainder (quotient was not overestimated) ?
+  (p8) fcmp.lt.unc.s1 p6,p10=f11,f0
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // get new quotient estimation: a'*y2
+  (p7) fma.s1 f13=f14,f10,f0
+  nop.i 0
+}
+  {.mfb
+  nop.m 0
+  // was f14=RZ(Q) ? (then new remainder f14>=0)
+  (p7) fcmp.lt.unc.s1 p7,p9=f14,f0
+  nop.b 0;;
+}
+
+
+.pred.rel "mutex",p6,p10
+  {.mfb
+  nop.m 0
+  // add b to estimated remainder (to cover the case when the quotient was overestimated)
+  // also set correct sign by using f9=|b|*sgn(a), f12=sgn(a)
+  (p6) fma.d.s0 f8=f11,f12,f9
+  nop.b 0
+}
+  {.mfb
+  nop.m 0
+  // calculate remainder (single precision)
+  // set correct sign of result before returning
+  (p10) fma.d.s0 f8=f11,f12,f0
+  (p8) br.ret.sptk b0;;
+}
+  {.mfi
+  nop.m 0
+  // if f13!=RZ(Q), get alternative quotient estimation: a''*y2
+  (p7) fma.s1 f13=f6,f10,f0
+  nop.i 0
+}
+  {.mfb
+  nop.m 0
+  // if f14 was RZ(Q), set remainder to f14
+  (p9) mov f6=f14
+  br.cond.sptk loop53;;
+}
+
+
+
+FMOD_X_NAN_INF:
+
+// Y zero ?
+{.mfi
+  nop.m 0
+  fclass.m p10,p0=f8,0xc3     // Test x=nan
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  fma.s1 f10=f9,f1,f0
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  fma.s0 f8=f8,f1,f0
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+(p10) fclass.m p10,p0=f9,0x07 // Test x=nan, and y=zero
+  nop.i 0;;
+}
+
+{.mfb
+ nop.m 0
+ fcmp.eq.unc.s1 p11,p0=f10,f0
+(p10) br.ret.spnt b0;;        // Exit with result=x if x=nan and y=zero
+}
+{.mib
+  nop.m 0
+  nop.i 0
+  // if Y zero
+  (p11) br.cond.spnt FMOD_Y_ZERO;;
+}
+
+// X infinity? Return QNAN indefinite
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p8,p9 = f8, 0x23
+      nop.i 999;;
+}
+// Y NaN ?
+{.mfi
+     nop.m 999
+(p8) fclass.m p9,p8=f9,0xc3
+     nop.i 0;;
+}
+{.mfi
+      nop.m 999
+(p8)  frcpa.s0 f8,p0 = f8,f8
+      nop.i 0
+}
+{ .mfi
+      nop.m 999
+    // also set Denormal flag if necessary
+(p8)  fma.s0 f9=f9,f1,f0
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p8)  fma.d.s0 f8=f8,f1,f0
+      nop.b 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p9)  frcpa.s0 f8,p7=f8,f9
+      br.ret.sptk   b0 ;;
+}
+
+
+FMOD_Y_NAN_INF_ZERO:
+
+// Y INF
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p7,p0 = f9, 0x23
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p7)  fma.d.s0 f8=f8,f1,f0
+(p7)  br.ret.spnt    b0 ;;
+}
+
+// Y NAN?
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p0 = f9, 0xc3
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p9)  fma.d.s0 f8=f9,f1,f0
+(p9)  br.ret.spnt    b0 ;;
+}
+
+FMOD_Y_ZERO:
+// Y zero? Must be zero at this point
+// because it is the only choice left.
+// Return QNAN indefinite
+
+{.mfi
+  nop.m 0
+  // set Invalid
+  frcpa.s0 f12,p0=f0,f0
+  nop.i 0
+}
+// X NAN?
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p10 = f8, 0xc3
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10)  fclass.nm  p9,p10 = f8, 0xff
+      nop.i 999 ;;
+}
+
+{.mfi
+ nop.m 999
+ (p9) frcpa.s0 f11,p7=f8,f0
+ nop.i 0;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)  frcpa.s0         f11,p7 = f9,f9
+      mov        GR_Parameter_TAG = 121 ;;
+}
+
+{ .mfi
+      nop.m 999
+      fmerge.s      f10 = f8, f8
+      nop.i 999
+}
+
+{ .mfb
+      nop.m 999
+      fma.d.s0 f8=f11,f1,f0
+      br.sptk __libm_error_region;;
+}
+
+GLOBAL_IEEE754_END(fmod)
+libm_alias_double_other (__fmod, fmod)
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfd [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfd [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+    nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfd [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#  // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_fmodf.S
@@ -0,0 +1,569 @@
+.file "fmodf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//====================================================================
+// 02/02/00 Initial version
+// 03/02/00 New Algorithm
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 11/28/00 Set FR_Y to f9
+// 03/11/02 Fixed flags for fmodf(qnan,zero)
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 04/28/03 Fix: fmod(sNaN,0) no longer sets errno
+//
+// API
+//====================================================================
+// float fmodf(float,float);
+//
+// Overview of operation
+//====================================================================
+//  fmod(a,b)=a-i*b,
+//  where i is an integer such that, if b!=0,
+//  |i|<|a/b| and |a/b-i|<1
+
+// Algorithm
+//====================================================================
+// a). if |a|<|b|, return a
+// b). get quotient and reciprocal overestimates accurate to
+//     33 bits (q2,y2)
+// c). if the exponent difference (exponent(a)-exponent(b))
+//     is less than 32, truncate quotient to integer and
+//     finish in one iteration
+// d). if exponent(a)-exponent(b)>=32 (q2>=2^32)
+//     round quotient estimate to single precision (k=RN(q2)),
+//     calculate partial remainder (a'=a-k*b),
+//     get quotient estimate (a'*y2), and repeat from c).
+
+// Special cases
+//====================================================================
+// b=+/-0: return NaN, call libm_error_support
+// a=+/-Inf, a=NaN or b=NaN: return NaN
+
+// Registers used
+//====================================================================
+// Predicate registers: p6-p11
+// General registers:   r2,r29,r32 (ar.pfs), r33-r39
+// Floating point registers: f6-f15
+
+GR_SAVE_B0                    = r33
+GR_SAVE_PFS                   = r34
+GR_SAVE_GP                    = r35
+GR_SAVE_SP                    = r36
+
+GR_Parameter_X                = r37
+GR_Parameter_Y                = r38
+GR_Parameter_RESULT           = r39
+GR_Parameter_TAG              = r40
+
+FR_X             = f10
+FR_Y             = f9
+FR_RESULT        = f8
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(fmodf)
+
+// inputs in f8, f9
+// result in f8
+
+{ .mfi
+  alloc r32=ar.pfs,1,4,4,0
+  // f6=|a|
+  fmerge.s f6=f0,f8
+  mov r2 = 0x0ffdd
+}
+  {.mfi
+  nop.m 0
+  // f7=|b|
+  fmerge.s f7=f0,f9
+  nop.i 0;;
+}
+
+{ .mfi
+  setf.exp f11 = r2
+  // (1) y0
+  frcpa.s1 f10,p6=f6,f7
+  nop.i 0
+}
+
+// eliminate special cases
+// Y +-NAN, +-inf, +-0?     p7
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p7,p0 = f9, 0xe7
+      nop.i 999;;
+}
+
+// qnan snan inf norm     unorm 0 -+
+// 1    1    1   0        0     0 11
+// e                      3
+// X +-NAN, +-inf, ?        p9
+
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p0 = f8, 0xe3
+      nop.i 999
+}
+
+// |x| < |y|? Return x p8
+{ .mfi
+      nop.m 999
+      fcmp.lt.unc.s1 p8,p0 = f6,f7
+      nop.i 999 ;;
+}
+
+{ .mfi
+  nop.m 0
+  // normalize y (if |x|<|y|)
+  (p8) fma.s0 f9=f9,f1,f0
+  nop.i 0;;
+}
+
+  { .mfi
+  mov r2=0x1001f
+  // (2) q0=a*y0
+  (p6) fma.s1 f13=f6,f10,f0
+  nop.i 0
+}
+{ .mfi
+  nop.m 0
+  // (3) e0 = 1 - b * y0
+  (p6) fnma.s1 f12=f7,f10,f1
+  nop.i 0;;
+}
+
+  {.mfi
+  nop.m 0
+  // normalize x (if |x|<|y|)
+  (p8) fma.s.s0 f8=f8,f1,f0
+  nop.i 0
+}
+{.bbb
+  (p9) br.cond.spnt FMOD_X_NAN_INF
+  (p7) br.cond.spnt FMOD_Y_NAN_INF_ZERO
+  // if |x|<|y|, return
+  (p8) br.ret.spnt    b0;;
+}
+
+  {.mfi
+  nop.m 0
+  // normalize x
+  fma.s0 f6=f6,f1,f0
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // normalize y
+  fma.s0 f7=f7,f1,f0
+  nop.i 0;;
+}
+
+
+  {.mfi
+  // f15=2^32
+  setf.exp f15=r2
+  // (4) q1=q0+e0*q0
+  (p6) fma.s1 f13=f12,f13,f13
+  nop.i 0
+}
+{ .mfi
+  nop.m 0
+  // (5) e1 = e0 * e0 + 2^-34
+  (p6) fma.s1 f14=f12,f12,f11
+  nop.i 0;;
+}
+{.mlx
+  nop.m 0
+  movl r2=0x33a00000;;
+}
+{ .mfi
+  nop.m 0
+  // (6) y1 = y0 + e0 * y0
+  (p6) fma.s1 f10=f12,f10,f10
+  nop.i 0;;
+}
+{.mfi
+  // set f12=1.25*2^{-24}
+  setf.s f12=r2
+  // (7) q2=q1+e1*q1
+  (p6) fma.s1 f13=f13,f14,f13
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  fmerge.s f9=f8,f9
+  nop.i 0
+}
+{ .mfi
+  nop.m 0
+  // (8) y2 = y1 + e1 * y1
+  (p6) fma.s1 f10=f14,f10,f10
+  // set p6=0, p10=0
+  cmp.ne.and p6,p10=r0,r0;;
+}
+
+.align 32
+loop24:
+  {.mfi
+  nop.m 0
+  // compare q2, 2^32
+  fcmp.lt.unc.s1 p8,p7=f13,f15
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // will truncate quotient to integer, if exponent<32 (in advance)
+  fcvt.fx.trunc.s1 f11=f13
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // if exponent>32, round quotient to single precision (perform in advance)
+  fma.s.s1 f13=f13,f1,f0
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // set f12=sgn(a)
+  (p8) fmerge.s f12=f8,f1
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // normalize truncated quotient
+  (p8) fcvt.xf f13=f11
+  nop.i 0;;
+}
+  { .mfi
+  nop.m 0
+  // calculate remainder (assuming f13=RZ(Q))
+  (p7) fnma.s1 f14=f13,f7,f6
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // also if exponent>32, round quotient to single precision
+  // and subtract 1 ulp: q=q-q*(1.25*2^{-24})
+  (p7) fnma.s.s1 f11=f13,f12,f13
+  nop.i 0;;
+}
+
+  {.mfi
+  nop.m 0
+  // (p8) calculate remainder (82-bit format)
+  (p8) fnma.s1 f11=f13,f7,f6
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // (p7) calculate remainder (assuming f11=RZ(Q))
+  (p7) fnma.s1 f6=f11,f7,f6
+  nop.i 0;;
+}
+
+
+  {.mfi
+  nop.m 0
+  // Final iteration (p8): is f6 the correct remainder (quotient was not overestimated) ?
+  (p8) fcmp.lt.unc.s1 p6,p10=f11,f0
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // get new quotient estimation: a'*y2
+  (p7) fma.s1 f13=f14,f10,f0
+  nop.i 0
+}
+  {.mfb
+  nop.m 0
+  // was f14=RZ(Q) ? (then new remainder f14>=0)
+  (p7) fcmp.lt.unc.s1 p7,p9=f14,f0
+  nop.b 0;;
+}
+
+
+.pred.rel "mutex",p6,p10
+  {.mfb
+  nop.m 0
+  // add b to estimated remainder (to cover the case when the quotient was overestimated)
+  // also set correct sign by using f9=|b|*sgn(a), f12=sgn(a)
+  (p6) fma.s.s0 f8=f11,f12,f9
+  nop.b 0
+}
+  {.mfb
+  nop.m 0
+  // calculate remainder (single precision)
+  // set correct sign of result before returning
+  (p10) fma.s.s0 f8=f11,f12,f0
+  (p8) br.ret.sptk b0;;
+}
+  {.mfi
+  nop.m 0
+  // if f13!=RZ(Q), get alternative quotient estimation: a''*y2
+  (p7) fma.s1 f13=f6,f10,f0
+  nop.i 0
+}
+  {.mfb
+  nop.m 0
+  // if f14 was RZ(Q), set remainder to f14
+  (p9) mov f6=f14
+  br.cond.sptk loop24;;
+}
+
+  {  .mmb
+    nop.m 0
+    nop.m 0
+    br.ret.sptk b0;;
+ }
+
+FMOD_X_NAN_INF:
+
+
+// Y zero ?
+{.mfi
+  nop.m 0
+  fclass.m p10,p0=f8,0xc3     // Test x=nan
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  fma.s1 f10=f9,f1,f0
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  fma.s0 f8=f8,f1,f0
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+(p10) fclass.m p10,p0=f9,0x07 // Test x=nan, and y=zero
+  nop.i 0;;
+}
+{.mfb
+ nop.m 0
+ fcmp.eq.unc.s1 p11,p0=f10,f0
+(p10) br.ret.spnt b0;;        // Exit with result=x if x=nan and y=zero
+}
+{.mib
+  nop.m 0
+  nop.i 0
+  // if Y zero
+  (p11) br.cond.spnt FMOD_Y_ZERO;;
+}
+
+// X infinity? Return QNAN indefinite
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p8,p9 = f8, 0x23
+      nop.i 999;;
+}
+// Y NaN ?
+{.mfi
+     nop.m 999
+(p8) fclass.m p9,p8=f9,0xc3
+     nop.i 0;;
+}
+{.mfi
+    nop.m 999
+(p8)  frcpa.s0 f8,p0 = f8,f8
+    nop.i 0
+}
+{ .mfi
+      nop.m 999
+    // also set Denormal flag if necessary
+(p8)  fma.s0 f9=f9,f1,f0
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p8)  fma.s.s0 f8=f8,f1,f0
+      nop.b 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p9)  frcpa.s0 f8,p7=f8,f9
+      br.ret.sptk    b0 ;;
+}
+
+
+FMOD_Y_NAN_INF_ZERO:
+
+// Y INF
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p7,p0 = f9, 0x23
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p7)  fma.s.s0 f8=f8,f1,f0
+(p7)  br.ret.spnt    b0 ;;
+}
+
+// Y NAN?
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p0 = f9, 0xc3
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p9)  fma.s.s0 f8=f9,f1,f0
+(p9)  br.ret.spnt    b0 ;;
+}
+
+FMOD_Y_ZERO:
+// Y zero? Must be zero at this point
+// because it is the only choice left.
+// Return QNAN indefinite
+
+{.mfi
+  nop.m 0
+  // set Invalid
+  frcpa.s0 f12,p0=f0,f0
+  nop.i 999
+}
+// X NAN?
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p10 = f8, 0xc3
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10)  fclass.nm  p9,p10 = f8, 0xff
+      nop.i 999 ;;
+}
+
+{.mfi
+ nop.m 999
+ (p9) frcpa.s0 f11,p7=f8,f0
+ nop.i 0;;
+}
+
+{ .mfi
+      nop.m 999
+(p10) frcpa.s0 f11,p7 = f0,f0
+nop.i 999;;
+}
+
+{ .mfi
+      nop.m 999
+      fmerge.s      f10 = f8, f8
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+      fma.s.s0 f8=f11,f1,f0
+      nop.i 999;;
+}
+
+EXP_ERROR_RETURN:
+
+
+{ .mib
+      nop.m 0
+      mov GR_Parameter_TAG=122
+      br.sptk __libm_error_region;;
+}
+
+GLOBAL_IEEE754_END(fmodf)
+libm_alias_float_other (__fmod, fmod)
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfs [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+    nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfs [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#;;  // Call error handling function
+}
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_fmodl.S
@@ -0,0 +1,672 @@
+.file "fmodl.s"
+
+
+// Copyright (c) 2000 - 2004, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//====================================================================
+// 02/02/00 Initial version
+// 03/02/00 New Algorithm
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+// set [ the previously overwritten ] GR_Parameter_RESULT.
+// 11/28/00 Set FR_Y to f9
+// 03/11/02 Fixed flags for fmodl(qnan, zero)
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header:.section,.global,.proc,.align
+// 04/28/03 Fix: fmod(sNaN, 0) no longer sets errno
+// 11/23/04 Reformatted routine and improved speed
+//
+// API
+//====================================================================
+// long double fmodl(long double, long double);
+//
+// Overview of operation
+//====================================================================
+// fmod(a, b)= a-i*b,
+// where i is an integer such that, if b!= 0,
+// |i|<|a/b| and |a/b-i|<1
+//
+// Algorithm
+//====================================================================
+// a). if |a|<|b|, return a
+// b). get quotient and reciprocal overestimates accurate to
+// 33 bits (q2, y2)
+// c). if the exponent difference (exponent(a)-exponent(b))
+// is less than 32, truncate quotient to integer and
+// finish in one iteration
+// d). if exponent(a)-exponent(b)>= 32 (q2>= 2^32)
+// round quotient estimate to single precision (k= RN(q2)),
+// calculate partial remainder (a'= a-k*b),
+// get quotient estimate (a'*y2), and repeat from c).
+//
+// Registers used
+//====================================================================
+
+GR_SMALLBIASEXP     = r2
+GR_2P32             = r3
+GR_SMALLBIASEXP     = r20
+GR_ROUNDCONST       = r21
+GR_SIG_B            = r22
+GR_ARPFS            = r23
+GR_TMP1             = r24
+GR_TMP2             = r25
+GR_TMP3             = r26
+
+GR_SAVE_B0          = r33
+GR_SAVE_PFS         = r34
+GR_SAVE_GP          = r35
+GR_SAVE_SP          = r36
+
+GR_Parameter_X      = r37
+GR_Parameter_Y      = r38
+GR_Parameter_RESULT = r39
+GR_Parameter_TAG    = r40
+
+FR_X                = f10
+FR_Y                = f9
+FR_RESULT           = f8
+
+FR_ABS_A            = f6
+FR_ABS_B            = f7
+FR_Y_INV            = f10
+FR_SMALLBIAS        = f11
+FR_E0               = f12
+FR_Q                = f13
+FR_E1               = f14
+FR_2P32             = f15
+FR_TMPX             = f32
+FR_TMPY             = f33
+FR_ROUNDCONST       = f34
+FR_QINT             = f35
+FR_QRND24           = f36
+FR_NORM_B           = f37
+FR_TMP              = f38
+FR_TMP2             = f39
+FR_DFLAG            = f40
+FR_Y_INV0           = f41
+FR_Y_INV1           = f42
+FR_Q0               = f43
+FR_Q1               = f44
+FR_QINT_Z           = f45
+FR_QREM             = f46
+FR_B_SGN_A          = f47
+
+.section .text
+GLOBAL_IEEE754_ENTRY(fmodl)
+
+// inputs in f8, f9
+// result in f8
+
+{ .mfi
+       getf.sig GR_SIG_B = f9
+       // FR_ABS_A = |a|
+       fmerge.s FR_ABS_A = f0, f8
+       mov GR_SMALLBIASEXP = 0x0ffdd
+}
+{ .mfi
+       nop.m 0
+       // FR_ABS_B = |b|
+       fmerge.s FR_ABS_B = f0, f9
+       nop.i 0
+}
+;;
+
+{ .mfi
+       setf.exp FR_SMALLBIAS = GR_SMALLBIASEXP
+       // (1) y0
+       frcpa.s1 FR_Y_INV0, p6 = FR_ABS_A, FR_ABS_B
+       nop.i 0
+}
+;;
+
+{ .mlx
+       nop.m 0
+       movl GR_ROUNDCONST = 0x33a00000
+}
+;;
+
+// eliminate special cases
+{ .mmi
+       nop.m 0
+       nop.m 0
+       // y pseudo-zero ?
+       cmp.eq p7, p10 = GR_SIG_B, r0
+}
+;;
+
+// set p7 if b +/-NAN, +/-inf, +/-0
+{ .mfi
+       nop.m 0
+ (p10) fclass.m p7, p10 = f9, 0xe7
+       nop.i 0
+}
+;;
+
+{ .mfi
+       mov GR_2P32 = 0x1001f
+       // (2) q0 = a*y0
+ (p6)  fma.s1 FR_Q0 = FR_ABS_A, FR_Y_INV0, f0
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       // (3) e0 = 1 - b * y0
+ (p6)  fnma.s1 FR_E0 = FR_ABS_B, FR_Y_INV0, f1
+       nop.i 0
+}
+;;
+
+// set p9 if a +/-NAN, +/-inf
+{ .mfi
+       nop.m 0
+       fclass.m.unc p9, p11 = f8, 0xe3
+       nop.i 0
+}
+       // |a| < |b|? Return a, p8=1
+{ .mfi
+       nop.m 0
+ (p10) fcmp.lt.unc.s1 p8, p0 = FR_ABS_A, FR_ABS_B
+       nop.i 0
+}
+;;
+
+// set p7 if b +/-NAN, +/-inf, +/-0
+{ .mfi
+       nop.m 0
+       // pseudo-NaN ?
+ (p10) fclass.nm p7, p0 = f9, 0xff
+       nop.i 0
+}
+;;
+
+// set p9 if a is +/-NaN, +/-Inf
+{ .mfi
+       nop.m 0
+ (p11) fclass.nm p9, p0 = f8, 0xff
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       // b denormal ? set D flag (if |a|<|b|)
+ (p8)  fnma.s0 FR_DFLAG = f9, f1, f9
+       nop.i 0
+}
+;;
+
+{ .mfi
+       // FR_2P32 = 2^32
+       setf.exp FR_2P32 = GR_2P32
+       // (4) q1 = q0+e0*q0
+ (p6)  fma.s1 FR_Q1 = FR_E0, FR_Q0, FR_Q0
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       // (5) e1 = e0 * e0 + 2^-34
+ (p6)  fma.s1 FR_E1 = FR_E0, FR_E0, FR_SMALLBIAS
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // normalize a (if |a|<|b|)
+ (p8)  fma.s0 f8 = f8, f1, f0
+       nop.i 0
+}
+{ .bbb
+ (p9) br.cond.spnt FMOD_A_NAN_INF
+ (p7) br.cond.spnt FMOD_B_NAN_INF_ZERO
+       // if |a|<|b|, return
+ (p8) br.ret.spnt b0
+}
+;;
+
+
+{ .mfi
+       nop.m 0
+       // (6) y1 = y0 + e0 * y0
+ (p6)  fma.s1 FR_Y_INV1 = FR_E0, FR_Y_INV0, FR_Y_INV0
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // a denormal ? set D flag
+       // b denormal ? set D flag
+       fcmp.eq.s0 p12,p0 = FR_ABS_A, FR_ABS_B
+       nop.i 0
+}
+{ .mfi
+       // set FR_ROUNDCONST = 1.25*2^{-24}
+       setf.s FR_ROUNDCONST = GR_ROUNDCONST
+       // (7) q2 = q1+e1*q1
+ (p6)  fma.s1 FR_Q = FR_Q1, FR_E1, FR_Q1
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       fmerge.s FR_B_SGN_A = f8, f9
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       // (8) y2 = y1 + e1 * y1
+ (p6)  fma.s1 FR_Y_INV = FR_E1, FR_Y_INV1, FR_Y_INV1
+       // set p6 = 0, p10 = 0
+       cmp.ne.and p6, p10 = r0, r0
+}
+;;
+
+//   will compute integer quotient bits (24 bits per iteration)
+.align 32
+loop64:
+{ .mfi
+       nop.m 0
+       // compare q2, 2^32
+       fcmp.lt.unc.s1 p8, p7 = FR_Q, FR_2P32
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       // will truncate quotient to integer, if exponent<32 (in advance)
+       fcvt.fx.trunc.s1 FR_QINT = FR_Q
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // if exponent>32 round quotient to single precision (perform in advance)
+       fma.s.s1 FR_QRND24 = FR_Q, f1, f0
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // set FR_ROUNDCONST = sgn(a)
+ (p8)  fmerge.s FR_ROUNDCONST = f8, f1
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       // normalize truncated quotient
+ (p8)  fcvt.xf FR_QRND24 = FR_QINT
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // calculate remainder (assuming FR_QRND24 = RZ(Q))
+ (p7)  fnma.s1 FR_E1 = FR_QRND24, FR_ABS_B, FR_ABS_A
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       // also if exponent>32, round quotient to single precision
+       // and subtract 1 ulp: q = q-q*(1.25*2^{-24})
+ (p7)  fnma.s.s1 FR_QINT_Z = FR_QRND24, FR_ROUNDCONST, FR_QRND24
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // (p8) calculate remainder (82-bit format)
+ (p8)  fnma.s1 FR_QREM = FR_QRND24, FR_ABS_B, FR_ABS_A
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       // (p7) calculate remainder (assuming FR_QINT_Z = RZ(Q))
+ (p7)  fnma.s1 FR_ABS_A = FR_QINT_Z, FR_ABS_B, FR_ABS_A
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // Final iteration (p8): is FR_ABS_A the correct remainder
+       // (quotient was not overestimated) ?
+ (p8)  fcmp.lt.unc.s1 p6, p10 = FR_QREM, f0
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // get new quotient estimation: a'*y2
+ (p7)  fma.s1 FR_Q = FR_E1, FR_Y_INV, f0
+       nop.i 0
+}
+{ .mfb
+       nop.m 0
+       // was FR_Q = RZ(Q) ? (then new remainder FR_E1> = 0)
+ (p7)  fcmp.lt.unc.s1 p7, p9 = FR_E1, f0
+       nop.b 0
+}
+;;
+
+.pred.rel "mutex", p6, p10
+{ .mfb
+       nop.m 0
+       // add b to estimated remainder (to cover the case when the quotient was
+       // overestimated)
+       // also set correct sign by using
+       // FR_B_SGN_A = |b|*sgn(a), FR_ROUNDCONST = sgn(a)
+ (p6)  fma.s0 f8 = FR_QREM, FR_ROUNDCONST, FR_B_SGN_A
+       nop.b 0
+}
+{ .mfb
+       nop.m 0
+       // set correct sign of result before returning: FR_ROUNDCONST = sgn(a)
+ (p10) fma.s0 f8 = FR_QREM, FR_ROUNDCONST, f0
+ (p8)  br.ret.sptk b0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // if f13! = RZ(Q), get alternative quotient estimation: a''*y2
+ (p7)  fma.s1 FR_Q = FR_ABS_A, FR_Y_INV, f0
+       nop.i 0
+}
+{ .mfb
+       nop.m 0
+       // if FR_E1 was RZ(Q), set remainder to FR_E1
+ (p9)  fma.s1 FR_ABS_A = FR_E1, f1, f0
+       br.cond.sptk loop64
+}
+;;
+
+FMOD_A_NAN_INF:
+
+// b zero ?
+{ .mfi
+       nop.m 0
+       fclass.m p10, p0 = f8, 0xc3 // Test a = nan
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       fma.s1 FR_NORM_B = f9, f1, f0
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       fma.s0 f8 = f8, f1, f0
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+ (p10) fclass.m p10, p0 = f9, 0x07 // Test x = nan, and y = zero
+       nop.i 0
+}
+;;
+
+{ .mfb
+       nop.m 0
+       fcmp.eq.unc.s1 p11, p0 = FR_NORM_B, f0
+ (p10) br.ret.spnt b0 // Exit with result = a if a = nan and b = zero
+}
+;;
+
+{ .mib
+       nop.m 0
+       nop.i 0
+       // if Y zero
+ (p11) br.cond.spnt FMOD_B_ZERO
+}
+;;
+
+// a= infinity? Return QNAN indefinite
+{ .mfi
+       // set p7 t0 0
+       cmp.ne p7, p0 = r0, r0
+       fclass.m.unc p8, p9 = f8, 0x23
+       nop.i 0
+}
+;;
+
+// b NaN ?
+{ .mfi
+       nop.m 0
+ (p8)  fclass.m p9, p8 = f9, 0xc3
+       nop.i 0
+}
+;;
+
+// b not pseudo-zero ? (GR_SIG_B holds significand)
+{ .mii
+       nop.m 0
+ (p8)  cmp.ne p7, p0 = GR_SIG_B, r0
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+ (p8)  frcpa.s0 f8, p0 = f8, f8
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       // also set Denormal flag if necessary
+ (p7)  fnma.s0 f9 = f9, f1, f9
+       nop.i 0
+}
+;;
+
+{ .mfb
+       nop.m 0
+ (p8)  fma.s0 f8 = f8, f1, f0
+       nop.b 0
+}
+;;
+
+{ .mfb
+       nop.m 0
+ (p9)  frcpa.s0 f8, p7 = f8, f9
+       br.ret.sptk b0
+}
+;;
+
+FMOD_B_NAN_INF_ZERO:
+// b INF
+{ .mfi
+       nop.m 0
+       fclass.m.unc p7, p0 = f9, 0x23
+       nop.i 0
+}
+;;
+
+{ .mfb
+       nop.m 0
+ (p7)  fma.s0 f8 = f8, f1, f0
+ (p7)  br.ret.spnt b0
+}
+;;
+
+// b NAN?
+{ .mfi
+       nop.m 0
+       fclass.m.unc p9, p10 = f9, 0xc3
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+ (p10) fclass.nm p9, p0 = f9, 0xff
+       nop.i 0
+}
+;;
+
+{ .mfb
+       nop.m 0
+ (p9)  fma.s0 f8 = f9, f1, f0
+ (p9)  br.ret.spnt b0
+}
+;;
+
+FMOD_B_ZERO:
+// Y zero? Must be zero at this point
+// because it is the only choice left.
+// Return QNAN indefinite
+
+{ .mfi
+       nop.m 0
+       // set Invalid
+       frcpa.s0 FR_TMP, p0 = f0, f0
+       nop.i 0
+}
+;;
+
+// a NAN?
+{ .mfi
+       nop.m 0
+       fclass.m.unc p9, p10 = f8, 0xc3
+       nop.i 0
+}
+;;
+
+{ .mfi
+       alloc GR_ARPFS = ar.pfs, 1, 4, 4, 0
+ (p10) fclass.nm p9, p10 = f8, 0xff
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+ (p9)  frcpa.s0 FR_TMP2, p7 = f8, f0
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+ (p10) frcpa.s0 FR_TMP2, p7 = f9, f9
+       mov GR_Parameter_TAG = 120
+}
+;;
+
+{ .mfi
+       nop.m 0
+       fmerge.s FR_X = f8, f8
+       nop.i 0
+}
+{ .mfb
+       nop.m 0
+       fma.s0 f8 = FR_TMP2, f1, f0
+       br.sptk __libm_error_region
+}
+;;
+
+GLOBAL_IEEE754_END(fmodl)
+libm_alias_ldouble_other (__fmod, fmod)
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+       add GR_Parameter_Y = -32, sp // Parameter 2 value
+       nop.f 0
+.save ar.pfs, GR_SAVE_PFS
+       mov GR_SAVE_PFS = ar.pfs     // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+       add sp = -64, sp             // Create new stack
+       nop.f 0
+       mov GR_SAVE_GP = gp          // Save gp
+}
+;;
+
+{ .mmi
+       stfe [ GR_Parameter_Y ] = FR_Y, 16 // Save Parameter 2 on stack
+       add GR_Parameter_X = 16, sp  // Parameter 1 address
+.save b0, GR_SAVE_B0
+       mov GR_SAVE_B0 = b0          // Save b0
+}
+;;
+
+.body
+{ .mib
+       stfe [ GR_Parameter_X ] = FR_X // Store Parameter 1 on stack
+       add GR_Parameter_RESULT = 0, GR_Parameter_Y
+       nop.b 0                      // Parameter 3 address
+}
+{ .mib
+       stfe [ GR_Parameter_Y ] = FR_RESULT // Store Parameter 3 on stack
+       add GR_Parameter_Y = -16, GR_Parameter_Y
+       br.call.sptk b0 = __libm_error_support# // Call error handling function
+}
+;;
+
+{ .mmi
+       nop.m 0
+       nop.m 0
+       add GR_Parameter_RESULT = 48, sp
+}
+;;
+
+{ .mmi
+       ldfe f8 = [ GR_Parameter_RESULT ] // Get return result off stack
+.restore sp
+       add sp = 64, sp                   // Restore stack pointer
+       mov b0 = GR_SAVE_B0               // Restore return address
+}
+;;
+
+{ .mib
+       mov gp = GR_SAVE_GP               // Restore gp
+       mov ar.pfs = GR_SAVE_PFS          // Restore ar.pfs
+       br.ret.sptk b0                    // Return
+}
+;;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type __libm_error_support#, @function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_gamma_r.c
@@ -0,0 +1 @@
+/* Not needed. */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_gammaf_r.c
@@ -0,0 +1 @@
+/* Not needed. */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_gammal_r.c
@@ -0,0 +1 @@
+/* Not needed. */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_hypot.S
@@ -0,0 +1,438 @@
+.file "hypot.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 02/02/00 hand-optimized
+// 04/04/00 Unwind support added
+// 06/20/00 new version
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 04/17/03 Added missing mutex directive
+//
+//*********************************************************************
+//                           ___________
+// Function:   hypot(x,y) = |(x^2 + y^2) = for double precision values
+//             x and y
+//             Also provides cabs functionality.
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8  (Input and Return Value)
+//                              f9  (Input)
+//                              f6 -f15, f32-f34
+//
+//    General Purpose Registers:
+//      r2,r3,r29 (Scratch)
+//      r32-r36 (Locals)
+//      r37-r40 (Used to pass arguments to error handling routine)
+//
+//    Predicate Registers:      p6 - p10
+//
+//*********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    All faults and exceptions should be raised correctly.
+//    Overflow can occur.
+//    hypot(Infinity and anything) = +Infinity
+//    hypot(QNaN and anything) = QNaN
+//    hypot(SNaN and anything ) = QNaN
+//
+//*********************************************************************
+//
+// Implementation:
+//  x2 = x * x   in double-extended
+//  y2 = y * y   in double-extended
+//  temp = x2 + y2   in double-extended
+//  sqrt(temp) rounded to double
+//
+//*********************************************************************
+
+GR_SAVE_PFS         = r33
+GR_SAVE_B0          = r34
+GR_SAVE_GP          = r35
+GR_Parameter_X      = r36
+GR_Parameter_Y      = r37
+GR_Parameter_RESULT = r38
+GR_Parameter_TAG    = r39
+
+FR_X                = f32
+FR_Y                = f33
+FR_RESULT           = f8
+
+.section .text
+
+LOCAL_LIBM_ENTRY(cabs)
+LOCAL_LIBM_END(cabs)
+
+GLOBAL_IEEE754_ENTRY(hypot)
+
+{.mfi
+  alloc r32= ar.pfs,0,4,4,0
+  // Compute x*x
+  fma.s1 f10=f8,f8,f0
+  // r2=bias-1
+  mov r2=0xfffe
+}
+{.mfi
+  // 63/8
+  mov r3=0x40fc //0000
+  // y*y
+  fma.s1 f11=f9,f9,f0
+  // r29=429/16
+  mov r29=0x41d68;; //000
+}
+
+{ .mfi
+     nop.m 0
+//   Check if x is an Inf - if so return Inf even
+//   if y is a NaN (C9X)
+     fclass.m.unc p7, p6 = f8, 0x023
+     shl r3=r3,16
+}
+{.mfi
+	nop.m 0
+  // if possible overflow, copy f8 to f32
+  // set Denormal, if necessary
+  // (p8)
+  fma.d.s0 f32=f8,f1,f0
+  nop.i 0;;
+}
+{ .mfi
+     nop.m 0
+//   Check if y is an Inf - if so return Inf even
+//   if x is a NaN (C9X)
+     fclass.m.unc p8, p9 = f9, 0x023
+     shl r29=r29,12
+}
+{ .mfb
+	 // f7=0.5
+	 setf.exp f7=r2
+//   For x=inf, multiply y by 1 to raise invalid on y an SNaN
+//   (p7) fma.s0 f9=f9,f1,f0
+     // copy f9 to f33; set Denormal, if necessary
+	 fma.d.s0 f33=f9,f1,f0
+     nop.b 0;;
+}
+{.mfb
+  // f13=63/8
+  setf.s f13=r3
+  // is y Zero ?
+  (p6) fclass.m p6,p0=f9,0x7
+  nop.b 0
+}
+{.mlx
+  nop.m 0
+  movl r2=0x408c0000;;
+}
+
+{.mfi
+  // f34=429/16
+  setf.s f34=r29
+  // is x Zero ?
+  (p9) fclass.m p9,p0=f8,0x7
+  // 231/16
+  mov r3=0x4167;; //0000
+}
+{.mfi
+  nop.m 0
+  // a=x2+y2
+  fma.s1 f12=f10,f1,f11
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // y not NaN ?
+  (p9) fclass.m p8,p0=f9,0x3f
+  shl r3=r3,16
+}
+{.mfi
+  nop.m 0
+  // f6=2
+  fma.s1 f6=f1,f1,f1
+  nop.i 0;;
+}
+
+
+{.mfi
+  nop.m 0
+  // x not NaN ?
+  (p6) fclass.m p7,p0=f8,0x3f
+  nop.i 0;;
+}
+{.mfi
+  // f9=35/8
+  setf.s f9=r2
+  nop.f 0
+  // 2*emax-2
+  mov r2=0x107fb;;
+}
+
+.pred.rel "mutex",p7,p8
+{.mfb
+  nop.m 0
+  // if f8=Infinity or f9=Zero, return |f8|
+  (p7) fmerge.s f8=f0,f32
+  (p7) br.ret.spnt b0
+}
+{.mfb
+  nop.m 0
+  // if f9=Infinity or f8=Zero, return |f9|
+  (p8) fmerge.s f8=f0,f33
+  (p8) br.ret.spnt b0;;
+}
+
+
+{.mfi
+  // f10 =231/16
+  setf.s f10=r3
+  // z0=frsqrta(a)
+  frsqrta.s1 f8,p6=f12
+  nop.i 0;;
+}
+
+{ .mfi
+	 nop.m 0
+//   Identify Natvals, Infs, NaNs, and Zeros
+//   and return result
+     fclass.m.unc p7, p0 = f12, 0x1E7
+     nop.i 0;;
+}
+{.mfb
+  // get exponent of x^2+y^2
+  getf.exp r3=f12
+  // if special case, set f8
+  (p7) mov f8=f12
+  (p7) br.ret.spnt b0;;
+}
+
+
+{.mfi
+  nop.m 0
+  // S0=a*z0
+  (p6) fma.s1 f14=f12,f8,f0
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // H0=0.5*z0
+  (p6) fma.s1 f15=f8,f7,f0
+  nop.i 0;;
+}
+
+
+{.mfi
+  nop.m 0
+  // f6=5/2
+  fma.s1 f6=f7,f1,f6
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // f11=3/2
+  fma.s1 f11=f7,f1,f1
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // d=0.5-S0*H0
+  (p6) fnma.s1 f7=f14,f15,f7
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // P67=231/16+429/16*d
+  (p6) fma.s1 f10=f34,f7,f10
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // P45=63/8*d+35/8
+  (p6) fma.s1 f9=f13,f7,f9
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // P23=5/2*d+3/2
+  (p6) fma.s1 f11=f6,f7,f11
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // d2=d*d
+  (p6) fma.s1 f13=f7,f7,f0
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // P47=d2*P67+P45
+  (p6) fma.s1 f10=f10,f13,f9
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // P13=d*P23+1
+  (p6) fma.s1 f11=f11,f7,f1
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // d3=d2*d
+  (p6) fma.s1 f13=f13,f7,f0
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // T0=d*S0
+  (p6) fma.s1 f15=f7,f14,f0
+  nop.i 0
+}
+{.mfi
+  // Is x^2 + y^2 well less than the overflow
+  // threshold?
+  (p6) cmp.lt.unc p7, p8 =  r3,r2
+  // P=P13+d3*P47
+  (p6) fma.s1 f10=f13,f10,f11
+  nop.i 0;;
+}
+
+{.mfb
+  nop.m 0
+  // S=P*T0+S0
+  fma.d.s0 f8=f10,f15,f14
+  // No overflow in this case
+  (p7) br.ret.sptk b0;;
+}
+
+{ .mfi
+     nop.m 0
+(p8) fsetc.s2 0x7F,0x42
+     // Possible overflow path, must detect by
+     // Setting widest range exponent with prevailing
+     // rounding mode.
+     nop.i 0 ;;
+}
+
+
+{ .mfi
+   // bias+0x400 (bias+EMAX+1)
+   (p8) mov r2=0x103ff
+   // S=P*T0+S0
+   (p8) fma.d.s2 f12=f10,f15,f14
+   nop.i 0 ;;
+}
+{ .mfi
+(p8) setf.exp f11 = r2
+(p8) fsetc.s2 0x7F,0x40
+//   Restore Original Mode in S2
+     nop.i 0 ;;
+}
+{ .mfi
+     nop.m 0
+(p8) fcmp.lt.unc.s1 p9, p10 =  f12, f11
+     nop.i 0 ;;
+}
+{ .mib
+     nop.m 0
+     mov GR_Parameter_TAG = 46
+	 // No overflow
+(p9) br.ret.sptk b0;;
+}
+GLOBAL_IEEE754_END(hypot)
+libm_alias_double_other (__hypot, hypot)
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfd [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfd [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfd [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#  // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+LOCAL_LIBM_END(__libm_error_region#)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_hypotf.S
@@ -0,0 +1,394 @@
+.file "hypotf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 02/02/00 hand-optimized
+// 04/04/00 Unwind support added
+// 06/26/00 new version
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 04/17/03 Added missing mutex directive
+//
+//*********************************************************************
+//                           ___________
+// Function:   hypotf(x,y) = |(x^2 + y^2) = for single precision values
+//             x and y
+//             Also provides cabsf functionality.
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8  (Input and Return Value)
+//                              f9  (Input)
+//                              f6 -f15
+//
+//    General Purpose Registers:
+//      r2-r3   (Scratch)
+//      r32-r36 (Locals)
+//      r37-r40 (Used to pass arguments to error handling routine)
+//
+//    Predicate Registers:      p6 - p10
+//
+//*********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    All faults and exceptions should be raised correctly.
+//    Overflow can occur.
+//    hypotf(Infinity and anything) = +Infinity
+//    hypotf(QNaN and anything) = QNaN
+//    hypotf(SNaN and anything ) = QNaN
+//
+//*********************************************************************
+//
+// Implementation:
+//  x2 = x * x   in double-extended
+//  y2 = y * y   in double-extended
+//  temp = x2 + y2   in double-extended
+//  sqrt(temp) rounded to single precision
+//
+//*********************************************************************
+
+GR_SAVE_PFS         = r33
+GR_SAVE_B0          = r34
+GR_SAVE_GP          = r35
+GR_Parameter_X      = r36
+GR_Parameter_Y      = r37
+GR_Parameter_RESULT = r38
+GR_Parameter_TAG    = r39
+
+FR_X                = f14
+FR_Y                = f15
+FR_RESULT           = f8
+
+.section .text
+
+LOCAL_LIBM_ENTRY(cabsf)
+LOCAL_LIBM_END(cabsf)
+
+GLOBAL_IEEE754_ENTRY(hypotf)
+{.mfi
+  alloc r32= ar.pfs,0,4,4,0
+  // Compute x*x
+  fma.s1 f10=f8,f8,f0
+  // r2=bias-1
+  mov r2=0xfffe
+}
+{.mfi
+  nop.m 0
+  // y*y
+  fma.s1 f11=f9,f9,f0
+  nop.i 0;;
+}
+
+{ .mfi
+     nop.m 0
+//   Check if x is an Inf - if so return Inf even
+//   if y is a NaN (C9X)
+     fclass.m.unc p7, p6 = f8, 0x023
+     nop.i 0
+}
+{.mfi
+  nop.m 0
+  // if possible overflow, copy f8 to f14
+  // set Denormal, if necessary
+  // (p8)
+  fma.s.s0 f14=f8,f1,f0
+  nop.i 0;;
+}
+
+{ .mfi
+     nop.m 0
+//   Check if y is an Inf - if so return Inf even
+//   if x is a NaN (C9X)
+     fclass.m.unc p8, p9 = f9, 0x023
+	 nop.i 0
+}
+{ .mfi
+     nop.m 0
+//   For x=inf, multiply y by 1 to raise invalid on y an SNaN
+//   (p7) fma.s0 f9=f9,f1,f0
+     // copy f9 to f15; set Denormal, if necessary
+	 fma.s.s0 f15=f9,f1,f0
+     nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // is y Zero ?
+  (p6) fclass.m p6,p0=f9,0x7
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // is x Zero ?
+  (p9) fclass.m p9,p0=f8,0x7
+  nop.i 0;;
+}
+
+{.mfi
+  // f7=0.5
+  setf.exp f7=r2
+  // a=x2+y2
+  fma.s1 f12=f10,f1,f11
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // x not NaN ?
+  (p6) fclass.m p7,p0=f8,0x3f
+  nop.i 0
+}
+{.mfi
+  // 2*emax-2
+  mov r2=0x100fb
+  // f6=2
+  fma.s1 f6=f1,f1,f1
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // y not NaN ?
+  (p9) fclass.m p8,p0=f9,0x3f
+  nop.i 0;;
+}
+
+.pred.rel "mutex",p7,p8
+{.mfb
+  nop.m 0
+  // if f8=Infinity or f9=Zero, return |f8|
+  (p7) fmerge.s f8=f0,f14
+  (p7) br.ret.spnt b0
+}
+{.mfb
+  nop.m 0
+  // if f9=Infinity or f8=Zero, return |f9|
+  (p8) fmerge.s f8=f0,f15
+  (p8) br.ret.spnt b0;;
+}
+
+{ .mfi
+	 nop.m 0
+//   Identify Natvals, Infs, NaNs, and Zeros
+//   and return result
+     fclass.m.unc p7, p0 = f12, 0x1E7
+     nop.i 0
+}
+{.mfi
+  nop.m 0
+  // z0=frsqrta(a)
+  frsqrta.s1 f8,p6=f12
+  nop.i 0;;
+}
+
+{.mfb
+  // get exponent of x^2+y^2
+  getf.exp r3=f12
+  // if special case, set f8
+  (p7) mov f8=f12
+  (p7) br.ret.spnt b0;;
+}
+
+
+{.mfi
+  nop.m 0
+  // S0=a*z0
+  (p6) fma.s1 f12=f12,f8,f0
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // H0=0.5*z0
+  (p6) fma.s1 f10=f8,f7,f0
+  nop.i 0;;
+}
+
+
+{.mfi
+  nop.m 0
+  // f6=5/2
+  fma.s1 f6=f7,f1,f6
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // f11=3/2
+  fma.s1 f11=f7,f1,f1
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // d=0.5-S0*H0
+  (p6) fnma.s1 f7=f12,f10,f7
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // P01=d+1
+  (p6) fma.s1 f10=f1,f7,f1
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // P23=5/2*d+3/2
+  (p6) fma.s1 f11=f6,f7,f11
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // d2=d*d
+  (p6) fma.s1 f7=f7,f7,f0
+  nop.i 0;;
+}
+
+
+{.mfi
+  // Is x^2 + y^2 well less than the overflow
+  // threshold?
+  (p6) cmp.lt.unc p7, p8 =  r3,r2
+  // P=P01+d2*P23
+  (p6) fma.s1 f10=f7,f11,f10
+  nop.i 0;;
+}
+
+{.mfb
+  nop.m 0
+  // S=P*S0
+  fma.s.s0 f8=f10,f12,f0
+  // No overflow in this case
+  (p7) br.ret.sptk b0;;
+}
+
+{ .mfi
+     nop.m 0
+(p8) fsetc.s2 0x7F,0x42
+     // Possible overflow path, must detect by
+     // Setting widest range exponent with prevailing
+     // rounding mode.
+     nop.i 0 ;;
+}
+
+
+{ .mfi
+   // bias+0x400 (bias+EMAX+1)
+   (p8) mov r2=0x1007f
+   // S=P*S0
+   (p8) fma.s.s2 f12=f10,f12,f0
+   nop.i 0 ;;
+}
+{ .mfi
+(p8) setf.exp f11 = r2
+(p8) fsetc.s2 0x7F,0x40
+//   Restore Original Mode in S2
+     nop.i 0 ;;
+}
+{ .mfi
+     nop.m 0
+(p8) fcmp.lt.unc.s1 p9, p10 =  f12, f11
+     nop.i 0 ;;
+}
+{ .mib
+     nop.m 0
+     mov GR_Parameter_TAG = 47
+	 // No overflow
+(p9) br.ret.sptk b0;;
+}
+GLOBAL_IEEE754_END(hypotf)
+libm_alias_float_other (__hypot, hypot)
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mii
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        mov   GR_Parameter_TAG = 47
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_hypotl.S
@@ -0,0 +1,475 @@
+.file "hypotl.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 02/02/00 hand-optimized
+// 04/04/00 Unwind support added
+// 06/20/00 new version
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+//*********************************************************************
+//                           ___________
+// Function:   hypotl(x,y) = |(x^2 + y^2) = for double extended values
+//             x and y
+//             Also provides cabsl functionality.
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8  (Input and Return Value)
+//                              f9  (Input)
+//                              f6 -f15, f32-f34
+//
+//    General Purpose Registers:
+//      r2-r3   (Scratch)
+//      r32-r36 (Locals)
+//      r37-r40 (Used to pass arguments to error handling routine)
+//
+//    Predicate Registers:      p6 - p10
+//
+//*********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    All faults and exceptions should be raised correctly.
+//    Overflow can occur.
+//    hypotl(Infinity and anything) = +Infinity
+//    hypotl(QNaN and anything) = QNaN
+//    hypotl(SNaN and anything ) = QNaN
+//
+//*********************************************************************
+//
+// Implementation:
+//  x2 = x * x   in double-extended
+//  y2 = y * y   in double-extended
+//  temp = x2 + y2   in double-extended
+//  sqrt(temp) rounded to double extended
+//
+//*********************************************************************
+
+GR_SAVE_PFS         = r33
+GR_SAVE_B0          = r34
+GR_SAVE_GP          = r35
+GR_Parameter_X      = r36
+GR_Parameter_Y      = r37
+GR_Parameter_RESULT = r38
+GR_Parameter_TAG    = r39
+
+FR_X                = f32
+FR_Y                = f33
+FR_RESULT           = f8
+
+.section .text
+
+LOCAL_LIBM_ENTRY(cabsl)
+LOCAL_LIBM_END(cabsl)
+
+GLOBAL_IEEE754_ENTRY(hypotl)
+{.mfi
+  alloc r32= ar.pfs,0,4,4,0
+  // Compute x*x
+  fma.s1 f10=f8,f8,f0
+  // r2=bias-1
+  mov r2=0xfffe
+}
+{.mfi
+  nop.m 0
+  // y*y
+  fma.s1 f11=f9,f9,f0
+  nop.i 0;;
+}
+
+{ .mfi
+     nop.m 0
+//   Check if x is an Inf - if so return Inf even
+//   if y is a NaN (C9X)
+     fclass.m.unc p7, p6 = f8, 0x023
+     nop.i 0
+}
+{.mfi
+	nop.m 0
+	// if possible overflow, copy f8 to f32
+	// set Denormal, if necessary
+	// (p8)
+	fma.s0 f32=f8,f1,f0
+    nop.i 0;;
+}
+{ .mfi
+     nop.m 0
+//   Check if y is an Inf - if so return Inf even
+//   if x is a NaN (C9X)
+     fclass.m.unc p8, p9 = f9, 0x023
+	 nop.i 0
+}
+{ .mfi
+     nop.m 999
+//   For x=inf, multiply y by 1 to raise invalid on y an SNaN
+//   (p7) fma.s0 f9=f9,f1,f0
+     // copy f9 to f33; set Denormal, if necessary
+	 fma.s0 f33=f9,f1,f0
+     nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // is y Zero ?
+  (p6) fclass.m p6,p0=f9,0x7
+  nop.i 0;;
+}
+
+{.mfi
+  // f7=0.5
+  setf.exp f7=r2
+  // a=x2+y2
+  fma.s1 f12=f10,f1,f11
+  nop.i 0
+}
+{.mfi
+  mov r2=0x408c  //0000
+  // dx=x*x-x2
+  fms.s1 f13=f8,f8,f10
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // is x Zero ?
+  (p9) fclass.m p9,p0=f8,0x7
+  shl r2=r2,16
+}
+{.mfi
+  nop.m 0
+  // dy=y*y-y2
+  fms.s1 f14=f9,f9,f11
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // x not NaN ?
+  (p6) fclass.m p7,p0=f8,0x3f
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // f6=2
+  fma.s1 f6=f1,f1,f1
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // f34=min(x2,y2)
+  famin.s1 f34=f10,f11
+  nop.i 0
+}
+{.mfb
+  nop.m 0
+  // f10=max(x2,y2)
+  famax.s1 f10=f11,f10
+  nop.b 0;; //
+}
+
+{.mfi
+  nop.m 0
+  // y not NaN ?
+  (p9) fclass.m p8,p0=f9,0x3f
+  nop.i 0;;
+}
+{.mfb
+  // f9=35/8
+  setf.s f9=r2
+  // if f8=Infinity or f9=Zero, return |f8|
+  (p7) fmerge.s f8=f0,f32
+  (p7) br.ret.spnt b0;;
+}
+
+
+{.mfi
+  nop.m 0
+  // z0=frsqrta(a)
+  frsqrta.s1 f8,p6=f12
+  nop.i 0;;
+}
+{ .mfi
+     nop.m 0
+//   Identify Natvals, Infs, NaNs, and Zeros
+//   and return result
+     fclass.m.unc p7, p0 = f12, 0x1E7
+     nop.i 0
+}
+{.mfi
+  // get exponent of x^2+y^2
+  getf.exp r3=f12
+  // dxy=dx+dy
+  fma.s1 f13=f13,f1,f14
+  nop.i 0;;
+}
+
+{.mfb
+  // 2*emax-2
+  mov r2=0x17ffb
+  // if f9=Infinity or f8=Zero, return |f9|
+  (p8) fmerge.s f8=f0,f33
+  (p8) br.ret.spnt b0
+}
+{.mfi
+  nop.m 0
+  // dd=a-max(x2,y2)
+  fnma.s1 f10=f10,f1,f12
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // S0=a*z0
+  (p6) fma.s1 f14=f12,f8,f0
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // H0=0.5*z0
+  (p6) fma.s1 f15=f8,f7,f0
+  nop.i 0;;
+}
+
+{.mfb
+  nop.m 0
+  // if special case, set f8
+  (p7) mov f8=f12
+  (p7) br.ret.spnt b0
+}
+{.mfi
+  nop.m 0
+  // da=min(x2,y2)-dd
+  fnma.s1 f10=f10,f1,f34
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // f6=5/2
+  fma.s1 f6=f7,f1,f6
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // f11=3/2
+  fma.s1 f11=f7,f1,f1
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // d=0.5-S0*H0
+  (p6) fnma.s1 f7=f14,f15,f7
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // P1=3/2*d+1
+  (p6) fma.s1 f11=f11,f7,f1
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // P2=35/8*d+5/2
+  (p6) fma.s1 f9=f9,f7,f6
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // d2=d*d
+  (p6) fma.s1 f34=f7,f7,f0
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // T0=d*S0
+  (p6) fma.s1 f6=f7,f14,f0
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // G0=d*H0
+  (p6) fma.s1 f7=f7,f15,f0
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // P=d2*P2+P1
+  (p6) fma.s1 f11=f34,f9,f11
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // S1=p*T0+S0
+  (p6) fma.s1 f14=f11,f6,f14
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // H1=p*G0+H0
+  (p6) fma.s1 f15=f11,f7,f15
+  nop.i 0;;
+}
+
+
+{.mfi
+  nop.m 0
+  // e1=a-S1*S1
+  (p6) fnma.s1 f7=f14,f14,f12
+  nop.i 0
+}
+{.mfi
+  // Is x^2 + y^2 well less than the overflow
+  // threshold?
+  (p6) cmp.lt.unc p7, p8 =  r3,r2
+  // c=dxy+da
+  (p6) fma.s1 f13=f13,f1,f10
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // e=e1+c
+  (p6) fma.s1 f13=f7,f1,f13
+  nop.i 0;;
+}
+
+{.mfb
+  nop.m 0
+  // S=e*H1+S1
+  fma.s0 f8=f13,f15,f14
+  // No overflow in this case
+  (p7) br.ret.sptk b0;;
+}
+
+{ .mfi
+     nop.m 0
+(p8) fsetc.s2 0x7F,0x42
+     // Possible overflow path, must detect by
+     // Setting widest range exponent with prevailing
+     // rounding mode.
+     nop.i 0 ;;
+}
+
+
+{ .mfi
+   // bias+0x4000 (bias+EMAX+1)
+   (p8) mov r2=0x13fff
+   // S=e*H1+S1
+   (p8) fma.s2 f12=f13,f15,f14
+   nop.i 0 ;;
+}
+{ .mfi
+(p8) setf.exp f11 = r2
+(p8) fsetc.s2 0x7F,0x40
+//   Restore Original Mode in S2
+     nop.i 0 ;;
+}
+{ .mfi
+     nop.m 0
+(p8) fcmp.lt.unc.s1 p9, p10 =  f12, f11
+     nop.i 0 ;;
+}
+{ .mib
+     nop.m 0
+     mov GR_Parameter_TAG = 45;
+	 // No overflow
+(p9) br.ret.sptk b0;;
+}
+GLOBAL_IEEE754_END(hypotl)
+libm_alias_ldouble_other (__hypot, hypot)
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfe [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfe [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfe [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#  // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+LOCAL_LIBM_END(__libm_error_region#)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_ilogbl.S
@@ -0,0 +1,267 @@
+.file "ilogbl.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/03/00 Initial version
+// 05/26/00 Fix bug when x a double-extended denormal;
+//          if x=0 call error routine, per C9X
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 01/20/01 Fixed result for x=0
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 01/20/03 Improved performance
+//
+// API
+//==============================================================
+// int ilogbl( long double x );
+//
+// Overview of operation
+//==============================================================
+// The ilogbl function extracts the exponent of x as an integer
+// and returns it in r8
+//
+// ilogbl is similar to logbl but differs in the following ways:
+//         +-inf
+//            ilogbl: returns INT_MAX
+//             logbl: returns +inf
+//         Nan  returns FP_LOGBNAN (which is either INT_MAX or INT_MIN)
+//            ilogbl: returns INT_MAX (7fffffff)
+//             logbl: returns QNAN (quietized SNAN)
+//         0    returns FP_ILOGB0 (which is either INT_MIN or -INT_MAX)
+//            ilogbl: returns -INT_MAX (80000001)
+//             logbl: returns -inf, raises the divide-by-zero exception,
+//                   and calls libm_error_support to set domain error
+//
+// Registers used
+//==============================================================
+// general registers used:
+// r26 -> r39
+// r36 -> r39 used as parameters to error path
+//
+// predicate registers used:
+// p6 -> p10
+// floating-point registers used:
+// f9, f10, f11
+// f8, input
+
+rExpBias            = r26
+rExpMask            = r27
+rSignexp_x          = r28
+rExp_x              = r29
+rIntMax             = r30
+rExp_2to64          = r31
+
+GR_SAVE_PFS         = r32
+rTrialResult        = r33
+GR_SAVE_B0          = r34
+GR_SAVE_GP          = r35
+
+GR_Parameter_X      = r36
+GR_Parameter_Y      = r37
+GR_Parameter_RESULT = r38
+GR_Parameter_TAG    = r39
+
+fTmp                = f9
+fNorm_x             = f10
+f2to64              = f11
+
+.section .text
+GLOBAL_LIBM_ENTRY(__ieee754_ilogbl)
+
+// X NORMAL
+// TrueExp_x = exp(f8) - 0xffff
+// r8 = TrueExp_x
+{ .mfi
+      getf.exp        rSignexp_x = f8
+      fclass.m        p8,p0 = f8, 0x0b   // Test for x unorm
+      mov             rExpBias = 0xffff  // Exponent bias
+}
+{ .mfi
+      nop.m           0
+      fnorm.s1        fNorm_x = f8
+      mov             rExpMask = 0x1ffff // Exponent mask
+}
+;;
+
+// Form signexp of 2^64 in case need to scale denormal
+{ .mfb
+      mov             rExp_2to64 = 0x1003f
+      fclass.m        p6,p9 = f8, 0x1e3  // Test x natval, nan, inf
+(p8)  br.cond.spnt    ILOGB_DENORM       // Branch if x unorm
+}
+;;
+
+ILOGB_COMMON:
+// Return here from ILOGB_DENORM
+{ .mfi
+      and             rExp_x = rSignexp_x, rExpMask // Get biased exponent
+      fclass.m        p7,p10 = f8, 0x07   // Test x zero
+      nop.i           0
+}
+{ .mlx
+      nop.m           0
+      movl            rIntMax = 0x000000007fffffff // Form INT_MAX
+}
+;;
+
+.pred.rel "mutex",p6,p9
+{ .mfi
+(p9)  sub             r8 = rExp_x, rExpBias // Get true exponent for normal path
+(p6)  fma.s0          fTmp = f8, f8, f0     // Dummy to set Invalid flag
+(p6)  mov             r8 = rIntMax          // If nan, inf, return INT_MAX
+}
+{ .mbb
+      nop.m           0
+(p7)  br.cond.spnt    ILOGB_ZERO            // Branch if x zero
+(p10) br.ret.sptk     b0                    // Exit if x not zero
+}
+;;
+
+
+ILOGB_DENORM:
+// Form 2^64 in case need to scale denormal
+// Check to see if double-extended denormal
+{ .mfi
+      setf.exp        f2to64 = rExp_2to64
+      fclass.m        p8,p0 = fNorm_x, 0x0b
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.eq.s0      p7,p0 = f8, f0           // Dummy op to set denormal flag
+      nop.i           0
+}
+;;
+
+// If double-extended denormal add 64 to exponent bias for scaling
+// If double-extended denormal form x * 2^64 which is normal
+{ .mfi
+(p8)  add             rExpBias = 64, rExpBias
+(p8)  fmpy.s1         fNorm_x = fNorm_x, f2to64
+      nop.i           0
+}
+;;
+
+// Logic is the same as normal path but use normalized input
+{ .mib
+      getf.exp        rSignexp_x = fNorm_x
+      nop.i           0
+      br.cond.sptk    ILOGB_COMMON             // Return to main path
+}
+;;
+
+ILOGB_ZERO:
+// Here if x zero
+// Return INT_MIN, call error support
+
+{ .mlx
+      alloc           r32=ar.pfs,1,3,4,0
+      movl            rTrialResult = 0x0000000080000000
+}
+{ .mib
+      mov             GR_Parameter_TAG = 156  // Error code
+      nop.i           0
+      br.cond.sptk    __libm_error_region     // Call error support
+}
+;;
+
+GLOBAL_LIBM_END(__ieee754_ilogbl)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+
+{ .mfi
+        add   GR_Parameter_Y=-32,sp           // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs               // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                         // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                     // Save gp
+};;
+
+{ .mmi
+        stfe [GR_Parameter_Y] = f0,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X    = 16,sp         // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                     // Save b0
+};;
+
+.body
+{ .mib
+        stfe [GR_Parameter_X] = f8            // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y    // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfe [GR_Parameter_Y] = f9            // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support# // Call error handling function
+};;
+
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+
+{ .mmi
+        mov   r8 = rTrialResult
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk   b0
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_lgamma_r.c
@@ -0,0 +1,70 @@
+/* file: lgamma_r.c */
+
+
+// Copyright (c) 2002 Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//
+
+// History
+//==============================================================
+// 02/04/02: Initial version
+// 02/22/02: Removed lgammaf_r, gammaf_r
+/*
+//   FUNCTIONS:    double  lgamma_r(double x, int* signgam)
+//                 double  gamma_r(double x, int* signgam)
+//                 Natural logarithm of GAMMA function
+*/
+
+#include "libm_support.h"
+
+
+extern double __libm_lgamma(double /*x*/, int* /*signgam*/, int /*signgamsz*/);
+
+
+double __ieee754_lgamma_r(double x, int* signgam)
+{
+    return __libm_lgamma(x, signgam, sizeof(*signgam));
+}
+libm_alias_double_r (__ieee754_lgamma, lgamma, _r)
+
+#ifndef _LIBC
+double __ieee754_gamma_r(double x, int* signgam)
+{
+    return __libm_lgamma(x, signgam, sizeof(*signgam));
+}
+weak_alias (__ieee754_gamma_r, gamma_r)
+#endif
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_lgammaf_r.c
@@ -0,0 +1,70 @@
+/* file: lgammaf_r.c */
+
+
+// Copyright (c) 2002 Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//
+
+// History
+//==============================================================
+// 02/04/02: Initial version
+// 02/22/02: Removed lgamma_r, gamma_r
+/*
+//   FUNCTIONS:    float   lgammaf_r(float x, int* signgam)
+//                 float   gammaf_r(float x, int* signgam)
+//                 Natural logarithm of GAMMA function
+*/
+
+#include "libm_support.h"
+
+
+extern float  __libm_lgammaf(float /*x*/, int* /*signgam*/, int /*signgamsz*/);
+
+
+float __ieee754_lgammaf_r(float x, int* signgam)
+{
+    return __libm_lgammaf(x, signgam, sizeof(*signgam));
+}
+libm_alias_float_r (__ieee754_lgamma, lgamma, _r)
+
+#ifndef _LIBC
+float __ieee754_gammaf_r(float x, int* signgam)
+{
+    return __libm_lgammaf(x, signgam, sizeof(*signgam));
+}
+weak_alias (__ieee754_gammaf_r, gammaf_r)
+#endif
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_lgammal_r.c
@@ -0,0 +1,69 @@
+/* file: lgammal_r.c */
+
+
+// Copyright (c) 2002 Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//
+
+// History
+//==============================================================
+// 08/15/02: Initial version
+/*
+//   FUNCTIONS:    long double  lgammal_r(long double x, int* signgam)
+//                 long double  gammal_r(long double x, int* signgam)
+//                 Natural logarithm of GAMMA function
+*/
+
+#include "libm_support.h"
+
+
+extern double __libm_lgammal(long double /*x*/, int* /*signgam*/, int /*signgamsz*/);
+
+
+long double __ieee754_lgammal_r(long double x, int* signgam)
+{
+    return __libm_lgammal(x, signgam, sizeof(*signgam));
+}
+libm_alias_ldouble_r (__ieee754_lgamma, lgamma, _r)
+
+#ifndef _LIBC
+long double __ieee754_gammal_r(long double x, int* signgam)
+{
+    return __libm_lgammal(x, signgam, sizeof(*signgam));
+}
+weak_alias (__ieee754_gammal_r, gammal_r)
+#endif
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_log.S
@@ -0,0 +1,1735 @@
+.file "log.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 04/04/00 Unwind support added
+// 06/16/00 Updated table to be rounded correctly
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 08/17/00 Improved speed of main path by 5 cycles
+//          Shortened path for x=1.0
+// 01/09/01 Improved speed, fixed flags for neg denormals
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 05/23/02 Modified algorithm. Now only one polynomial is used
+//          for |x-1| >= 1/256 and for |x-1| < 1/256
+// 12/11/02 Improved performance for Itanium 2
+// 03/31/05 Reformatted delimiters between data tables
+//
+// API
+//==============================================================
+// double log(double)
+// double log10(double)
+//
+//
+// Overview of operation
+//==============================================================
+// Background
+// ----------
+//
+// This algorithm is based on fact that
+// log(a b) = log(a) + log(b).
+// In our case we have x = 2^N f, where 1 <= f < 2.
+// So
+//   log(x) = log(2^N f) = log(2^N) + log(f) = n*log(2) + log(f)
+//
+// To calculate log(f) we do following
+//   log(f) = log(f * frcpa(f) / frcpa(f)) =
+//          = log(f * frcpa(f)) + log(1/frcpa(f))
+//
+// According to definition of IA-64's frcpa instruction it's a
+// floating point that approximates 1/f using a lookup on the
+// top of 8 bits of the input number's significand with relative
+// error < 2^(-8.886). So we have following
+//
+// |(1/f - frcpa(f)) / (1/f))| = |1 - f*frcpa(f)| < 1/256
+//
+// and
+//
+// log(f) = log(f * frcpa(f)) + log(1/frcpa(f)) =
+//        = log(1 + r) + T
+//
+// The first value can be computed by polynomial P(r) approximating
+// log(1 + r) on |r| < 1/256 and the second is precomputed tabular
+// value defined by top 8 bit of f.
+//
+// Finally we have that  log(x) ~ (N*log(2) + T) + P(r)
+//
+// Note that if input argument is close to 1.0 (in our case it means
+// that |1 - x| < 1/256) we can use just polynomial approximation
+// because x = 2^0 * f = f = 1 + r and
+// log(x) = log(1 + r) ~ P(r)
+//
+//
+// To compute log10(x) we use the simple identity
+//
+//  log10(x) = log(x)/log(10)
+//
+// so we have that
+//
+//  log10(x) = (N*log(2) + T  + log(1+r)) / log(10) =
+//           = N*(log(2)/log(10)) + (T/log(10)) + log(1 + r)/log(10)
+//
+//
+// Implementation
+// --------------
+// It can be seen that formulas for log and log10 differ from one another
+// only by coefficients and tabular values. Namely as log as log10 are
+// calculated as (N*L1 + T) + L2*Series(r) where in case of log
+//   L1 = log(2)
+//   T  = log(1/frcpa(x))
+//   L2 = 1.0
+// and in case of log10
+//   L1 = log(2)/log(10)
+//   T  = log(1/frcpa(x))/log(10)
+//   L2 = 1.0/log(10)
+//
+// So common code with two different entry points those set pointers
+// to the base address of corresponding data sets containing values
+// of L2,T and prepare integer representation of L1 needed for following
+// setf instruction.
+//
+// Note that both log and log10 use common approximation polynomial
+// it means we need only one set of coefficients of approximation.
+//
+//
+// 1. |x-1| >= 1/256
+//   InvX = frcpa(x)
+//   r = InvX*x - 1
+//   P(r) = r*((r*A3 - A2) + r^4*((A4 + r*A5) + r^2*(A6 + r*A7)),
+//   all coefficients are calculated in quad and rounded to double
+//   precision. A7,A6,A5,A4 are stored in memory whereas A3 and A2
+//   created with setf.
+//
+//   N = float(n) where n is true unbiased exponent of x
+//
+//   T is tabular value of log(1/frcpa(x)) calculated in quad precision
+//   and represented by two floating-point numbers 64-bit Thi and 32-bit Tlo.
+//   To load Thi,Tlo we get bits from 55 to 62 of register format significand
+//   as index and calculate two addresses
+//     ad_Thi = Thi_table_base_addr + 8 * index
+//     ad_Tlo = Tlo_table_base_addr + 4 * index
+//
+//   L2 (1.0 or 1.0/log(10) depending on function) is calculated in quad
+//   precision and rounded to double extended; it's loaded from memory.
+//
+//   L1 (log(2) or log10(2) depending on function) is calculated in quad
+//   precision and represented by two floating-point 64-bit numbers L1hi,L1lo
+//   stored in memory.
+//
+//   And final result = ((L1hi*N + Thi) + (N*L1lo + Tlo)) + L2*P(r)
+//
+//
+// 2. |x-1| < 1/256
+//   r = x - 1
+//   P(r) = r*((r*A3 - A2) + r^4*((A4 + r*A5) + r^2*(A6 + r*A7)),
+//   A7,A6,A5A4,A3,A2 are the same as in case |x-1| >= 1/256
+//
+//   And final results
+//     log(x)   = P(r)
+//     log10(x) = L2*P(r)
+//
+// 3. How we define is input argument such that |x-1| < 1/256 or not.
+//
+//    To do it we analyze biased exponent and integer representation of
+//    input argument
+//
+//      a) First we test is biased exponent equal to 0xFFFE or 0xFFFF (i.e.
+//         we test is 0.5 <= x < 2). This comparison can be performed using
+//         unsigned version of cmp instruction in such a way
+//         biased_exponent_of_x - 0xFFFE < 2
+//
+//
+//      b) Second (in case when result of a) is true) we need to compare x
+//         with 1-1/256 and 1+1/256 or in double precision memory representation
+//         with 0x3FEFE00000000000 and 0x3FF0100000000000 correspondingly.
+//         This comparison can be made like in a), using unsigned
+//         version of cmp i.e. ix - 0x3FEFE00000000000 < 0x0000300000000000.
+//         0x0000300000000000 is difference between 0x3FF0100000000000 and
+//         0x3FEFE00000000000
+//
+//    Note: NaT, any NaNs, +/-INF, +/-0, negatives and unnormalized numbers are
+//          filtered and processed on special branches.
+//
+
+//
+// Special values
+//==============================================================
+//
+// log(+0)    = -inf
+// log(-0)    = -inf
+//
+// log(+qnan) = +qnan
+// log(-qnan) = -qnan
+// log(+snan) = +qnan
+// log(-snan) = -qnan
+//
+// log(-n)    = QNAN Indefinite
+// log(-inf)  = QNAN Indefinite
+//
+// log(+inf)  = +inf
+//
+//
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input
+// f7 -> f15,  f32 -> f42
+//
+// General registers used:
+// r8  -> r11
+// r14 -> r23
+//
+// Predicate registers used:
+// p6 -> p15
+
+// Assembly macros
+//==============================================================
+GR_TAG                 = r8
+GR_ad_1                = r8
+GR_ad_2                = r9
+GR_Exp                 = r10
+GR_N                   = r11
+
+GR_x                   = r14
+GR_dx                  = r15
+GR_NearOne             = r15
+GR_xorg                = r16
+GR_mask                = r16
+GR_05                  = r17
+GR_A3                  = r18
+GR_Sig                 = r19
+GR_Ind                 = r19
+GR_Nm1                 = r20
+GR_bias                = r21
+GR_ad_3                = r22
+GR_rexp                = r23
+
+
+GR_SAVE_B0             = r33
+GR_SAVE_PFS            = r34
+GR_SAVE_GP             = r35
+GR_SAVE_SP             = r36
+
+GR_Parameter_X         = r37
+GR_Parameter_Y         = r38
+GR_Parameter_RESULT    = r39
+GR_Parameter_TAG       = r40
+
+
+
+FR_NormX               = f7
+FR_RcpX                = f9
+FR_tmp                 = f9
+FR_r                   = f10
+FR_r2                  = f11
+FR_r4                  = f12
+FR_N                   = f13
+FR_Ln2hi               = f14
+FR_Ln2lo               = f15
+
+FR_A7                  = f32
+FR_A6                  = f33
+FR_A5                  = f34
+FR_A4                  = f35
+FR_A3                  = f36
+FR_A2                  = f37
+
+FR_Thi                 = f38
+FR_NxLn2hipThi         = f38
+FR_NxLn2pT             = f38
+FR_Tlo                 = f39
+FR_NxLn2lopTlo         = f39
+
+FR_InvLn10             = f40
+FR_A32                 = f41
+FR_A321                = f42
+
+
+FR_Y                   = f1
+FR_X                   = f10
+FR_RESULT              = f8
+
+
+// Data
+//==============================================================
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(log_data)
+// coefficients of polynomial approximation
+data8 0x3FC2494104381A8E // A7
+data8 0xBFC5556D556BBB69 // A6
+//
+// two parts of ln(2)
+data8 0x3FE62E42FEF00000,0x3DD473DE6AF278ED
+//
+data8 0x8000000000000000,0x3FFF // 1.0
+//
+data8 0x3FC999999988B5E9 // A5
+data8 0xBFCFFFFFFFF6FFF5 // A4
+//
+// hi parts of ln(1/frcpa(1+i/256)), i=0...255
+data8 0x3F60040155D5889D // 0
+data8 0x3F78121214586B54 // 1
+data8 0x3F841929F96832EF // 2
+data8 0x3F8C317384C75F06 // 3
+data8 0x3F91A6B91AC73386 // 4
+data8 0x3F95BA9A5D9AC039 // 5
+data8 0x3F99D2A8074325F3 // 6
+data8 0x3F9D6B2725979802 // 7
+data8 0x3FA0C58FA19DFAA9 // 8
+data8 0x3FA2954C78CBCE1A // 9
+data8 0x3FA4A94D2DA96C56 // 10
+data8 0x3FA67C94F2D4BB58 // 11
+data8 0x3FA85188B630F068 // 12
+data8 0x3FAA6B8ABE73AF4C // 13
+data8 0x3FAC441E06F72A9E // 14
+data8 0x3FAE1E6713606D06 // 15
+data8 0x3FAFFA6911AB9300 // 16
+data8 0x3FB0EC139C5DA600 // 17
+data8 0x3FB1DBD2643D190B // 18
+data8 0x3FB2CC7284FE5F1C // 19
+data8 0x3FB3BDF5A7D1EE64 // 20
+data8 0x3FB4B05D7AA012E0 // 21
+data8 0x3FB580DB7CEB5701 // 22
+data8 0x3FB674F089365A79 // 23
+data8 0x3FB769EF2C6B568D // 24
+data8 0x3FB85FD927506A47 // 25
+data8 0x3FB9335E5D594988 // 26
+data8 0x3FBA2B0220C8E5F4 // 27
+data8 0x3FBB0004AC1A86AB // 28
+data8 0x3FBBF968769FCA10 // 29
+data8 0x3FBCCFEDBFEE13A8 // 30
+data8 0x3FBDA727638446A2 // 31
+data8 0x3FBEA3257FE10F79 // 32
+data8 0x3FBF7BE9FEDBFDE5 // 33
+data8 0x3FC02AB352FF25F3 // 34
+data8 0x3FC097CE579D204C // 35
+data8 0x3FC1178E8227E47B // 36
+data8 0x3FC185747DBECF33 // 37
+data8 0x3FC1F3B925F25D41 // 38
+data8 0x3FC2625D1E6DDF56 // 39
+data8 0x3FC2D1610C868139 // 40
+data8 0x3FC340C59741142E // 41
+data8 0x3FC3B08B6757F2A9 // 42
+data8 0x3FC40DFB08378003 // 43
+data8 0x3FC47E74E8CA5F7C // 44
+data8 0x3FC4EF51F6466DE4 // 45
+data8 0x3FC56092E02BA516 // 46
+data8 0x3FC5D23857CD74D4 // 47
+data8 0x3FC6313A37335D76 // 48
+data8 0x3FC6A399DABBD383 // 49
+data8 0x3FC70337DD3CE41A // 50
+data8 0x3FC77654128F6127 // 51
+data8 0x3FC7E9D82A0B022D // 52
+data8 0x3FC84A6B759F512E // 53
+data8 0x3FC8AB47D5F5A30F // 54
+data8 0x3FC91FE49096581B // 55
+data8 0x3FC981634011AA75 // 56
+data8 0x3FC9F6C407089664 // 57
+data8 0x3FCA58E729348F43 // 58
+data8 0x3FCABB55C31693AC // 59
+data8 0x3FCB1E104919EFD0 // 60
+data8 0x3FCB94EE93E367CA // 61
+data8 0x3FCBF851C067555E // 62
+data8 0x3FCC5C0254BF23A5 // 63
+data8 0x3FCCC000C9DB3C52 // 64
+data8 0x3FCD244D99C85673 // 65
+data8 0x3FCD88E93FB2F450 // 66
+data8 0x3FCDEDD437EAEF00 // 67
+data8 0x3FCE530EFFE71012 // 68
+data8 0x3FCEB89A1648B971 // 69
+data8 0x3FCF1E75FADF9BDE // 70
+data8 0x3FCF84A32EAD7C35 // 71
+data8 0x3FCFEB2233EA07CD // 72
+data8 0x3FD028F9C7035C1C // 73
+data8 0x3FD05C8BE0D9635A // 74
+data8 0x3FD085EB8F8AE797 // 75
+data8 0x3FD0B9C8E32D1911 // 76
+data8 0x3FD0EDD060B78080 // 77
+data8 0x3FD122024CF0063F // 78
+data8 0x3FD14BE2927AECD4 // 79
+data8 0x3FD180618EF18ADF // 80
+data8 0x3FD1B50BBE2FC63B // 81
+data8 0x3FD1DF4CC7CF242D // 82
+data8 0x3FD214456D0EB8D4 // 83
+data8 0x3FD23EC5991EBA49 // 84
+data8 0x3FD2740D9F870AFB // 85
+data8 0x3FD29ECDABCDFA03 // 86
+data8 0x3FD2D46602ADCCEE // 87
+data8 0x3FD2FF66B04EA9D4 // 88
+data8 0x3FD335504B355A37 // 89
+data8 0x3FD360925EC44F5C // 90
+data8 0x3FD38BF1C3337E74 // 91
+data8 0x3FD3C25277333183 // 92
+data8 0x3FD3EDF463C1683E // 93
+data8 0x3FD419B423D5E8C7 // 94
+data8 0x3FD44591E0539F48 // 95
+data8 0x3FD47C9175B6F0AD // 96
+data8 0x3FD4A8B341552B09 // 97
+data8 0x3FD4D4F39089019F // 98
+data8 0x3FD501528DA1F967 // 99
+data8 0x3FD52DD06347D4F6 // 100
+data8 0x3FD55A6D3C7B8A89 // 101
+data8 0x3FD5925D2B112A59 // 102
+data8 0x3FD5BF406B543DB1 // 103
+data8 0x3FD5EC433D5C35AD // 104
+data8 0x3FD61965CDB02C1E // 105
+data8 0x3FD646A84935B2A1 // 106
+data8 0x3FD6740ADD31DE94 // 107
+data8 0x3FD6A18DB74A58C5 // 108
+data8 0x3FD6CF31058670EC // 109
+data8 0x3FD6F180E852F0B9 // 110
+data8 0x3FD71F5D71B894EF // 111
+data8 0x3FD74D5AEFD66D5C // 112
+data8 0x3FD77B79922BD37D // 113
+data8 0x3FD7A9B9889F19E2 // 114
+data8 0x3FD7D81B037EB6A6 // 115
+data8 0x3FD8069E33827230 // 116
+data8 0x3FD82996D3EF8BCA // 117
+data8 0x3FD85855776DCBFA // 118
+data8 0x3FD8873658327CCE // 119
+data8 0x3FD8AA75973AB8CE // 120
+data8 0x3FD8D992DC8824E4 // 121
+data8 0x3FD908D2EA7D9511 // 122
+data8 0x3FD92C59E79C0E56 // 123
+data8 0x3FD95BD750EE3ED2 // 124
+data8 0x3FD98B7811A3EE5B // 125
+data8 0x3FD9AF47F33D406B // 126
+data8 0x3FD9DF270C1914A7 // 127
+data8 0x3FDA0325ED14FDA4 // 128
+data8 0x3FDA33440224FA78 // 129
+data8 0x3FDA57725E80C382 // 130
+data8 0x3FDA87D0165DD199 // 131
+data8 0x3FDAAC2E6C03F895 // 132
+data8 0x3FDADCCC6FDF6A81 // 133
+data8 0x3FDB015B3EB1E790 // 134
+data8 0x3FDB323A3A635948 // 135
+data8 0x3FDB56FA04462909 // 136
+data8 0x3FDB881AA659BC93 // 137
+data8 0x3FDBAD0BEF3DB164 // 138
+data8 0x3FDBD21297781C2F // 139
+data8 0x3FDC039236F08818 // 140
+data8 0x3FDC28CB1E4D32FC // 141
+data8 0x3FDC4E19B84723C1 // 142
+data8 0x3FDC7FF9C74554C9 // 143
+data8 0x3FDCA57B64E9DB05 // 144
+data8 0x3FDCCB130A5CEBAF // 145
+data8 0x3FDCF0C0D18F326F // 146
+data8 0x3FDD232075B5A201 // 147
+data8 0x3FDD490246DEFA6B // 148
+data8 0x3FDD6EFA918D25CD // 149
+data8 0x3FDD9509707AE52F // 150
+data8 0x3FDDBB2EFE92C554 // 151
+data8 0x3FDDEE2F3445E4AE // 152
+data8 0x3FDE148A1A2726CD // 153
+data8 0x3FDE3AFC0A49FF3F // 154
+data8 0x3FDE6185206D516D // 155
+data8 0x3FDE882578823D51 // 156
+data8 0x3FDEAEDD2EAC990C // 157
+data8 0x3FDED5AC5F436BE2 // 158
+data8 0x3FDEFC9326D16AB8 // 159
+data8 0x3FDF2391A21575FF // 160
+data8 0x3FDF4AA7EE03192C // 161
+data8 0x3FDF71D627C30BB0 // 162
+data8 0x3FDF991C6CB3B379 // 163
+data8 0x3FDFC07ADA69A90F // 164
+data8 0x3FDFE7F18EB03D3E // 165
+data8 0x3FE007C053C5002E // 166
+data8 0x3FE01B942198A5A0 // 167
+data8 0x3FE02F74400C64EA // 168
+data8 0x3FE04360BE7603AC // 169
+data8 0x3FE05759AC47FE33 // 170
+data8 0x3FE06B5F1911CF51 // 171
+data8 0x3FE078BF0533C568 // 172
+data8 0x3FE08CD9687E7B0E // 173
+data8 0x3FE0A10074CF9019 // 174
+data8 0x3FE0B5343A234476 // 175
+data8 0x3FE0C974C89431CD // 176
+data8 0x3FE0DDC2305B9886 // 177
+data8 0x3FE0EB524BAFC918 // 178
+data8 0x3FE0FFB54213A475 // 179
+data8 0x3FE114253DA97D9F // 180
+data8 0x3FE128A24F1D9AFF // 181
+data8 0x3FE1365252BF0864 // 182
+data8 0x3FE14AE558B4A92D // 183
+data8 0x3FE15F85A19C765B // 184
+data8 0x3FE16D4D38C119FA // 185
+data8 0x3FE18203C20DD133 // 186
+data8 0x3FE196C7BC4B1F3A // 187
+data8 0x3FE1A4A738B7A33C // 188
+data8 0x3FE1B981C0C9653C // 189
+data8 0x3FE1CE69E8BB106A // 190
+data8 0x3FE1DC619DE06944 // 191
+data8 0x3FE1F160A2AD0DA3 // 192
+data8 0x3FE2066D7740737E // 193
+data8 0x3FE2147DBA47A393 // 194
+data8 0x3FE229A1BC5EBAC3 // 195
+data8 0x3FE237C1841A502E // 196
+data8 0x3FE24CFCE6F80D9A // 197
+data8 0x3FE25B2C55CD5762 // 198
+data8 0x3FE2707F4D5F7C40 // 199
+data8 0x3FE285E0842CA383 // 200
+data8 0x3FE294294708B773 // 201
+data8 0x3FE2A9A2670AFF0C // 202
+data8 0x3FE2B7FB2C8D1CC0 // 203
+data8 0x3FE2C65A6395F5F5 // 204
+data8 0x3FE2DBF557B0DF42 // 205
+data8 0x3FE2EA64C3F97654 // 206
+data8 0x3FE3001823684D73 // 207
+data8 0x3FE30E97E9A8B5CC // 208
+data8 0x3FE32463EBDD34E9 // 209
+data8 0x3FE332F4314AD795 // 210
+data8 0x3FE348D90E7464CF // 211
+data8 0x3FE35779F8C43D6D // 212
+data8 0x3FE36621961A6A99 // 213
+data8 0x3FE37C299F3C366A // 214
+data8 0x3FE38AE2171976E7 // 215
+data8 0x3FE399A157A603E7 // 216
+data8 0x3FE3AFCCFE77B9D1 // 217
+data8 0x3FE3BE9D503533B5 // 218
+data8 0x3FE3CD7480B4A8A2 // 219
+data8 0x3FE3E3C43918F76C // 220
+data8 0x3FE3F2ACB27ED6C6 // 221
+data8 0x3FE4019C2125CA93 // 222
+data8 0x3FE4181061389722 // 223
+data8 0x3FE42711518DF545 // 224
+data8 0x3FE436194E12B6BF // 225
+data8 0x3FE445285D68EA69 // 226
+data8 0x3FE45BCC464C893A // 227
+data8 0x3FE46AED21F117FC // 228
+data8 0x3FE47A1527E8A2D3 // 229
+data8 0x3FE489445EFFFCCB // 230
+data8 0x3FE4A018BCB69835 // 231
+data8 0x3FE4AF5A0C9D65D7 // 232
+data8 0x3FE4BEA2A5BDBE87 // 233
+data8 0x3FE4CDF28F10AC46 // 234
+data8 0x3FE4DD49CF994058 // 235
+data8 0x3FE4ECA86E64A683 // 236
+data8 0x3FE503C43CD8EB68 // 237
+data8 0x3FE513356667FC57 // 238
+data8 0x3FE522AE0738A3D7 // 239
+data8 0x3FE5322E26867857 // 240
+data8 0x3FE541B5CB979809 // 241
+data8 0x3FE55144FDBCBD62 // 242
+data8 0x3FE560DBC45153C6 // 243
+data8 0x3FE5707A26BB8C66 // 244
+data8 0x3FE587F60ED5B8FF // 245
+data8 0x3FE597A7977C8F31 // 246
+data8 0x3FE5A760D634BB8A // 247
+data8 0x3FE5B721D295F10E // 248
+data8 0x3FE5C6EA94431EF9 // 249
+data8 0x3FE5D6BB22EA86F5 // 250
+data8 0x3FE5E6938645D38F // 251
+data8 0x3FE5F673C61A2ED1 // 252
+data8 0x3FE6065BEA385926 // 253
+data8 0x3FE6164BFA7CC06B // 254
+data8 0x3FE62643FECF9742 // 255
+//
+// lo parts of ln(1/frcpa(1+i/256)), i=0...255
+data4 0x20E70672 // 0
+data4 0x1F60A5D0 // 1
+data4 0x218EABA0 // 2
+data4 0x21403104 // 3
+data4 0x20E9B54E // 4
+data4 0x21EE1382 // 5
+data4 0x226014E3 // 6
+data4 0x2095E5C9 // 7
+data4 0x228BA9D4 // 8
+data4 0x22932B86 // 9
+data4 0x22608A57 // 10
+data4 0x220209F3 // 11
+data4 0x212882CC // 12
+data4 0x220D46E2 // 13
+data4 0x21FA4C28 // 14
+data4 0x229E5BD9 // 15
+data4 0x228C9838 // 16
+data4 0x2311F954 // 17
+data4 0x221365DF // 18
+data4 0x22BD0CB3 // 19
+data4 0x223D4BB7 // 20
+data4 0x22A71BBE // 21
+data4 0x237DB2FA // 22
+data4 0x23194C9D // 23
+data4 0x22EC639E // 24
+data4 0x2367E669 // 25
+data4 0x232E1D5F // 26
+data4 0x234A639B // 27
+data4 0x2365C0E0 // 28
+data4 0x234646C1 // 29
+data4 0x220CBF9C // 30
+data4 0x22A00FD4 // 31
+data4 0x2306A3F2 // 32
+data4 0x23745A9B // 33
+data4 0x2398D756 // 34
+data4 0x23DD0B6A // 35
+data4 0x23DE338B // 36
+data4 0x23A222DF // 37
+data4 0x223164F8 // 38
+data4 0x23B4E87B // 39
+data4 0x23D6CCB8 // 40
+data4 0x220C2099 // 41
+data4 0x21B86B67 // 42
+data4 0x236D14F1 // 43
+data4 0x225A923F // 44
+data4 0x22748723 // 45
+data4 0x22200D13 // 46
+data4 0x23C296EA // 47
+data4 0x2302AC38 // 48
+data4 0x234B1996 // 49
+data4 0x2385E298 // 50
+data4 0x23175BE5 // 51
+data4 0x2193F482 // 52
+data4 0x23BFEA90 // 53
+data4 0x23D70A0C // 54
+data4 0x231CF30A // 55
+data4 0x235D9E90 // 56
+data4 0x221AD0CB // 57
+data4 0x22FAA08B // 58
+data4 0x23D29A87 // 59
+data4 0x20C4B2FE // 60
+data4 0x2381B8B7 // 61
+data4 0x23F8D9FC // 62
+data4 0x23EAAE7B // 63
+data4 0x2329E8AA // 64
+data4 0x23EC0322 // 65
+data4 0x2357FDCB // 66
+data4 0x2392A9AD // 67
+data4 0x22113B02 // 68
+data4 0x22DEE901 // 69
+data4 0x236A6D14 // 70
+data4 0x2371D33E // 71
+data4 0x2146F005 // 72
+data4 0x23230B06 // 73
+data4 0x22F1C77D // 74
+data4 0x23A89FA3 // 75
+data4 0x231D1241 // 76
+data4 0x244DA96C // 77
+data4 0x23ECBB7D // 78
+data4 0x223E42B4 // 79
+data4 0x23801BC9 // 80
+data4 0x23573263 // 81
+data4 0x227C1158 // 82
+data4 0x237BD749 // 83
+data4 0x21DDBAE9 // 84
+data4 0x23401735 // 85
+data4 0x241D9DEE // 86
+data4 0x23BC88CB // 87
+data4 0x2396D5F1 // 88
+data4 0x23FC89CF // 89
+data4 0x2414F9A2 // 90
+data4 0x2474A0F5 // 91
+data4 0x24354B60 // 92
+data4 0x23C1EB40 // 93
+data4 0x2306DD92 // 94
+data4 0x24353B6B // 95
+data4 0x23CD1701 // 96
+data4 0x237C7A1C // 97
+data4 0x245793AA // 98
+data4 0x24563695 // 99
+data4 0x23C51467 // 100
+data4 0x24476B68 // 101
+data4 0x212585A9 // 102
+data4 0x247B8293 // 103
+data4 0x2446848A // 104
+data4 0x246A53F8 // 105
+data4 0x246E496D // 106
+data4 0x23ED1D36 // 107
+data4 0x2314C258 // 108
+data4 0x233244A7 // 109
+data4 0x245B7AF0 // 110
+data4 0x24247130 // 111
+data4 0x22D67B38 // 112
+data4 0x2449F620 // 113
+data4 0x23BBC8B8 // 114
+data4 0x237D3BA0 // 115
+data4 0x245E8F13 // 116
+data4 0x2435573F // 117
+data4 0x242DE666 // 118
+data4 0x2463BC10 // 119
+data4 0x2466587D // 120
+data4 0x2408144B // 121
+data4 0x2405F0E5 // 122
+data4 0x22381CFF // 123
+data4 0x24154F9B // 124
+data4 0x23A4E96E // 125
+data4 0x24052967 // 126
+data4 0x2406963F // 127
+data4 0x23F7D3CB // 128
+data4 0x2448AFF4 // 129
+data4 0x24657A21 // 130
+data4 0x22FBC230 // 131
+data4 0x243C8DEA // 132
+data4 0x225DC4B7 // 133
+data4 0x23496EBF // 134
+data4 0x237C2B2B // 135
+data4 0x23A4A5B1 // 136
+data4 0x2394E9D1 // 137
+data4 0x244BC950 // 138
+data4 0x23C7448F // 139
+data4 0x2404A1AD // 140
+data4 0x246511D5 // 141
+data4 0x24246526 // 142
+data4 0x23111F57 // 143
+data4 0x22868951 // 144
+data4 0x243EB77F // 145
+data4 0x239F3DFF // 146
+data4 0x23089666 // 147
+data4 0x23EBFA6A // 148
+data4 0x23C51312 // 149
+data4 0x23E1DD5E // 150
+data4 0x232C0944 // 151
+data4 0x246A741F // 152
+data4 0x2414DF8D // 153
+data4 0x247B5546 // 154
+data4 0x2415C980 // 155
+data4 0x24324ABD // 156
+data4 0x234EB5E5 // 157
+data4 0x2465E43E // 158
+data4 0x242840D1 // 159
+data4 0x24444057 // 160
+data4 0x245E56F0 // 161
+data4 0x21AE30F8 // 162
+data4 0x23FB3283 // 163
+data4 0x247A4D07 // 164
+data4 0x22AE314D // 165
+data4 0x246B7727 // 166
+data4 0x24EAD526 // 167
+data4 0x24B41DC9 // 168
+data4 0x24EE8062 // 169
+data4 0x24A0C7C4 // 170
+data4 0x24E8DA67 // 171
+data4 0x231120F7 // 172
+data4 0x24401FFB // 173
+data4 0x2412DD09 // 174
+data4 0x248C131A // 175
+data4 0x24C0A7CE // 176
+data4 0x243DD4C8 // 177
+data4 0x24457FEB // 178
+data4 0x24DEEFBB // 179
+data4 0x243C70AE // 180
+data4 0x23E7A6FA // 181
+data4 0x24C2D311 // 182
+data4 0x23026255 // 183
+data4 0x2437C9B9 // 184
+data4 0x246BA847 // 185
+data4 0x2420B448 // 186
+data4 0x24C4CF5A // 187
+data4 0x242C4981 // 188
+data4 0x24DE1525 // 189
+data4 0x24F5CC33 // 190
+data4 0x235A85DA // 191
+data4 0x24A0B64F // 192
+data4 0x244BA0A4 // 193
+data4 0x24AAF30A // 194
+data4 0x244C86F9 // 195
+data4 0x246D5B82 // 196
+data4 0x24529347 // 197
+data4 0x240DD008 // 198
+data4 0x24E98790 // 199
+data4 0x2489B0CE // 200
+data4 0x22BC29AC // 201
+data4 0x23F37C7A // 202
+data4 0x24987FE8 // 203
+data4 0x22AFE20B // 204
+data4 0x24C8D7C2 // 205
+data4 0x24B28B7D // 206
+data4 0x23B6B271 // 207
+data4 0x24C77CB6 // 208
+data4 0x24EF1DCA // 209
+data4 0x24A4F0AC // 210
+data4 0x24CF113E // 211
+data4 0x2496BBAB // 212
+data4 0x23C7CC8A // 213
+data4 0x23AE3961 // 214
+data4 0x2410A895 // 215
+data4 0x23CE3114 // 216
+data4 0x2308247D // 217
+data4 0x240045E9 // 218
+data4 0x24974F60 // 219
+data4 0x242CB39F // 220
+data4 0x24AB8D69 // 221
+data4 0x23436788 // 222
+data4 0x24305E9E // 223
+data4 0x243E71A9 // 224
+data4 0x23C2A6B3 // 225
+data4 0x23FFE6CF // 226
+data4 0x2322D801 // 227
+data4 0x24515F21 // 228
+data4 0x2412A0D6 // 229
+data4 0x24E60D44 // 230
+data4 0x240D9251 // 231
+data4 0x247076E2 // 232
+data4 0x229B101B // 233
+data4 0x247B12DE // 234
+data4 0x244B9127 // 235
+data4 0x2499EC42 // 236
+data4 0x21FC3963 // 237
+data4 0x23E53266 // 238
+data4 0x24CE102D // 239
+data4 0x23CC45D2 // 240
+data4 0x2333171D // 241
+data4 0x246B3533 // 242
+data4 0x24931129 // 243
+data4 0x24405FFA // 244
+data4 0x24CF464D // 245
+data4 0x237095CD // 246
+data4 0x24F86CBD // 247
+data4 0x24E2D84B // 248
+data4 0x21ACBB44 // 249
+data4 0x24F43A8C // 250
+data4 0x249DB931 // 251
+data4 0x24A385EF // 252
+data4 0x238B1279 // 253
+data4 0x2436213E // 254
+data4 0x24F18A3B // 255
+LOCAL_OBJECT_END(log_data)
+
+
+LOCAL_OBJECT_START(log10_data)
+// coefficients of polynoimal approximation
+data8 0x3FC2494104381A8E // A7
+data8 0xBFC5556D556BBB69 // A6
+//
+// two parts of ln(2)/ln(10)
+data8 0x3FD3441350900000, 0x3DCEF3FDE623E256
+//
+data8 0xDE5BD8A937287195,0x3FFD // 1/ln(10)
+//
+data8 0x3FC999999988B5E9 // A5
+data8 0xBFCFFFFFFFF6FFF5 // A4
+//
+// Hi parts of ln(1/frcpa(1+i/256))/ln(10), i=0...255
+data8 0x3F4BD27045BFD024 // 0
+data8 0x3F64E84E793A474A // 1
+data8 0x3F7175085AB85FF0 // 2
+data8 0x3F787CFF9D9147A5 // 3
+data8 0x3F7EA9D372B89FC8 // 4
+data8 0x3F82DF9D95DA961C // 5
+data8 0x3F866DF172D6372B // 6
+data8 0x3F898D79EF5EEDEF // 7
+data8 0x3F8D22ADF3F9579C // 8
+data8 0x3F9024231D30C398 // 9
+data8 0x3F91F23A98897D49 // 10
+data8 0x3F93881A7B818F9E // 11
+data8 0x3F951F6E1E759E35 // 12
+data8 0x3F96F2BCE7ADC5B4 // 13
+data8 0x3F988D362CDF359E // 14
+data8 0x3F9A292BAF010981 // 15
+data8 0x3F9BC6A03117EB97 // 16
+data8 0x3F9D65967DE3AB08 // 17
+data8 0x3F9F061167FC31E7 // 18
+data8 0x3FA05409E4F7819B // 19
+data8 0x3FA125D0432EA20D // 20
+data8 0x3FA1F85D440D299B // 21
+data8 0x3FA2AD755749617C // 22
+data8 0x3FA381772A00E603 // 23
+data8 0x3FA45643E165A70A // 24
+data8 0x3FA52BDD034475B8 // 25
+data8 0x3FA5E3966B7E9295 // 26
+data8 0x3FA6BAAF47C5B244 // 27
+data8 0x3FA773B3E8C4F3C7 // 28
+data8 0x3FA84C51EBEE8D15 // 29
+data8 0x3FA906A6786FC1CA // 30
+data8 0x3FA9C197ABF00DD6 // 31
+data8 0x3FAA9C78712191F7 // 32
+data8 0x3FAB58C09C8D637C // 33
+data8 0x3FAC15A8BCDD7B7E // 34
+data8 0x3FACD331E2C2967B // 35
+data8 0x3FADB11ED766ABF4 // 36
+data8 0x3FAE70089346A9E6 // 37
+data8 0x3FAF2F96C6754AED // 38
+data8 0x3FAFEFCA8D451FD5 // 39
+data8 0x3FB0585283764177 // 40
+data8 0x3FB0B913AAC7D3A6 // 41
+data8 0x3FB11A294F2569F5 // 42
+data8 0x3FB16B51A2696890 // 43
+data8 0x3FB1CD03ADACC8BD // 44
+data8 0x3FB22F0BDD7745F5 // 45
+data8 0x3FB2916ACA38D1E7 // 46
+data8 0x3FB2F4210DF7663C // 47
+data8 0x3FB346A6C3C49065 // 48
+data8 0x3FB3A9FEBC605409 // 49
+data8 0x3FB3FD0C10A3AA54 // 50
+data8 0x3FB46107D3540A81 // 51
+data8 0x3FB4C55DD16967FE // 52
+data8 0x3FB51940330C000A // 53
+data8 0x3FB56D620EE7115E // 54
+data8 0x3FB5D2ABCF26178D // 55
+data8 0x3FB6275AA5DEBF81 // 56
+data8 0x3FB68D4EAF26D7EE // 57
+data8 0x3FB6E28C5C54A28D // 58
+data8 0x3FB7380B9665B7C7 // 59
+data8 0x3FB78DCCC278E85B // 60
+data8 0x3FB7F50C2CF25579 // 61
+data8 0x3FB84B5FD5EAEFD7 // 62
+data8 0x3FB8A1F6BAB2B226 // 63
+data8 0x3FB8F8D144557BDF // 64
+data8 0x3FB94FEFDCD61D92 // 65
+data8 0x3FB9A752EF316149 // 66
+data8 0x3FB9FEFAE7611EDF // 67
+data8 0x3FBA56E8325F5C86 // 68
+data8 0x3FBAAF1B3E297BB3 // 69
+data8 0x3FBB079479C372AC // 70
+data8 0x3FBB6054553B12F7 // 71
+data8 0x3FBBB95B41AB5CE5 // 72
+data8 0x3FBC12A9B13FE079 // 73
+data8 0x3FBC6C4017382BEA // 74
+data8 0x3FBCB41FBA42686C // 75
+data8 0x3FBD0E38CE73393E // 76
+data8 0x3FBD689B2193F132 // 77
+data8 0x3FBDC3472B1D285F // 78
+data8 0x3FBE0C06300D528B // 79
+data8 0x3FBE6738190E394B // 80
+data8 0x3FBEC2B50D208D9A // 81
+data8 0x3FBF0C1C2B936827 // 82
+data8 0x3FBF68216C9CC726 // 83
+data8 0x3FBFB1F6381856F3 // 84
+data8 0x3FC00742AF4CE5F8 // 85
+data8 0x3FC02C64906512D2 // 86
+data8 0x3FC05AF1E63E03B4 // 87
+data8 0x3FC0804BEA723AA8 // 88
+data8 0x3FC0AF1FD6711526 // 89
+data8 0x3FC0D4B2A88059FF // 90
+data8 0x3FC0FA5EF136A06C // 91
+data8 0x3FC1299A4FB3E305 // 92
+data8 0x3FC14F806253C3EC // 93
+data8 0x3FC175805D1587C1 // 94
+data8 0x3FC19B9A637CA294 // 95
+data8 0x3FC1CB5FC26EDE16 // 96
+data8 0x3FC1F1B4E65F2590 // 97
+data8 0x3FC218248B5DC3E5 // 98
+data8 0x3FC23EAED62ADC76 // 99
+data8 0x3FC26553EBD337BC // 100
+data8 0x3FC28C13F1B118FF // 101
+data8 0x3FC2BCAA14381385 // 102
+data8 0x3FC2E3A740B7800E // 103
+data8 0x3FC30ABFD8F333B6 // 104
+data8 0x3FC331F403985096 // 105
+data8 0x3FC35943E7A6068F // 106
+data8 0x3FC380AFAC6E7C07 // 107
+data8 0x3FC3A8377997B9E5 // 108
+data8 0x3FC3CFDB771C9ADB // 109
+data8 0x3FC3EDA90D39A5DE // 110
+data8 0x3FC4157EC09505CC // 111
+data8 0x3FC43D7113FB04C0 // 112
+data8 0x3FC4658030AD1CCE // 113
+data8 0x3FC48DAC404638F5 // 114
+data8 0x3FC4B5F56CBBB869 // 115
+data8 0x3FC4DE5BE05E7582 // 116
+data8 0x3FC4FCBC0776FD85 // 117
+data8 0x3FC525561E9256EE // 118
+data8 0x3FC54E0DF3198865 // 119
+data8 0x3FC56CAB7112BDE2 // 120
+data8 0x3FC59597BA735B15 // 121
+data8 0x3FC5BEA23A506FD9 // 122
+data8 0x3FC5DD7E08DE382E // 123
+data8 0x3FC606BDD3F92355 // 124
+data8 0x3FC6301C518A501E // 125
+data8 0x3FC64F3770618915 // 126
+data8 0x3FC678CC14C1E2D7 // 127
+data8 0x3FC6981005ED2947 // 128
+data8 0x3FC6C1DB5F9BB335 // 129
+data8 0x3FC6E1488ECD2880 // 130
+data8 0x3FC70B4B2E7E41B8 // 131
+data8 0x3FC72AE209146BF8 // 132
+data8 0x3FC7551C81BD8DCF // 133
+data8 0x3FC774DD76CC43BD // 134
+data8 0x3FC79F505DB00E88 // 135
+data8 0x3FC7BF3BDE099F30 // 136
+data8 0x3FC7E9E7CAC437F8 // 137
+data8 0x3FC809FE4902D00D // 138
+data8 0x3FC82A2757995CBD // 139
+data8 0x3FC85525C625E098 // 140
+data8 0x3FC8757A79831887 // 141
+data8 0x3FC895E2058D8E02 // 142
+data8 0x3FC8C13437695531 // 143
+data8 0x3FC8E1C812EF32BE // 144
+data8 0x3FC9026F112197E8 // 145
+data8 0x3FC923294888880A // 146
+data8 0x3FC94EEA4B8334F2 // 147
+data8 0x3FC96FD1B639FC09 // 148
+data8 0x3FC990CCA66229AB // 149
+data8 0x3FC9B1DB33334842 // 150
+data8 0x3FC9D2FD740E6606 // 151
+data8 0x3FC9FF49EEDCB553 // 152
+data8 0x3FCA209A84FBCFF7 // 153
+data8 0x3FCA41FF1E43F02B // 154
+data8 0x3FCA6377D2CE9377 // 155
+data8 0x3FCA8504BAE0D9F5 // 156
+data8 0x3FCAA6A5EEEBEFE2 // 157
+data8 0x3FCAC85B878D7878 // 158
+data8 0x3FCAEA259D8FFA0B // 159
+data8 0x3FCB0C0449EB4B6A // 160
+data8 0x3FCB2DF7A5C50299 // 161
+data8 0x3FCB4FFFCA70E4D1 // 162
+data8 0x3FCB721CD17157E2 // 163
+data8 0x3FCB944ED477D4EC // 164
+data8 0x3FCBB695ED655C7C // 165
+data8 0x3FCBD8F2364AEC0F // 166
+data8 0x3FCBFB63C969F4FF // 167
+data8 0x3FCC1DEAC134D4E9 // 168
+data8 0x3FCC4087384F4F80 // 169
+data8 0x3FCC6339498F09E1 // 170
+data8 0x3FCC86010FFC076B // 171
+data8 0x3FCC9D3D065C5B41 // 172
+data8 0x3FCCC029375BA079 // 173
+data8 0x3FCCE32B66978BA4 // 174
+data8 0x3FCD0643AFD51404 // 175
+data8 0x3FCD29722F0DEA45 // 176
+data8 0x3FCD4CB70070FE43 // 177
+data8 0x3FCD6446AB3F8C95 // 178
+data8 0x3FCD87B0EF71DB44 // 179
+data8 0x3FCDAB31D1FE99A6 // 180
+data8 0x3FCDCEC96FDC888E // 181
+data8 0x3FCDE69088763579 // 182
+data8 0x3FCE0A4E4A25C1FF // 183
+data8 0x3FCE2E2315755E32 // 184
+data8 0x3FCE461322D1648A // 185
+data8 0x3FCE6A0E95C7787B // 186
+data8 0x3FCE8E216243DD60 // 187
+data8 0x3FCEA63AF26E007C // 188
+data8 0x3FCECA74ED15E0B7 // 189
+data8 0x3FCEEEC692CCD259 // 190
+data8 0x3FCF070A36B8D9C0 // 191
+data8 0x3FCF2B8393E34A2D // 192
+data8 0x3FCF5014EF538A5A // 193
+data8 0x3FCF68833AF1B17F // 194
+data8 0x3FCF8D3CD9F3F04E // 195
+data8 0x3FCFA5C61ADD93E9 // 196
+data8 0x3FCFCAA8567EBA79 // 197
+data8 0x3FCFE34CC8743DD8 // 198
+data8 0x3FD0042BFD74F519 // 199
+data8 0x3FD016BDF6A18017 // 200
+data8 0x3FD023262F907322 // 201
+data8 0x3FD035CCED8D32A1 // 202
+data8 0x3FD042430E869FFB // 203
+data8 0x3FD04EBEC842B2DF // 204
+data8 0x3FD06182E84FD4AB // 205
+data8 0x3FD06E0CB609D383 // 206
+data8 0x3FD080E60BEC8F12 // 207
+data8 0x3FD08D7E0D894735 // 208
+data8 0x3FD0A06CC96A2055 // 209
+data8 0x3FD0AD131F3B3C55 // 210
+data8 0x3FD0C01771E775FB // 211
+data8 0x3FD0CCCC3CAD6F4B // 212
+data8 0x3FD0D986D91A34A8 // 213
+data8 0x3FD0ECA9B8861A2D // 214
+data8 0x3FD0F972F87FF3D5 // 215
+data8 0x3FD106421CF0E5F7 // 216
+data8 0x3FD11983EBE28A9C // 217
+data8 0x3FD12661E35B7859 // 218
+data8 0x3FD13345D2779D3B // 219
+data8 0x3FD146A6F597283A // 220
+data8 0x3FD15399E81EA83D // 221
+data8 0x3FD16092E5D3A9A6 // 222
+data8 0x3FD17413C3B7AB5D // 223
+data8 0x3FD1811BF629D6FA // 224
+data8 0x3FD18E2A47B46685 // 225
+data8 0x3FD19B3EBE1A4418 // 226
+data8 0x3FD1AEE9017CB450 // 227
+data8 0x3FD1BC0CED7134E1 // 228
+data8 0x3FD1C93712ABC7FF // 229
+data8 0x3FD1D66777147D3E // 230
+data8 0x3FD1EA3BD1286E1C // 231
+data8 0x3FD1F77BED932C4C // 232
+data8 0x3FD204C25E1B031F // 233
+data8 0x3FD2120F28CE69B1 // 234
+data8 0x3FD21F6253C48D00 // 235
+data8 0x3FD22CBBE51D60A9 // 236
+data8 0x3FD240CE4C975444 // 237
+data8 0x3FD24E37F8ECDAE7 // 238
+data8 0x3FD25BA8215AF7FC // 239
+data8 0x3FD2691ECC29F042 // 240
+data8 0x3FD2769BFFAB2DFF // 241
+data8 0x3FD2841FC23952C9 // 242
+data8 0x3FD291AA1A384978 // 243
+data8 0x3FD29F3B0E15584A // 244
+data8 0x3FD2B3A0EE479DF7 // 245
+data8 0x3FD2C142842C09E5 // 246
+data8 0x3FD2CEEACCB7BD6C // 247
+data8 0x3FD2DC99CE82FF20 // 248
+data8 0x3FD2EA4F902FD7D9 // 249
+data8 0x3FD2F80C186A25FC // 250
+data8 0x3FD305CF6DE7B0F6 // 251
+data8 0x3FD3139997683CE7 // 252
+data8 0x3FD3216A9BB59E7C // 253
+data8 0x3FD32F4281A3CEFE // 254
+data8 0x3FD33D2150110091 // 255
+//
+// Lo parts of ln(1/frcpa(1+i/256))/ln(10), i=0...255
+data4 0x1FB0EB5A // 0
+data4 0x206E5EE3 // 1
+data4 0x208F3609 // 2
+data4 0x2070EB03 // 3
+data4 0x1F314BAE // 4
+data4 0x217A889D // 5
+data4 0x21E63650 // 6
+data4 0x21C2F4A3 // 7
+data4 0x2192A10C // 8
+data4 0x1F84B73E // 9
+data4 0x2243FBCA // 10
+data4 0x21BD9C51 // 11
+data4 0x213C542B // 12
+data4 0x21047386 // 13
+data4 0x21217D8F // 14
+data4 0x226791B7 // 15
+data4 0x204CCE66 // 16
+data4 0x2234CE9F // 17
+data4 0x220675E2 // 18
+data4 0x22B8E5BA // 19
+data4 0x22C12D14 // 20
+data4 0x211D41F0 // 21
+data4 0x228507F3 // 22
+data4 0x22F7274B // 23
+data4 0x22A7FDD1 // 24
+data4 0x2244A06E // 25
+data4 0x215DCE69 // 26
+data4 0x22F5C961 // 27
+data4 0x22EBEF29 // 28
+data4 0x222A2CB6 // 29
+data4 0x22B9FE00 // 30
+data4 0x22E79EB7 // 31
+data4 0x222F9607 // 32
+data4 0x2189D87F // 33
+data4 0x2236DB45 // 34
+data4 0x22ED77FB // 35
+data4 0x21CB70F0 // 36
+data4 0x21B8ACE8 // 37
+data4 0x22EC58C1 // 38
+data4 0x22CFCC1C // 39
+data4 0x2343E77A // 40
+data4 0x237FBC7F // 41
+data4 0x230D472E // 42
+data4 0x234686FB // 43
+data4 0x23770425 // 44
+data4 0x223977EC // 45
+data4 0x2345800A // 46
+data4 0x237BC351 // 47
+data4 0x23191502 // 48
+data4 0x232BAC12 // 49
+data4 0x22692421 // 50
+data4 0x234D409D // 51
+data4 0x22EC3214 // 52
+data4 0x2376C916 // 53
+data4 0x22B00DD1 // 54
+data4 0x2309D910 // 55
+data4 0x22F925FD // 56
+data4 0x22A63A7B // 57
+data4 0x2106264A // 58
+data4 0x234227F9 // 59
+data4 0x1ECB1978 // 60
+data4 0x23460A62 // 61
+data4 0x232ED4B1 // 62
+data4 0x226DDC38 // 63
+data4 0x1F101A73 // 64
+data4 0x21B1F82B // 65
+data4 0x22752F19 // 66
+data4 0x2320BC15 // 67
+data4 0x236EEC5E // 68
+data4 0x23404D3E // 69
+data4 0x2304C517 // 70
+data4 0x22F7441A // 71
+data4 0x230D3D7A // 72
+data4 0x2264A9DF // 73
+data4 0x22410CC8 // 74
+data4 0x2342CCCB // 75
+data4 0x23560BD4 // 76
+data4 0x237BBFFE // 77
+data4 0x2373A206 // 78
+data4 0x22C871B9 // 79
+data4 0x2354B70C // 80
+data4 0x232EDB33 // 81
+data4 0x235DB680 // 82
+data4 0x230EF422 // 83
+data4 0x235316CA // 84
+data4 0x22EEEE8B // 85
+data4 0x2375C88C // 86
+data4 0x235ABD21 // 87
+data4 0x23A0D232 // 88
+data4 0x23F5FFB5 // 89
+data4 0x23D3CEC8 // 90
+data4 0x22A92204 // 91
+data4 0x238C64DF // 92
+data4 0x23B82896 // 93
+data4 0x22D633B8 // 94
+data4 0x23861E93 // 95
+data4 0x23CB594B // 96
+data4 0x2330387E // 97
+data4 0x21CD4702 // 98
+data4 0x2284C505 // 99
+data4 0x23D6995C // 100
+data4 0x23F6C807 // 101
+data4 0x239CEF5C // 102
+data4 0x239442B0 // 103
+data4 0x22B35EE5 // 104
+data4 0x2391E9A4 // 105
+data4 0x23A390F5 // 106
+data4 0x2349AC9C // 107
+data4 0x23FA5535 // 108
+data4 0x21E3A46A // 109
+data4 0x23B44ABA // 110
+data4 0x23CEA8E0 // 111
+data4 0x23F647DC // 112
+data4 0x2390D1A8 // 113
+data4 0x23D0CFA2 // 114
+data4 0x236E0872 // 115
+data4 0x23B88B91 // 116
+data4 0x2283C359 // 117
+data4 0x232F647F // 118
+data4 0x23122CD7 // 119
+data4 0x232CF564 // 120
+data4 0x232630FD // 121
+data4 0x23BEE1C8 // 122
+data4 0x23B2BD30 // 123
+data4 0x2301F1C0 // 124
+data4 0x23CE4D67 // 125
+data4 0x23A353C9 // 126
+data4 0x238086E8 // 127
+data4 0x22D0D29E // 128
+data4 0x23A3B3C8 // 129
+data4 0x23F69F4B // 130
+data4 0x23EA3C21 // 131
+data4 0x23951C88 // 132
+data4 0x2372AFFC // 133
+data4 0x23A6D1A8 // 134
+data4 0x22BBBAF4 // 135
+data4 0x227FA3DD // 136
+data4 0x23804D9B // 137
+data4 0x232D771F // 138
+data4 0x239CB57B // 139
+data4 0x2303CF34 // 140
+data4 0x22218C2A // 141
+data4 0x23991BEE // 142
+data4 0x23EB3596 // 143
+data4 0x230487FA // 144
+data4 0x2135DF4C // 145
+data4 0x2380FD2D // 146
+data4 0x23EB75E9 // 147
+data4 0x211C62C8 // 148
+data4 0x23F518F1 // 149
+data4 0x23FEF882 // 150
+data4 0x239097C7 // 151
+data4 0x223E2BDA // 152
+data4 0x23988F89 // 153
+data4 0x22E4A4AD // 154
+data4 0x23F03D9C // 155
+data4 0x23F5018F // 156
+data4 0x23E1E250 // 157
+data4 0x23FD3D90 // 158
+data4 0x22DEE2FF // 159
+data4 0x238342AB // 160
+data4 0x22E6736F // 161
+data4 0x233AFC28 // 162
+data4 0x2395F661 // 163
+data4 0x23D8B991 // 164
+data4 0x23CD58D5 // 165
+data4 0x21941FD6 // 166
+data4 0x23352915 // 167
+data4 0x235D09EE // 168
+data4 0x22DC7EF9 // 169
+data4 0x238BC9F3 // 170
+data4 0x2397DF8F // 171
+data4 0x2380A7BB // 172
+data4 0x23EFF48C // 173
+data4 0x21E67408 // 174
+data4 0x236420F7 // 175
+data4 0x22C8DFB5 // 176
+data4 0x239B5D35 // 177
+data4 0x23BDC09D // 178
+data4 0x239E822C // 179
+data4 0x23984F0A // 180
+data4 0x23EF2119 // 181
+data4 0x23F738B8 // 182
+data4 0x23B66187 // 183
+data4 0x23B06AD7 // 184
+data4 0x2369140F // 185
+data4 0x218DACE6 // 186
+data4 0x21DF23F1 // 187
+data4 0x235D8B34 // 188
+data4 0x23460333 // 189
+data4 0x23F11D62 // 190
+data4 0x23C37147 // 191
+data4 0x22B2AE2A // 192
+data4 0x23949211 // 193
+data4 0x23B69799 // 194
+data4 0x23DBEC75 // 195
+data4 0x229A6FB3 // 196
+data4 0x23FC6C60 // 197
+data4 0x22D01FFC // 198
+data4 0x235985F0 // 199
+data4 0x23F7ECA5 // 200
+data4 0x23F924D3 // 201
+data4 0x2381B92F // 202
+data4 0x243A0FBE // 203
+data4 0x24712D72 // 204
+data4 0x24594E2F // 205
+data4 0x220CD12A // 206
+data4 0x23D87FB0 // 207
+data4 0x2338288A // 208
+data4 0x242BB2CC // 209
+data4 0x220F6265 // 210
+data4 0x23BB7FE3 // 211
+data4 0x2301C0A2 // 212
+data4 0x246709AB // 213
+data4 0x23A619E2 // 214
+data4 0x24030E3B // 215
+data4 0x233C36CC // 216
+data4 0x241AAB77 // 217
+data4 0x243D41A3 // 218
+data4 0x23834A60 // 219
+data4 0x236AC7BF // 220
+data4 0x23B6D597 // 221
+data4 0x210E9474 // 222
+data4 0x242156E6 // 223
+data4 0x243A1D68 // 224
+data4 0x2472187C // 225
+data4 0x23834E86 // 226
+data4 0x23CA0807 // 227
+data4 0x24745887 // 228
+data4 0x23E2B0E1 // 229
+data4 0x2421EB67 // 230
+data4 0x23DCC64E // 231
+data4 0x22DF71D1 // 232
+data4 0x238D5ECA // 233
+data4 0x23CDE86F // 234
+data4 0x24131F45 // 235
+data4 0x240FE4E2 // 236
+data4 0x2317731A // 237
+data4 0x24015C76 // 238
+data4 0x2301A4E8 // 239
+data4 0x23E52A6D // 240
+data4 0x247D8A0D // 241
+data4 0x23DFEEBA // 242
+data4 0x22139FEC // 243
+data4 0x2454A112 // 244
+data4 0x23C21E28 // 245
+data4 0x2460D813 // 246
+data4 0x24258924 // 247
+data4 0x2425680F // 248
+data4 0x24194D1E // 249
+data4 0x24242C2F // 250
+data4 0x243DDE5E // 251
+data4 0x23DEB388 // 252
+data4 0x23E0E6EB // 253
+data4 0x24393E74 // 254
+data4 0x241B1863 // 255
+LOCAL_OBJECT_END(log10_data)
+
+
+
+// Code
+//==============================================================
+
+// log   has p13 true, p14 false
+// log10 has p14 true, p13 false
+
+.section .text
+GLOBAL_IEEE754_ENTRY(log10)
+{ .mfi
+      getf.exp      GR_Exp = f8 // if x is unorm then must recompute
+      frcpa.s1      FR_RcpX,p0 = f1,f8
+      mov           GR_05 = 0xFFFE // biased exponent of A2=0.5
+}
+{ .mlx
+      addl          GR_ad_1 = @ltoff(log10_data),gp
+      movl          GR_A3 = 0x3fd5555555555557 // double precision memory
+                                               // representation of A3
+};;
+
+{ .mfi
+      getf.sig      GR_Sig = f8 // get significand to calculate index
+      fclass.m      p8,p0 = f8,9 // is x positive unorm?
+      mov           GR_xorg = 0x3fefe // double precision memory msb of 255/256
+}
+{ .mib
+      ld8           GR_ad_1 = [GR_ad_1]
+      cmp.eq        p14,p13 = r0,r0 // set p14 to 1 for log10
+      br.cond.sptk  log_log10_common
+};;
+GLOBAL_IEEE754_END(log10)
+libm_alias_double_other (__log10, log10)
+
+
+GLOBAL_IEEE754_ENTRY(log)
+{ .mfi
+      getf.exp      GR_Exp = f8 // if x is unorm then must recompute
+      frcpa.s1      FR_RcpX,p0 = f1,f8
+      mov           GR_05 = 0xfffe
+}
+{ .mlx
+      addl          GR_ad_1 = @ltoff(log_data),gp
+      movl          GR_A3 = 0x3fd5555555555557 // double precision memory
+                                               // representation of A3
+};;
+
+{ .mfi
+      getf.sig      GR_Sig = f8 // get significand to calculate index
+      fclass.m      p8,p0 = f8,9 // is x positive unorm?
+      mov           GR_xorg = 0x3fefe // double precision memory msb of 255/256
+}
+{ .mfi
+      ld8           GR_ad_1 = [GR_ad_1]
+      nop.f         0
+      cmp.eq        p13,p14 = r0,r0 // set p13 to 1 for log
+};;
+
+log_log10_common:
+{ .mfi
+      getf.d        GR_x = f8 // double precision memory representation of x
+      fclass.m      p9,p0 = f8,0x1E1 // is x NaN, NaT or +Inf?
+      dep.z         GR_dx = 3, 44, 2 // Create 0x0000300000000000
+                                     // Difference between double precision
+                                     // memory representations of 257/256 and
+                                     // 255/256
+}
+{ .mfi
+      setf.exp      FR_A2 = GR_05 // create A2
+      fnorm.s1      FR_NormX = f8
+      mov           GR_bias = 0xffff
+};;
+
+{ .mfi
+      setf.d        FR_A3 = GR_A3 // create A3
+      fcmp.eq.s1    p12,p0 = f1,f8 // is x equal to 1.0?
+      dep.z         GR_xorg = GR_xorg, 44, 19 // 0x3fefe00000000000
+                                              // double precision memory
+                                              // representation of 255/256
+}
+{ .mib
+      add           GR_ad_2 = 0x30,GR_ad_1 // address of A5,A4
+      add           GR_ad_3 = 0x840,GR_ad_1 // address of ln(1/frcpa) lo parts
+(p8)  br.cond.spnt  log_positive_unorms
+};;
+
+log_core:
+{ .mfi
+      ldfpd         FR_A7,FR_A6 = [GR_ad_1],16
+      fclass.m      p10,p0 = f8,0x3A // is x < 0?
+      sub           GR_Nm1 = GR_Exp,GR_05 // unbiased_exponent_of_x - 1
+}
+{ .mfi
+      ldfpd         FR_A5,FR_A4 = [GR_ad_2],16
+(p9)  fma.d.s0      f8 = f8,f1,f0 // set V-flag
+      sub           GR_N = GR_Exp,GR_bias // unbiased_exponent_of_x
+};;
+
+{ .mfi
+      setf.sig      FR_N = GR_N // copy unbiased exponent of x to significand
+      fms.s1        FR_r = FR_RcpX,f8,f1 // range reduction for |x-1|>=1/256
+      extr.u        GR_Ind = GR_Sig,55,8 // get bits from 55 to 62 as index
+}
+{ .mib
+      sub           GR_x = GR_x, GR_xorg // get diff between x and 255/256
+      cmp.gtu       p6, p7 = 2, GR_Nm1 // p6 true if 0.5 <= x < 2
+(p9)  br.ret.spnt   b0 // exit for NaN, NaT and +Inf
+};;
+
+{ .mfi
+      ldfpd         FR_Ln2hi,FR_Ln2lo = [GR_ad_1],16
+      fclass.m      p11,p0 = f8,0x07 // is x = 0?
+      shladd        GR_ad_3 = GR_Ind,2,GR_ad_3 // address of Tlo
+}
+{ .mib
+      shladd        GR_ad_2 = GR_Ind,3,GR_ad_2 // address of Thi
+(p6)  cmp.leu       p6, p7 = GR_x, GR_dx       // 255/256 <= x <= 257/256
+(p10) br.cond.spnt  log_negatives // jump if x is negative
+};;
+
+// p6 is true if |x-1| < 1/256
+// p7 is true if |x-1| >= 1/256
+{ .mfi
+      ldfd          FR_Thi = [GR_ad_2]
+(p6)  fms.s1        FR_r = f8,f1,f1 // range reduction for |x-1|<1/256
+      nop.i         0
+};;
+
+{ .mmi
+(p7)  ldfs          FR_Tlo = [GR_ad_3]
+      nop.m         0
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p12) fma.d.s0      f8 = f0,f0,f0
+(p12) br.ret.spnt   b0 // exit for +1.0
+};;
+
+.pred.rel "mutex",p6,p7
+{ .mfi
+(p6)  mov           GR_NearOne = 1
+      fms.s1        FR_A32 = FR_A3,FR_r,FR_A2 // A3*r-A2
+(p7)  mov           GR_NearOne = 0
+}
+{ .mfb
+      ldfe          FR_InvLn10 = [GR_ad_1],16
+      fma.s1        FR_r2 = FR_r,FR_r,f0 // r^2
+(p11) br.cond.spnt  log_zeroes // jump if x is zero
+};;
+
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A6 = FR_A7,FR_r,FR_A6 // A7*r+A6
+      nop.i         0
+}
+{ .mfi
+(p7)  cmp.eq.unc    p9,p0 = r0,r0  // set p9 if |x-1| > 1/256
+      fma.s1        FR_A4 = FR_A5,FR_r,FR_A4 // A5*r+A4
+(p14) cmp.eq.unc    p8,p0 = 1,GR_NearOne // set p8 to 1 if it's log10
+                                         // and argument near 1.0
+};;
+
+{ .mfi
+(p6)  getf.exp      GR_rexp = FR_r  // Get signexp of x-1
+(p7)  fcvt.xf       FR_N = FR_N
+(p8)  cmp.eq        p9,p6 = r0,r0        // Also set p9 and clear p6 if log10
+                                         // and arg near 1
+};;
+
+{ .mfi
+      nop.m         0
+      fma.s1        FR_r4 = FR_r2,FR_r2,f0 // r^4
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p8)  fma.s1        FR_NxLn2pT = f0,f0,f0  // Clear NxLn2pT if log10 near 1
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      // (A3*r+A2)*r^2+r
+      fma.s1        FR_A321 = FR_A32,FR_r2,FR_r
+      mov           GR_mask = 0x1ffff
+}
+{ .mfi
+      nop.m         0
+      // (A7*r+A6)*r^2+(A5*r+A4)
+      fma.s1        FR_A4 = FR_A6,FR_r2,FR_A4
+      nop.i         0
+};;
+
+{ .mfi
+(p6)  and           GR_rexp = GR_rexp, GR_mask
+      // N*Ln2hi+Thi
+(p7)  fma.s1        FR_NxLn2hipThi = FR_N,FR_Ln2hi,FR_Thi
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      // N*Ln2lo+Tlo
+(p7)  fma.s1        FR_NxLn2lopTlo = FR_N,FR_Ln2lo,FR_Tlo
+      nop.i         0
+};;
+
+{ .mfi
+(p6)  sub           GR_rexp = GR_rexp, GR_bias // unbiased exponent of x-1
+(p9)  fma.s1        f8 = FR_A4,FR_r4,FR_A321 // P(r) if |x-1| >= 1/256 or
+                                             // log10 and |x-1| < 1/256
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      // (N*Ln2hi+Thi) + (N*Ln2lo+Tlo)
+(p7)  fma.s1        FR_NxLn2pT = FR_NxLn2hipThi,f1,FR_NxLn2lopTlo
+      nop.i         0
+};;
+
+{ .mfi
+(p6)  cmp.gt.unc    p10, p6 = -40, GR_rexp // Test |x-1| < 2^-40
+      nop.f         0
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+(p10) fma.d.s0      f8 = FR_A32,FR_r2,FR_r // log(x) if |x-1| < 2^-40
+      nop.i         0
+};;
+
+.pred.rel "mutex",p6,p9
+{ .mfi
+      nop.m         0
+(p6)  fma.d.s0      f8 = FR_A4,FR_r4,FR_A321 // log(x) if 2^-40 <= |x-1| < 1/256
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p9)  fma.d.s0      f8 = f8,FR_InvLn10,FR_NxLn2pT // result if |x-1| >= 1/256
+                                                  // or log10 and |x-1| < 1/256
+      br.ret.sptk   b0
+};;
+
+.align 32
+log_positive_unorms:
+{ .mmf
+      getf.exp      GR_Exp = FR_NormX // recompute biased exponent
+      getf.d        GR_x = FR_NormX   // recompute double precision x
+      fcmp.eq.s1    p12,p0 = f1,FR_NormX // is x equal to 1.0?
+};;
+
+{ .mfb
+      getf.sig      GR_Sig = FR_NormX // recompute significand
+      fcmp.eq.s0    p15, p0 = f8, f0  // set denormal flag
+      br.cond.sptk  log_core
+};;
+
+.align 32
+log_zeroes:
+{ .mfi
+      nop.m         0
+      fmerge.s      FR_X = f8,f8 // keep input argument for subsequent
+                                 // call of __libm_error_support#
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fms.s1        FR_tmp = f0,f0,f1 // -1.0
+      nop.i         0
+};;
+
+.pred.rel "mutex",p13,p14
+{ .mfi
+(p13) mov           GR_TAG = 2 // set libm error in case of log
+      frcpa.s0      f8,p0 = FR_tmp,f0 // log(+/-0) should be equal to -INF.
+                                      // We can get it using frcpa because it
+                                      // sets result to the IEEE-754 mandated
+                                      // quotient of FR_tmp/f0.
+                                      // As far as FR_tmp is -1 it'll be -INF
+      nop.i         0
+}
+{ .mib
+(p14) mov           GR_TAG = 8 // set libm error in case of log10
+      nop.i         0
+      br.cond.sptk  log_libm_err
+};;
+
+.align 32
+log_negatives:
+{ .mfi
+      nop.m         0
+      fmerge.s      FR_X = f8,f8
+      nop.i         0
+};;
+
+.pred.rel "mutex",p13,p14
+{ .mfi
+(p13) mov           GR_TAG = 3 // set libm error in case of log
+      frcpa.s0      f8,p0 = f0,f0 // log(negatives) should be equal to NaN.
+                                  // We can get it using frcpa because it
+                                  // sets result to the IEEE-754 mandated
+                                  // quotient of f0/f0 i.e. NaN.
+(p14) mov           GR_TAG = 9 // set libm error in case of log10
+};;
+
+.align 32
+log_libm_err:
+{ .mmi
+      alloc         r32 = ar.pfs,1,4,4,0
+      mov           GR_Parameter_TAG = GR_TAG
+      nop.i         0
+};;
+GLOBAL_IEEE754_END(log)
+libm_alias_double_other (__log, log)
+#ifdef SHARED
+.symver log,log@@GLIBC_2.29
+.weak __log_compat
+.set __log_compat,__log
+.symver __log_compat,log@GLIBC_2.2
+#endif
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y = -32,sp         // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS = ar.pfs             // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp = -64,sp                       // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP = gp                   // Save gp
+};;
+
+{ .mmi
+        stfd [GR_Parameter_Y] = FR_Y,16       // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp            // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0 = b0                   // Save b0
+};;
+
+.body
+{ .mib
+        stfd [GR_Parameter_X] = FR_X          // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = FR_RESULT     // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support# // Call error handling function
+};;
+
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]      // Get return result off stack
+.restore sp
+        add   sp = 64,sp                      // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                 // Restore return address
+};;
+
+{ .mib
+        mov   gp = GR_SAVE_GP                 // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS            // Restore ar.pfs
+        br.ret.sptk     b0                    // Return
+};;
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_log10.c
@@ -0,0 +1 @@
+/* Not needed. */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_log10f.c
@@ -0,0 +1 @@
+/* Not needed. */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_log10l.c
@@ -0,0 +1 @@
+/* Not needed. */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_log2.S
@@ -0,0 +1,715 @@
+.file "log2.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//=================================================================
+// 09/11/00 Initial version
+// 03/19/01 Added one polynomial coefficient, to improve accuracy
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 04/18/03 Reformatted T[255]
+//
+// API
+//=================================================================
+// double log2(double)
+//
+// Overview of operation
+//=================================================================
+// Background
+//
+// Implementation
+//
+// Let x = 2^l * m, where     m=1.b1 b2 ... b8 b9 ... b52
+//     y=frcpa(m),   r=m*y-1, f=b1 b2 .. b8 (table index)
+// j=0 if f<128; j=1 if f>=128
+// T is a table that stores log2(1/y) (in entries 1..255) rounded to
+//   double extended precision; f is used as an index; T[255]=0
+//
+// If f=0 and b9=0, r is set to 2^{-8}* 0.b9 b10 ... b52 = m-1 (fractional part of m),
+//                  and 0 is used instead of T[0]
+//                  (polynomial evaluation only, for m=1+r, 0<=r<2^{-9})
+// If f=255, r is set to (m-2)/2  (T[255]=0, and only polynomial evaluation is used
+//                                 for m=2(1-r'), 0<=r'<2^{-9})
+//
+// log2(x) is approximated as
+//     (l-j) + T[f] + (c1*r+c2*r^2+...+c7*r^7), if f>0
+//
+
+
+// Special values
+//=================================================================
+//  log2(0)=-inf, raises Divide by Zero
+//  log2(+inf)=inf
+//  log2(x)=NaN,  raises Invalid if x<0
+//
+
+
+// Registers used
+//==============================================================
+//   f6-f15, f32-f33
+//   r2-r3, r23-r30
+//   p6,p7,p8,p12
+//
+
+
+GR_SAVE_B0                    = r33
+GR_SAVE_PFS                   = r34
+GR_SAVE_GP                    = r35 // This reg. can safely be used
+GR_SAVE_SP                    = r36
+
+GR_Parameter_X                = r37
+GR_Parameter_Y                = r38
+GR_Parameter_RESULT           = r39
+GR_Parameter_TAG              = r40
+
+FR_X             = f10
+FR_Y             = f1
+FR_RESULT        = f8
+
+
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+
+data8 0xbfd0000000000000, 0x3fc999999999999a //C_4, C_5
+data8 0xbfc5555555555555, 0x3fc2492492492492 //C_6, C_7
+data8 0xb8aa3b295c17f0bc, 0x00003fff  // C_1
+data8 0xaaaaaaaaaaaaaaab, 0x00003ffd  // C_3=1/3
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+LOCAL_OBJECT_START(T_table)
+
+data8 0xb8d8752172fed131, 0x00003ff6
+data8 0x8ae7f475764180a3, 0x00003ff8
+data8 0xe7f73862e72ee35d, 0x00003ff8
+data8 0xa2b25310c941a2f2, 0x00003ff9
+data8 0xcbb91d671abb2e85, 0x00003ff9
+data8 0xfac91e34daa50483, 0x00003ff9
+data8 0x9504a5042eb495c5, 0x00003ffa
+data8 0xa9c4a0bbb580ee02, 0x00003ffa
+data8 0xc19264dc8a5e3bf9, 0x00003ffa
+data8 0xd67aa6703ebf4a77, 0x00003ffa
+data8 0xee76cac6d6e08ce7, 0x00003ffa
+data8 0x81c3f7de5434ed04, 0x00003ffb
+data8 0x8c563033a3ce01e4, 0x00003ffb
+data8 0x9876e9f09a98661c, 0x00003ffb
+data8 0xa31e0ac9b2326ce2, 0x00003ffb
+data8 0xadcf09e1fd10e4a5, 0x00003ffb
+data8 0xb889f992cf03cdb6, 0x00003ffb
+data8 0xc34eec68d901a714, 0x00003ffb
+data8 0xce1df524e9909ed9, 0x00003ffb
+data8 0xd8f726bcb0b80ad0, 0x00003ffb
+data8 0xe3da945b878e27d1, 0x00003ffb
+data8 0xeec851633b76a320, 0x00003ffb
+data8 0xf82ea4bb6101421a, 0x00003ffb
+data8 0x8197ddd7736b2864, 0x00003ffc
+data8 0x871dad4f994253f0, 0x00003ffc
+data8 0x8ca8cae3e892d549, 0x00003ffc
+data8 0x916d6e1559a4b697, 0x00003ffc
+data8 0x97028118efabeb7d, 0x00003ffc
+data8 0x9bcfbce1592ad5d5, 0x00003ffc
+data8 0xa16ee95d0da54a91, 0x00003ffc
+data8 0xa644dcf3403fa5d0, 0x00003ffc
+data8 0xab1ee14ffd659064, 0x00003ffc
+data8 0xb0cd12faebcc6757, 0x00003ffc
+data8 0xb5affdf9b3b221e0, 0x00003ffc
+data8 0xba970fb307c6ade1, 0x00003ffc
+data8 0xbf824f3a9f3e7561, 0x00003ffc
+data8 0xc544c055fde99333, 0x00003ffc
+data8 0xca39266532bdf26c, 0x00003ffc
+data8 0xcf31d124b8fa2f56, 0x00003ffc
+data8 0xd42ec7f59017b6ab, 0x00003ffc
+data8 0xd930124bea9a2c67, 0x00003ffc
+data8 0xde35b7af70e4dab3, 0x00003ffc
+data8 0xe33fbfbb8533ef03, 0x00003ffc
+data8 0xe77625911a7dcef3, 0x00003ffc
+data8 0xec884bd689cc12e3, 0x00003ffc
+data8 0xf19eeabf9e99a40a, 0x00003ffc
+data8 0xf6ba0a35e3d88051, 0x00003ffc
+data8 0xfbd9b237f7b4192b, 0x00003ffc
+data8 0x80111d4a1ee0c79e, 0x00003ffd
+data8 0x82a523a5f875bbfc, 0x00003ffd
+data8 0x84ccecdc92cd0815, 0x00003ffd
+data8 0x87653369d92c057a, 0x00003ffd
+data8 0x89ffd1742da3aa21, 0x00003ffd
+data8 0x8c2d2227d053d9b6, 0x00003ffd
+data8 0x8e5c189793f7f798, 0x00003ffd
+data8 0x90fd0a20e72f3c96, 0x00003ffd
+data8 0x932fa937301e59ae, 0x00003ffd
+data8 0x95d5061a5f0f5f7f, 0x00003ffd
+data8 0x980b5a2ef10e7023, 0x00003ffd
+data8 0x9a4361c5514d3c27, 0x00003ffd
+data8 0x9c7d1f7d541313fd, 0x00003ffd
+data8 0x9f2b16040b500d04, 0x00003ffd
+data8 0xa168a0fa9db22c98, 0x00003ffd
+data8 0xa3a7eaa1f9116293, 0x00003ffd
+data8 0xa5e8f5b4072a3d44, 0x00003ffd
+data8 0xa82bc4f11a5e88aa, 0x00003ffd
+data8 0xaa705b2001db8317, 0x00003ffd
+data8 0xacb6bb0e1e0f8005, 0x00003ffd
+data8 0xaefee78f75707221, 0x00003ffd
+data8 0xb148e37ec994dd99, 0x00003ffd
+data8 0xb394b1bdaca0bc17, 0x00003ffd
+data8 0xb5e255349707e496, 0x00003ffd
+data8 0xb831d0d2fda791cc, 0x00003ffd
+data8 0xba83278f6838ab20, 0x00003ffd
+data8 0xbcd65c67881c7d47, 0x00003ffd
+data8 0xbeb3e0f21d72dc92, 0x00003ffd
+data8 0xc10a7a03457d35dc, 0x00003ffd
+data8 0xc362f9b6f51eddd3, 0x00003ffd
+data8 0xc5bd6326ebfce656, 0x00003ffd
+data8 0xc7a0b3d0637c8f97, 0x00003ffd
+data8 0xc9fe96af0df8e4b5, 0x00003ffd
+data8 0xcc5e6c214b4a2cd7, 0x00003ffd
+data8 0xce46199f374d29cf, 0x00003ffd
+data8 0xd0a978a14c0d9ebe, 0x00003ffd
+data8 0xd293fecafec7f9b5, 0x00003ffd
+data8 0xd4faf1f6f5cf32e6, 0x00003ffd
+data8 0xd6e8595abaad34d1, 0x00003ffd
+data8 0xd952eb7a8ffc1593, 0x00003ffd
+data8 0xdb433ccd805f171e, 0x00003ffd
+data8 0xddb178dc43e6bd84, 0x00003ffd
+data8 0xdfa4bcfb333342a4, 0x00003ffd
+data8 0xe19953741ccea015, 0x00003ffd
+data8 0xe40cee16a2ff21c5, 0x00003ffd
+data8 0xe6048470cdbde8ea, 0x00003ffd
+data8 0xe7fd7308d6895b14, 0x00003ffd
+data8 0xe9f7bbb6a1ff9f87, 0x00003ffd
+data8 0xec7280138809433d, 0x00003ffd
+data8 0xee6fda4365cd051f, 0x00003ffd
+data8 0xf06e94a122ff1f12, 0x00003ffd
+data8 0xf26eb1151441fce5, 0x00003ffd
+data8 0xf470318b88a77e2f, 0x00003ffd
+data8 0xf67317f4d4c8aa58, 0x00003ffd
+data8 0xf8f8b250a9c4cde6, 0x00003ffd
+data8 0xfafec54831f1a484, 0x00003ffd
+data8 0xfd06449bf3eaea1e, 0x00003ffd
+data8 0xff0f324ddb19ab67, 0x00003ffd
+data8 0x808cc8320a9acf15, 0x00003ffe
+data8 0x8192b0748f2cef06, 0x00003ffe
+data8 0x829952f5e6a24ee5, 0x00003ffe
+data8 0x83a0b0bfafe1424e, 0x00003ffe
+data8 0x8466b29f9c41caea, 0x00003ffe
+data8 0x856f5aae0881d857, 0x00003ffe
+data8 0x8678c0eae8ee8190, 0x00003ffe
+data8 0x8782e6685676b9d7, 0x00003ffe
+data8 0x888dcc3abc4554ec, 0x00003ffe
+data8 0x89997378de7b98b8, 0x00003ffe
+data8 0x8aa5dd3be1044279, 0x00003ffe
+data8 0x8b6facdfd0360ab8, 0x00003ffe
+data8 0x8c7d6db7169e0cdb, 0x00003ffe
+data8 0x8d8bf424d6e130b2, 0x00003ffe
+data8 0x8e575b506f409fa6, 0x00003ffe
+data8 0x8f673e418776492c, 0x00003ffe
+data8 0x9077e9ed700ef9ba, 0x00003ffe
+data8 0x9144ef1baec80b20, 0x00003ffe
+data8 0x9256fcdb537f035f, 0x00003ffe
+data8 0x9369d68d75e7e1d6, 0x00003ffe
+data8 0x943880613b8f9f1e, 0x00003ffe
+data8 0x954cc1d9e0d94206, 0x00003ffe
+data8 0xd3c70a37bdf7a294, 0x0000bffd
+data8 0xd19bb053fb0284ec, 0x0000bffd
+data8 0xcffa1a3b7dafb8bf, 0x0000bffd
+data8 0xcdcbe1e2776479ee, 0x0000bffd
+data8 0xcc282218b8bfdda2, 0x0000bffd
+data8 0xc9f703a9afcb38ac, 0x0000bffd
+data8 0xc851146ab89593c6, 0x0000bffd
+data8 0xc61d08265927a860, 0x0000bffd
+data8 0xc474e39705912d26, 0x0000bffd
+data8 0xc23de19ec30c6e3e, 0x0000bffd
+data8 0xc09381cc45db45b4, 0x0000bffd
+data8 0xbee82b4e025ff90c, 0x0000bffd
+data8 0xbcace101149788ec, 0x0000bffd
+data8 0xbaff46962ea47964, 0x0000bffd
+data8 0xb950b1be5e0c14a2, 0x0000bffd
+data8 0xb7110e6ce866f2bc, 0x0000bffd
+data8 0xb5602ccc2a81db52, 0x0000bffd
+data8 0xb3ae4ce740fc8ef1, 0x0000bffd
+data8 0xb1fb6d92c8240ccc, 0x0000bffd
+data8 0xafb609c09b244abc, 0x0000bffd
+data8 0xae00d1cfdeb43cfd, 0x0000bffd
+data8 0xac4a967a8c8c9bd0, 0x0000bffd
+data8 0xaa93568c249e6c52, 0x0000bffd
+data8 0xa8db10cdff375343, 0x0000bffd
+data8 0xa68e6fc5a42376e3, 0x0000bffd
+data8 0xa4d3c25e68dc57f2, 0x0000bffd
+data8 0xa3180b0c192a3816, 0x0000bffd
+data8 0xa15b488e7aa329a0, 0x0000bffd
+data8 0x9f9d79a30f0e1d5f, 0x0000bffd
+data8 0x9dde9d050ee7d4ac, 0x0000bffd
+data8 0x9c1eb16d63d7356c, 0x0000bffd
+data8 0x9a5db592a310c36a, 0x0000bffd
+data8 0x989ba82907a9016f, 0x0000bffd
+data8 0x96d887e26cd57b79, 0x0000bffd
+data8 0x9514536e481c3a4f, 0x0000bffd
+data8 0x934f0979a3715fc9, 0x0000bffd
+data8 0x9188a8af1742a9d5, 0x0000bffd
+data8 0x8fc12fb6c470995f, 0x0000bffd
+data8 0x8df89d364e34f8f1, 0x0000bffd
+data8 0x8c2eefd0d3f67dd6, 0x0000bffd
+data8 0x8a642626eb093d54, 0x0000bffd
+data8 0x88983ed6985bae58, 0x0000bffd
+data8 0x86cb387b4a0feec6, 0x0000bffd
+data8 0x84fd11add101024b, 0x0000bffd
+data8 0x83c856dd81804b78, 0x0000bffd
+data8 0x81f84c2c62afd6f1, 0x0000bffd
+data8 0x80271d3e4be5ea5a, 0x0000bffd
+data8 0xfca991447e7b485d, 0x0000bffc
+data8 0xf90299c904793a3c, 0x0000bffc
+data8 0xf559511d2dc1ed69, 0x0000bffc
+data8 0xf2e72afee9bd2aee, 0x0000bffc
+data8 0xef39ff1d8a40770e, 0x0000bffc
+data8 0xeb8a7a2311c935dc, 0x0000bffc
+data8 0xe7d8990dc620012f, 0x0000bffc
+data8 0xe560b1e3b86e44b6, 0x0000bffc
+data8 0xe1aadb38caee80c4, 0x0000bffc
+data8 0xddf2a051f81b76a4, 0x0000bffc
+data8 0xdb7678bafcaf4b5f, 0x0000bffc
+data8 0xd7ba3a8f0df19bfc, 0x0000bffc
+data8 0xd3fb8fdbdd5cebdb, 0x0000bffc
+data8 0xd17b191905c35652, 0x0000bffc
+data8 0xcdb85d29cefd7121, 0x0000bffc
+data8 0xc9f32c3c88221ef6, 0x0000bffc
+data8 0xc76e5741a95b5dae, 0x0000bffc
+data8 0xc3a506d80d38c718, 0x0000bffc
+data8 0xbfd938ccef8b68c1, 0x0000bffc
+data8 0xbd4ff63e82eef78c, 0x0000bffc
+data8 0xb97ffa2b563865bd, 0x0000bffc
+data8 0xb6f3eb3011eddcea, 0x0000bffc
+data8 0xb31fb7d64898b3e6, 0x0000bffc
+data8 0xb090d63a409e7880, 0x0000bffc
+data8 0xacb8623c7ffa4f39, 0x0000bffc
+data8 0xa8dd5c83d2e45246, 0x0000bffc
+data8 0xa649e998a8d91f2e, 0x0000bffc
+data8 0xa26a93fed6faa94f, 0x0000bffc
+data8 0x9fd43df079d0db1f, 0x0000bffc
+data8 0x9d3cbe69aecac4c2, 0x0000bffc
+data8 0x99574f13c570d0fb, 0x0000bffc
+data8 0x96bce349bf7ee6c7, 0x0000bffc
+data8 0x92d30c9b86cee18e, 0x0000bffc
+data8 0x9035adef17c5bd5c, 0x0000bffc
+data8 0x8c4765e8e8b5f251, 0x0000bffc
+data8 0x89a70da448316ffa, 0x0000bffc
+data8 0x85b44a24474af78a, 0x0000bffc
+data8 0x8310f17aab5adf70, 0x0000bffc
+data8 0x806c6388d0965f29, 0x0000bffc
+data8 0xf8e69092bf0c5ead, 0x0000bffb
+data8 0xf397608bfd2d90e6, 0x0000bffb
+data8 0xee45be24d0eedbc4, 0x0000bffb
+data8 0xe646af233db881e9, 0x0000bffb
+data8 0xe0eee4e1ce3d06fb, 0x0000bffb
+data8 0xdb94a049e6e87a4f, 0x0000bffb
+data8 0xd3888ef9a4249f5a, 0x0000bffb
+data8 0xce280e6fbac39194, 0x0000bffb
+data8 0xc8c50b72319ad574, 0x0000bffb
+data8 0xc0abcd39f41e329b, 0x0000bffb
+data8 0xbb4279cfa7f9667b, 0x0000bffb
+data8 0xb5d69bac77ec398a, 0x0000bffb
+data8 0xb068306bf20d6233, 0x0000bffb
+data8 0xa83dc1b019ddb6a8, 0x0000bffb
+data8 0xa2c8eb1886c2d024, 0x0000bffb
+data8 0x9d517ee93f8e16c0, 0x0000bffb
+data8 0x97d77aae659b92fb, 0x0000bffb
+data8 0x8f9b91da5736d415, 0x0000bffb
+data8 0x8a1b06b09b7fd1d1, 0x0000bffb
+data8 0x8497daca0a2e077a, 0x0000bffb
+data8 0xfe241745a453f10c, 0x0000bffa
+data8 0xf3132d6708d723c5, 0x0000bffa
+data8 0xe7fcf2e21a0e7d77, 0x0000bffa
+data8 0xd75198b04afb8da9, 0x0000bffa
+data8 0xcc2dfe1a4a8ca305, 0x0000bffa
+data8 0xc10500d63aa65882, 0x0000bffa
+data8 0xb5d69bac77ec398a, 0x0000bffa
+data8 0xaaa2c95dc66abcde, 0x0000bffa
+data8 0x9f6984a342d13101, 0x0000bffa
+data8 0x942ac82e5387ac51, 0x0000bffa
+data8 0x88e68ea899a0976c, 0x0000bffa
+data8 0xefebc4409ccf872e, 0x0000bff9
+data8 0xd947b0c6642ef69e, 0x0000bff9
+data8 0xc2987d51e043d407, 0x0000bff9
+data8 0xabde1eeee6bfd257, 0x0000bff9
+data8 0x95188a9917cf2e01, 0x0000bff9
+data8 0xfc8f6a777c1b7f1e, 0x0000bff8
+data8 0xced727635c59725c, 0x0000bff8
+data8 0xa108358a4c904615, 0x0000bff8
+data8 0xe644fcbeb3ac9c90, 0x0000bff7
+data8 0x8a4bd667bf08e7de, 0x0000bff7
+data8 0x0000000000000000 // T[255] Low
+data8 0x0000000000000000 // T[255] High
+LOCAL_OBJECT_END(T_table)
+
+
+
+.section .text
+WEAK_LIBM_ENTRY(log2)
+
+{ .mfi
+  alloc r32=ar.pfs,1,4,4,0
+  // y=frcpa(x)
+  frcpa.s1 f6,p0=f1,f8
+  // will form significand of 1.5 (to test whether the index is 128 or above)
+  mov r24=0xc
+}
+{.mfi
+  nop.m 0
+  // normalize x
+  fma.s1 f7=f8,f1,f0
+  // r2 = pointer to C_1...C_6 followed by T_table
+  addl r2 = @ltoff(poly_coeffs), gp;;
+}
+{.mfi
+  // get significand
+  getf.sig r25=f8
+  // f8 denormal ?
+  fclass.m p8,p10=f8,0x9
+  // will form significand of 1.5 (to test whether the index is 128 or above)
+  shl r24=r24,60
+}
+{.mfi
+  mov r26=0x804
+  nop.f 0
+  // r23=bias-1
+  mov r23=0xfffe;;
+}
+
+{.mmf
+  getf.exp r29=f8
+  // load start address for C_1...C_6 followed by T_table
+  ld8 r2=[r2]
+  // will continue only for positive normal/denormal numbers
+  fclass.nm.unc p12,p7 = f8, 0x19 ;;
+}
+
+.pred.rel "mutex",p8,p10
+{.mfi
+  // denormal input, repeat get significand (after normalization)
+  (p8) getf.sig r25=f7
+  // x=1 ?
+  fcmp.eq.s0 p6,p0=f8,f1
+  // get T_index
+  (p10) shr.u r28=r25,63-8
+}
+{.mfi
+  // f32=0.5
+  setf.exp f32=r23
+  nop.f 0
+  // r27=bias
+  mov r27=0xffff;;
+}
+
+{.mmi
+  // denormal input, repeat get exponent (after normalization)
+  (p8) getf.exp r29=f7
+  mov r23=0xff
+  // r26=0x80400...0 (threshold for using polynomial approximation)
+  shl r26=r26,64-12;;
+}
+
+{.mfb
+  add r3=48,r2
+  // r=1-x*y
+  fms.s1 f6=f6,f8,f1
+  (p12) br.cond.spnt SPECIAL_LOG2
+}
+{.mfi
+  // load C_4, C_5
+  ldfpd f10,f11=[r2],16
+  nop.f 0
+  cmp.geu p12,p0=r25,r24;;
+}
+
+{.mmi
+  // load C_6, C_7
+  ldfpd f12,f13=[r2],16
+  // r27=bias-1 (if index >=128, will add exponent+1)
+  (p12) mov r27=0xfffe
+  (p8) shr.u r28=r25,63-8;;
+}
+
+
+{.mfi
+  // load C_1
+  ldfe f14=[r2],32
+  fmerge.se f7=f1,f7
+  // if first 9 bits after leading 1 are all zero, then p8=1
+  cmp.ltu p8,p12=r25,r26
+}
+{.mfi
+  // load C_3
+  ldfe f15=[r3]
+  nop.f 0
+  // get T_index
+  and r28=r28,r23;;
+}
+{.mfi
+  // r29=exponent-bias
+  sub r29=r29,r27
+  // x=1, return 0
+  (p6) fma.d.s0 f8=f0,f0,f0
+  // get T address
+  shladd r2=r28,4,r2
+}
+{.mfb
+  // first 8 bits after leading 1 are all ones ?
+  cmp.eq p10,p0=r23,r28
+  // if first 8 bits after leading bit are 0, use polynomial approx. only
+  (p8) fms.s1 f6=f7,f1,f1
+  // x=1, return
+  (p6) br.ret.spnt b0;;
+}
+{.mfi
+  // r26=1
+  mov r26=1
+  // if first 8 bits after leading 1 are all ones, use polynomial approx. only
+  (p10) fms.s1 f6=f7,f32,f1
+  nop.i 0;;
+}
+
+.pred.rel "mutex",p8,p12
+{.mmf
+  // load T (unless first 9 bits after leading 1 are 0)
+  (p12) ldfe f33=[r2]
+  // f8=expon - bias
+  setf.sig f8=r29
+  // set T=0 (if first 9 bits after leading 1 are 0)
+  (p8) fma.s1 f33=f0,f0,f0;;
+}
+
+{.mfi
+  nop.m 0
+  // P12=1-0.5*r
+  fnma.s1 f32=f32,f6,f1
+  // r26=2^{63}
+  shl r26=r26,63
+}
+{.mfi
+  nop.m 0
+  // r2=r*r
+  fma.s1 f7=f6,f6,f0
+  nop.i 0;;
+}
+{.mfi
+  // significand(x)=1 ?
+  cmp.eq p0,p6=r26,r25
+  // P67=C_6+C_7*r
+  fma.s1 f13=f13,f6,f12
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // P45=C_4+C_5*r
+  fma.s1 f10=f11,f6,f10
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // C_1*r
+  (p6) fma.s1 f14=f14,f6,f0
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // normalize additive term (l=exponent of x)
+  fcvt.xf f8=f8
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // P13=1-0.5*r+C_3*r^2
+  (p6) fma.s1 f15=f15,f7,f32
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // P47=P45+r2*P67
+  (p6) fma.s1 f13=f13,f7,f10
+  // if significand(x)=1, return exponent (l)
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // r3=r^3
+  (p6) fma.s1 f7=f7,f6,f0
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // add T+l
+  (p6) fma.s1 f8=f8,f1,f33
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // P17=P13+r3*P47
+  (p6) fma.s1 f13=f13,f7,f15
+  nop.i 0;;
+}
+
+{.mfb
+  nop.m 0
+  // result=T+l+(C_1*r)*P16
+  (p6) fma.d.s0 f8=f13,f14,f8
+  // return
+  br.ret.sptk b0;;
+}
+
+
+SPECIAL_LOG2:
+{.mfi
+  nop.m 0
+  // x=+Infinity ?
+  fclass.m p7,p0=f8,0x21
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // x=+/-Zero ?
+  fclass.m p8,p0=f8,0x7
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // x=-Infinity, -normal, -denormal ?
+  fclass.m p6,p0=f8,0x3a
+  nop.i 0;;
+}
+{.mfb
+  nop.m 0
+  // log2(+Infinity)=+Infinity
+  nop.f 0
+  (p7) br.ret.spnt b0;;
+}
+{.mfi
+  (p8) mov GR_Parameter_TAG = 170
+  // log2(+/-0)=-infinity, raises Divide by Zero
+  // set f8=-0
+  (p8) fmerge.ns f8=f0,f8
+  nop.i 0;;
+}
+{.mfb
+  nop.m 0
+  (p8) frcpa.s0 f8,p0=f1,f8
+  (p8) br.cond.sptk __libm_error_region;;
+}
+{.mfb
+  (p6) mov GR_Parameter_TAG = 171
+  // x<0: return NaN, raise Invalid
+  (p6) frcpa.s0 f8,p0=f0,f0
+  (p6) br.cond.sptk __libm_error_region;;
+}
+
+
+{.mfb
+  nop.m 0
+  // Remaining cases: NaNs
+  fma.d.s0 f8=f8,f1,f0
+  br.ret.sptk b0;;
+}
+
+WEAK_LIBM_END(log2)
+libm_alias_double_other (__log2, log2)
+#ifdef SHARED
+.symver log2,log2@@GLIBC_2.29
+.weak __log2_compat
+.set __log2_compat,__log2
+.symver __log2_compat,log2@GLIBC_2.2
+#endif
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfd [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfd [GR_Parameter_X] = FR_X                  // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+	nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = FR_RESULT             // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#         // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_log2_data.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_log2f.S
@@ -0,0 +1,553 @@
+.file "log2f.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 09/11/00 Initial version
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+// API
+//==============================================================
+// float log2f(float)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// Let x = 2^l * m, where     m=1.b1 b2 ... b8 b9 ... b52
+//     y=frcpa(m),   r=m*y-1, f=b1 b2 .. b8 (table index)
+// j=0 if f<128; j=1 if f>=128
+// T is a table that stores log2(1/y) (in entries 1..255) rounded to
+//   double extended precision; f is used as an index; T[255]=0
+//
+// If f=0 and b9=0, r is set to 2^{-8}* 0.b9 b10 ... b52 = m-1 (fractional part of m),
+//                  and 0 is used instead of T[0]
+//                  (polynomial evaluation only, for m=1+r, 0<=r<2^{-9})
+// If f=255, r is set to (m-2)/2  (T[255]=0, and only polynomial evaluation is used
+//                                 for m=2(1-r'), 0<=r'<2^{-9})
+//
+// log2f(x) is approximated as
+//     (l-j) + T[f] + (c1*r+c2*r^2+...+c6*r^6), if f>0
+//
+
+
+// Special values
+//==============================================================
+//  log2f(0)=-inf, raises Divide by Zero
+//  log2f(+inf)=inf
+//  log2f(x)=NaN,  raises Invalid if x<0
+//
+
+
+// Registers used
+//==============================================================
+//   f6-f14
+//   r2-r3, r23-r30
+//   p6,p7,p8,p12
+//
+
+
+GR_SAVE_B0                    = r33
+GR_SAVE_PFS                   = r34
+GR_SAVE_GP                    = r35 // This reg. can safely be used
+GR_SAVE_SP                    = r36
+
+GR_Parameter_X                = r37
+GR_Parameter_Y                = r38
+GR_Parameter_RESULT           = r39
+GR_Parameter_TAG              = r40
+
+FR_X             = f10
+FR_Y             = f1
+FR_RESULT        = f8
+
+
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+
+data8 0x3fdec709dc3a03fd, 0xbfd71547652b82fe //C_3 and C_4
+data8 0xb8aa3b295c17f0bc, 0x00003fff  // C_1
+data8 0xb8aa3b295c17f0bc, 0x0000bffe  // C_2
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+LOCAL_OBJECT_START(T_table)
+
+data8 0x3f671b0ea42e5fda, 0x3f815cfe8eaec830
+data8 0x3f8cfee70c5ce5dc, 0x3f94564a62192834
+data8 0x3f997723ace35766, 0x3f9f5923c69b54a1
+data8 0x3fa2a094a085d693, 0x3fa538941776b01e
+data8 0x3fa8324c9b914bc7, 0x3faacf54ce07d7e9
+data8 0x3fadced958dadc12, 0x3fb0387efbca869e
+data8 0x3fb18ac6067479c0, 0x3fb30edd3e13530d
+data8 0x3fb463c15936464e, 0x3fb5b9e13c3fa21d
+data8 0x3fb7113f3259e07a, 0x3fb869dd8d1b2035
+data8 0x3fb9c3bea49d3214, 0x3fbb1ee4d7961701
+data8 0x3fbc7b528b70f1c5, 0x3fbdd90a2c676ed4
+data8 0x3fbf05d4976c2028, 0x3fc032fbbaee6d65
+data8 0x3fc0e3b5a9f3284a, 0x3fc195195c7d125b
+data8 0x3fc22dadc2ab3497, 0x3fc2e050231df57d
+data8 0x3fc379f79c2b255b, 0x3fc42ddd2ba1b4a9
+data8 0x3fc4c89b9e6807f5, 0x3fc563dc29ffacb2
+data8 0x3fc619a25f5d798d, 0x3fc6b5ffbf367644
+data8 0x3fc752e1f660f8d6, 0x3fc7f049e753e7cf
+data8 0x3fc8a8980abfbd32, 0x3fc94724cca657be
+data8 0x3fc9e63a24971f46, 0x3fca85d8feb202f7
+data8 0x3fcb2602497d5346, 0x3fcbc6b6f5ee1c9b
+data8 0x3fcc67f7f770a67e, 0x3fcceec4b2234fba
+data8 0x3fcd91097ad13982, 0x3fce33dd57f3d335
+data8 0x3fced74146bc7b10, 0x3fcf7b3646fef683
+data8 0x3fd00223a943dc19, 0x3fd054a474bf0eb7
+data8 0x3fd0999d9b9259a1, 0x3fd0eca66d3b2581
+data8 0x3fd13ffa2e85b475, 0x3fd185a444fa0a7b
+data8 0x3fd1cb8312f27eff, 0x3fd21fa1441ce5e8
+data8 0x3fd265f526e603cb, 0x3fd2baa0c34be1ec
+data8 0x3fd3016b45de21ce, 0x3fd3486c38aa29a8
+data8 0x3fd38fa3efaa8262, 0x3fd3e562c0816a02
+data8 0x3fd42d141f53b646, 0x3fd474fd543f222c
+data8 0x3fd4bd1eb680e548, 0x3fd505789e234bd1
+data8 0x3fd54e0b64003b70, 0x3fd596d761c3c1f0
+data8 0x3fd5dfdcf1eeae0e, 0x3fd6291c6fd9329c
+data8 0x3fd6729637b59418, 0x3fd6bc4aa692e0fd
+data8 0x3fd7063a1a5fb4f2, 0x3fd75064f1ed0715
+data8 0x3fd79acb8cf10390, 0x3fd7d67c1e43ae5c
+data8 0x3fd8214f4068afa7, 0x3fd86c5f36dea3dc
+data8 0x3fd8b7ac64dd7f9d, 0x3fd8f4167a0c6f92
+data8 0x3fd93fd2d5e1bf1d, 0x3fd98bcd84296946
+data8 0x3fd9c8c333e6e9a5, 0x3fda152f142981b4
+data8 0x3fda527fd95fd8ff, 0x3fda9f5e3edeb9e6
+data8 0x3fdadd0b2b5755a7, 0x3fdb2a5d6f51ff83
+data8 0x3fdb686799b00be3, 0x3fdbb62f1b887cd8
+data8 0x3fdbf4979f666668, 0x3fdc332a6e8399d4
+data8 0x3fdc819dc2d45fe4, 0x3fdcc0908e19b7bd
+data8 0x3fdcffae611ad12b, 0x3fdd3ef776d43ff4
+data8 0x3fdd8e5002710128, 0x3fddcdfb486cb9a1
+data8 0x3fde0dd294245fe4, 0x3fde4dd622a28840
+data8 0x3fde8e06317114f0, 0x3fdece62fe9a9915
+data8 0x3fdf1f164a15389a, 0x3fdf5fd8a9063e35
+data8 0x3fdfa0c8937e7d5d, 0x3fdfe1e649bb6335
+data8 0x3fe011990641535a, 0x3fe032560e91e59e
+data8 0x3fe0532a5ebcd44a, 0x3fe0741617f5fc28
+data8 0x3fe08cd653f38839, 0x3fe0adeb55c1103b
+data8 0x3fe0cf181d5d1dd0, 0x3fe0f05ccd0aced7
+data8 0x3fe111b9875788ab, 0x3fe1332e6f1bcf73
+data8 0x3fe154bba77c2088, 0x3fe16df59bfa06c1
+data8 0x3fe18fadb6e2d3c2, 0x3fe1b17e849adc26
+data8 0x3fe1caeb6a0de814, 0x3fe1ece7c830eec9
+data8 0x3fe20efd3dae01df, 0x3fe2289de375d901
+data8 0x3fe24adf9b6a6fe0, 0x3fe26d3ad1aebcfc
+data8 0x3fe287100c2771f4, 0x3fe2a9983b3c1b28
+data8 0xbfda78e146f7bef4, 0xbfda33760a7f6051
+data8 0xbfd9ff43476fb5f7, 0xbfd9b97c3c4eec8f
+data8 0xbfd98504431717fc, 0xbfd93ee07535f967
+data8 0xbfd90a228d5712b2, 0xbfd8c3a104cb24f5
+data8 0xbfd88e9c72e0b226, 0xbfd847bc33d8618e
+data8 0xbfd812703988bb69, 0xbfd7dd0569c04bff
+data8 0xbfd7959c202292f1, 0xbfd75fe8d2c5d48f
+data8 0xbfd72a1637cbc183, 0xbfd6e221cd9d0cde
+data8 0xbfd6ac059985503b, 0xbfd675c99ce81f92
+data8 0xbfd63f6db2590482, 0xbfd5f6c138136489
+data8 0xbfd5c01a39fbd688, 0xbfd58952cf519193
+data8 0xbfd5526ad18493ce, 0xbfd51b6219bfe6ea
+data8 0xbfd4d1cdf8b4846f, 0xbfd49a784bcd1b8b
+data8 0xbfd4630161832547, 0xbfd42b6911cf5465
+data8 0xbfd3f3af3461e1c4, 0xbfd3bbd3a0a1dcfb
+data8 0xbfd383d62dac7ae7, 0xbfd34bb6b2546218
+data8 0xbfd313750520f520, 0xbfd2db10fc4d9aaf
+data8 0xbfd2a28a6dc90387, 0xbfd269e12f346e2c
+data8 0xbfd2311515e2e855, 0xbfd1f825f6d88e13
+data8 0xbfd1bf13a6c9c69f, 0xbfd185ddfa1a7ed0
+data8 0xbfd14c84c4dd6128, 0xbfd11307dad30b76
+data8 0xbfd0d9670f6941fe, 0xbfd09fa235ba2020
+data8 0xbfd0790adbb03009, 0xbfd03f09858c55fb
+data8 0xbfd004e3a7c97cbd, 0xbfcf9532288fcf69
+data8 0xbfcf205339208f27, 0xbfceab2a23a5b83e
+data8 0xbfce5ce55fdd37a5, 0xbfcde73fe3b1480f
+data8 0xbfcd714f44623927, 0xbfccfb1321b8c400
+data8 0xbfccac163c770dc9, 0xbfcc355b67195dd0
+data8 0xbfcbbe540a3f036f, 0xbfcb6ecf175f95e9
+data8 0xbfcaf74751e1be33, 0xbfca7f71fb7bab9d
+data8 0xbfca2f632320b86b, 0xbfc9b70ba539dfae
+data8 0xbfc93e6587910444, 0xbfc8edcae8352b6c
+data8 0xbfc874a0db01a719, 0xbfc7fb27199df16d
+data8 0xbfc7a9fec7d05ddf, 0xbfc72fff456ac70d
+data8 0xbfc6de7d66023dbc, 0xbfc663f6fac91316
+data8 0xbfc6121ac74813cf, 0xbfc5970c478fff4a
+data8 0xbfc51bab907a5c8a, 0xbfc4c93d33151b24
+data8 0xbfc44d527fdadf55, 0xbfc3fa87be0f3a1b
+data8 0xbfc3a797cd35d959, 0xbfc32ae9e278ae1a
+data8 0xbfc2d79c6937efdd, 0xbfc25a619370d9dc
+data8 0xbfc206b5bde2f8b8, 0xbfc188ecbd1d16be
+data8 0xbfc134e1b489062e, 0xbfc0b6894488e95f
+data8 0xbfc0621e2f556b5c, 0xbfc00d8c711a12cc
+data8 0xbfbf1cd21257e18c, 0xbfbe72ec117fa5b2
+data8 0xbfbdc8b7c49a1ddb, 0xbfbcc8d5e467b710
+data8 0xbfbc1ddc9c39c7a1, 0xbfbb7294093cdd0f
+data8 0xbfba7111df348494, 0xbfb9c501cdf75872
+data8 0xbfb918a16e46335b, 0xbfb81579a73e83c6
+data8 0xbfb7684f39f4ff2d, 0xbfb6bad3758efd87
+data8 0xbfb60d060d7e41ac, 0xbfb507b836033bb7
+data8 0xbfb4591d6310d85a, 0xbfb3aa2fdd27f1c3
+data8 0xbfb2faef55ccb372, 0xbfb1f3723b4ae6db
+data8 0xbfb14360d6136ffa, 0xbfb092fb594145c1
+data8 0xbfafc482e8b48a7e, 0xbfae6265ace11ae4
+data8 0xbfacff9e5c4341d0, 0xbfaaea3316095f72
+data8 0xbfa985bfc3495194, 0xbfa820a01ac754cb
+data8 0xbfa6bad3758efd87, 0xbfa554592bb8cd58
+data8 0xbfa3ed3094685a26, 0xbfa2855905ca70f6
+data8 0xbfa11cd1d5133413, 0xbf9dfd78881399f1
+data8 0xbf9b28f618cc85df, 0xbf98530faa3c087b
+data8 0xbf957bc3dddcd7fa, 0xbf92a3115322f9e6
+data8 0xbf8f91ed4eef8370, 0xbf89dae4ec6b8b2e
+data8 0xbf842106b1499209, 0xbf7cc89f97d67594
+data8 0xbf71497accf7e11d, 0x0000000000000000
+LOCAL_OBJECT_END(T_table)
+
+
+.section .text
+WEAK_LIBM_ENTRY(log2f)
+
+{ .mfi
+  alloc r32=ar.pfs,1,4,4,0
+  // y=frcpa(x)
+  frcpa.s1 f6,p0=f1,f8
+  // will form significand of 1.5 (to test whether the index is 128 or above)
+  mov r24=0xc
+}
+{.mfi
+  nop.m 0
+  // normalize x
+  fma.s1 f7=f8,f1,f0
+  // r2 = pointer to C_1...C_6 followed by T_table
+  addl r2 = @ltoff(poly_coeffs), gp;;
+}
+{.mfi
+  // get significand
+  getf.sig r25=f8
+  // f8 denormal ?
+  fclass.m p8,p10=f8,0x9
+  // will form significand of 1.5 (to test whether the index is 128 or above)
+  shl r24=r24,60
+}
+{.mfi
+  mov r26=0x804
+  nop.f 0
+  // r23=bias-1
+  mov r23=0xfffe;;
+}
+
+{.mmf
+  getf.exp r29=f8
+  // load start address for C_1...C_6 followed by T_table
+  ld8 r2=[r2]
+  // will continue only for positive normal/denormal numbers
+  fclass.nm.unc p12,p7 = f8, 0x19 ;;
+}
+
+.pred.rel "mutex",p8,p10
+{.mfi
+  // denormal input, repeat get significand (after normalization)
+  (p8) getf.sig r25=f7
+  // x=1 ?
+  fcmp.eq.s0 p6,p0=f8,f1
+  // get T_index
+  (p10) shr.u r28=r25,63-8
+}
+{.mfi
+  // f12=0.5
+  setf.exp f12=r23
+  nop.f 0
+  // r27=bias
+  mov r27=0xffff;;
+}
+
+{.mfb
+  // denormal input, repeat get exponent (after normalization)
+  (p8) getf.exp r29=f7
+  nop.f 0
+  (p12) br.cond.spnt SPECIAL_log2f
+}
+{.mfi
+  cmp.geu p12,p0=r25,r24
+  nop.f 0
+  mov r23=0xff;;
+}
+
+{.mfi
+  add r3=32,r2
+  // r=1-x*y
+  fms.s1 f6=f6,f8,f1
+  // r26=0x80400...0 (threshold for using polynomial approximation)
+  shl r26=r26,64-12
+}
+{.mfi
+  // load C_3, C_4
+  ldfpd f10,f11=[r2],16
+  nop.f 0
+  // r27=bias-1 (if index >=128, will add exponent+1)
+  (p12) mov r27=0xfffe;;
+}
+
+{.mfi
+  // load C_1
+  ldfe f14=[r2],32
+  // x=1, return 0
+  (p6) fma.s.s0 f8=f0,f0,f0
+  (p8) shr.u r28=r25,63-8
+}
+{.mib
+  // load C_2
+  ldfe f13=[r3]
+  // r29=exponent-bias
+  sub r29=r29,r27
+  // x=1, return
+  (p6) br.ret.spnt b0;;
+}
+
+
+{.mfi
+  // get T_index
+  and r28=r28,r23
+  fmerge.se f7=f1,f7
+  // if first 9 bits after leading 1 are all zero, then p8=1
+  cmp.ltu p8,p12=r25,r26;;
+}
+{.mfi
+  // f8=expon - bias
+  setf.sig f8=r29
+  nop.f 0
+  // get T address
+  shladd r2=r28,3,r2
+}
+{.mfi
+  // first 8 bits after leading 1 are all ones ?
+  cmp.eq p10,p0=r23,r28
+  // if first 8 bits after leading bit are 0, use polynomial approx. only
+  (p8) fms.s1 f6=f7,f1,f1
+  nop.i 0;;
+}
+{.mfi
+  //r26=1
+  mov r26=1
+  // if first 8 bits after leading 1 are all ones, use polynomial approx. only
+  (p10) fms.s1 f6=f7,f12,f1
+  nop.i 0;;
+}
+
+.pred.rel "mutex",p8,p12
+{.mmf
+  // load T (unless first 9 bits after leading 1 are 0)
+  (p12) ldfd f12=[r2]
+  nop.m 0
+  // set T=0 (if first 9 bits after leading 1 are 0)
+  (p8) fma.s1 f12=f0,f0,f0;;
+}
+
+{.mfi
+  nop.m 0
+  // P34=C_3+C_4*r
+  fma.s1 f10=f11,f6,f10
+  // r26=2^{63}
+  shl r26=r26,63
+}
+{.mfi
+  nop.m 0
+  // r2=r*r
+  fma.s1 f11=f6,f6,f0
+  nop.i 0;;
+}
+{.mfi
+  // significand of x is 1 ?
+  cmp.eq p0,p6=r25,r26
+  // P12=C_1+C_2*r
+  fma.s1 f14=f13,f6,f14
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // normalize additive term (l=exponent of x)
+  fcvt.xf f8=f8
+  // if significand(x)=1, return exponent (l)
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // add T+l
+  (p6) fma.s1 f8=f8,f1,f12
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // P14=P12+r2*P34
+  (p6) fma.s1 f13=f10,f11,f14
+  nop.i 0;;
+}
+
+{.mfb
+  nop.m 0
+  // result=T+l+r*P14
+  (p6) fma.s.s0 f8=f13,f6,f8
+  // return
+  br.ret.sptk b0;;
+}
+
+
+SPECIAL_log2f:
+{.mfi
+  nop.m 0
+  // x=+Infinity ?
+  fclass.m p7,p0=f8,0x21
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // x=+/-Zero ?
+  fclass.m p8,p0=f8,0x7
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // x=-Infinity, -normal, -denormal ?
+  fclass.m p6,p0=f8,0x3a
+  nop.i 0;;
+}
+{.mfb
+  nop.m 0
+  // log2f(+Infinity)=+Infinity
+  nop.f 0
+  (p7) br.ret.spnt b0;;
+}
+{.mfi
+  (p8) mov GR_Parameter_TAG = 172
+  // log2f(+/-0)=-infinity, raises Divide by Zero
+  // set f8=-0
+  (p8) fmerge.ns f8=f0,f8
+  nop.i 0;;
+}
+{.mfb
+  nop.m 0
+  (p8) frcpa.s0 f8,p0=f1,f8
+  (p8) br.cond.sptk __libm_error_region;;
+}
+{.mfb
+  (p6) mov GR_Parameter_TAG = 173
+  // x<0: return NaN, raise Invalid
+  (p6) frcpa.s0 f8,p0=f0,f0
+  (p6) br.cond.sptk __libm_error_region;;
+}
+
+
+{.mfb
+  nop.m 0
+  // Remaining cases: NaNs
+  fma.s.s0 f8=f8,f1,f0
+  br.ret.sptk b0;;
+}
+
+WEAK_LIBM_END(log2f)
+libm_alias_float_other (__log2, log2)
+#ifdef SHARED
+.symver log2f,log2f@@GLIBC_2.27
+.weak __log2f_compat
+.set __log2f_compat,__log2f
+.symver __log2f_compat,log2f@GLIBC_2.2
+#endif
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfs [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfs [GR_Parameter_X] = FR_X                  // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+	nop.b 0
+}
+{ .mib
+        stfs [GR_Parameter_Y] = FR_RESULT             // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#         // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_log2f_data.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_log2l.S
@@ -0,0 +1,815 @@
+.file "log2l.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 09/25/00 Initial version
+// 11/22/00 Fixed accuracy bug (for mantissas near 1, 2)
+// 12/07/00 Fixed C_1l constant, eliminated rounding errors in
+//          reduced argument (x*frcpa(x)-1)
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+// API
+//==============================================================
+// long double log2l(long double)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// Let x = 2^l * m, where     m=1.b1 b2 ... b8 b9 ... b52
+//     y=frcpa(m),   r=m*y-1, f=b1 b2 .. b8
+// T_hi is a table that stores the 24 most significant bits of log2(1/y)
+// (in entries 1..255) in single precision format
+// T_low is a table that stores (log2(1/y)-T_high), rounded to double
+// precision
+//
+// f is used as an index; T_high[255]=T_low[255]=0
+//
+// If f=0 and b9=0, r is set to 2^{-8}* 0.b9 b10 ... b52 = m-1 (fractional part of m),
+//                  and 0 is used instead of T_high[0], T_low[0]
+//                  (polynomial evaluation only, for m=1+r, 0<=r<2^{-9})
+// If f=255, r is set to (m-2)/2  (T[255]=0, and only polynomial evaluation is used
+//                                 for m=2(1-r'), 0<=r'<2^{-9})
+//
+// If 2^{-9}<=m<2-2^{-8} or (input not near 1), let C1r=(2^{16}+C1*r)-2^{16}
+//                       and let E=((RN(m*y)-1)-r)+(m*y-RN(m*y))
+// Else let C1r=C1*r (rounded to 64 significant bits)  and let  E=0
+//
+// Let D=C1*r-C1r
+//
+//
+// log2l(x) is approximated as
+//     (l+T_high[f]+C1r) + (D+r*(c1+c2*r+c3*r^2...+c8*r^7)+(T_low[f]+C_1*E))
+//
+
+
+// Special values
+//==============================================================
+//  log2l(0)=-inf, raises Divide by Zero
+//  log2l(+inf)=inf
+//  log2l(x)=NaN,  raises Invalid if x<0
+//
+
+
+// Registers used
+//==============================================================
+//   f6-f15, f32-f36
+//   r2-r3, r23-r23
+//   p6,p7,p8,p12
+//
+
+
+GR_SAVE_B0                    = r33
+GR_SAVE_PFS                   = r34
+GR_SAVE_GP                    = r35 // This reg. can safely be used
+GR_SAVE_SP                    = r36
+
+GR_Parameter_X                = r37
+GR_Parameter_Y                = r38
+GR_Parameter_RESULT           = r39
+GR_Parameter_TAG              = r40
+
+FR_X             = f10
+FR_Y             = f1
+FR_RESULT        = f8
+
+
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+
+data8 0xb8aa3b295c17f0bc, 0x00003fff  // C_1
+data8 0x3fca61762a7aded9, 0xbfc71547652b82fe // C_7, C_8
+data8 0x3fd2776c50ef9bfe, 0xbfcec709dc3a03fd // C_5, C_6
+data8 0x3fdec709dc3a03fd, 0xbfd71547652b82fe  // C_3, C_4
+//data8 0xd871319ff0342580, 0x0000bfbd	// C_1l (low part of C1)
+data8 0x82f0025f2dc582ee, 0x0000bfbe   // C_1l (low part of C1)
+data8 0xb8aa3b295c17f0bc, 0x0000bffe  // C_2
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+
+
+LOCAL_OBJECT_START(T_table)
+
+data4 0x3b38d875, 0x3c0ae7f4, 0x3c67f738, 0x3ca2b253
+data4 0x3ccbb91d, 0x3cfac91e, 0x3d1504a5, 0x3d29c4a0
+data4 0x3d419264, 0x3d567aa6, 0x3d6e76ca, 0x3d81c3f7
+data4 0x3d8c5630, 0x3d9876e9, 0x3da31e0a, 0x3dadcf09
+data4 0x3db889f9, 0x3dc34eec, 0x3dce1df5, 0x3dd8f726
+data4 0x3de3da94, 0x3deec851, 0x3df82ea4, 0x3e0197dd
+data4 0x3e071dad, 0x3e0ca8ca, 0x3e116d6e, 0x3e170281
+data4 0x3e1bcfbc, 0x3e216ee9, 0x3e2644dc, 0x3e2b1ee1
+data4 0x3e30cd12, 0x3e35affd, 0x3e3a970f, 0x3e3f824f
+data4 0x3e4544c0, 0x3e4a3926, 0x3e4f31d1, 0x3e542ec7
+data4 0x3e593012, 0x3e5e35b7, 0x3e633fbf, 0x3e677625
+data4 0x3e6c884b, 0x3e719eea, 0x3e76ba0a, 0x3e7bd9b2
+data4 0x3e80111d, 0x3e82a523, 0x3e84ccec, 0x3e876533
+data4 0x3e89ffd1, 0x3e8c2d22, 0x3e8e5c18, 0x3e90fd0a
+data4 0x3e932fa9, 0x3e95d506, 0x3e980b5a, 0x3e9a4361
+data4 0x3e9c7d1f, 0x3e9f2b16, 0x3ea168a0, 0x3ea3a7ea
+data4 0x3ea5e8f5, 0x3ea82bc4, 0x3eaa705b, 0x3eacb6bb
+data4 0x3eaefee7, 0x3eb148e3, 0x3eb394b1, 0x3eb5e255
+data4 0x3eb831d0, 0x3eba8327, 0x3ebcd65c, 0x3ebeb3e0
+data4 0x3ec10a7a, 0x3ec362f9, 0x3ec5bd63, 0x3ec7a0b3
+data4 0x3ec9fe96, 0x3ecc5e6c, 0x3ece4619, 0x3ed0a978
+data4 0x3ed293fe, 0x3ed4faf1, 0x3ed6e859, 0x3ed952eb
+data4 0x3edb433c, 0x3eddb178, 0x3edfa4bc, 0x3ee19953
+data4 0x3ee40cee, 0x3ee60484, 0x3ee7fd73, 0x3ee9f7bb
+data4 0x3eec7280, 0x3eee6fda, 0x3ef06e94, 0x3ef26eb1
+data4 0x3ef47031, 0x3ef67317, 0x3ef8f8b2, 0x3efafec5
+data4 0x3efd0644, 0x3eff0f32, 0x3f008cc8, 0x3f0192b0
+data4 0x3f029952, 0x3f03a0b0, 0x3f0466b2, 0x3f056f5a
+data4 0x3f0678c0, 0x3f0782e6, 0x3f088dcc, 0x3f099973
+data4 0x3f0aa5dd, 0x3f0b6fac, 0x3f0c7d6d, 0x3f0d8bf4
+data4 0x3f0e575b, 0x3f0f673e, 0x3f1077e9, 0x3f1144ef
+data4 0x3f1256fc, 0x3f1369d6, 0x3f143880, 0x3f154cc1
+data4 0x3f161c7a, 0x3f173227, 0x3f1802f2, 0x3f191a0f
+data4 0x3f19ebee, 0x3f1b047e, 0x3f1bd775, 0x3f1cf17b
+data4 0x3f1dc58e, 0x3f1ee10f, 0x3f1fb63f, 0x3f208bea
+data4 0x3f21a98f, 0x3f22805c, 0x3f2357a7, 0x3f247778
+data4 0x3f254fe9, 0x3f2628d9, 0x3f270249, 0x3f2824fb
+data4 0x3f28ff97, 0x3f29dab4, 0x3f2ab654, 0x3f2b9277
+data4 0x3f2cb8c8, 0x3f2d961e, 0x3f2e73fa, 0x3f2f525b
+data4 0x3f303143, 0x3f3110b1, 0x3f31f0a7, 0x3f32d125
+data4 0x3f33b22b, 0x3f3493bc, 0x3f3575d6, 0x3f36587b
+data4 0x3f373bab, 0x3f381f68, 0x3f3903b1, 0x3f39e888
+data4 0x3f3acdec, 0x3f3bb3e0, 0x3f3c9a63, 0x3f3d8177
+data4 0x3f3e1bd4, 0x3f3f03d9, 0x3f3fec71, 0x3f40d59b
+data4 0x3f41bf59, 0x3f42a9ab, 0x3f434635, 0x3f443180
+data4 0x3f451d61, 0x3f4609d9, 0x3f46a7d3, 0x3f479549
+data4 0x3f488357, 0x3f492261, 0x3f4a1171, 0x3f4b011c
+data4 0x3f4ba139, 0x3f4c91e8, 0x3f4d8334, 0x3f4e246a
+data4 0x3f4f16be, 0x3f5009b1, 0x3f50ac02, 0x3f51a001
+data4 0x3f524305, 0x3f533812, 0x3f53dbca, 0x3f54d1e7
+data4 0x3f55c8a8, 0x3f566d85, 0x3f57655b, 0x3f580af0
+data4 0x3f58b0d0, 0x3f59aa2c, 0x3f5a50c7, 0x3f5b4b3c
+data4 0x3f5bf294, 0x3f5cee26, 0x3f5d963c, 0x3f5e92ed
+data4 0x3f5f3bc3, 0x3f5fe4e7, 0x3f60e32d, 0x3f618d13
+data4 0x3f623748, 0x3f63372a, 0x3f63e223, 0x3f648d6b
+data4 0x3f658eee, 0x3f663afe, 0x3f66e75e, 0x3f67ea86
+data4 0x3f6897b0, 0x3f69452c, 0x3f69f2f9, 0x3f6af847
+data4 0x3f6ba6e2, 0x3f6c55d0, 0x3f6d0510, 0x3f6e0c8d
+data4 0x3f6ebc9f, 0x3f6f6d04, 0x3f701dbe, 0x3f70cecd
+data4 0x3f718030, 0x3f728ae6, 0x3f733d20, 0x3f73efaf
+data4 0x3f74a296, 0x3f7555d3, 0x3f760967, 0x3f76bd53
+data4 0x3f777197, 0x3f7880a1, 0x3f7935c2, 0x3f79eb3c
+data4 0x3f7aa10f, 0x3f7b573b, 0x3f7c0dc2, 0x3f7cc4a3
+data4 0x3f7d7bdf, 0x3f7e3376, 0x3f7eeb68, 0x00000000
+LOCAL_OBJECT_END(T_table)
+
+
+
+LOCAL_OBJECT_START(T_low)
+
+
+data8 0x3dc0b97f689876ef, 0x3dfd5d906028ac01
+data8 0x3df8b9cbb8d7240b, 0x3de0c941a2f220cd
+data8 0x3e09c6aecba15936, 0x3dfa6d528241827c
+data8 0x3dd0bad25714903c, 0x3e2776b01dc036a2
+data8 0x3e2b914bc77f158b, 0x3e1c0fafd29dc74a
+data8 0x3e28dadc119cd3de, 0x3e3bca869da085be
+data8 0x3e19d1e700f2200a, 0x3e3e13530cc37504
+data8 0x3e3936464d9c41ee, 0x3e3c3fa21c9499d0
+data8 0x3e3259e079b6c6e8, 0x3e2a364069c4f7f3
+data8 0x3e1274c84f6c6364, 0x3e3796170159f454
+data8 0x3e26e1e389f4364e, 0x3e28cedda8c7f658
+data8 0x3e376c2028433268, 0x3e4aee6d650c82e1
+data8 0x3e33e65094fbeeb4, 0x3e4c7d125aa92c5d
+data8 0x3e1559a4b69691d8, 0x3e18efabeb7d7221
+data8 0x3e4c2b255abaa8de, 0x3e37436952a4538b
+data8 0x3e4e6807f4ba00b8, 0x3e33ff5964190e42
+data8 0x3e4f5d798cead43c, 0x3e4f3676443bf453
+data8 0x3e4660f8d5bc1bf5, 0x3e2d4f9f3ab04f36
+data8 0x3e357f7a64ccd537, 0x3e394caf7c9b05af
+data8 0x3e225c7d17ab29b0, 0x3e4eb202f6d55a12
+data8 0x3e32faa68b19bcd2, 0x3e45ee1c9b566a8b
+data8 0x3e4770a67de054ff, 0x3e42234fb9de6d6b
+data8 0x3e4ad139825c6e19, 0x3e47f3d334814a93
+data8 0x3e2af1ec402867b6, 0x3e2bfbda0c956e3d
+data8 0x3e4287b831e77ff2, 0x3e54bf0eb77f7b89
+data8 0x3e5b9259a1029607, 0x3e4a764b015e699d
+data8 0x3e4d0b68ea883ab5, 0x3e33e829ecdadf46
+data8 0x3e52f27efef3031b, 0x3e3073979e4af89e
+data8 0x3e3b980f2cd6c253, 0x3e2a5f0f5f7f66a9
+data8 0x3e37788738117b02, 0x3e58aa29a784d52f
+data8 0x3e4f5504c4ff2466, 0x3e002d40340fa647
+data8 0x3e5f53b64592f4c3, 0x3e543f222c526802
+data8 0x3e5680e547a872fa, 0x3e5e234bd1154450
+data8 0x3e3000edc18b6d21, 0x3e1c3c1f000942a8
+data8 0x3e51eeae0e442d6e, 0x3e4fb265376623f2
+data8 0x3e57b5941782d830, 0x3e3a4b83f24ae52c
+data8 0x3e5a5fb4f23978de, 0x3e51ed071563fb02
+data8 0x3e49e2071f51a7a8, 0x3e5e43ae5b924234
+data8 0x3dfa2be9aedf374a, 0x3e56dea3dbba67d5
+data8 0x3e3375fe732b3c3e, 0x3e5a0c6f91f2e77e
+data8 0x3e55e1bf1c969e41, 0x3e30a5a5166b8eee
+data8 0x3e53e6e9a539d46c, 0x3e542981b3d7b0e6
+data8 0x3e595fd8ff36ad64, 0x3e5edeb9e65cbbb4
+data8 0x3e46aeab4d3434c1, 0x3e4ea3ff0564b010
+data8 0x3e59b00be2e3c25a, 0x3e5b887cd7b0821f
+data8 0x3e5f666668547b4d, 0x3e4d0733a805273f
+data8 0x3e26a2ff21c4aec5, 0x3e4c336f7a3a78f3
+data8 0x3e11ad12b628e2d0, 0x3e56d43ff3f0ea64
+data8 0x3e238809433cccd2, 0x3e40d9734147d40f
+data8 0x3e54245fe3e24e06, 0x3e251441fce4d48c
+data8 0x3e517114efc5d1f9, 0x3e5e9a99154b0d82
+data8 0x3e442a71337970f8, 0x3e420c7c69211fdf
+data8 0x3e537e7d5d43c6a7, 0x3e4376c66ad9ad8b
+data8 0x3e49054d678a4f1c, 0x3e5d23cb3bc19f18
+data8 0x3e6ebcd449dcab2b, 0x3e67f5fc2849c88a
+data8 0x3e63f388395d3e84, 0x3e65c1103b0ad7e9
+data8 0x3e6d5d1dd031f353, 0x3e5a159dae75c4d0
+data8 0x3e4d5e22aa75f71d, 0x3e5e379ee62e1e35
+data8 0x3e4df082213cb2dc, 0x3e6bfa06c156f521
+data8 0x3e66e2d3c19b517b, 0x3e426b7098590071
+data8 0x3e541bd027e9854e, 0x3e5061dd924b0ac0
+data8 0x3e6dae01df373a03, 0x3e3baec80b207b0b
+data8 0x3e6b6a6fe06bebac, 0x3e61aebcfc3ab5d1
+data8 0x3e584ee3e7c79d83, 0x3e6b3c1b2840cb40
+data8 0x3e6c842085d6befd, 0x3e6ac04fd7b141e0
+data8 0x3e6c48250474141d, 0x3e2d889b86125f69
+data8 0x3e6e74740225dad0, 0x3e45940d31d50a7c
+data8 0x3e695476a6c39ddc, 0x3e6d9a6d857a060a
+data8 0x3e4a3e9bb4b69337, 0x3e484f3ce4707ed6
+data8 0x3e39dd125d25fc27, 0x3e563fb400de8732
+data8 0x3e5fdd6d0ee28b48, 0x3e669d15b869bb07
+data8 0x3e40687cfad7964d, 0x3e69317990d43957
+data8 0x3e633d57e24ae1bd, 0x3e618bf03710eabb
+data8 0x3e4b4df6fccd1160, 0x3e3fb26ddaa1ec45
+data8 0x3e3810a5e1817fd4, 0x3e6857373642fa5c
+data8 0x3e673db6193add31, 0x3e63200c8acbc9c3
+data8 0x3e3d2dee448ebb62, 0x3e6a19723a80db6a
+data8 0x3e5e7cdab8fd3e6a, 0x3e671855cd660672
+data8 0x3e473c3c78a85ecd, 0x3e5f5e23056a7cf2
+data8 0x3e52538519527367, 0x3e4b573bcf2580e9
+data8 0x3e6d6f856fe90c60, 0x3e2d932a8487642e
+data8 0x3e5236fc78b6174c, 0x3e50cb91d406db50
+data8 0x3e650e8bd562aa57, 0x3e424ee3d9a82f2e
+data8 0x3e59363960e1e3d9, 0x3e379604c1150a3e
+data8 0x3e6d914f6c2ac258, 0x3e62967a451a7b48
+data8 0x3e684b5f01139cb2, 0x3e448bbfbf6d292c
+data8 0x3e6227e7fb487e73, 0x3e6d39d50290f458
+data8 0x3e58368342b4b668, 0x3e65dc0c25bd1763
+data8 0x3e61b7dc362e22b5, 0x3e671691f094bb80
+data8 0x3e5011642d5123f2, 0x3e4c4eb7f11e41be
+data8 0x3e5dcee36ca242cf, 0x3e6791cefff688f1
+data8 0x3e60e23c8dda4ecd, 0x3e48e6a22fe78cfe
+data8 0x3e6d703f244adc86, 0x3e6a281a85a5049d
+data8 0x3e570f20e6403d9e, 0x3e2211518a12956f
+data8 0x3e6737d1e54d71df, 0x3e66b1881476f5e9
+data8 0x3e6e1bbeef085376, 0x3e47cad4944a32be
+data8 0x3e527f2c738e7ee9, 0x3e699883a4b9fb29
+data8 0x3e5c17d1108740d9, 0x3e5d4a9c79a43389
+data8 0x3e49fdc24462ba3b, 0x3e24dbb3a60cceb2
+data8 0x3e5c5bf618780748, 0x3e5c38005b0c778c
+data8 0x3e6be168dd6dd3fe, 0x3e633ab9370693b0
+data8 0x3dd290556b0ae339, 0x3e607c317927096a
+data8 0x3e59651353b3d90e, 0x3e4d8751e5e0ae0d
+data8 0x3e46c81023272a85, 0x3e6b23c988f391b2
+data8 0x3e608741d215209c, 0x3e60b8ba506d758f
+data8 0x3e62ddbe74803297, 0x3e5dbb8b5087587d
+data8 0x3e642aa529048131, 0x3e3dcbda6835dcf4
+data8 0x3e6db503ce854d2a, 0x3e6dd00b49bc6849
+data8 0x3e4db2f11243bc84, 0x3e3b9848efc2ea97
+data8 0x3e58f18e17c82609, 0x3e6ed8645e16c312
+data8 0x3e4065bdb60a5dd4, 0x3e490453c6e6c30a
+data8 0x3e62373994aa31ba, 0x3e56305f0e6b2a95
+data8 0x3e68c1601a6614ee, 0x3e614e204f19d93f
+data8 0x3e6e5037ca773299, 0x3e693f98892561a6
+data8 0x3e639de4f4bf700d, 0x3e416c071e93fd97
+data8 0x3e65466991b415ef, 0x3e6896a324afac9d
+data8 0x3e44f64802e2f11c, 0x3e64d7d747e2191a
+data8 0x3e6174b7581de84c, 0x3e44c7b946e1d43c
+data8 0x3e6a3bcbe30512ec, 0x3e5d3ed411c95ce4
+data8 0x3e3e5b5735cfaf8e, 0x3e6e538ab34efb51
+data8 0x3e514e204f19d93f, 0x3e5a88e6550c89a4
+data8 0x3e66b97a5d9dfd8b, 0x3e5f46b1e14ebaf3
+data8 0x3e357665f6893f5d, 0x3e6bbf633078d1d5
+data8 0x3e5e7337a212c417, 0x3e3570fde15fc8cc
+data8 0x3e21119402da92b4, 0x3e6566e830d1ff3b
+data8 0x3e558883e480e220, 0x3e589ca3a68da411
+data8 0x3e44eb66df73d648, 0x3e1a0a629b1b7e68
+data8 0x3e54cc207b8c1116, 0x0000000000000000
+LOCAL_OBJECT_END(T_low)
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(log2l)
+
+{ .mfi
+  alloc r32=ar.pfs,1,4,4,0
+  // normalize x
+  // y=frcpa(x)
+  frcpa.s1 f41,p0=f1,f8
+  // r26=bias-1
+  mov r26=0xfffe
+}
+{.mfi
+  // r23=bias+16
+  mov r23=0xffff+16
+  fma.s1 f7=f8,f1,f0
+  // r2 = pointer to C_1...C_6 followed by T_table
+  addl r2 = @ltoff(poly_coeffs), gp;;
+}
+{.mfi
+  // get significand
+  getf.sig r25=f8
+  // f8 denormal ?
+  fclass.m p8,p10=f8,0x9
+  // r24=bias-8
+  mov r24=0xffff-8;;
+}
+{.mfi
+  setf.exp f36=r26
+  nop.f 0
+  // r27=bias
+  mov r27=0xffff;;
+}
+
+{.mmf
+  getf.exp r29=f8
+  // load start address for C_1...C_7 followed by T_table
+  ld8 r2=[r2]
+  // will continue only for positive normal/unnormal numbers
+  fclass.m.unc p0,p12 = f8, 0x19;;
+}
+
+
+.pred.rel "mutex",p8,p10
+{.mfi
+  // denormal input, repeat get significand (after normalization)
+  (p8) getf.sig r25=f7
+  // x=1 ?
+  fcmp.eq.s0 p6,p0=f8,f1
+  // get T_index
+  (p10) shr.u r28=r25,63-8
+}
+{.mfi
+  // f32=2^16
+  setf.exp f32=r23
+  nop.f 0
+  mov r26=0x804;;
+}
+
+{.mfi
+  // denormal input, repeat get exponent (after normalization)
+  (p8) getf.exp r29=f7
+  // f33=0
+  mov f33=f0
+  // r26=0x80400...0 (threshold for using polynomial approximation)
+  shl r26=r26,64-12;;
+}
+
+{.mfb
+  add r3=16,r2
+  // r=x*y-1
+  fms.s1 f6=f41,f8,f1
+  (p12) br.cond.spnt SPECIAL_log2l
+}
+{.mfi
+  // load C_1
+  ldfe f14=[r2],48
+  // RN(x*y)
+  fma.s1 f43=f41,f8,f0
+  mov r23=0xff;;
+}
+
+{.mmi
+  // load C_7, C_8
+  ldfpd f10,f11=[r3],16
+  // load C_3,C_4
+  ldfpd f15,f42=[r2],16
+  (p8) shr.u r28=r25,63-8;;
+}
+
+
+{.mfi
+  // load C_5, C_6
+  ldfpd f12,f13=[r3]
+  // pseudo-zero ?
+  fcmp.eq.s0 p7,p0=f7,f0
+  // if first 9 bits after leading 1 are all zero, then p8=1
+  cmp.ltu p8,p12=r25,r26
+}
+{.mfi
+  // load C1l
+  ldfe f34=[r2],16
+  fmerge.se f7=f1,f7
+  // get T_index
+  and r28=r28,r23;;
+}
+{.mfi
+  // r29=exponent-bias
+  sub r29=r29,r27
+  // if first 8 bits after leading bit are 0, use polynomial approx. only
+  (p8) fms.s1 f6=f7,f1,f1
+  // start address of T_low
+  add r3=1024+16,r2
+}
+{.mfi
+  // load C_2
+  ldfe f35=[r2],16
+  // x=1, return 0
+  (p6) fma.s0 f8=f0,f0,f0
+  // first 8 bits after leading 1 are all ones ?
+  cmp.eq p10,p0=r23,r28;;
+}
+
+{.mfb
+  // if first 8 bits after leading 1 are all ones, use polynomial approx. only
+  // add 1 to the exponent additive term, and estimate log2(1-r)
+  (p10) add r29=1,r29
+  nop.f 0
+  (p7) br.cond.spnt LOG2_PSEUDO_ZERO
+}
+{.mfi
+  // get T_low address
+  shladd r3=r28,3,r3
+  // if first 8 bits after leading 1 are all ones, use polynomial approx. only
+  (p10) fms.s1 f6=f7,f36,f1
+  // p10 --> p8=1, p12=0
+  (p10) cmp.eq p8,p12=r0,r0;;
+}
+
+{.mfi
+  // get T_high address
+  shladd r2=r28,2,r2
+  // L(x*y)=x*y-RN(x*y)
+  fms.s1 f41=f41,f8,f43
+  nop.i 0
+}
+{.mfi
+  // p13=p12
+  (p12) cmp.eq.unc p13,p0=r0,r0
+  // RtH=RN(x*y)-1  (will eliminate rounding errors in r)
+  fms.s1 f43=f43,f1,f1
+  nop.i 0;;
+}
+
+.pred.rel "mutex",p8,p12
+{.mfb
+  // load T_high (unless first 9 bits after leading 1 are 0)
+  (p12) ldfs f7=[r2]
+  // set T_high=0 (if first 9 bits after leading 1 are 0)
+  (p8) fma.s1 f7=f0,f0,f0
+  // x=1, return
+  (p6) br.ret.spnt b0
+}
+.pred.rel "mutex",p8,p12
+{.mfi
+  // p12: load T_low
+  (p12) ldfd f36=[r3]
+  // p8: set T_low=0
+  (p8) fma.s1 f36=f0,f0,f0
+  (p8) cmp.eq p8,p12=r29,r0;; //nop.i 0;;
+}
+
+.pred.rel "mutex",p8,p12
+{.mfi
+  // f8=expon - bias
+  setf.sig f8=r29
+  // general case: 2^{16}+C1*r
+  (p12) fma.s1 f33=f6,f14,f32
+  nop.i 0
+}
+{.mfi
+  // r26=1
+  mov r26=1
+  // p8 (mantissa is close to 1, or close to 2): 2^{-8}+C1*r
+  (p8) fma.s1 f32=f6,f14,f33
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // P78=C_7+C_8*r
+  fma.s1 f10=f11,f6,f10
+  // r26=2^{63}
+  shl r26=r26,63
+}
+{.mfi
+  nop.m 0
+  // P34=C_3+r*C_4
+  fma.s1 f15=f42,f6,f15
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // r2=r*r
+  fma.s1 f11=f6,f6,f0
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // P56=C_5+C_6*r
+  fma.s1 f13=f13,f6,f12
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // Rth-r
+  (p13) fms.s1 f43=f43,f1,f6
+  nop.i 0
+}
+{.mfi
+  // significand(x)=1 ?
+  cmp.eq p0,p6=r25,r26
+  // P12=C1l+C_2*r
+  fma.s1 f34=f35,f6,f34
+  nop.i 0;;
+}
+
+.pred.rel "mutex",p8,p12
+{.mfi
+  nop.m 0
+  // p12: C1r=(2^{16}+C1*r)-2^{16}
+  (p12) fms.s1 f32=f33,f1,f32
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // p8: C1r=C1*r (double extended)
+  (p8) fms.s1 f32=f32,f1,f33
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // L(x*y)*C_1+T_low
+  (p13) fma.s1 f36=f41,f14,f36
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // P58=P56+r2*P78
+  fma.s1 f13=f11,f10,f13
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // P14=P12+r2*P34
+  fma.s1 f15=f15,f11,f34
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // r4=r2*r2
+  fma.s1 f11=f11,f11,f0
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // normalize additive term (l=exponent of x)
+  fcvt.xf f8=f8
+  nop.i 0;;
+}
+
+
+{.mfi
+  nop.m 0
+  // D=C1*r-C1r
+  (p6) fms.s1 f12=f14,f6,f32
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // T_low'=(Rth-r)*C1+(L(x*y)*C1+T_low)
+  (p13) fma.s1 f36=f43,f14,f36
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // P18=P14+r4*P58
+  (p6) fma.s1 f13=f11,f13,f15
+  nop.i 0;;
+}
+
+{.mfi
+  nop.m 0
+  // add T_high+l
+  (p6) fma.s1 f8=f8,f1,f7
+  nop.i 0;;
+}
+
+
+{.mfi
+  nop.m 0
+  // D+T_low
+  (p6) fma.s1 f12=f12,f1,f36
+  nop.i 0;;
+}
+
+
+{.mfi
+  nop.m 0
+  // (T_high+l)+C1r
+  (p6) fma.s1 f8=f8,f1,f32
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // (D+T_low)+r*P18
+  (p6) fma.s1 f13=f13,f6,f12
+  nop.i 0;;
+}
+
+//{.mfb
+//nop.m 0
+//mov f8=f36
+//fma.s0 f8=f13,f6,f0
+//br.ret.sptk b0;;
+//}
+
+
+{.mfb
+  nop.m 0
+  // result=((T_high+l)+C1r)+((D+T_low)+r*P18)
+  (p6) fma.s0 f8=f13,f1,f8
+  // return
+  br.ret.sptk b0;;
+}
+
+
+SPECIAL_log2l:
+{.mfi
+  nop.m 0
+  mov FR_X=f8
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // x=+Infinity ?
+  fclass.m p7,p0=f8,0x21
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // x=+/-Zero ?
+  fclass.m p8,p0=f7,0x7
+  nop.i 0;;
+}
+{.mfi
+  nop.m 0
+  // x=-Infinity, -normal, -denormal ?
+  fclass.m p6,p0=f8,0x3a
+  nop.i 0;;
+}
+{.mfb
+  nop.m 0
+  // log2l(+Infinity)=+Infinity
+  nop.f 0
+  (p7) br.ret.spnt b0;;
+}
+{.mfi
+  (p8) mov GR_Parameter_TAG = 168
+  // log2l(+/-0)=-infinity, raises Divide by Zero
+  // set f8=-0
+  (p8) fmerge.ns f8=f0,f8
+  nop.i 0;;
+}
+{.mfb
+  nop.m 0
+  (p8) frcpa.s0 f8,p0=f1,f8
+  (p8) br.cond.sptk __libm_error_region;;
+}
+{.mfb
+  (p6) mov GR_Parameter_TAG = 169
+  // x<0: return NaN, raise Invalid
+  (p6) frcpa.s0 f8,p0=f0,f0
+  (p6) br.cond.sptk __libm_error_region;;
+}
+
+
+{.mfb
+  nop.m 0
+  // Remaining cases: NaNs
+  fma.s0 f8=f8,f1,f0
+  br.ret.sptk b0;;
+}
+
+LOG2_PSEUDO_ZERO:
+
+{.mfi
+  nop.m 0
+  mov FR_X=f8
+  nop.i 0
+}
+{.mfi
+  mov GR_Parameter_TAG = 168
+  // log2l(+/-0)=-infinity, raises Divide by Zero
+  // set f8=-0
+  fmerge.ns f8=f0,f8
+  nop.i 0;;
+}
+{.mfb
+  nop.m 0
+  frcpa.s0 f8,p0=f1,f8
+  br.cond.sptk __libm_error_region;;
+}
+
+
+GLOBAL_IEEE754_END(log2l)
+libm_alias_ldouble_other (__log2, log2)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfe [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfe [GR_Parameter_X] = FR_X                  // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+	nop.b 0
+}
+{ .mib
+        stfe [GR_Parameter_Y] = FR_RESULT             // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#         // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_log_data.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_logf.S
@@ -0,0 +1,1165 @@
+.file "logf.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 03/01/00 Initial version
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 01/10/01 Improved speed, fixed flags for neg denormals
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 05/23/02 Modified algorithm. Now only one polynomial is used
+//          for |x-1| >= 1/256 and for |x-1| < 1/256
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 03/31/05 Reformatted delimiters between data tables
+//
+// API
+//==============================================================
+// float logf(float)
+// float log10f(float)
+//
+//
+// Overview of operation
+//==============================================================
+// Background
+// ----------
+//
+// This algorithm is based on fact that
+// log(a b) = log(a) + log(b).
+//
+// In our case we have x = 2^N f, where 1 <= f < 2.
+// So
+//   log(x) = log(2^N f) = log(2^N) + log(f) = n*log(2) + log(f)
+//
+// To calculate log(f) we do following
+//   log(f) = log(f * frcpa(f) / frcpa(f)) =
+//          = log(f * frcpa(f)) + log(1/frcpa(f))
+//
+// According to definition of IA-64's frcpa instruction it's a
+// floating point that approximates 1/f using a lookup on the
+// top of 8 bits of the input number's significand with relative
+// error < 2^(-8.886). So we have following
+//
+// |(1/f - frcpa(f)) / (1/f))| = |1 - f*frcpa(f)| < 1/256
+//
+// and
+//
+// log(f) = log(f * frcpa(f)) + log(1/frcpa(f)) =
+//        = log(1 + r) + T
+//
+// The first value can be computed by polynomial P(r) approximating
+// log(1 + r) on |r| < 1/256 and the second is precomputed tabular
+// value defined by top 8 bit of f.
+//
+// Finally we have that  log(x) ~ (N*log(2) + T) + P(r)
+//
+// Note that if input argument is close to 1.0 (in our case it means
+// that |1 - x| < 1/256) we can use just polynomial approximation
+// because x = 2^0 * f = f = 1 + r and
+// log(x) = log(1 + r) ~ P(r)
+//
+//
+// To compute log10(x) we just use identity:
+//
+//  log10(x) = log(x)/log(10)
+//
+// so we have that
+//
+//  log10(x) = (N*log(2) + T  + log(1+r)) / log(10) =
+//           = N*(log(2)/log(10)) + (T/log(10)) + log(1 + r)/log(10)
+//
+//
+// Implementation
+// --------------
+// It can be seen that formulas for log and log10 differ from one another
+// only by coefficients and tabular values. Namely as log as log10 are
+// calculated as (N*L1 + T) + L2*Series(r) where in case of log
+//   L1 = log(2)
+//   T  = log(1/frcpa(x))
+//   L2 = 1.0
+// and in case of log10
+//   L1 = log(2)/log(10)
+//   T  = log(1/frcpa(x))/log(10)
+//   L2 = 1.0/log(10)
+//
+// So common code with two different entry points those set pointers
+// to the base address of corresponding data sets containing values
+// of L2,T and prepare integer representation of L1 needed for following
+// setf instruction can be used.
+//
+// Note that both log and log10 use common approximation polynomial
+// it means we need only one set of coefficients of approximation.
+//
+// 1. Computation of log(x) for |x-1| >= 1/256
+//   InvX = frcpa(x)
+//   r = InvX*x - 1
+//   P(r) = r*((1 - A2*r) + r^2*(A3 - A4*r)) = r*P2(r),
+//   A4,A3,A2 are created with setf inctruction.
+//   We use Taylor series and so A4 = 1/4, A3 = 1/3,
+//   A2 = 1/2 rounded to double.
+//
+//   N = float(n) where n is true unbiased exponent of x
+//
+//   T is tabular value of log(1/frcpa(x)) calculated in quad precision
+//   and rounded to double. To T we get bits from 55 to 62 of register
+//   format significand of x and calculate address
+//     ad_T = table_base_addr + 8 * index
+//
+//   L2 (1.0 or 1.0/log(10) depending on function) is calculated in quad
+//   precision and rounded to double; it's loaded from memory
+//
+//   L1 (log(2) or log10(2) depending on function) is calculated in quad
+//   precision and rounded to double; it's created with setf.
+//
+//   And final result = P2(r)*(r*L2) + (T + N*L1)
+//
+//
+// 2. Computation of log(x) for |x-1| < 1/256
+//   r = x - 1
+//   P(r) = r*((1 - A2*r) + r^2*(A3 - A4*r)) = r*P2(r),
+//   A4,A3,A2 are the same as in case |x-1| >= 1/256
+//
+//   And final result = P2(r)*(r*L2)
+//
+// 3. How we define is input argument such that |x-1| < 1/256 or not.
+//
+//    To do it we analyze biased exponent and significand of input argument.
+//
+//      a) First we test is biased exponent equal to 0xFFFE or 0xFFFF (i.e.
+//         we test is 0.5 <= x < 2). This comparison can be performed using
+//         unsigned version of cmp instruction in such a way
+//         biased_exponent_of_x - 0xFFFE < 2
+//
+//
+//      b) Second (in case when result of a) is true) we need to compare x
+//         with 1-1/256 and 1+1/256 or in register format representation with
+//         0xFFFEFF00000000000000 and 0xFFFF8080000000000000 correspondingly.
+//         As far as biased exponent of x here can be equal only to 0xFFFE or
+//         0xFFFF we need to test only last bit of it. Also signifigand always
+//         has implicit bit set to 1 that can be excluded from comparison.
+//         Thus it's quite enough to generate 64-bit integer bits of that are
+//         ix[63] = biased_exponent_of_x[0] and ix[62-0] = significand_of_x[62-0]
+//         and compare it with 0x7F00000000000000 and 0x80800000000000000 (those
+//         obtained like ix from register representatinos of 255/256 and
+//         257/256). This comparison can be made like in a), using unsigned
+//         version of cmp i.e. ix - 0x7F00000000000000 < 0x0180000000000000.
+//         0x0180000000000000 is difference between 0x80800000000000000 and
+//         0x7F00000000000000.
+//
+//    Note: NaT, any NaNs, +/-INF, +/-0, negatives and unnormalized numbers are
+//          filtered and processed on special branches.
+//
+//
+// Special values
+//==============================================================
+//
+// logf(+0)    = -inf
+// logf(-0)    = -inf
+//
+// logf(+qnan) = +qnan
+// logf(-qnan) = -qnan
+// logf(+snan) = +qnan
+// logf(-snan) = -qnan
+//
+// logf(-n)    = QNAN Indefinite
+// logf(-inf)  = QNAN Indefinite
+//
+// logf(+inf)  = +inf
+//
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input
+// f12 -> f14,  f33 -> f39
+//
+// General registers used:
+// r8  -> r11
+// r14 -> r19
+//
+// Predicate registers used:
+// p6 -> p12
+
+
+// Assembly macros
+//==============================================================
+
+GR_TAG                 = r8
+GR_ad_T                = r8
+GR_N                   = r9
+GR_Exp                 = r10
+GR_Sig                 = r11
+
+GR_025                 = r14
+GR_05                  = r15
+GR_A3                  = r16
+GR_Ind                 = r17
+GR_dx                  = r15
+GR_Ln2                 = r19
+GR_de                  = r20
+GR_x                   = r21
+GR_xorg                = r22
+
+GR_SAVE_B0             = r33
+GR_SAVE_PFS            = r34
+GR_SAVE_GP             = r35
+GR_SAVE_SP             = r36
+
+GR_Parameter_X         = r37
+GR_Parameter_Y         = r38
+GR_Parameter_RESULT    = r39
+GR_Parameter_TAG       = r40
+
+
+FR_A2                  = f12
+FR_A3                  = f13
+FR_A4                  = f14
+
+FR_RcpX                = f33
+FR_r                   = f34
+FR_r2                  = f35
+FR_tmp                 = f35
+FR_Ln2                 = f36
+FR_T                   = f37
+FR_N                   = f38
+FR_NxLn2pT             = f38
+FR_NormX               = f39
+FR_InvLn10             = f40
+
+
+FR_Y                   = f1
+FR_X                   = f10
+FR_RESULT              = f8
+
+
+// Data tables
+//==============================================================
+RODATA
+.align 16
+LOCAL_OBJECT_START(logf_data)
+data8 0x3FF0000000000000 // 1.0
+//
+// ln(1/frcpa(1+i/256)), i=0...255
+data8 0x3F60040155D5889E // 0
+data8 0x3F78121214586B54 // 1
+data8 0x3F841929F96832F0 // 2
+data8 0x3F8C317384C75F06 // 3
+data8 0x3F91A6B91AC73386 // 4
+data8 0x3F95BA9A5D9AC039 // 5
+data8 0x3F99D2A8074325F4 // 6
+data8 0x3F9D6B2725979802 // 7
+data8 0x3FA0C58FA19DFAAA // 8
+data8 0x3FA2954C78CBCE1B // 9
+data8 0x3FA4A94D2DA96C56 // 10
+data8 0x3FA67C94F2D4BB58 // 11
+data8 0x3FA85188B630F068 // 12
+data8 0x3FAA6B8ABE73AF4C // 13
+data8 0x3FAC441E06F72A9E // 14
+data8 0x3FAE1E6713606D07 // 15
+data8 0x3FAFFA6911AB9301 // 16
+data8 0x3FB0EC139C5DA601 // 17
+data8 0x3FB1DBD2643D190B // 18
+data8 0x3FB2CC7284FE5F1C // 19
+data8 0x3FB3BDF5A7D1EE64 // 20
+data8 0x3FB4B05D7AA012E0 // 21
+data8 0x3FB580DB7CEB5702 // 22
+data8 0x3FB674F089365A7A // 23
+data8 0x3FB769EF2C6B568D // 24
+data8 0x3FB85FD927506A48 // 25
+data8 0x3FB9335E5D594989 // 26
+data8 0x3FBA2B0220C8E5F5 // 27
+data8 0x3FBB0004AC1A86AC // 28
+data8 0x3FBBF968769FCA11 // 29
+data8 0x3FBCCFEDBFEE13A8 // 30
+data8 0x3FBDA727638446A2 // 31
+data8 0x3FBEA3257FE10F7A // 32
+data8 0x3FBF7BE9FEDBFDE6 // 33
+data8 0x3FC02AB352FF25F4 // 34
+data8 0x3FC097CE579D204D // 35
+data8 0x3FC1178E8227E47C // 36
+data8 0x3FC185747DBECF34 // 37
+data8 0x3FC1F3B925F25D41 // 38
+data8 0x3FC2625D1E6DDF57 // 39
+data8 0x3FC2D1610C86813A // 40
+data8 0x3FC340C59741142E // 41
+data8 0x3FC3B08B6757F2A9 // 42
+data8 0x3FC40DFB08378003 // 43
+data8 0x3FC47E74E8CA5F7C // 44
+data8 0x3FC4EF51F6466DE4 // 45
+data8 0x3FC56092E02BA516 // 46
+data8 0x3FC5D23857CD74D5 // 47
+data8 0x3FC6313A37335D76 // 48
+data8 0x3FC6A399DABBD383 // 49
+data8 0x3FC70337DD3CE41B // 50
+data8 0x3FC77654128F6127 // 51
+data8 0x3FC7E9D82A0B022D // 52
+data8 0x3FC84A6B759F512F // 53
+data8 0x3FC8AB47D5F5A310 // 54
+data8 0x3FC91FE49096581B // 55
+data8 0x3FC981634011AA75 // 56
+data8 0x3FC9F6C407089664 // 57
+data8 0x3FCA58E729348F43 // 58
+data8 0x3FCABB55C31693AD // 59
+data8 0x3FCB1E104919EFD0 // 60
+data8 0x3FCB94EE93E367CB // 61
+data8 0x3FCBF851C067555F // 62
+data8 0x3FCC5C0254BF23A6 // 63
+data8 0x3FCCC000C9DB3C52 // 64
+data8 0x3FCD244D99C85674 // 65
+data8 0x3FCD88E93FB2F450 // 66
+data8 0x3FCDEDD437EAEF01 // 67
+data8 0x3FCE530EFFE71012 // 68
+data8 0x3FCEB89A1648B971 // 69
+data8 0x3FCF1E75FADF9BDE // 70
+data8 0x3FCF84A32EAD7C35 // 71
+data8 0x3FCFEB2233EA07CD // 72
+data8 0x3FD028F9C7035C1C // 73
+data8 0x3FD05C8BE0D9635A // 74
+data8 0x3FD085EB8F8AE797 // 75
+data8 0x3FD0B9C8E32D1911 // 76
+data8 0x3FD0EDD060B78081 // 77
+data8 0x3FD122024CF0063F // 78
+data8 0x3FD14BE2927AECD4 // 79
+data8 0x3FD180618EF18ADF // 80
+data8 0x3FD1B50BBE2FC63B // 81
+data8 0x3FD1DF4CC7CF242D // 82
+data8 0x3FD214456D0EB8D4 // 83
+data8 0x3FD23EC5991EBA49 // 84
+data8 0x3FD2740D9F870AFB // 85
+data8 0x3FD29ECDABCDFA04 // 86
+data8 0x3FD2D46602ADCCEE // 87
+data8 0x3FD2FF66B04EA9D4 // 88
+data8 0x3FD335504B355A37 // 89
+data8 0x3FD360925EC44F5D // 90
+data8 0x3FD38BF1C3337E75 // 91
+data8 0x3FD3C25277333184 // 92
+data8 0x3FD3EDF463C1683E // 93
+data8 0x3FD419B423D5E8C7 // 94
+data8 0x3FD44591E0539F49 // 95
+data8 0x3FD47C9175B6F0AD // 96
+data8 0x3FD4A8B341552B09 // 97
+data8 0x3FD4D4F3908901A0 // 98
+data8 0x3FD501528DA1F968 // 99
+data8 0x3FD52DD06347D4F6 // 100
+data8 0x3FD55A6D3C7B8A8A // 101
+data8 0x3FD5925D2B112A59 // 102
+data8 0x3FD5BF406B543DB2 // 103
+data8 0x3FD5EC433D5C35AE // 104
+data8 0x3FD61965CDB02C1F // 105
+data8 0x3FD646A84935B2A2 // 106
+data8 0x3FD6740ADD31DE94 // 107
+data8 0x3FD6A18DB74A58C5 // 108
+data8 0x3FD6CF31058670EC // 109
+data8 0x3FD6F180E852F0BA // 110
+data8 0x3FD71F5D71B894F0 // 111
+data8 0x3FD74D5AEFD66D5C // 112
+data8 0x3FD77B79922BD37E // 113
+data8 0x3FD7A9B9889F19E2 // 114
+data8 0x3FD7D81B037EB6A6 // 115
+data8 0x3FD8069E33827231 // 116
+data8 0x3FD82996D3EF8BCB // 117
+data8 0x3FD85855776DCBFB // 118
+data8 0x3FD8873658327CCF // 119
+data8 0x3FD8AA75973AB8CF // 120
+data8 0x3FD8D992DC8824E5 // 121
+data8 0x3FD908D2EA7D9512 // 122
+data8 0x3FD92C59E79C0E56 // 123
+data8 0x3FD95BD750EE3ED3 // 124
+data8 0x3FD98B7811A3EE5B // 125
+data8 0x3FD9AF47F33D406C // 126
+data8 0x3FD9DF270C1914A8 // 127
+data8 0x3FDA0325ED14FDA4 // 128
+data8 0x3FDA33440224FA79 // 129
+data8 0x3FDA57725E80C383 // 130
+data8 0x3FDA87D0165DD199 // 131
+data8 0x3FDAAC2E6C03F896 // 132
+data8 0x3FDADCCC6FDF6A81 // 133
+data8 0x3FDB015B3EB1E790 // 134
+data8 0x3FDB323A3A635948 // 135
+data8 0x3FDB56FA04462909 // 136
+data8 0x3FDB881AA659BC93 // 137
+data8 0x3FDBAD0BEF3DB165 // 138
+data8 0x3FDBD21297781C2F // 139
+data8 0x3FDC039236F08819 // 140
+data8 0x3FDC28CB1E4D32FD // 141
+data8 0x3FDC4E19B84723C2 // 142
+data8 0x3FDC7FF9C74554C9 // 143
+data8 0x3FDCA57B64E9DB05 // 144
+data8 0x3FDCCB130A5CEBB0 // 145
+data8 0x3FDCF0C0D18F326F // 146
+data8 0x3FDD232075B5A201 // 147
+data8 0x3FDD490246DEFA6B // 148
+data8 0x3FDD6EFA918D25CD // 149
+data8 0x3FDD9509707AE52F // 150
+data8 0x3FDDBB2EFE92C554 // 151
+data8 0x3FDDEE2F3445E4AF // 152
+data8 0x3FDE148A1A2726CE // 153
+data8 0x3FDE3AFC0A49FF40 // 154
+data8 0x3FDE6185206D516E // 155
+data8 0x3FDE882578823D52 // 156
+data8 0x3FDEAEDD2EAC990C // 157
+data8 0x3FDED5AC5F436BE3 // 158
+data8 0x3FDEFC9326D16AB9 // 159
+data8 0x3FDF2391A2157600 // 160
+data8 0x3FDF4AA7EE03192D // 161
+data8 0x3FDF71D627C30BB0 // 162
+data8 0x3FDF991C6CB3B379 // 163
+data8 0x3FDFC07ADA69A910 // 164
+data8 0x3FDFE7F18EB03D3E // 165
+data8 0x3FE007C053C5002E // 166
+data8 0x3FE01B942198A5A1 // 167
+data8 0x3FE02F74400C64EB // 168
+data8 0x3FE04360BE7603AD // 169
+data8 0x3FE05759AC47FE34 // 170
+data8 0x3FE06B5F1911CF52 // 171
+data8 0x3FE078BF0533C568 // 172
+data8 0x3FE08CD9687E7B0E // 173
+data8 0x3FE0A10074CF9019 // 174
+data8 0x3FE0B5343A234477 // 175
+data8 0x3FE0C974C89431CE // 176
+data8 0x3FE0DDC2305B9886 // 177
+data8 0x3FE0EB524BAFC918 // 178
+data8 0x3FE0FFB54213A476 // 179
+data8 0x3FE114253DA97D9F // 180
+data8 0x3FE128A24F1D9AFF // 181
+data8 0x3FE1365252BF0865 // 182
+data8 0x3FE14AE558B4A92D // 183
+data8 0x3FE15F85A19C765B // 184
+data8 0x3FE16D4D38C119FA // 185
+data8 0x3FE18203C20DD133 // 186
+data8 0x3FE196C7BC4B1F3B // 187
+data8 0x3FE1A4A738B7A33C // 188
+data8 0x3FE1B981C0C9653D // 189
+data8 0x3FE1CE69E8BB106B // 190
+data8 0x3FE1DC619DE06944 // 191
+data8 0x3FE1F160A2AD0DA4 // 192
+data8 0x3FE2066D7740737E // 193
+data8 0x3FE2147DBA47A394 // 194
+data8 0x3FE229A1BC5EBAC3 // 195
+data8 0x3FE237C1841A502E // 196
+data8 0x3FE24CFCE6F80D9A // 197
+data8 0x3FE25B2C55CD5762 // 198
+data8 0x3FE2707F4D5F7C41 // 199
+data8 0x3FE285E0842CA384 // 200
+data8 0x3FE294294708B773 // 201
+data8 0x3FE2A9A2670AFF0C // 202
+data8 0x3FE2B7FB2C8D1CC1 // 203
+data8 0x3FE2C65A6395F5F5 // 204
+data8 0x3FE2DBF557B0DF43 // 205
+data8 0x3FE2EA64C3F97655 // 206
+data8 0x3FE3001823684D73 // 207
+data8 0x3FE30E97E9A8B5CD // 208
+data8 0x3FE32463EBDD34EA // 209
+data8 0x3FE332F4314AD796 // 210
+data8 0x3FE348D90E7464D0 // 211
+data8 0x3FE35779F8C43D6E // 212
+data8 0x3FE36621961A6A99 // 213
+data8 0x3FE37C299F3C366A // 214
+data8 0x3FE38AE2171976E7 // 215
+data8 0x3FE399A157A603E7 // 216
+data8 0x3FE3AFCCFE77B9D1 // 217
+data8 0x3FE3BE9D503533B5 // 218
+data8 0x3FE3CD7480B4A8A3 // 219
+data8 0x3FE3E3C43918F76C // 220
+data8 0x3FE3F2ACB27ED6C7 // 221
+data8 0x3FE4019C2125CA93 // 222
+data8 0x3FE4181061389722 // 223
+data8 0x3FE42711518DF545 // 224
+data8 0x3FE436194E12B6BF // 225
+data8 0x3FE445285D68EA69 // 226
+data8 0x3FE45BCC464C893A // 227
+data8 0x3FE46AED21F117FC // 228
+data8 0x3FE47A1527E8A2D3 // 229
+data8 0x3FE489445EFFFCCC // 230
+data8 0x3FE4A018BCB69835 // 231
+data8 0x3FE4AF5A0C9D65D7 // 232
+data8 0x3FE4BEA2A5BDBE87 // 233
+data8 0x3FE4CDF28F10AC46 // 234
+data8 0x3FE4DD49CF994058 // 235
+data8 0x3FE4ECA86E64A684 // 236
+data8 0x3FE503C43CD8EB68 // 237
+data8 0x3FE513356667FC57 // 238
+data8 0x3FE522AE0738A3D8 // 239
+data8 0x3FE5322E26867857 // 240
+data8 0x3FE541B5CB979809 // 241
+data8 0x3FE55144FDBCBD62 // 242
+data8 0x3FE560DBC45153C7 // 243
+data8 0x3FE5707A26BB8C66 // 244
+data8 0x3FE587F60ED5B900 // 245
+data8 0x3FE597A7977C8F31 // 246
+data8 0x3FE5A760D634BB8B // 247
+data8 0x3FE5B721D295F10F // 248
+data8 0x3FE5C6EA94431EF9 // 249
+data8 0x3FE5D6BB22EA86F6 // 250
+data8 0x3FE5E6938645D390 // 251
+data8 0x3FE5F673C61A2ED2 // 252
+data8 0x3FE6065BEA385926 // 253
+data8 0x3FE6164BFA7CC06B // 254
+data8 0x3FE62643FECF9743 // 255
+LOCAL_OBJECT_END(logf_data)
+
+LOCAL_OBJECT_START(log10f_data)
+data8 0x3FDBCB7B1526E50E // 1/ln(10)
+//
+// ln(1/frcpa(1+i/256))/ln(10), i=0...255
+data8 0x3F4BD27045BFD025 // 0
+data8 0x3F64E84E793A474A // 1
+data8 0x3F7175085AB85FF0 // 2
+data8 0x3F787CFF9D9147A5 // 3
+data8 0x3F7EA9D372B89FC8 // 4
+data8 0x3F82DF9D95DA961C // 5
+data8 0x3F866DF172D6372C // 6
+data8 0x3F898D79EF5EEDF0 // 7
+data8 0x3F8D22ADF3F9579D // 8
+data8 0x3F9024231D30C398 // 9
+data8 0x3F91F23A98897D4A // 10
+data8 0x3F93881A7B818F9E // 11
+data8 0x3F951F6E1E759E35 // 12
+data8 0x3F96F2BCE7ADC5B4 // 13
+data8 0x3F988D362CDF359E // 14
+data8 0x3F9A292BAF010982 // 15
+data8 0x3F9BC6A03117EB97 // 16
+data8 0x3F9D65967DE3AB09 // 17
+data8 0x3F9F061167FC31E8 // 18
+data8 0x3FA05409E4F7819C // 19
+data8 0x3FA125D0432EA20E // 20
+data8 0x3FA1F85D440D299B // 21
+data8 0x3FA2AD755749617D // 22
+data8 0x3FA381772A00E604 // 23
+data8 0x3FA45643E165A70B // 24
+data8 0x3FA52BDD034475B8 // 25
+data8 0x3FA5E3966B7E9295 // 26
+data8 0x3FA6BAAF47C5B245 // 27
+data8 0x3FA773B3E8C4F3C8 // 28
+data8 0x3FA84C51EBEE8D15 // 29
+data8 0x3FA906A6786FC1CB // 30
+data8 0x3FA9C197ABF00DD7 // 31
+data8 0x3FAA9C78712191F7 // 32
+data8 0x3FAB58C09C8D637C // 33
+data8 0x3FAC15A8BCDD7B7E // 34
+data8 0x3FACD331E2C2967C // 35
+data8 0x3FADB11ED766ABF4 // 36
+data8 0x3FAE70089346A9E6 // 37
+data8 0x3FAF2F96C6754AEE // 38
+data8 0x3FAFEFCA8D451FD6 // 39
+data8 0x3FB0585283764178 // 40
+data8 0x3FB0B913AAC7D3A7 // 41
+data8 0x3FB11A294F2569F6 // 42
+data8 0x3FB16B51A2696891 // 43
+data8 0x3FB1CD03ADACC8BE // 44
+data8 0x3FB22F0BDD7745F5 // 45
+data8 0x3FB2916ACA38D1E8 // 46
+data8 0x3FB2F4210DF7663D // 47
+data8 0x3FB346A6C3C49066 // 48
+data8 0x3FB3A9FEBC60540A // 49
+data8 0x3FB3FD0C10A3AA54 // 50
+data8 0x3FB46107D3540A82 // 51
+data8 0x3FB4C55DD16967FE // 52
+data8 0x3FB51940330C000B // 53
+data8 0x3FB56D620EE7115E // 54
+data8 0x3FB5D2ABCF26178E // 55
+data8 0x3FB6275AA5DEBF81 // 56
+data8 0x3FB68D4EAF26D7EE // 57
+data8 0x3FB6E28C5C54A28D // 58
+data8 0x3FB7380B9665B7C8 // 59
+data8 0x3FB78DCCC278E85B // 60
+data8 0x3FB7F50C2CF2557A // 61
+data8 0x3FB84B5FD5EAEFD8 // 62
+data8 0x3FB8A1F6BAB2B226 // 63
+data8 0x3FB8F8D144557BDF // 64
+data8 0x3FB94FEFDCD61D92 // 65
+data8 0x3FB9A752EF316149 // 66
+data8 0x3FB9FEFAE7611EE0 // 67
+data8 0x3FBA56E8325F5C87 // 68
+data8 0x3FBAAF1B3E297BB4 // 69
+data8 0x3FBB079479C372AD // 70
+data8 0x3FBB6054553B12F7 // 71
+data8 0x3FBBB95B41AB5CE6 // 72
+data8 0x3FBC12A9B13FE079 // 73
+data8 0x3FBC6C4017382BEA // 74
+data8 0x3FBCB41FBA42686D // 75
+data8 0x3FBD0E38CE73393F // 76
+data8 0x3FBD689B2193F133 // 77
+data8 0x3FBDC3472B1D2860 // 78
+data8 0x3FBE0C06300D528B // 79
+data8 0x3FBE6738190E394C // 80
+data8 0x3FBEC2B50D208D9B // 81
+data8 0x3FBF0C1C2B936828 // 82
+data8 0x3FBF68216C9CC727 // 83
+data8 0x3FBFB1F6381856F4 // 84
+data8 0x3FC00742AF4CE5F8 // 85
+data8 0x3FC02C64906512D2 // 86
+data8 0x3FC05AF1E63E03B4 // 87
+data8 0x3FC0804BEA723AA9 // 88
+data8 0x3FC0AF1FD6711527 // 89
+data8 0x3FC0D4B2A8805A00 // 90
+data8 0x3FC0FA5EF136A06C // 91
+data8 0x3FC1299A4FB3E306 // 92
+data8 0x3FC14F806253C3ED // 93
+data8 0x3FC175805D1587C1 // 94
+data8 0x3FC19B9A637CA295 // 95
+data8 0x3FC1CB5FC26EDE17 // 96
+data8 0x3FC1F1B4E65F2590 // 97
+data8 0x3FC218248B5DC3E5 // 98
+data8 0x3FC23EAED62ADC76 // 99
+data8 0x3FC26553EBD337BD // 100
+data8 0x3FC28C13F1B11900 // 101
+data8 0x3FC2BCAA14381386 // 102
+data8 0x3FC2E3A740B7800F // 103
+data8 0x3FC30ABFD8F333B6 // 104
+data8 0x3FC331F403985097 // 105
+data8 0x3FC35943E7A60690 // 106
+data8 0x3FC380AFAC6E7C07 // 107
+data8 0x3FC3A8377997B9E6 // 108
+data8 0x3FC3CFDB771C9ADB // 109
+data8 0x3FC3EDA90D39A5DF // 110
+data8 0x3FC4157EC09505CD // 111
+data8 0x3FC43D7113FB04C1 // 112
+data8 0x3FC4658030AD1CCF // 113
+data8 0x3FC48DAC404638F6 // 114
+data8 0x3FC4B5F56CBBB869 // 115
+data8 0x3FC4DE5BE05E7583 // 116
+data8 0x3FC4FCBC0776FD85 // 117
+data8 0x3FC525561E9256EE // 118
+data8 0x3FC54E0DF3198865 // 119
+data8 0x3FC56CAB7112BDE2 // 120
+data8 0x3FC59597BA735B15 // 121
+data8 0x3FC5BEA23A506FDA // 122
+data8 0x3FC5DD7E08DE382F // 123
+data8 0x3FC606BDD3F92355 // 124
+data8 0x3FC6301C518A501F // 125
+data8 0x3FC64F3770618916 // 126
+data8 0x3FC678CC14C1E2D8 // 127
+data8 0x3FC6981005ED2947 // 128
+data8 0x3FC6C1DB5F9BB336 // 129
+data8 0x3FC6E1488ECD2881 // 130
+data8 0x3FC70B4B2E7E41B9 // 131
+data8 0x3FC72AE209146BF9 // 132
+data8 0x3FC7551C81BD8DCF // 133
+data8 0x3FC774DD76CC43BE // 134
+data8 0x3FC79F505DB00E88 // 135
+data8 0x3FC7BF3BDE099F30 // 136
+data8 0x3FC7E9E7CAC437F9 // 137
+data8 0x3FC809FE4902D00D // 138
+data8 0x3FC82A2757995CBE // 139
+data8 0x3FC85525C625E098 // 140
+data8 0x3FC8757A79831887 // 141
+data8 0x3FC895E2058D8E03 // 142
+data8 0x3FC8C13437695532 // 143
+data8 0x3FC8E1C812EF32BE // 144
+data8 0x3FC9026F112197E8 // 145
+data8 0x3FC923294888880B // 146
+data8 0x3FC94EEA4B8334F3 // 147
+data8 0x3FC96FD1B639FC09 // 148
+data8 0x3FC990CCA66229AC // 149
+data8 0x3FC9B1DB33334843 // 150
+data8 0x3FC9D2FD740E6607 // 151
+data8 0x3FC9FF49EEDCB553 // 152
+data8 0x3FCA209A84FBCFF8 // 153
+data8 0x3FCA41FF1E43F02B // 154
+data8 0x3FCA6377D2CE9378 // 155
+data8 0x3FCA8504BAE0D9F6 // 156
+data8 0x3FCAA6A5EEEBEFE3 // 157
+data8 0x3FCAC85B878D7879 // 158
+data8 0x3FCAEA259D8FFA0B // 159
+data8 0x3FCB0C0449EB4B6B // 160
+data8 0x3FCB2DF7A5C50299 // 161
+data8 0x3FCB4FFFCA70E4D1 // 162
+data8 0x3FCB721CD17157E3 // 163
+data8 0x3FCB944ED477D4ED // 164
+data8 0x3FCBB695ED655C7D // 165
+data8 0x3FCBD8F2364AEC0F // 166
+data8 0x3FCBFB63C969F4FF // 167
+data8 0x3FCC1DEAC134D4E9 // 168
+data8 0x3FCC4087384F4F80 // 169
+data8 0x3FCC6339498F09E2 // 170
+data8 0x3FCC86010FFC076C // 171
+data8 0x3FCC9D3D065C5B42 // 172
+data8 0x3FCCC029375BA07A // 173
+data8 0x3FCCE32B66978BA4 // 174
+data8 0x3FCD0643AFD51404 // 175
+data8 0x3FCD29722F0DEA45 // 176
+data8 0x3FCD4CB70070FE44 // 177
+data8 0x3FCD6446AB3F8C96 // 178
+data8 0x3FCD87B0EF71DB45 // 179
+data8 0x3FCDAB31D1FE99A7 // 180
+data8 0x3FCDCEC96FDC888F // 181
+data8 0x3FCDE6908876357A // 182
+data8 0x3FCE0A4E4A25C200 // 183
+data8 0x3FCE2E2315755E33 // 184
+data8 0x3FCE461322D1648A // 185
+data8 0x3FCE6A0E95C7787B // 186
+data8 0x3FCE8E216243DD60 // 187
+data8 0x3FCEA63AF26E007C // 188
+data8 0x3FCECA74ED15E0B7 // 189
+data8 0x3FCEEEC692CCD25A // 190
+data8 0x3FCF070A36B8D9C1 // 191
+data8 0x3FCF2B8393E34A2D // 192
+data8 0x3FCF5014EF538A5B // 193
+data8 0x3FCF68833AF1B180 // 194
+data8 0x3FCF8D3CD9F3F04F // 195
+data8 0x3FCFA5C61ADD93E9 // 196
+data8 0x3FCFCAA8567EBA7A // 197
+data8 0x3FCFE34CC8743DD8 // 198
+data8 0x3FD0042BFD74F519 // 199
+data8 0x3FD016BDF6A18017 // 200
+data8 0x3FD023262F907322 // 201
+data8 0x3FD035CCED8D32A1 // 202
+data8 0x3FD042430E869FFC // 203
+data8 0x3FD04EBEC842B2E0 // 204
+data8 0x3FD06182E84FD4AC // 205
+data8 0x3FD06E0CB609D383 // 206
+data8 0x3FD080E60BEC8F12 // 207
+data8 0x3FD08D7E0D894735 // 208
+data8 0x3FD0A06CC96A2056 // 209
+data8 0x3FD0AD131F3B3C55 // 210
+data8 0x3FD0C01771E775FB // 211
+data8 0x3FD0CCCC3CAD6F4B // 212
+data8 0x3FD0D986D91A34A9 // 213
+data8 0x3FD0ECA9B8861A2D // 214
+data8 0x3FD0F972F87FF3D6 // 215
+data8 0x3FD106421CF0E5F7 // 216
+data8 0x3FD11983EBE28A9D // 217
+data8 0x3FD12661E35B785A // 218
+data8 0x3FD13345D2779D3B // 219
+data8 0x3FD146A6F597283A // 220
+data8 0x3FD15399E81EA83D // 221
+data8 0x3FD16092E5D3A9A6 // 222
+data8 0x3FD17413C3B7AB5E // 223
+data8 0x3FD1811BF629D6FB // 224
+data8 0x3FD18E2A47B46686 // 225
+data8 0x3FD19B3EBE1A4418 // 226
+data8 0x3FD1AEE9017CB450 // 227
+data8 0x3FD1BC0CED7134E2 // 228
+data8 0x3FD1C93712ABC7FF // 229
+data8 0x3FD1D66777147D3F // 230
+data8 0x3FD1EA3BD1286E1C // 231
+data8 0x3FD1F77BED932C4C // 232
+data8 0x3FD204C25E1B031F // 233
+data8 0x3FD2120F28CE69B1 // 234
+data8 0x3FD21F6253C48D01 // 235
+data8 0x3FD22CBBE51D60AA // 236
+data8 0x3FD240CE4C975444 // 237
+data8 0x3FD24E37F8ECDAE8 // 238
+data8 0x3FD25BA8215AF7FC // 239
+data8 0x3FD2691ECC29F042 // 240
+data8 0x3FD2769BFFAB2E00 // 241
+data8 0x3FD2841FC23952C9 // 242
+data8 0x3FD291AA1A384978 // 243
+data8 0x3FD29F3B0E15584B // 244
+data8 0x3FD2B3A0EE479DF7 // 245
+data8 0x3FD2C142842C09E6 // 246
+data8 0x3FD2CEEACCB7BD6D // 247
+data8 0x3FD2DC99CE82FF21 // 248
+data8 0x3FD2EA4F902FD7DA // 249
+data8 0x3FD2F80C186A25FD // 250
+data8 0x3FD305CF6DE7B0F7 // 251
+data8 0x3FD3139997683CE7 // 252
+data8 0x3FD3216A9BB59E7C // 253
+data8 0x3FD32F4281A3CEFF // 254
+data8 0x3FD33D2150110092 // 255
+LOCAL_OBJECT_END(log10f_data)
+
+
+// Code
+//==============================================================
+.section .text
+
+// logf   has p13 true, p14 false
+// log10f has p14 true, p13 false
+
+GLOBAL_IEEE754_ENTRY(log10f)
+{ .mfi
+      getf.exp      GR_Exp = f8 // if x is unorm then must recompute
+      frcpa.s1      FR_RcpX,p0 = f1,f8
+      mov           GR_05 = 0xFFFE // biased exponent of A2=0.5
+}
+{ .mlx
+      addl          GR_ad_T = @ltoff(log10f_data),gp
+      movl          GR_A3 = 0x3FD5555555555555 // double precision memory
+                                               // representation of A3
+};;
+{ .mfi
+      getf.sig      GR_Sig = f8 // if x is unorm then must recompute
+      fclass.m      p8,p0 = f8,9 // is x positive unorm?
+      sub           GR_025 = GR_05,r0,1 // biased exponent of A4=0.25
+}
+{ .mlx
+      ld8           GR_ad_T = [GR_ad_T]
+      movl          GR_Ln2 = 0x3FD34413509F79FF // double precision memory
+                                                // representation of
+                                                // log(2)/ln(10)
+};;
+{ .mfi
+      setf.d        FR_A3 = GR_A3 // create A3
+      fcmp.eq.s1    p14,p13 = f0,f0 // set p14 to 1 for log10f
+      dep.z         GR_xorg = GR_05,55,8 // 0x7F00000000000000 integer number
+                                         // bits of that are
+                                         // GR_xorg[63]   = last bit of biased
+                                         //            exponent of 255/256
+                                         // GR_xorg[62-0] = bits from 62 to 0
+                                         //            of significand of 255/256
+}
+{ .mib
+      setf.exp      FR_A2 = GR_05 // create A2
+      sub           GR_de = GR_Exp,GR_05 // biased_exponent_of_x - 0xFFFE
+                                         // needed for comparison with 0.5 and 2.0
+      br.cond.sptk  logf_log10f_common
+};;
+GLOBAL_IEEE754_END(log10f)
+libm_alias_float_other (__log10, log10)
+
+GLOBAL_IEEE754_ENTRY(logf)
+{ .mfi
+      getf.exp      GR_Exp = f8 // if x is unorm then must recompute
+      frcpa.s1      FR_RcpX,p0 = f1,f8
+      mov           GR_05 = 0xFFFE // biased exponent of A2=-0.5
+}
+{ .mlx
+      addl          GR_ad_T = @ltoff(logf_data),gp
+      movl          GR_A3 = 0x3FD5555555555555 // double precision memory
+                                               // representation of A3
+};;
+{ .mfi
+      getf.sig      GR_Sig = f8 // if x is unorm then must recompute
+      fclass.m      p8,p0 = f8,9 // is x positive unorm?
+      dep.z         GR_xorg = GR_05,55,8 // 0x7F00000000000000 integer number
+                                         // bits of that are
+                                         // GR_xorg[63]   = last bit of biased
+                                         //            exponent of 255/256
+                                         // GR_xorg[62-0] = bits from 62 to 0
+                                         //            of significand of 255/256
+}
+{ .mfi
+      ld8           GR_ad_T = [GR_ad_T]
+      nop.f         0
+      sub           GR_025 = GR_05,r0,1 // biased exponent of A4=0.25
+};;
+{ .mfi
+      setf.d        FR_A3 = GR_A3 // create A3
+      fcmp.eq.s1    p13,p14 = f0,f0 // p13 - true for logf
+      sub           GR_de = GR_Exp,GR_05 // biased_exponent_of_x - 0xFFFE
+                                         // needed for comparison with 0.5 and 2.0
+}
+{ .mlx
+      setf.exp      FR_A2 = GR_05 // create A2
+      movl          GR_Ln2 = 0x3FE62E42FEFA39EF // double precision memory
+                                                // representation of log(2)
+};;
+logf_log10f_common:
+{ .mfi
+      setf.exp      FR_A4 = GR_025 // create A4=0.25
+      fclass.m      p9,p0 = f8,0x3A // is x < 0 (including negateve unnormals)?
+      dep           GR_x = GR_Exp,GR_Sig,63,1 // produce integer that bits are
+                                              // GR_x[63] = GR_Exp[0]
+                                              // GR_x[62-0] = GR_Sig[62-0]
+}
+{ .mib
+      sub           GR_N = GR_Exp,GR_05,1 // unbiased exponent of x
+      cmp.gtu       p6,p7 = 2,GR_de // is 0.5 <= x < 2.0?
+(p8)  br.cond.spnt  logf_positive_unorm
+};;
+logf_core:
+{ .mfi
+      setf.sig      FR_N = GR_N // copy unbiased exponent of x to the
+                                // significand field of FR_N
+      fclass.m      p10,p0 = f8,0x1E1 // is x NaN, NaT or +Inf?
+      dep.z         GR_dx = GR_05,54,3 // 0x0180000000000000 - difference
+                                       // between our integer representations
+                                       // of 257/256 and 255/256
+}
+{ .mfi
+      nop.m         0
+      nop.f         0
+      sub           GR_x = GR_x,GR_xorg // difference between representations
+                                        // of x and 255/256
+};;
+{ .mfi
+      ldfd          FR_InvLn10 = [GR_ad_T],8
+      fcmp.eq.s1    p11,p0 = f8,f1 // is x equal to 1.0?
+      extr.u        GR_Ind = GR_Sig,55,8 // get bits from 55 to 62 as index
+}
+{ .mib
+      setf.d        FR_Ln2 = GR_Ln2 // create log(2) or log10(2)
+(p6)  cmp.gtu       p6,p7 = GR_dx,GR_x // set p6 if 255/256 <= x < 257/256
+(p9)  br.cond.spnt  logf_negatives // jump if input argument is negative number
+};;
+// p6 is true if |x-1| < 1/256
+// p7 is true if |x-1| >= 1/256
+.pred.rel "mutex",p6,p7
+{ .mfi
+      shladd        GR_ad_T = GR_Ind,3,GR_ad_T // calculate address of T
+(p7)  fms.s1        FR_r = FR_RcpX,f8,f1 // range reduction for |x-1|>=1/256
+      extr.u        GR_Exp = GR_Exp,0,17 // exponent without sign
+}
+{ .mfb
+      nop.m         0
+(p6)  fms.s1        FR_r = f8,f1,f1 // range reduction for |x-1|<1/256
+(p10) br.cond.spnt  logf_nan_nat_pinf // exit for NaN, NaT or +Inf
+};;
+{ .mfb
+      ldfd          FR_T = [GR_ad_T] // load T
+(p11) fma.s.s0      f8 = f0,f0,f0
+(p11) br.ret.spnt   b0 // exit for x = 1.0
+};;
+{ .mib
+      nop.m         0
+      cmp.eq        p12,p0 = r0,GR_Exp // is x +/-0? (here it's quite enough
+                                       // only to compare exponent with 0
+                                       // because all unnormals already
+                                       // have been filtered)
+(p12) br.cond.spnt  logf_zeroes        // Branch if input argument is +/-0
+};;
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_A2 = FR_A2,FR_r,f1 // A2*r+1
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_r2 = FR_r,FR_r,f0  // r^2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fcvt.xf       FR_N = FR_N // convert integer N in significand of FR_N
+                                // to floating-point representation
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_A3 = FR_A4,FR_r,FR_A3 // A4*r+A3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_r = FR_r,FR_InvLn10,f0 // For log10f we have r/log(10)
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A2 = FR_A3,FR_r2,FR_A2 // (A4*r+A3)*r^2+(A2*r+1)
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_NxLn2pT = FR_N,FR_Ln2,FR_T // N*Ln2+T
+      nop.i         0
+};;
+.pred.rel "mutex",p6,p7
+{ .mfi
+      nop.m         0
+(p7)  fma.s.s0      f8 = FR_A2,FR_r,FR_NxLn2pT // result for |x-1|>=1/256
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p6)  fma.s.s0      f8 = FR_A2,FR_r,f0 // result for |x-1|<1/256
+      br.ret.sptk   b0
+};;
+
+.align 32
+logf_positive_unorm:
+{ .mfi
+      nop.m         0
+(p8)  fma.s0        f8 = f8,f1,f0 // Normalize & set D-flag
+      nop.i         0
+};;
+{ .mfi
+      getf.exp      GR_Exp = f8    // recompute biased exponent
+      nop.f         0
+      cmp.ne        p6,p7 = r0,r0  // p6 <- 0, p7 <- 1 because
+                                   // in case of unorm we are out
+                                   // interval [255/256; 257/256]
+};;
+{ .mfi
+      getf.sig      GR_Sig = f8 // recompute significand
+      nop.f         0
+      nop.i         0
+};;
+{ .mib
+      sub           GR_N = GR_Exp,GR_05,1 // unbiased exponent N
+      nop.i         0
+      br.cond.sptk  logf_core // return into main path
+};;
+
+.align 32
+logf_nan_nat_pinf:
+{ .mfi
+      nop.m         0
+      fma.s.s0      f8 = f8,f1,f0 // set V-flag
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+      nop.f         0
+      br.ret.sptk   b0 // exit for NaN, NaT or +Inf
+};;
+
+.align 32
+logf_zeroes:
+{ .mfi
+      nop.m         0
+      fmerge.s      FR_X = f8,f8 // keep input argument for subsequent
+                                 // call of __libm_error_support#
+      nop.i         0
+}
+{ .mfi
+(p13) mov           GR_TAG = 4 // set libm error in case of logf
+      fms.s1        FR_tmp = f0,f0,f1 // -1.0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      frcpa.s0      f8,p0 = FR_tmp,f0 // log(+/-0) should be equal to -INF.
+                                      // We can get it using frcpa because it
+                                      // sets result to the IEEE-754 mandated
+                                      // quotient of FR_tmp/f0.
+                                      // As far as FR_tmp is -1 it'll be -INF
+      nop.i         0
+}
+{ .mib
+(p14) mov           GR_TAG = 10 // set libm error in case of log10f
+      nop.i         0
+      br.cond.sptk  logf_libm_err
+};;
+
+.align 32
+logf_negatives:
+{ .mfi
+(p13) mov           GR_TAG = 5 // set libm error in case of logf
+      fmerge.s      FR_X = f8,f8 // keep input argument for subsequent
+                                 // call of __libm_error_support#
+      nop.i         0
+};;
+{ .mfi
+(p14) mov           GR_TAG = 11 // set libm error in case of log10f
+      frcpa.s0      f8,p0 = f0,f0 // log(negatives) should be equal to NaN.
+                                  // We can get it using frcpa because it
+                                  // sets result to the IEEE-754 mandated
+                                  // quotient of f0/f0 i.e. NaN.
+      nop.i         0
+};;
+
+.align 32
+logf_libm_err:
+{ .mmi
+      alloc         r32 = ar.pfs,1,4,4,0
+      mov           GR_Parameter_TAG = GR_TAG
+      nop.i         0
+};;
+GLOBAL_IEEE754_END(logf)
+libm_alias_float_other (__log, log)
+#ifdef SHARED
+.symver logf,logf@@GLIBC_2.27
+.weak __logf_compat
+.set __logf_compat,__logf
+.symver __logf_compat,logf@GLIBC_2.2
+#endif
+
+
+// Stack operations when calling error support.
+//       (1)               (2)                          (3) (call)              (4)
+//   sp   -> +          psp -> +                     psp -> +                   sp -> +
+//           |                 |                            |                         |
+//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
+//           |                 |                            |                         |
+//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
+//           |                 |                            |                         |
+//           |                 | <- GR_X               X1 ->|                         |
+//           |                 |                            |                         |
+//  sp-64 -> +          sp ->  +                     sp ->  +                         +
+//    save ar.pfs          save b0                                               restore gp
+//    save gp                                                                    restore ar.pfs
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+      add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+      nop.f 0
+.save ar.pfs,GR_SAVE_PFS
+      mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+      add sp=-64,sp                           // Create new stack
+      nop.f 0
+      mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+      stfs [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
+      add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+      mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+      stfs [GR_Parameter_X] = FR_X                  // STORE Parameter 1 on stack
+      add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+      nop.b 0
+}
+{ .mib
+      stfs [GR_Parameter_Y] = FR_RESULT             // STORE Parameter 3 on stack
+      add   GR_Parameter_Y = -16,GR_Parameter_Y
+      br.call.sptk b0=__libm_error_support#         // Call error handling function
+};;
+{ .mmi
+      nop.m 0
+      nop.m 0
+      add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+      ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+      add   sp = 64,sp                       // Restore stack pointer
+      mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+      mov   gp = GR_SAVE_GP                  // Restore gp
+      mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+      br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_logf_data.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_logl.S
@@ -0,0 +1,1201 @@
+.file "logl.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 05/21/01 Extracted logl and log10l from log1pl.s file, and optimized
+//          all paths.
+// 06/20/01 Fixed error tag for x=-inf.
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align;
+//          used data8 for long double table values
+//
+//*********************************************************************
+//
+//*********************************************************************
+//
+// Function:   Combined logl(x) and log10l(x) where
+//             logl(x)   = ln(x), for double-extended precision x values
+//             log10l(x) = log (x), for double-extended precision x values
+//                           10
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8 (Input and Return Value)
+//                              f34-f76
+//
+//    General Purpose Registers:
+//      r32-r56
+//      r53-r56 (Used to pass arguments to error handling routine)
+//
+//    Predicate Registers:      p6-p14
+//
+//*********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    Denormal  fault raised on denormal inputs
+//    Overflow exceptions cannot occur
+//    Underflow exceptions raised when appropriate for log1p
+//    (Error Handling Routine called for underflow)
+//    Inexact raised when appropriate by algorithm
+//
+//    logl(inf) = inf
+//    logl(-inf) = QNaN
+//    logl(+/-0) = -inf
+//    logl(SNaN) = QNaN
+//    logl(QNaN) = QNaN
+//    logl(EM_special Values) = QNaN
+//    log10l(inf) = inf
+//    log10l(-inf) = QNaN
+//    log10l(+/-0) = -inf
+//    log10l(SNaN) = QNaN
+//    log10l(QNaN) = QNaN
+//    log10l(EM_special Values) = QNaN
+//
+//*********************************************************************
+//
+// Overview
+//
+// The method consists of two cases.
+//
+// If      |X-1| < 2^(-7)	use case log_near1;
+// else      			use case log_regular;
+//
+// Case log_near1:
+//
+//   logl( 1 + X ) can be approximated by a simple polynomial
+//   in W = X-1. This polynomial resembles the truncated Taylor
+//   series W - W^/2 + W^3/3 - ...
+//
+// Case log_regular:
+//
+//   Here we use a table lookup method. The basic idea is that in
+//   order to compute logl(Arg) for an argument Arg in [1,2), we
+//   construct a value G such that G*Arg is close to 1 and that
+//   logl(1/G) is obtainable easily from a table of values calculated
+//   beforehand. Thus
+//
+//      logl(Arg) = logl(1/G) + logl(G*Arg)
+//      	 = logl(1/G) + logl(1 + (G*Arg - 1))
+//
+//   Because |G*Arg - 1| is small, the second term on the right hand
+//   side can be approximated by a short polynomial. We elaborate
+//   this method in four steps.
+//
+//   Step 0: Initialization
+//
+//   We need to calculate logl( X ). Obtain N, S_hi such that
+//
+//      X = 2^N * S_hi 	exactly
+//
+//   where S_hi in [1,2)
+//
+//   Step 1: Argument Reduction
+//
+//   Based on S_hi, obtain G_1, G_2, G_3 from a table and calculate
+//
+//      G := G_1 * G_2 * G_3
+//      r := (G * S_hi - 1)
+//
+//   These G_j's have the property that the product is exactly
+//   representable and that |r| < 2^(-12) as a result.
+//
+//   Step 2: Approximation
+//
+//
+//   logl(1 + r) is approximated by a short polynomial poly(r).
+//
+//   Step 3: Reconstruction
+//
+//
+//   Finally, logl( X ) is given by
+//
+//   logl( X )   =   logl( 2^N * S_hi )
+//                 ~=~  N*logl(2) + logl(1/G) + logl(1 + r)
+//                 ~=~  N*logl(2) + logl(1/G) + poly(r).
+//
+// **** Algorithm ****
+//
+// Case log_near1:
+//
+// Here we compute a simple polynomial. To exploit parallelism, we split
+// the polynomial into two portions.
+//
+//       W := X - 1
+//       Wsq := W * W
+//       W4  := Wsq*Wsq
+//       W6  := W4*Wsq
+//       Y_hi := W + Wsq*(P_1 + W*(P_2 + W*(P_3 + W*P_4))
+//       Y_lo := W6*(P_5 + W*(P_6 + W*(P_7 + W*P_8)))
+//
+// Case log_regular:
+//
+// We present the algorithm in four steps.
+//
+//   Step 0. Initialization
+//   ----------------------
+//
+//   Z := X
+//   N := unbaised exponent of Z
+//   S_hi := 2^(-N) * Z
+//
+//   Step 1. Argument Reduction
+//   --------------------------
+//
+//   Let
+//
+//      Z = 2^N * S_hi = 2^N * 1.d_1 d_2 d_3 ... d_63
+//
+//   We obtain G_1, G_2, G_3 by the following steps.
+//
+//
+//      Define		X_0 := 1.d_1 d_2 ... d_14. This is extracted
+//      		from S_hi.
+//
+//      Define		A_1 := 1.d_1 d_2 d_3 d_4. This is X_0 truncated
+//      		to lsb = 2^(-4).
+//
+//      Define		index_1 := [ d_1 d_2 d_3 d_4 ].
+//
+//      Fetch 		Z_1 := (1/A_1) rounded UP in fixed point with
+//      fixed point	lsb = 2^(-15).
+//      		Z_1 looks like z_0.z_1 z_2 ... z_15
+//      	        Note that the fetching is done using index_1.
+//      		A_1 is actually not needed in the implementation
+//      		and is used here only to explain how is the value
+//      		Z_1 defined.
+//
+//      Fetch		G_1 := (1/A_1) truncated to 21 sig. bits.
+//      floating pt.	Again, fetching is done using index_1. A_1
+//      		explains how G_1 is defined.
+//
+//      Calculate	X_1 := X_0 * Z_1 truncated to lsb = 2^(-14)
+//      		     = 1.0 0 0 0 d_5 ... d_14
+//      		This is accomplished by integer multiplication.
+//      		It is proved that X_1 indeed always begin
+//      		with 1.0000 in fixed point.
+//
+//
+//      Define		A_2 := 1.0 0 0 0 d_5 d_6 d_7 d_8. This is X_1
+//      		truncated to lsb = 2^(-8). Similar to A_1,
+//      		A_2 is not needed in actual implementation. It
+//      		helps explain how some of the values are defined.
+//
+//      Define		index_2 := [ d_5 d_6 d_7 d_8 ].
+//
+//      Fetch 		Z_2 := (1/A_2) rounded UP in fixed point with
+//      fixed point	lsb = 2^(-15). Fetch done using index_2.
+//      		Z_2 looks like z_0.z_1 z_2 ... z_15
+//
+//      Fetch		G_2 := (1/A_2) truncated to 21 sig. bits.
+//      floating pt.
+//
+//      Calculate	X_2 := X_1 * Z_2 truncated to lsb = 2^(-14)
+//      		     = 1.0 0 0 0 0 0 0 0 d_9 d_10 ... d_14
+//      		This is accomplished by integer multiplication.
+//      		It is proved that X_2 indeed always begin
+//      		with 1.00000000 in fixed point.
+//
+//
+//      Define		A_3 := 1.0 0 0 0 0 0 0 0 d_9 d_10 d_11 d_12 d_13 1.
+//      		This is 2^(-14) + X_2 truncated to lsb = 2^(-13).
+//
+//      Define		index_3 := [ d_9 d_10 d_11 d_12 d_13 ].
+//
+//      Fetch		G_3 := (1/A_3) truncated to 21 sig. bits.
+//      floating pt.	Fetch is done using index_3.
+//
+//      Compute		G := G_1 * G_2 * G_3.
+//
+//      This is done exactly since each of G_j only has 21 sig. bits.
+//
+//      Compute
+//
+//      	r := (G*S_hi - 1)
+//
+//
+//  Step 2. Approximation
+//  ---------------------
+//
+//   This step computes an approximation to logl( 1 + r ) where r is the
+//   reduced argument just obtained. It is proved that |r| <= 1.9*2^(-13);
+//   thus logl(1+r) can be approximated by a short polynomial:
+//
+//      logl(1+r) ~=~ poly = r + Q1 r^2 + ... + Q4 r^5
+//
+//
+//  Step 3. Reconstruction
+//  ----------------------
+//
+//   This step computes the desired result of logl(X):
+//
+//      logl(X)  =   logl( 2^N * S_hi )
+//      	  =   N*logl(2) + logl( S_hi )
+//      	  =   N*logl(2) + logl(1/G) +
+//      	      logl(1 + G*S_hi - 1 )
+//
+//   logl(2), logl(1/G_j) are stored as pairs of (single,double) numbers:
+//   log2_hi, log2_lo, log1byGj_hi, log1byGj_lo. The high parts are
+//   single-precision numbers and the low parts are double precision
+//   numbers. These have the property that
+//
+//      N*log2_hi + SUM ( log1byGj_hi )
+//
+//   is computable exactly in double-extended precision (64 sig. bits).
+//   Finally
+//
+//      Y_hi := N*log2_hi + SUM ( log1byGj_hi )
+//      Y_lo := poly_hi + [ poly_lo +
+//              ( SUM ( log1byGj_lo ) + N*log2_lo ) ]
+//
+
+RODATA
+.align 64
+
+// ************* DO NOT CHANGE THE ORDER OF THESE TABLES *************
+
+// P_8, P_7, P_6, P_5, P_4, P_3, P_2, and P_1
+
+LOCAL_OBJECT_START(Constants_P)
+data8  0xE3936754EFD62B15,0x00003FFB
+data8  0x8003B271A5E56381,0x0000BFFC
+data8  0x9249248C73282DB0,0x00003FFC
+data8  0xAAAAAA9F47305052,0x0000BFFC
+data8  0xCCCCCCCCCCD17FC9,0x00003FFC
+data8  0x8000000000067ED5,0x0000BFFD
+data8  0xAAAAAAAAAAAAAAAA,0x00003FFD
+data8  0xFFFFFFFFFFFFFFFE,0x0000BFFD
+LOCAL_OBJECT_END(Constants_P)
+
+// log2_hi, log2_lo, Q_4, Q_3, Q_2, and Q_1
+
+LOCAL_OBJECT_START(Constants_Q)
+data8  0xB172180000000000,0x00003FFE
+data8  0x82E308654361C4C6,0x0000BFE2
+data8  0xCCCCCAF2328833CB,0x00003FFC
+data8  0x80000077A9D4BAFB,0x0000BFFD
+data8  0xAAAAAAAAAAABE3D2,0x00003FFD
+data8  0xFFFFFFFFFFFFDAB7,0x0000BFFD
+LOCAL_OBJECT_END(Constants_Q)
+
+// 1/ln10_hi, 1/ln10_lo
+
+LOCAL_OBJECT_START(Constants_1_by_LN10)
+data8  0xDE5BD8A937287195,0x00003FFD
+data8  0xD56EAABEACCF70C8,0x00003FBB
+LOCAL_OBJECT_END(Constants_1_by_LN10)
+
+
+// Z1 - 16 bit fixed
+
+LOCAL_OBJECT_START(Constants_Z_1)
+data4  0x00008000
+data4  0x00007879
+data4  0x000071C8
+data4  0x00006BCB
+data4  0x00006667
+data4  0x00006187
+data4  0x00005D18
+data4  0x0000590C
+data4  0x00005556
+data4  0x000051EC
+data4  0x00004EC5
+data4  0x00004BDB
+data4  0x00004925
+data4  0x0000469F
+data4  0x00004445
+data4  0x00004211
+LOCAL_OBJECT_END(Constants_Z_1)
+
+// G1 and H1 - IEEE single and h1 - IEEE double
+
+LOCAL_OBJECT_START(Constants_G_H_h1)
+data4  0x3F800000,0x00000000
+data8  0x0000000000000000
+data4  0x3F70F0F0,0x3D785196
+data8  0x3DA163A6617D741C
+data4  0x3F638E38,0x3DF13843
+data8  0x3E2C55E6CBD3D5BB
+data4  0x3F579430,0x3E2FF9A0
+data8  0xBE3EB0BFD86EA5E7
+data4  0x3F4CCCC8,0x3E647FD6
+data8  0x3E2E6A8C86B12760
+data4  0x3F430C30,0x3E8B3AE7
+data8  0x3E47574C5C0739BA
+data4  0x3F3A2E88,0x3EA30C68
+data8  0x3E20E30F13E8AF2F
+data4  0x3F321640,0x3EB9CEC8
+data8  0xBE42885BF2C630BD
+data4  0x3F2AAAA8,0x3ECF9927
+data8  0x3E497F3497E577C6
+data4  0x3F23D708,0x3EE47FC5
+data8  0x3E3E6A6EA6B0A5AB
+data4  0x3F1D89D8,0x3EF8947D
+data8  0xBDF43E3CD328D9BE
+data4  0x3F17B420,0x3F05F3A1
+data8  0x3E4094C30ADB090A
+data4  0x3F124920,0x3F0F4303
+data8  0xBE28FBB2FC1FE510
+data4  0x3F0D3DC8,0x3F183EBF
+data8  0x3E3A789510FDE3FA
+data4  0x3F088888,0x3F20EC80
+data8  0x3E508CE57CC8C98F
+data4  0x3F042108,0x3F29516A
+data8  0xBE534874A223106C
+LOCAL_OBJECT_END(Constants_G_H_h1)
+
+// Z2 - 16 bit fixed
+
+LOCAL_OBJECT_START(Constants_Z_2)
+data4  0x00008000
+data4  0x00007F81
+data4  0x00007F02
+data4  0x00007E85
+data4  0x00007E08
+data4  0x00007D8D
+data4  0x00007D12
+data4  0x00007C98
+data4  0x00007C20
+data4  0x00007BA8
+data4  0x00007B31
+data4  0x00007ABB
+data4  0x00007A45
+data4  0x000079D1
+data4  0x0000795D
+data4  0x000078EB
+LOCAL_OBJECT_END(Constants_Z_2)
+
+// G2 and H2 - IEEE single and h2 - IEEE double
+
+LOCAL_OBJECT_START(Constants_G_H_h2)
+data4  0x3F800000,0x00000000
+data8  0x0000000000000000
+data4  0x3F7F00F8,0x3B7F875D
+data8  0x3DB5A11622C42273
+data4  0x3F7E03F8,0x3BFF015B
+data8  0x3DE620CF21F86ED3
+data4  0x3F7D08E0,0x3C3EE393
+data8  0xBDAFA07E484F34ED
+data4  0x3F7C0FC0,0x3C7E0586
+data8  0xBDFE07F03860BCF6
+data4  0x3F7B1880,0x3C9E75D2
+data8  0x3DEA370FA78093D6
+data4  0x3F7A2328,0x3CBDC97A
+data8  0x3DFF579172A753D0
+data4  0x3F792FB0,0x3CDCFE47
+data8  0x3DFEBE6CA7EF896B
+data4  0x3F783E08,0x3CFC15D0
+data8  0x3E0CF156409ECB43
+data4  0x3F774E38,0x3D0D874D
+data8  0xBE0B6F97FFEF71DF
+data4  0x3F766038,0x3D1CF49B
+data8  0xBE0804835D59EEE8
+data4  0x3F757400,0x3D2C531D
+data8  0x3E1F91E9A9192A74
+data4  0x3F748988,0x3D3BA322
+data8  0xBE139A06BF72A8CD
+data4  0x3F73A0D0,0x3D4AE46F
+data8  0x3E1D9202F8FBA6CF
+data4  0x3F72B9D0,0x3D5A1756
+data8  0xBE1DCCC4BA796223
+data4  0x3F71D488,0x3D693B9D
+data8  0xBE049391B6B7C239
+LOCAL_OBJECT_END(Constants_G_H_h2)
+
+// G3 and H3 - IEEE single and h3 - IEEE double
+
+LOCAL_OBJECT_START(Constants_G_H_h3)
+data4  0x3F7FFC00,0x38800100
+data8  0x3D355595562224CD
+data4  0x3F7FF400,0x39400480
+data8  0x3D8200A206136FF6
+data4  0x3F7FEC00,0x39A00640
+data8  0x3DA4D68DE8DE9AF0
+data4  0x3F7FE400,0x39E00C41
+data8  0xBD8B4291B10238DC
+data4  0x3F7FDC00,0x3A100A21
+data8  0xBD89CCB83B1952CA
+data4  0x3F7FD400,0x3A300F22
+data8  0xBDB107071DC46826
+data4  0x3F7FCC08,0x3A4FF51C
+data8  0x3DB6FCB9F43307DB
+data4  0x3F7FC408,0x3A6FFC1D
+data8  0xBD9B7C4762DC7872
+data4  0x3F7FBC10,0x3A87F20B
+data8  0xBDC3725E3F89154A
+data4  0x3F7FB410,0x3A97F68B
+data8  0xBD93519D62B9D392
+data4  0x3F7FAC18,0x3AA7EB86
+data8  0x3DC184410F21BD9D
+data4  0x3F7FA420,0x3AB7E101
+data8  0xBDA64B952245E0A6
+data4  0x3F7F9C20,0x3AC7E701
+data8  0x3DB4B0ECAABB34B8
+data4  0x3F7F9428,0x3AD7DD7B
+data8  0x3D9923376DC40A7E
+data4  0x3F7F8C30,0x3AE7D474
+data8  0x3DC6E17B4F2083D3
+data4  0x3F7F8438,0x3AF7CBED
+data8  0x3DAE314B811D4394
+data4  0x3F7F7C40,0x3B03E1F3
+data8  0xBDD46F21B08F2DB1
+data4  0x3F7F7448,0x3B0BDE2F
+data8  0xBDDC30A46D34522B
+data4  0x3F7F6C50,0x3B13DAAA
+data8  0x3DCB0070B1F473DB
+data4  0x3F7F6458,0x3B1BD766
+data8  0xBDD65DDC6AD282FD
+data4  0x3F7F5C68,0x3B23CC5C
+data8  0xBDCDAB83F153761A
+data4  0x3F7F5470,0x3B2BC997
+data8  0xBDDADA40341D0F8F
+data4  0x3F7F4C78,0x3B33C711
+data8  0x3DCD1BD7EBC394E8
+data4  0x3F7F4488,0x3B3BBCC6
+data8  0xBDC3532B52E3E695
+data4  0x3F7F3C90,0x3B43BAC0
+data8  0xBDA3961EE846B3DE
+data4  0x3F7F34A0,0x3B4BB0F4
+data8  0xBDDADF06785778D4
+data4  0x3F7F2CA8,0x3B53AF6D
+data8  0x3DCC3ED1E55CE212
+data4  0x3F7F24B8,0x3B5BA620
+data8  0xBDBA31039E382C15
+data4  0x3F7F1CC8,0x3B639D12
+data8  0x3D635A0B5C5AF197
+data4  0x3F7F14D8,0x3B6B9444
+data8  0xBDDCCB1971D34EFC
+data4  0x3F7F0CE0,0x3B7393BC
+data8  0x3DC7450252CD7ADA
+data4  0x3F7F04F0,0x3B7B8B6D
+data8  0xBDB68F177D7F2A42
+LOCAL_OBJECT_END(Constants_G_H_h3)
+
+
+// Floating Point Registers
+
+FR_Input_X      = f8
+
+FR_Y_hi         = f34
+FR_Y_lo         = f35
+
+FR_Scale        = f36
+FR_X_Prime      = f37
+FR_S_hi         = f38
+FR_W            = f39
+FR_G            = f40
+
+FR_H            = f41
+FR_wsq          = f42
+FR_w4           = f43
+FR_h            = f44
+FR_w6           = f45
+
+FR_G2           = f46
+FR_H2           = f47
+FR_poly_lo      = f48
+FR_P8           = f49
+FR_poly_hi      = f50
+
+FR_P7           = f51
+FR_h2           = f52
+FR_rsq          = f53
+FR_P6           = f54
+FR_r            = f55
+
+FR_log2_hi      = f56
+FR_log2_lo      = f57
+FR_p87          = f58
+FR_p876         = f58
+FR_p8765        = f58
+FR_float_N      = f59
+FR_Q4           = f60
+
+FR_p43          = f61
+FR_p432         = f61
+FR_p4321        = f61
+FR_P4           = f62
+FR_G3           = f63
+FR_H3           = f64
+FR_h3           = f65
+
+FR_Q3           = f66
+FR_P3           = f67
+FR_Q2           = f68
+FR_P2           = f69
+FR_1LN10_hi     = f70
+
+FR_Q1           = f71
+FR_P1           = f72
+FR_1LN10_lo     = f73
+FR_P5           = f74
+FR_rcub         = f75
+
+FR_Output_X_tmp = f76
+
+FR_X                = f8
+FR_Y                = f0
+FR_RESULT           = f76
+
+
+// General Purpose Registers
+
+GR_ad_p         = r33
+GR_Index1       = r34
+GR_Index2       = r35
+GR_signif       = r36
+GR_X_0          = r37
+GR_X_1          = r38
+GR_X_2          = r39
+GR_Z_1          = r40
+GR_Z_2          = r41
+GR_N            = r42
+GR_Bias         = r43
+GR_M            = r44
+GR_Index3       = r45
+GR_ad_p2        = r46
+GR_exp_mask     = r47
+GR_exp_2tom7    = r48
+GR_ad_ln10      = r49
+GR_ad_tbl_1     = r50
+GR_ad_tbl_2     = r51
+GR_ad_tbl_3     = r52
+GR_ad_q         = r53
+GR_ad_z_1       = r54
+GR_ad_z_2       = r55
+GR_ad_z_3       = r56
+
+//
+// Added for unwind support
+//
+
+GR_SAVE_PFS         = r50
+GR_SAVE_B0          = r51
+GR_SAVE_GP          = r52
+GR_Parameter_X      = r53
+GR_Parameter_Y      = r54
+GR_Parameter_RESULT = r55
+GR_Parameter_TAG    = r56
+
+.section .text
+
+GLOBAL_IEEE754_ENTRY(logl)
+{ .mfi
+      alloc r32 = ar.pfs,0,21,4,0
+      fclass.m p6, p0 =  FR_Input_X, 0x1E3  // Test for natval, nan, inf
+      cmp.eq  p7, p14 = r0, r0              // Set p7 if logl
+}
+{ .mfb
+      addl GR_ad_z_1 = @ltoff(Constants_Z_1#),gp
+      fnorm.s1 FR_X_Prime = FR_Input_X      // Normalize x
+      br.cond.sptk LOGL_BEGIN
+}
+;;
+
+GLOBAL_IEEE754_END(logl)
+libm_alias_ldouble_other (__log, log)
+
+
+GLOBAL_IEEE754_ENTRY(log10l)
+{ .mfi
+      alloc r32 = ar.pfs,0,21,4,0
+      fclass.m p6, p0 =  FR_Input_X, 0x1E3  // Test for natval, nan, inf
+      cmp.ne  p7, p14 = r0, r0              // Set p14 if log10l
+}
+{ .mfb
+      addl GR_ad_z_1 = @ltoff(Constants_Z_1#),gp
+      fnorm.s1 FR_X_Prime = FR_Input_X      // Normalize x
+      nop.b 999
+}
+;;
+
+
+// Common code for logl and log10
+LOGL_BEGIN:
+{ .mfi
+      ld8    GR_ad_z_1 = [GR_ad_z_1]          // Get pointer to Constants_Z_1
+      fclass.m p10, p0 =  FR_Input_X, 0x0b    // Test for denormal
+      mov GR_exp_2tom7 = 0x0fff8              // Exponent of 2^-7
+}
+;;
+
+{ .mfb
+      getf.sig GR_signif = FR_Input_X         // Get significand of x
+      fcmp.eq.s1 p9, p0 =  FR_Input_X, f1     // Test for x=1.0
+(p6)  br.cond.spnt LOGL_64_special            // Branch for nan, inf, natval
+}
+;;
+
+{ .mfi
+      add   GR_ad_tbl_1 = 0x040, GR_ad_z_1    // Point to Constants_G_H_h1
+      fcmp.lt.s1 p13, p0 =  FR_Input_X, f0    // Test for x<0
+      add   GR_ad_p = -0x100, GR_ad_z_1       // Point to Constants_P
+}
+{ .mib
+      add   GR_ad_z_2 = 0x140, GR_ad_z_1      // Point to Constants_Z_2
+      add   GR_ad_tbl_2 = 0x180, GR_ad_z_1    // Point to Constants_G_H_h2
+(p10) br.cond.spnt LOGL_64_denormal           // Branch for denormal
+}
+;;
+
+LOGL_64_COMMON:
+{ .mfi
+      add   GR_ad_q = 0x080, GR_ad_p          // Point to Constants_Q
+      fcmp.eq.s1 p8, p0 =  FR_Input_X, f0     // Test for x=0
+      extr.u GR_Index1 = GR_signif, 59, 4     // Get high 4 bits of signif
+}
+{ .mfb
+      add   GR_ad_tbl_3 = 0x280, GR_ad_z_1    // Point to Constants_G_H_h3
+(p9)  fma.s0  f8 = FR_Input_X, f0, f0         // If x=1, return +0.0
+(p9)  br.ret.spnt  b0                         // Exit if x=1
+}
+;;
+
+{ .mfi
+      shladd GR_ad_z_1 = GR_Index1, 2, GR_ad_z_1  // Point to Z_1
+      fclass.nm p10, p0 =  FR_Input_X, 0x1FF  // Test for unsupported
+      extr.u GR_X_0 = GR_signif, 49, 15       // Get high 15 bits of significand
+}
+{ .mfi
+      ldfe FR_P8 = [GR_ad_p],16               // Load P_8 for near1 path
+      fsub.s1 FR_W = FR_X_Prime, f1           // W = x - 1
+      add   GR_ad_ln10 = 0x060, GR_ad_q       // Point to Constants_1_by_LN10
+}
+;;
+
+{ .mfi
+      ld4 GR_Z_1 = [GR_ad_z_1]                // Load Z_1
+      nop.f 999
+      mov GR_exp_mask = 0x1FFFF               // Create exponent mask
+}
+{ .mib
+      shladd GR_ad_tbl_1 = GR_Index1, 4, GR_ad_tbl_1  // Point to G_1
+      mov GR_Bias = 0x0FFFF                   // Create exponent bias
+(p13) br.cond.spnt LOGL_64_negative           // Branch if x<0
+}
+;;
+
+{ .mfb
+      ldfps  FR_G, FR_H = [GR_ad_tbl_1],8     // Load G_1, H_1
+      fmerge.se FR_S_hi =  f1,FR_X_Prime      // Form |x|
+(p8)  br.cond.spnt LOGL_64_zero               // Branch if x=0
+}
+;;
+
+{ .mmb
+      getf.exp GR_N =  FR_X_Prime             // Get N = exponent of x
+      ldfd  FR_h = [GR_ad_tbl_1]              // Load h_1
+(p10) br.cond.spnt LOGL_64_unsupported        // Branch for unsupported type
+}
+;;
+
+{ .mfi
+      ldfe FR_log2_hi = [GR_ad_q],16          // Load log2_hi
+      fcmp.eq.s0 p8, p0 =  FR_Input_X, f0     // Dummy op to flag denormals
+      pmpyshr2.u GR_X_1 = GR_X_0,GR_Z_1,15    // Get bits 30-15 of X_0 * Z_1
+}
+;;
+
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mmi
+      ldfe FR_log2_lo = [GR_ad_q],16          // Load log2_lo
+(p14) ldfe FR_1LN10_hi = [GR_ad_ln10],16      // If log10l, load 1/ln10_hi
+      sub GR_N = GR_N, GR_Bias
+}
+;;
+
+{ .mmi
+      ldfe FR_Q4 = [GR_ad_q],16               // Load Q4
+(p14) ldfe FR_1LN10_lo = [GR_ad_ln10]         // If log10l, load 1/ln10_lo
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ldfe FR_Q3 = [GR_ad_q],16               // Load Q3
+      setf.sig FR_float_N = GR_N   // Put integer N into rightmost significand
+      nop.i 999
+}
+;;
+
+{ .mmi
+      getf.exp GR_M = FR_W                    // Get signexp of w = x - 1
+      ldfe FR_Q2 = [GR_ad_q],16               // Load Q2
+      extr.u GR_Index2 = GR_X_1, 6, 4         // Extract bits 6-9 of X_1
+}
+;;
+
+{ .mmi
+      ldfe FR_Q1 = [GR_ad_q]                  // Load Q1
+      shladd GR_ad_z_2 = GR_Index2, 2, GR_ad_z_2  // Point to Z_2
+      add GR_ad_p2  = 0x30,GR_ad_p            // Point to P_4
+}
+;;
+
+{ .mmi
+      ld4 GR_Z_2 = [GR_ad_z_2]                // Load Z_2
+      shladd GR_ad_tbl_2 = GR_Index2, 4, GR_ad_tbl_2  // Point to G_2
+      and GR_M = GR_exp_mask, GR_M            // Get exponent of w = x - 1
+}
+;;
+
+{ .mmi
+      ldfps  FR_G2, FR_H2 = [GR_ad_tbl_2],8   // Load G_2, H_2
+      cmp.lt  p8, p9 =  GR_M, GR_exp_2tom7    // Test |x-1| < 2^-7
+      nop.i 999
+}
+;;
+
+// Paths are merged.
+//  p8 is for the near1 path: |x-1| < 2^-7
+//  p9 is for regular path:   |x-1| >= 2^-7
+
+{ .mmi
+      ldfd  FR_h2 = [GR_ad_tbl_2]             // Load h_2
+      nop.m 999
+      nop.i 999
+}
+;;
+
+{ .mmi
+(p8)  ldfe FR_P7 = [GR_ad_p],16               // Load P_7 for near1 path
+(p8)  ldfe FR_P4 = [GR_ad_p2],16              // Load P_4 for near1 path
+(p9)  pmpyshr2.u GR_X_2 = GR_X_1,GR_Z_2,15    // Get bits 30-15 of X_1 * Z_2
+}
+;;
+
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mmi
+(p8)  ldfe FR_P6 = [GR_ad_p],16               // Load P_6 for near1 path
+(p8)  ldfe FR_P3 = [GR_ad_p2],16              // Load P_3 for near1 path
+      nop.i 999
+}
+;;
+
+{ .mmf
+(p8)  ldfe FR_P5 = [GR_ad_p],16               // Load P_5 for near1 path
+(p8)  ldfe FR_P2 = [GR_ad_p2],16              // Load P_2 for near1 path
+(p8)  fmpy.s1 FR_wsq = FR_W, FR_W             // wsq = w * w for near1 path
+}
+;;
+
+{ .mmi
+(p8)  ldfe FR_P1 = [GR_ad_p2],16 ;;           // Load P_1 for near1 path
+      nop.m 999
+(p9)  extr.u GR_Index3 = GR_X_2, 1, 5         // Extract bits 1-5 of X_2
+}
+;;
+
+{ .mfi
+(p9)  shladd GR_ad_tbl_3 = GR_Index3, 4, GR_ad_tbl_3  // Point to G_3
+(p9)  fcvt.xf FR_float_N = FR_float_N
+      nop.i 999
+}
+;;
+
+{ .mfi
+(p9)  ldfps  FR_G3, FR_H3 = [GR_ad_tbl_3],8   // Load G_3, H_3
+      nop.f 999
+      nop.i 999
+}
+;;
+
+{ .mfi
+(p9)  ldfd  FR_h3 = [GR_ad_tbl_3]             // Load h_3
+(p9)  fmpy.s1 FR_G = FR_G, FR_G2              // G = G_1 * G_2
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p9)  fadd.s1 FR_H = FR_H, FR_H2              // H = H_1 + H_2
+      nop.i 999
+}
+;;
+
+{ .mmf
+      nop.m 999
+      nop.m 999
+(p9)  fadd.s1 FR_h = FR_h, FR_h2              // h = h_1 + h_2
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p8)  fmpy.s1 FR_w4 = FR_wsq, FR_wsq          // w4 = w^4 for near1 path
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p8)  fma.s1 FR_p87 = FR_W, FR_P8, FR_P7      // p87 = w * P8 + P7
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p8)  fma.s1 FR_p43 = FR_W, FR_P4, FR_P3      // p43 = w * P4 + P3
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fmpy.s1 FR_G = FR_G, FR_G3              // G = (G_1 * G_2) * G_3
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p9)  fadd.s1 FR_H = FR_H, FR_H3              // H = (H_1 + H_2) + H_3
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fadd.s1 FR_h = FR_h, FR_h3              // h = (h_1 + h_2) + h_3
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p8)  fmpy.s1 FR_w6 = FR_w4, FR_wsq           // w6 = w^6 for near1 path
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p8)  fma.s1 FR_p432 = FR_W, FR_p43, FR_P2    // p432 = w * p43 + P2
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p8)  fma.s1 FR_p876 = FR_W, FR_p87, FR_P6    // p876 = w * p87 + P6
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fms.s1 FR_r = FR_G, FR_S_hi, f1         // r = G * S_hi - 1
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p9)  fma.s1 FR_Y_hi = FR_float_N, FR_log2_hi, FR_H // Y_hi = N * log2_hi + H
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fma.s1 FR_h = FR_float_N, FR_log2_lo, FR_h  // h = N * log2_lo + h
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p8)  fma.s1 FR_p4321 = FR_W, FR_p432, FR_P1      // p4321 = w * p432 + P1
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p8)  fma.s1 FR_p8765 = FR_W, FR_p876, FR_P5      // p8765 = w * p876 + P5
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fma.s1 FR_poly_lo = FR_r, FR_Q4, FR_Q3      // poly_lo = r * Q4 + Q3
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p9)  fmpy.s1 FR_rsq = FR_r, FR_r                 // rsq = r * r
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p8)  fma.s1 FR_Y_lo = FR_wsq, FR_p4321, f0       // Y_lo = wsq * p4321
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p8)  fma.s1 FR_Y_hi = FR_W, f1, f0               // Y_hi = w for near1 path
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fma.s1 FR_poly_lo = FR_poly_lo, FR_r, FR_Q2 // poly_lo = poly_lo * r + Q2
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p9)  fma.s1 FR_rcub = FR_rsq, FR_r, f0           // rcub = r^3
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p8)  fma.s1 FR_Y_lo = FR_w6, FR_p8765,FR_Y_lo // Y_lo = w6 * p8765 + w2 * p4321
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fma.s1 FR_poly_hi = FR_Q1, FR_rsq, FR_r     // poly_hi = Q1 * rsq + r
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fma.s1 FR_poly_lo = FR_poly_lo, FR_rcub, FR_h // poly_lo = poly_lo*r^3 + h
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fadd.s1 FR_Y_lo = FR_poly_hi, FR_poly_lo    // Y_lo = poly_hi + poly_lo
+      nop.i 999
+}
+;;
+
+// Remainder of code is common for near1 and regular paths
+{ .mfi
+      nop.m 999
+(p7)  fadd.s0  f8 = FR_Y_lo,FR_Y_hi               // If logl, result=Y_lo+Y_hi
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p14) fmpy.s1 FR_Output_X_tmp = FR_Y_lo,FR_1LN10_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p14) fma.s1  FR_Output_X_tmp = FR_Y_hi,FR_1LN10_lo,FR_Output_X_tmp
+      nop.i 999
+}
+;;
+
+{ .mfb
+      nop.m 999
+(p14) fma.s0  f8 = FR_Y_hi,FR_1LN10_hi,FR_Output_X_tmp
+      br.ret.sptk   b0                        // Common exit for 0 < x < inf
+}
+;;
+
+
+// Here if x=+-0
+LOGL_64_zero:
+//
+//    If x=+-0 raise divide by zero and return -inf
+//
+{ .mfi
+(p7)  mov   GR_Parameter_TAG = 0
+      fsub.s1 FR_Output_X_tmp = f0, f1
+      nop.i 999
+}
+;;
+
+{ .mfb
+(p14) mov   GR_Parameter_TAG = 6
+      frcpa.s0 FR_Output_X_tmp, p8 =  FR_Output_X_tmp, f0
+      br.cond.sptk __libm_error_region
+}
+;;
+
+LOGL_64_special:
+{ .mfi
+      nop.m 999
+      fclass.m.unc p8, p0 =  FR_Input_X, 0x1E1  // Test for natval, nan, +inf
+      nop.i 999
+}
+;;
+
+//
+//    For SNaN raise invalid and return QNaN.
+//    For QNaN raise invalid and return QNaN.
+//    For +Inf return +Inf.
+//
+{ .mfb
+      nop.m 999
+(p8)  fmpy.s0 f8 =  FR_Input_X, f1
+(p8)  br.ret.sptk   b0                          // Return for natval, nan, +inf
+}
+;;
+
+//
+//    For -Inf raise invalid and return QNaN.
+//
+{ .mmi
+(p7)  mov   GR_Parameter_TAG = 1
+      nop.m 999
+      nop.i 999
+}
+;;
+
+{ .mfb
+(p14) mov   GR_Parameter_TAG = 7
+      fmpy.s0 FR_Output_X_tmp =  FR_Input_X, f0
+      br.cond.sptk __libm_error_region
+}
+;;
+
+// Here if x denormal or unnormal
+LOGL_64_denormal:
+{ .mmi
+      getf.sig GR_signif = FR_X_Prime   // Get significand of normalized input
+      nop.m 999
+      nop.i 999
+}
+;;
+
+{ .mmb
+      getf.exp GR_N =  FR_X_Prime       // Get exponent of normalized input
+      nop.m 999
+      br.cond.sptk   LOGL_64_COMMON     // Branch back to common code
+}
+;;
+
+LOGL_64_unsupported:
+//
+//    Return generated NaN or other value.
+//
+{ .mfb
+      nop.m 999
+      fmpy.s0 f8 = FR_Input_X, f0
+      br.ret.sptk   b0
+}
+;;
+
+// Here if -inf < x < 0
+LOGL_64_negative:
+//
+//    Deal with x < 0 in a special way - raise
+//    invalid and produce QNaN indefinite.
+//
+{ .mfi
+(p7)  mov   GR_Parameter_TAG = 1
+      frcpa.s0 FR_Output_X_tmp, p8 =  f0, f0
+      nop.i 999
+}
+;;
+
+{ .mib
+(p14) mov   GR_Parameter_TAG = 7
+      nop.i 999
+      br.cond.sptk __libm_error_region
+}
+;;
+
+
+GLOBAL_IEEE754_END(log10l)
+libm_alias_ldouble_other (__log10, log10)
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfe [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfe [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfe [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#  // Call error handling function
+};;
+{ .mmi
+        nop.m 999
+        nop.m 999
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region#)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_pow.S
@@ -0,0 +1,2302 @@
+.file "pow.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 02/03/00 Added p12 to definite over/under path. With odd power we did not
+//          maintain the sign of x in this path.
+// 04/04/00 Unwind support added
+// 04/19/00 pow(+-1,inf) now returns NaN
+//          pow(+-val, +-inf) returns 0 or inf, but now does not call error
+//          support
+//          Added s1 to fcvt.fx because invalid flag was incorrectly set.
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 09/07/00 Improved performance by eliminating bank conflicts and other stalls,
+//          and tweaking the critical path
+// 09/08/00 Per c99, pow(+-1,inf) now returns 1, and pow(+1,nan) returns 1
+// 09/28/00 Updated NaN**0 path
+// 01/20/01 Fixed denormal flag settings.
+// 02/13/01 Improved speed.
+// 03/19/01 Reordered exp polynomial to improve speed and eliminate monotonicity
+//          problem in round up, down, and to zero modes.  Also corrected
+//          overflow result when x negative, y odd in round up, down, zero.
+// 06/14/01 Added brace missing from bundle
+// 12/10/01 Corrected case where x negative, 2^52 <= |y| < 2^53, y odd integer.
+// 12/20/01 Fixed monotonity problem in round to nearest.
+// 02/08/02 Fixed overflow/underflow cases that were not calling error support.
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 08/29/02 Improved Itanium 2 performance
+// 09/21/02 Added branch for |y*log(x)|<2^-11 to fix monotonicity problems.
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 03/31/05 Reformatted delimiters between data tables
+//
+// API
+//==============================================================
+// double pow(double x, double y)
+//
+// Overview of operation
+//==============================================================
+//
+// Three steps...
+// 1. Log(x)
+// 2. y Log(x)
+// 3. exp(y log(x))
+//
+// This means we work with the absolute value of x and merge in the sign later.
+//      Log(x) = G + delta + r -rsq/2 + p
+// G,delta depend on the exponent of x and table entries. The table entries are
+// indexed by the exponent of x, called K.
+//
+// The G and delta come out of the reduction; r is the reduced x.
+//
+// B = frcpa(x)
+// xB-1 is small means that B is the approximate inverse of x.
+//
+//      Log(x) = Log( (1/B)(Bx) )
+//             = Log(1/B) + Log(Bx)
+//             = Log(1/B) + Log( 1 + (Bx-1))
+//
+//      x  = 2^K 1.x_1x_2.....x_52
+//      B= frcpa(x) = 2^-k Cm
+//      Log(1/B) = Log(1/(2^-K Cm))
+//      Log(1/B) = Log((2^K/ Cm))
+//      Log(1/B) = K Log(2) + Log(1/Cm)
+//
+//      Log(x)   = K Log(2) + Log(1/Cm) + Log( 1 + (Bx-1))
+//
+// If you take the significand of x, set the exponent to true 0, then Cm is
+// the frcpa. We tabulate the Log(1/Cm) values. There are 256 of them.
+// The frcpa table is indexed by 8 bits, the x_1 thru x_8.
+// m = x_1x_2...x_8 is an 8-bit index.
+//
+//      Log(1/Cm) = log(1/frcpa(1+m/256)) where m goes from 0 to 255.
+//
+// We tabulate as two doubles, T and t, where T +t is the value itself.
+//
+//      Log(x)   = (K Log(2)_hi + T) + (Log(2)_hi + t) + Log( 1 + (Bx-1))
+//      Log(x)   =  G + delta           + Log( 1 + (Bx-1))
+//
+// The Log( 1 + (Bx-1)) can be calculated as a series in r = Bx-1.
+//
+//      Log( 1 + (Bx-1)) = r - rsq/2 + p
+//
+// Then,
+//
+//      yLog(x) = yG + y delta + y(r-rsq/2) + yp
+//      yLog(x) = Z1 + e3      + Z2         + Z3 + (e2 + e3)
+//
+//
+//     exp(yLog(x)) = exp(Z1 + Z2 + Z3) exp(e1 + e2 + e3)
+//
+//
+//       exp(Z3) is another series.
+//       exp(e1 + e2 + e3) is approximated as f3 = 1 + (e1 + e2 + e3)
+//
+//       Z1 (128/log2) = number of log2/128 in Z1 is N1
+//       Z2 (128/log2) = number of log2/128 in Z2 is N2
+//
+//       s1 = Z1 - N1 log2/128
+//       s2 = Z2 - N2 log2/128
+//
+//       s = s1 + s2
+//       N = N1 + N2
+//
+//       exp(Z1 + Z2) = exp(Z)
+//       exp(Z)       = exp(s) exp(N log2/128)
+//
+//       exp(r)       = exp(Z - N log2/128)
+//
+//      r = s + d = (Z - N (log2/128)_hi) -N (log2/128)_lo
+//                =  Z - N (log2/128)
+//
+//      Z         = s+d +N (log2/128)
+//
+//      exp(Z)    = exp(s) (1+d) exp(N log2/128)
+//
+//      N = M 128 + n
+//
+//      N log2/128 = M log2 + n log2/128
+//
+//      n is 8 binary digits = n_7n_6...n_1
+//
+//      n log2/128 = n_7n_6n_5 16 log2/128 + n_4n_3n_2n_1 log2/128
+//      n log2/128 = n_7n_6n_5 log2/8 + n_4n_3n_2n_1 log2/128
+//      n log2/128 = I2 log2/8 + I1 log2/128
+//
+//      N log2/128 = M log2 + I2 log2/8 + I1 log2/128
+//
+//      exp(Z)    = exp(s) (1+d) exp(log(2^M) + log(2^I2/8) + log(2^I1/128))
+//      exp(Z)    = exp(s) (1+d1) (1+d2)(2^M) 2^I2/8 2^I1/128
+//      exp(Z)    = exp(s) f1 f2 (2^M) 2^I2/8 2^I1/128
+//
+// I1, I2 are table indices. Use a series for exp(s).
+// Then get exp(Z)
+//
+//     exp(yLog(x)) = exp(Z1 + Z2 + Z3) exp(e1 + e2 + e3)
+//     exp(yLog(x)) = exp(Z) exp(Z3) f3
+//     exp(yLog(x)) = exp(Z)f3 exp(Z3)
+//     exp(yLog(x)) = A exp(Z3)
+//
+// We actually calculate exp(Z3) -1.
+// Then,
+//     exp(yLog(x)) = A + A( exp(Z3)   -1)
+//
+
+// Table Generation
+//==============================================================
+
+// The log values
+// ==============
+// The operation (K*log2_hi) must be exact. K is the true exponent of x.
+// If we allow gradual underflow (denormals), K can be represented in 12 bits
+// (as a two's complement number). We assume 13 bits as an engineering
+// precaution.
+//
+//           +------------+----------------+-+
+//           |  13 bits   | 50 bits        | |
+//           +------------+----------------+-+
+//           0            1                66
+//                        2                34
+//
+// So we want the lsb(log2_hi) to be 2^-50
+// We get log2 as a quad-extended (15-bit exponent, 128-bit significand)
+//
+//      0 fffe b17217f7d1cf79ab c9e3b39803f2f6af (4...)
+//
+// Consider numbering the bits left to right, starting at 0 thru 127.
+// Bit 0 is the 2^-1 bit; bit 49 is the 2^-50 bit.
+//
+//  ...79ab
+//     0111 1001 1010 1011
+//     44
+//     89
+//
+// So if we shift off the rightmost 14 bits, then (shift back only
+// the top half) we get
+//
+//      0 fffe b17217f7d1cf4000 e6af278ece600fcb dabc000000000000
+//
+// Put the right 64-bit signficand in an FR register, convert to double;
+// it is exact. Put the next 128 bits into a quad register and round to double.
+// The true exponent of the low part is -51.
+//
+// hi is 0 fffe b17217f7d1cf4000
+// lo is 0 ffcc e6af278ece601000
+//
+// Convert to double memory format and get
+//
+// hi is 0x3fe62e42fefa39e8
+// lo is 0x3cccd5e4f1d9cc02
+//
+// log2_hi + log2_lo is an accurate value for log2.
+//
+//
+// The T and t values
+// ==================
+// A similar method is used to generate the T and t values.
+//
+// K * log2_hi + T  must be exact.
+//
+// Smallest T,t
+// ----------
+// The smallest T,t is
+//       T                   t
+// 0x3f60040155d58800, 0x3c93bce0ce3ddd81  log(1/frcpa(1+0/256))=  +1.95503e-003
+//
+// The exponent is 0x3f6 (biased)  or -9 (true).
+// For the smallest T value, what we want is to clip the significand such that
+// when it is shifted right by 9, its lsb is in the bit for 2^-51. The 9 is the
+// specific for the first entry. In general, it is 0xffff - (biased 15-bit
+// exponent).
+
+// Independently, what we have calculated is the table value as a quad
+// precision number.
+// Table entry 1 is
+// 0 fff6 80200aaeac44ef38 338f77605fdf8000
+//
+// We store this quad precision number in a data structure that is
+//    sign:           1
+//    exponent:      15
+//    signficand_hi: 64 (includes explicit bit)
+//    signficand_lo: 49
+// Because the explicit bit is included, the significand is 113 bits.
+//
+// Consider significand_hi for table entry 1.
+//
+//
+// +-+--- ... -------+--------------------+
+// | |
+// +-+--- ... -------+--------------------+
+// 0 1               4444444455555555556666
+//                   2345678901234567890123
+//
+// Labeled as above, bit 0 is 2^0, bit 1 is 2^-1, etc.
+// Bit 42 is 2^-42. If we shift to the right by 9, the bit in
+// bit 42 goes in 51.
+//
+// So what we want to do is shift bits 43 thru 63 into significand_lo.
+// This is shifting bit 42 into bit 63, taking care to retain shifted-off bits.
+// Then shifting (just with signficaand_hi) back into bit 42.
+//
+// The shift_value is 63-42 = 21. In general, this is
+//      63 - (51 -(0xffff - 0xfff6))
+// For this example, it is
+//      63 - (51 - 9) = 63 - 42  = 21
+//
+// This means we are shifting 21 bits into significand_lo. We must maintain more
+// that a 128-bit signficand not to lose bits. So before the shift we put the
+// 128-bit significand into a 256-bit signficand and then shift.
+// The 256-bit significand has four parts: hh, hl, lh, and ll.
+//
+// Start off with
+//      hh         hl         lh         ll
+//      <64>       <49><15_0> <64_0>     <64_0>
+//
+// After shift by 21 (then return for significand_hi),
+//      <43><21_0> <21><43>   <6><58_0>  <64_0>
+//
+// Take the hh part and convert to a double. There is no rounding here.
+// The conversion is exact. The true exponent of the high part is the same as
+// the true exponent of the input quad.
+//
+// We have some 64 plus significand bits for the low part. In this example, we
+// have 70 bits. We want to round this to a double. Put them in a quad and then
+// do a quad fnorm.
+// For this example the true exponent of the low part is
+//      true_exponent_of_high - 43 = true_exponent_of_high - (64-21)
+// In general, this is
+//      true_exponent_of_high - (64 - shift_value)
+//
+//
+// Largest T,t
+// ----------
+// The largest T,t is
+// 0x3fe62643fecf9742, 0x3c9e3147684bd37d  log(1/frcpa(1+255/256))=+6.92171e-001
+//
+// Table entry 256 is
+// 0 fffe b1321ff67cba178c 51da12f4df5a0000
+//
+// The shift value is
+//      63 - (51 -(0xffff - 0xfffe)) = 13
+//
+// The true exponent of the low part is
+//      true_exponent_of_high - (64 - shift_value)
+//      -1 - (64-13) = -52
+// Biased as a double, this is 0x3cb
+//
+//
+//
+// So then lsb(T) must be >= 2^-51
+// msb(Klog2_hi) <= 2^12
+//
+//              +--------+---------+
+//              |       51 bits    | <== largest T
+//              +--------+---------+
+//              | 9 bits | 42 bits | <== smallest T
+// +------------+----------------+-+
+// |  13 bits   | 50 bits        | |
+// +------------+----------------+-+
+
+
+// Special Cases
+//==============================================================
+
+//                                   double     float
+// overflow                          error 24   30
+
+// underflow                         error 25   31
+
+// X zero  Y zero
+//  +0     +0                 +1     error 26   32
+//  -0     +0                 +1     error 26   32
+//  +0     -0                 +1     error 26   32
+//  -0     -0                 +1     error 26   32
+
+// X zero  Y negative
+//  +0     -odd integer       +inf   error 27   33  divide-by-zero
+//  -0     -odd integer       -inf   error 27   33  divide-by-zero
+//  +0     !-odd integer      +inf   error 27   33  divide-by-zero
+//  -0     !-odd integer      +inf   error 27   33  divide-by-zero
+//  +0     -inf               +inf   error 27   33  divide-by-zero
+//  -0     -inf               +inf   error 27   33  divide-by-zero
+
+// X zero  Y positive
+//  +0     +odd integer       +0
+//  -0     +odd integer       -0
+//  +0     !+odd integer      +0
+//  -0     !+odd integer      +0
+//  +0     +inf               +0
+//  -0     +inf               +0
+//  +0     Y NaN              quiet Y               invalid if Y SNaN
+//  -0     Y NaN              quiet Y               invalid if Y SNaN
+
+// X one
+//  -1     Y inf              +1
+//  -1     Y NaN              quiet Y               invalid if Y SNaN
+//  +1     Y NaN              +1                    invalid if Y SNaN
+//  +1     Y any else         +1
+
+// X -     Y not integer      QNAN   error 28   34  invalid
+
+// X NaN   Y 0                +1     error 29   35
+// X NaN   Y NaN              quiet X               invalid if X or Y SNaN
+// X NaN   Y any else         quiet X               invalid if X SNaN
+// X !+1   Y NaN              quiet Y               invalid if Y SNaN
+
+
+// X +inf  Y >0               +inf
+// X -inf  Y >0, !odd integer +inf
+// X -inf  Y >0, odd integer  -inf
+
+// X +inf  Y <0               +0
+// X -inf  Y <0, !odd integer +0
+// X -inf  Y <0, odd integer  -0
+
+// X +inf  Y =0               +1
+// X -inf  Y =0               +1
+
+// |X|<1   Y +inf             +0
+// |X|<1   Y -inf             +inf
+// |X|>1   Y +inf             +inf
+// |X|>1   Y -inf             +0
+
+// X any   Y =0               +1
+
+// Assembly macros
+//==============================================================
+
+// integer registers used
+
+pow_GR_signexp_X          = r14
+pow_GR_17ones             = r15
+pow_AD_P                  = r16
+pow_GR_exp_2tom8          = r17
+pow_GR_sig_X              = r18
+pow_GR_10033              = r19
+pow_GR_16ones             = r20
+
+pow_AD_Tt                 = r21
+pow_GR_exp_X              = r22
+pow_AD_Q                  = r23
+pow_GR_true_exp_X         = r24
+pow_GR_y_zero             = r25
+
+pow_GR_exp_Y              = r26
+pow_AD_tbl1               = r27
+pow_AD_tbl2               = r28
+pow_GR_offset             = r29
+pow_GR_exp_Xm1            = r30
+pow_GR_xneg_yodd          = r31
+
+pow_GR_signexp_Xm1        = r35
+pow_GR_int_W1             = r36
+pow_GR_int_W2             = r37
+pow_GR_int_N              = r38
+pow_GR_index1             = r39
+pow_GR_index2             = r40
+
+pow_AD_T1                 = r41
+pow_AD_T2                 = r42
+pow_int_GR_M              = r43
+pow_GR_sig_int_Y          = r44
+pow_GR_sign_Y_Gpr         = r45
+
+pow_GR_17ones_m1          = r46
+pow_GR_one                = r47
+pow_GR_sign_Y             = r48
+pow_GR_signexp_Y_Gpr      = r49
+pow_GR_exp_Y_Gpr          = r50
+
+pow_GR_true_exp_Y_Gpr     = r51
+pow_GR_signexp_Y          = r52
+pow_GR_x_one              = r53
+pow_GR_exp_2toM63         = r54
+pow_GR_big_pos            = r55
+
+pow_GR_big_neg            = r56
+
+GR_SAVE_B0                = r50
+GR_SAVE_GP                = r51
+GR_SAVE_PFS               = r52
+
+GR_Parameter_X            = r53
+GR_Parameter_Y            = r54
+GR_Parameter_RESULT       = r55
+pow_GR_tag                = r56
+
+
+// floating point registers used
+
+POW_B                     = f32
+POW_NORM_X                = f33
+POW_Xm1                   = f34
+POW_r1                    = f34
+POW_P4                    = f35
+
+POW_P5                    = f36
+POW_NORM_Y                = f37
+POW_Q2                    = f38
+POW_Q3                    = f39
+POW_P2                    = f40
+
+POW_P3                    = f41
+POW_P0                    = f42
+POW_log2_lo               = f43
+POW_r                     = f44
+POW_Q0_half               = f45
+
+POW_Q1                    = f46
+POW_tmp                   = f47
+POW_log2_hi               = f48
+POW_Q4                    = f49
+POW_P1                    = f50
+
+POW_log2_by_128_hi        = f51
+POW_inv_log2_by_128       = f52
+POW_rsq                   = f53
+POW_Yrcub                 = f54
+POW_log2_by_128_lo        = f55
+
+POW_v6                    = f56
+POW_xsq                   = f57
+POW_v4                    = f58
+POW_v2                    = f59
+POW_T                     = f60
+
+POW_Tt                    = f61
+POW_RSHF                  = f62
+POW_v21ps                 = f63
+POW_s4                    = f64
+POW_twoV                  = f65
+
+POW_U                     = f66
+POW_G                     = f67
+POW_delta                 = f68
+POW_v3                    = f69
+POW_V                     = f70
+
+POW_p                     = f71
+POW_Z1                    = f72
+POW_e3                    = f73
+POW_e2                    = f74
+POW_Z2                    = f75
+
+POW_e1                    = f76
+POW_W1                    = f77
+POW_UmZ2                  = f78
+POW_W2                    = f79
+POW_Z3                    = f80
+
+POW_int_W1                = f81
+POW_e12                   = f82
+POW_int_W2                = f83
+POW_UmZ2pV                = f84
+POW_Z3sq                  = f85
+
+POW_e123                  = f86
+POW_N1float               = f87
+POW_N2float               = f88
+POW_f3                    = f89
+POW_q                     = f90
+
+POW_s1                    = f91
+POW_Nfloat                = f92
+POW_s2                    = f93
+POW_f2                    = f94
+POW_f1                    = f95
+
+POW_T1                    = f96
+POW_T2                    = f97
+POW_2M                    = f98
+POW_s                     = f99
+POW_f12                   = f100
+
+POW_ssq                   = f101
+POW_T1T2                  = f102
+POW_1ps                   = f103
+POW_A                     = f104
+POW_es                    = f105
+
+POW_Xp1                   = f106
+POW_int_K                 = f107
+POW_K                     = f108
+POW_f123                  = f109
+POW_Gpr                   = f110
+
+POW_Y_Gpr                 = f111
+POW_int_Y                 = f112
+POW_abs_q                 = f114
+POW_2toM63                = f115
+
+POW_float_int_Y           = f116
+POW_ftz_urm_f8            = f117
+POW_wre_urm_f8            = f118
+POW_big_neg               = f119
+POW_big_pos               = f120
+
+POW_GY_Z2                 = f121
+POW_pYrcub_e3             = f122
+POW_d                     = f123
+POW_d2                    = f124
+POW_poly_d_hi             = f121
+POW_poly_d_lo             = f122
+POW_poly_d                = f121
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(pow_table_P)
+data8 0x8000F7B249FF332D, 0x0000BFFC  // P_5
+data8 0xAAAAAAA9E7902C7F, 0x0000BFFC  // P_3
+data8 0x80000000000018E5, 0x0000BFFD  // P_1
+data8 0xb8aa3b295c17f0bc, 0x00004006  // inv_ln2_by_128
+//
+//
+data8 0x3FA5555555554A9E // Q_2
+data8 0x3F8111124F4DD9F9 // Q_3
+data8 0x3FE0000000000000 // Q_0
+data8 0x3FC5555555554733 // Q_1
+data8 0x3F56C16D9360FFA0 // Q_4
+data8 0x43e8000000000000 // Right shift constant for exp
+data8 0xc9e3b39803f2f6af, 0x00003fb7  // ln2_by_128_lo
+data8 0x0000000000000000 // pad to eliminate bank conflicts with pow_table_Q
+data8 0x0000000000000000 // pad to eliminate bank conflicts with pow_table_Q
+LOCAL_OBJECT_END(pow_table_P)
+
+LOCAL_OBJECT_START(pow_table_Q)
+data8 0x9249FE7F0DC423CF, 0x00003FFC  // P_4
+data8 0xCCCCCCCC4ED2BA7F, 0x00003FFC  // P_2
+data8 0xAAAAAAAAAAAAB505, 0x00003FFD  // P_0
+data8 0x3fe62e42fefa39e8, 0x3cccd5e4f1d9cc02 // log2 hi lo =  +6.93147e-001
+data8 0xb17217f7d1cf79ab, 0x00003ff7  // ln2_by_128_hi
+LOCAL_OBJECT_END(pow_table_Q)
+
+
+LOCAL_OBJECT_START(pow_Tt)
+data8 0x3f60040155d58800, 0x3c93bce0ce3ddd81 // log(1/frcpa(1+0/256))=  +1.95503e-003
+data8 0x3f78121214586a00, 0x3cb540e0a5cfc9bc // log(1/frcpa(1+1/256))=  +5.87661e-003
+data8 0x3f841929f9683200, 0x3cbdf1d57404da1f // log(1/frcpa(1+2/256))=  +9.81362e-003
+data8 0x3f8c317384c75f00, 0x3c69806208c04c22 // log(1/frcpa(1+3/256))=  +1.37662e-002
+data8 0x3f91a6b91ac73380, 0x3c7874daa716eb32 // log(1/frcpa(1+4/256))=  +1.72376e-002
+data8 0x3f95ba9a5d9ac000, 0x3cacbb84e08d78ac // log(1/frcpa(1+5/256))=  +2.12196e-002
+data8 0x3f99d2a807432580, 0x3cbcf80538b441e1 // log(1/frcpa(1+6/256))=  +2.52177e-002
+data8 0x3f9d6b2725979800, 0x3c6095e5c8f8f359 // log(1/frcpa(1+7/256))=  +2.87291e-002
+data8 0x3fa0c58fa19dfa80, 0x3cb4c5d4e9d0dda2 // log(1/frcpa(1+8/256))=  +3.27573e-002
+data8 0x3fa2954c78cbce00, 0x3caa932b860ab8d6 // log(1/frcpa(1+9/256))=  +3.62953e-002
+data8 0x3fa4a94d2da96c40, 0x3ca670452b76bbd5 // log(1/frcpa(1+10/256))=  +4.03542e-002
+data8 0x3fa67c94f2d4bb40, 0x3ca84104f9941798 // log(1/frcpa(1+11/256))=  +4.39192e-002
+data8 0x3fa85188b630f040, 0x3cb40a882cbf0153 // log(1/frcpa(1+12/256))=  +4.74971e-002
+data8 0x3faa6b8abe73af40, 0x3c988d46e25c9059 // log(1/frcpa(1+13/256))=  +5.16017e-002
+data8 0x3fac441e06f72a80, 0x3cae3e930a1a2a96 // log(1/frcpa(1+14/256))=  +5.52072e-002
+data8 0x3fae1e6713606d00, 0x3c8a796f6283b580 // log(1/frcpa(1+15/256))=  +5.88257e-002
+data8 0x3faffa6911ab9300, 0x3c5193070351e88a // log(1/frcpa(1+16/256))=  +6.24574e-002
+data8 0x3fb0ec139c5da600, 0x3c623f2a75eb992d // log(1/frcpa(1+17/256))=  +6.61022e-002
+data8 0x3fb1dbd2643d1900, 0x3ca649b2ef8927f0 // log(1/frcpa(1+18/256))=  +6.97605e-002
+data8 0x3fb2cc7284fe5f00, 0x3cbc5e86599513e2 // log(1/frcpa(1+19/256))=  +7.34321e-002
+data8 0x3fb3bdf5a7d1ee60, 0x3c90bd4bb69dada3 // log(1/frcpa(1+20/256))=  +7.71173e-002
+data8 0x3fb4b05d7aa012e0, 0x3c54e377c9b8a54f // log(1/frcpa(1+21/256))=  +8.08161e-002
+data8 0x3fb580db7ceb5700, 0x3c7fdb2f98354cde // log(1/frcpa(1+22/256))=  +8.39975e-002
+data8 0x3fb674f089365a60, 0x3cb9994c9d3301c1 // log(1/frcpa(1+23/256))=  +8.77219e-002
+data8 0x3fb769ef2c6b5680, 0x3caaec639db52a79 // log(1/frcpa(1+24/256))=  +9.14602e-002
+data8 0x3fb85fd927506a40, 0x3c9f9f99a3cf8e25 // log(1/frcpa(1+25/256))=  +9.52125e-002
+data8 0x3fb9335e5d594980, 0x3ca15c3abd47d99a // log(1/frcpa(1+26/256))=  +9.84401e-002
+data8 0x3fba2b0220c8e5e0, 0x3cb4ca639adf6fc3 // log(1/frcpa(1+27/256))=  +1.02219e-001
+data8 0x3fbb0004ac1a86a0, 0x3ca7cb81bf959a59 // log(1/frcpa(1+28/256))=  +1.05469e-001
+data8 0x3fbbf968769fca00, 0x3cb0c646c121418e // log(1/frcpa(1+29/256))=  +1.09274e-001
+data8 0x3fbccfedbfee13a0, 0x3ca0465fce24ab4b // log(1/frcpa(1+30/256))=  +1.12548e-001
+data8 0x3fbda727638446a0, 0x3c82803f4e2e6603 // log(1/frcpa(1+31/256))=  +1.15832e-001
+data8 0x3fbea3257fe10f60, 0x3cb986a3f2313d1a // log(1/frcpa(1+32/256))=  +1.19677e-001
+data8 0x3fbf7be9fedbfde0, 0x3c97d16a6a621cf4 // log(1/frcpa(1+33/256))=  +1.22985e-001
+data8 0x3fc02ab352ff25f0, 0x3c9cc6baad365600 // log(1/frcpa(1+34/256))=  +1.26303e-001
+data8 0x3fc097ce579d2040, 0x3cb9ba16d329440b // log(1/frcpa(1+35/256))=  +1.29633e-001
+data8 0x3fc1178e8227e470, 0x3cb7bc671683f8e6 // log(1/frcpa(1+36/256))=  +1.33531e-001
+data8 0x3fc185747dbecf30, 0x3c9d1116f66d2345 // log(1/frcpa(1+37/256))=  +1.36885e-001
+data8 0x3fc1f3b925f25d40, 0x3c8162c9ef939ac6 // log(1/frcpa(1+38/256))=  +1.40250e-001
+data8 0x3fc2625d1e6ddf50, 0x3caad3a1ec384fc3 // log(1/frcpa(1+39/256))=  +1.43627e-001
+data8 0x3fc2d1610c868130, 0x3cb3ad997036941b // log(1/frcpa(1+40/256))=  +1.47015e-001
+data8 0x3fc340c597411420, 0x3cbc2308262c7998 // log(1/frcpa(1+41/256))=  +1.50414e-001
+data8 0x3fc3b08b6757f2a0, 0x3cb2170d6cdf0526 // log(1/frcpa(1+42/256))=  +1.53825e-001
+data8 0x3fc40dfb08378000, 0x3c9bb453c4f7b685 // log(1/frcpa(1+43/256))=  +1.56677e-001
+data8 0x3fc47e74e8ca5f70, 0x3cb836a48fdfce9d // log(1/frcpa(1+44/256))=  +1.60109e-001
+data8 0x3fc4ef51f6466de0, 0x3ca07a43919aa64b // log(1/frcpa(1+45/256))=  +1.63553e-001
+data8 0x3fc56092e02ba510, 0x3ca85006899d97b0 // log(1/frcpa(1+46/256))=  +1.67010e-001
+data8 0x3fc5d23857cd74d0, 0x3ca30a5ba6e7abbe // log(1/frcpa(1+47/256))=  +1.70478e-001
+data8 0x3fc6313a37335d70, 0x3ca905586f0ac97e // log(1/frcpa(1+48/256))=  +1.73377e-001
+data8 0x3fc6a399dabbd380, 0x3c9b2c6657a96684 // log(1/frcpa(1+49/256))=  +1.76868e-001
+data8 0x3fc70337dd3ce410, 0x3cb50bc52f55cdd8 // log(1/frcpa(1+50/256))=  +1.79786e-001
+data8 0x3fc77654128f6120, 0x3cad2eb7c9a39efe // log(1/frcpa(1+51/256))=  +1.83299e-001
+data8 0x3fc7e9d82a0b0220, 0x3cba127e90393c01 // log(1/frcpa(1+52/256))=  +1.86824e-001
+data8 0x3fc84a6b759f5120, 0x3cbd7fd52079f706 // log(1/frcpa(1+53/256))=  +1.89771e-001
+data8 0x3fc8ab47d5f5a300, 0x3cbfae141751a3de // log(1/frcpa(1+54/256))=  +1.92727e-001
+data8 0x3fc91fe490965810, 0x3cb69cf30a1c319e // log(1/frcpa(1+55/256))=  +1.96286e-001
+data8 0x3fc981634011aa70, 0x3ca5bb3d208bc42a // log(1/frcpa(1+56/256))=  +1.99261e-001
+data8 0x3fc9f6c407089660, 0x3ca04d68658179a0 // log(1/frcpa(1+57/256))=  +2.02843e-001
+data8 0x3fca58e729348f40, 0x3c99f5411546c286 // log(1/frcpa(1+58/256))=  +2.05838e-001
+data8 0x3fcabb55c31693a0, 0x3cb9a5350eb327d5 // log(1/frcpa(1+59/256))=  +2.08842e-001
+data8 0x3fcb1e104919efd0, 0x3c18965fcce7c406 // log(1/frcpa(1+60/256))=  +2.11855e-001
+data8 0x3fcb94ee93e367c0, 0x3cb503716da45184 // log(1/frcpa(1+61/256))=  +2.15483e-001
+data8 0x3fcbf851c0675550, 0x3cbdf1b3f7ab5378 // log(1/frcpa(1+62/256))=  +2.18516e-001
+data8 0x3fcc5c0254bf23a0, 0x3ca7aab9ed0b1d7b // log(1/frcpa(1+63/256))=  +2.21558e-001
+data8 0x3fccc000c9db3c50, 0x3c92a7a2a850072a // log(1/frcpa(1+64/256))=  +2.24609e-001
+data8 0x3fcd244d99c85670, 0x3c9f6019120edf4c // log(1/frcpa(1+65/256))=  +2.27670e-001
+data8 0x3fcd88e93fb2f450, 0x3c6affb96815e081 // log(1/frcpa(1+66/256))=  +2.30741e-001
+data8 0x3fcdedd437eaef00, 0x3c72553595897976 // log(1/frcpa(1+67/256))=  +2.33820e-001
+data8 0x3fce530effe71010, 0x3c90913b020fa182 // log(1/frcpa(1+68/256))=  +2.36910e-001
+data8 0x3fceb89a1648b970, 0x3c837ba4045bfd25 // log(1/frcpa(1+69/256))=  +2.40009e-001
+data8 0x3fcf1e75fadf9bd0, 0x3cbcea6d13e0498d // log(1/frcpa(1+70/256))=  +2.43117e-001
+data8 0x3fcf84a32ead7c30, 0x3ca5e3a67b3c6d77 // log(1/frcpa(1+71/256))=  +2.46235e-001
+data8 0x3fcfeb2233ea07c0, 0x3cba0c6f0049c5a6 // log(1/frcpa(1+72/256))=  +2.49363e-001
+data8 0x3fd028f9c7035c18, 0x3cb0a30b06677ff6 // log(1/frcpa(1+73/256))=  +2.52501e-001
+data8 0x3fd05c8be0d96358, 0x3ca0f1c77ccb5865 // log(1/frcpa(1+74/256))=  +2.55649e-001
+data8 0x3fd085eb8f8ae790, 0x3cbd513f45fe7a97 // log(1/frcpa(1+75/256))=  +2.58174e-001
+data8 0x3fd0b9c8e32d1910, 0x3c927449047ca006 // log(1/frcpa(1+76/256))=  +2.61339e-001
+data8 0x3fd0edd060b78080, 0x3c89b52d8435f53e // log(1/frcpa(1+77/256))=  +2.64515e-001
+data8 0x3fd122024cf00638, 0x3cbdd976fabda4bd // log(1/frcpa(1+78/256))=  +2.67701e-001
+data8 0x3fd14be2927aecd0, 0x3cb02f90ad0bc471 // log(1/frcpa(1+79/256))=  +2.70257e-001
+data8 0x3fd180618ef18ad8, 0x3cbd003792c71a98 // log(1/frcpa(1+80/256))=  +2.73461e-001
+data8 0x3fd1b50bbe2fc638, 0x3ca9ae64c6403ead // log(1/frcpa(1+81/256))=  +2.76675e-001
+data8 0x3fd1df4cc7cf2428, 0x3cb43f0455f7e395 // log(1/frcpa(1+82/256))=  +2.79254e-001
+data8 0x3fd214456d0eb8d0, 0x3cb0fbd748d75d30 // log(1/frcpa(1+83/256))=  +2.82487e-001
+data8 0x3fd23ec5991eba48, 0x3c906edd746b77e2 // log(1/frcpa(1+84/256))=  +2.85081e-001
+data8 0x3fd2740d9f870af8, 0x3ca9802e6a00a670 // log(1/frcpa(1+85/256))=  +2.88333e-001
+data8 0x3fd29ecdabcdfa00, 0x3cacecef70890cfa // log(1/frcpa(1+86/256))=  +2.90943e-001
+data8 0x3fd2d46602adcce8, 0x3cb97911955f3521 // log(1/frcpa(1+87/256))=  +2.94214e-001
+data8 0x3fd2ff66b04ea9d0, 0x3cb12dabe191d1c9 // log(1/frcpa(1+88/256))=  +2.96838e-001
+data8 0x3fd335504b355a30, 0x3cbdf9139df924ec // log(1/frcpa(1+89/256))=  +3.00129e-001
+data8 0x3fd360925ec44f58, 0x3cb253e68977a1e3 // log(1/frcpa(1+90/256))=  +3.02769e-001
+data8 0x3fd38bf1c3337e70, 0x3cb3d283d2a2da21 // log(1/frcpa(1+91/256))=  +3.05417e-001
+data8 0x3fd3c25277333180, 0x3cadaa5b035eae27 // log(1/frcpa(1+92/256))=  +3.08735e-001
+data8 0x3fd3edf463c16838, 0x3cb983d680d3c108 // log(1/frcpa(1+93/256))=  +3.11399e-001
+data8 0x3fd419b423d5e8c0, 0x3cbc86dd921c139d // log(1/frcpa(1+94/256))=  +3.14069e-001
+data8 0x3fd44591e0539f48, 0x3c86a76d6dc2782e // log(1/frcpa(1+95/256))=  +3.16746e-001
+data8 0x3fd47c9175b6f0a8, 0x3cb59a2e013c6b5f // log(1/frcpa(1+96/256))=  +3.20103e-001
+data8 0x3fd4a8b341552b08, 0x3c93f1e86e468694 // log(1/frcpa(1+97/256))=  +3.22797e-001
+data8 0x3fd4d4f390890198, 0x3cbf5e4ea7c5105a // log(1/frcpa(1+98/256))=  +3.25498e-001
+data8 0x3fd501528da1f960, 0x3cbf58da53e9ad10 // log(1/frcpa(1+99/256))=  +3.28206e-001
+data8 0x3fd52dd06347d4f0, 0x3cb98a28cebf6eef // log(1/frcpa(1+100/256))=  +3.30921e-001
+data8 0x3fd55a6d3c7b8a88, 0x3c9c76b67c2d1fd4 // log(1/frcpa(1+101/256))=  +3.33644e-001
+data8 0x3fd5925d2b112a58, 0x3c9029616a4331b8 // log(1/frcpa(1+102/256))=  +3.37058e-001
+data8 0x3fd5bf406b543db0, 0x3c9fb8292ecfc820 // log(1/frcpa(1+103/256))=  +3.39798e-001
+data8 0x3fd5ec433d5c35a8, 0x3cb71a1229d17eec // log(1/frcpa(1+104/256))=  +3.42545e-001
+data8 0x3fd61965cdb02c18, 0x3cbba94fe1dbb8d2 // log(1/frcpa(1+105/256))=  +3.45300e-001
+data8 0x3fd646a84935b2a0, 0x3c9ee496d2c9ae57 // log(1/frcpa(1+106/256))=  +3.48063e-001
+data8 0x3fd6740add31de90, 0x3cb1da3a6c7a9dfd // log(1/frcpa(1+107/256))=  +3.50833e-001
+data8 0x3fd6a18db74a58c0, 0x3cb494c257add8dc // log(1/frcpa(1+108/256))=  +3.53610e-001
+data8 0x3fd6cf31058670e8, 0x3cb0b244a70a8da9 // log(1/frcpa(1+109/256))=  +3.56396e-001
+data8 0x3fd6f180e852f0b8, 0x3c9db7aefa866720 // log(1/frcpa(1+110/256))=  +3.58490e-001
+data8 0x3fd71f5d71b894e8, 0x3cbe91c4bf324957 // log(1/frcpa(1+111/256))=  +3.61289e-001
+data8 0x3fd74d5aefd66d58, 0x3cb06b3d9bfac023 // log(1/frcpa(1+112/256))=  +3.64096e-001
+data8 0x3fd77b79922bd378, 0x3cb727d8804491f4 // log(1/frcpa(1+113/256))=  +3.66911e-001
+data8 0x3fd7a9b9889f19e0, 0x3ca2ef22df5bc543 // log(1/frcpa(1+114/256))=  +3.69734e-001
+data8 0x3fd7d81b037eb6a0, 0x3cb8fd3ba07a7ece // log(1/frcpa(1+115/256))=  +3.72565e-001
+data8 0x3fd8069e33827230, 0x3c8bd1e25866e61a // log(1/frcpa(1+116/256))=  +3.75404e-001
+data8 0x3fd82996d3ef8bc8, 0x3ca5aab9f5928928 // log(1/frcpa(1+117/256))=  +3.77538e-001
+data8 0x3fd85855776dcbf8, 0x3ca56f33337789d6 // log(1/frcpa(1+118/256))=  +3.80391e-001
+data8 0x3fd8873658327cc8, 0x3cbb8ef0401db49d // log(1/frcpa(1+119/256))=  +3.83253e-001
+data8 0x3fd8aa75973ab8c8, 0x3cbb9961f509a680 // log(1/frcpa(1+120/256))=  +3.85404e-001
+data8 0x3fd8d992dc8824e0, 0x3cb220512a53732d // log(1/frcpa(1+121/256))=  +3.88280e-001
+data8 0x3fd908d2ea7d9510, 0x3c985f0e513bfb5c // log(1/frcpa(1+122/256))=  +3.91164e-001
+data8 0x3fd92c59e79c0e50, 0x3cb82e073fd30d63 // log(1/frcpa(1+123/256))=  +3.93332e-001
+data8 0x3fd95bd750ee3ed0, 0x3ca4aa7cdb6dd8a8 // log(1/frcpa(1+124/256))=  +3.96231e-001
+data8 0x3fd98b7811a3ee58, 0x3caa93a5b660893e // log(1/frcpa(1+125/256))=  +3.99138e-001
+data8 0x3fd9af47f33d4068, 0x3cac294b3b3190ba // log(1/frcpa(1+126/256))=  +4.01323e-001
+data8 0x3fd9df270c1914a0, 0x3cbe1a58fd0cd67e // log(1/frcpa(1+127/256))=  +4.04245e-001
+data8 0x3fda0325ed14fda0, 0x3cb1efa7950fb57e // log(1/frcpa(1+128/256))=  +4.06442e-001
+data8 0x3fda33440224fa78, 0x3c8915fe75e7d477 // log(1/frcpa(1+129/256))=  +4.09379e-001
+data8 0x3fda57725e80c380, 0x3ca72bd1062b1b7f // log(1/frcpa(1+130/256))=  +4.11587e-001
+data8 0x3fda87d0165dd198, 0x3c91f7845f58dbad // log(1/frcpa(1+131/256))=  +4.14539e-001
+data8 0x3fdaac2e6c03f890, 0x3cb6f237a911c509 // log(1/frcpa(1+132/256))=  +4.16759e-001
+data8 0x3fdadccc6fdf6a80, 0x3c90ddc4b7687169 // log(1/frcpa(1+133/256))=  +4.19726e-001
+data8 0x3fdb015b3eb1e790, 0x3c692dd7d90e1e8e // log(1/frcpa(1+134/256))=  +4.21958e-001
+data8 0x3fdb323a3a635948, 0x3c6f85655cbe14de // log(1/frcpa(1+135/256))=  +4.24941e-001
+data8 0x3fdb56fa04462908, 0x3c95252d841994de // log(1/frcpa(1+136/256))=  +4.27184e-001
+data8 0x3fdb881aa659bc90, 0x3caa53a745a3642f // log(1/frcpa(1+137/256))=  +4.30182e-001
+data8 0x3fdbad0bef3db160, 0x3cb32f2540dcc16a // log(1/frcpa(1+138/256))=  +4.32437e-001
+data8 0x3fdbd21297781c28, 0x3cbd8e891e106f1d // log(1/frcpa(1+139/256))=  +4.34697e-001
+data8 0x3fdc039236f08818, 0x3c809435af522ba7 // log(1/frcpa(1+140/256))=  +4.37718e-001
+data8 0x3fdc28cb1e4d32f8, 0x3cb3944752fbd81e // log(1/frcpa(1+141/256))=  +4.39990e-001
+data8 0x3fdc4e19b84723c0, 0x3c9a465260cd3fe5 // log(1/frcpa(1+142/256))=  +4.42267e-001
+data8 0x3fdc7ff9c74554c8, 0x3c92447d5b6ca369 // log(1/frcpa(1+143/256))=  +4.45311e-001
+data8 0x3fdca57b64e9db00, 0x3cb44344a8a00c82 // log(1/frcpa(1+144/256))=  +4.47600e-001
+data8 0x3fdccb130a5ceba8, 0x3cbefaddfb97b73f // log(1/frcpa(1+145/256))=  +4.49895e-001
+data8 0x3fdcf0c0d18f3268, 0x3cbd3e7bfee57898 // log(1/frcpa(1+146/256))=  +4.52194e-001
+data8 0x3fdd232075b5a200, 0x3c9222599987447c // log(1/frcpa(1+147/256))=  +4.55269e-001
+data8 0x3fdd490246defa68, 0x3cabafe9a767a80d // log(1/frcpa(1+148/256))=  +4.57581e-001
+data8 0x3fdd6efa918d25c8, 0x3cb58a2624e1c6fd // log(1/frcpa(1+149/256))=  +4.59899e-001
+data8 0x3fdd9509707ae528, 0x3cbdc3babce578e7 // log(1/frcpa(1+150/256))=  +4.62221e-001
+data8 0x3fddbb2efe92c550, 0x3cb0ac0943c434a4 // log(1/frcpa(1+151/256))=  +4.64550e-001
+data8 0x3fddee2f3445e4a8, 0x3cbba9d07ce820e8 // log(1/frcpa(1+152/256))=  +4.67663e-001
+data8 0x3fde148a1a2726c8, 0x3cb6537e3375b205 // log(1/frcpa(1+153/256))=  +4.70004e-001
+data8 0x3fde3afc0a49ff38, 0x3cbfed5518dbc20e // log(1/frcpa(1+154/256))=  +4.72350e-001
+data8 0x3fde6185206d5168, 0x3cb6572601f73d5c // log(1/frcpa(1+155/256))=  +4.74702e-001
+data8 0x3fde882578823d50, 0x3c9b24abd4584d1a // log(1/frcpa(1+156/256))=  +4.77060e-001
+data8 0x3fdeaedd2eac9908, 0x3cb0ceb5e4d2c8f7 // log(1/frcpa(1+157/256))=  +4.79423e-001
+data8 0x3fded5ac5f436be0, 0x3ca72f21f1f5238e // log(1/frcpa(1+158/256))=  +4.81792e-001
+data8 0x3fdefc9326d16ab8, 0x3c85081a1639a45c // log(1/frcpa(1+159/256))=  +4.84166e-001
+data8 0x3fdf2391a21575f8, 0x3cbf11015bdd297a // log(1/frcpa(1+160/256))=  +4.86546e-001
+data8 0x3fdf4aa7ee031928, 0x3cb3795bc052a2d1 // log(1/frcpa(1+161/256))=  +4.88932e-001
+data8 0x3fdf71d627c30bb0, 0x3c35c61f0f5a88f3 // log(1/frcpa(1+162/256))=  +4.91323e-001
+data8 0x3fdf991c6cb3b378, 0x3c97d99419be6028 // log(1/frcpa(1+163/256))=  +4.93720e-001
+data8 0x3fdfc07ada69a908, 0x3cbfe9341ded70b1 // log(1/frcpa(1+164/256))=  +4.96123e-001
+data8 0x3fdfe7f18eb03d38, 0x3cb85718a640c33f // log(1/frcpa(1+165/256))=  +4.98532e-001
+data8 0x3fe007c053c5002c, 0x3cb3addc9c065f09 // log(1/frcpa(1+166/256))=  +5.00946e-001
+data8 0x3fe01b942198a5a0, 0x3c9d5aa4c77da6ac // log(1/frcpa(1+167/256))=  +5.03367e-001
+data8 0x3fe02f74400c64e8, 0x3cb5a0ee4450ef52 // log(1/frcpa(1+168/256))=  +5.05793e-001
+data8 0x3fe04360be7603ac, 0x3c9dd00c35630fe0 // log(1/frcpa(1+169/256))=  +5.08225e-001
+data8 0x3fe05759ac47fe30, 0x3cbd063e1f0bd82c // log(1/frcpa(1+170/256))=  +5.10663e-001
+data8 0x3fe06b5f1911cf50, 0x3cae8da674af5289 // log(1/frcpa(1+171/256))=  +5.13107e-001
+data8 0x3fe078bf0533c568, 0x3c62241edf5fd1f7 // log(1/frcpa(1+172/256))=  +5.14740e-001
+data8 0x3fe08cd9687e7b0c, 0x3cb3007febcca227 // log(1/frcpa(1+173/256))=  +5.17194e-001
+data8 0x3fe0a10074cf9018, 0x3ca496e84603816b // log(1/frcpa(1+174/256))=  +5.19654e-001
+data8 0x3fe0b5343a234474, 0x3cb46098d14fc90a // log(1/frcpa(1+175/256))=  +5.22120e-001
+data8 0x3fe0c974c89431cc, 0x3cac0a7cdcbb86c6 // log(1/frcpa(1+176/256))=  +5.24592e-001
+data8 0x3fe0ddc2305b9884, 0x3cb2f753210410ff // log(1/frcpa(1+177/256))=  +5.27070e-001
+data8 0x3fe0eb524bafc918, 0x3c88affd6682229e // log(1/frcpa(1+178/256))=  +5.28726e-001
+data8 0x3fe0ffb54213a474, 0x3cadeefbab9af993 // log(1/frcpa(1+179/256))=  +5.31214e-001
+data8 0x3fe114253da97d9c, 0x3cbaf1c2b8bc160a // log(1/frcpa(1+180/256))=  +5.33709e-001
+data8 0x3fe128a24f1d9afc, 0x3cb9cf4df375e650 // log(1/frcpa(1+181/256))=  +5.36210e-001
+data8 0x3fe1365252bf0864, 0x3c985a621d4be111 // log(1/frcpa(1+182/256))=  +5.37881e-001
+data8 0x3fe14ae558b4a92c, 0x3ca104c4aa8977d1 // log(1/frcpa(1+183/256))=  +5.40393e-001
+data8 0x3fe15f85a19c7658, 0x3cbadf26e540f375 // log(1/frcpa(1+184/256))=  +5.42910e-001
+data8 0x3fe16d4d38c119f8, 0x3cb3aea11caec416 // log(1/frcpa(1+185/256))=  +5.44592e-001
+data8 0x3fe18203c20dd130, 0x3cba82d1211d1d6d // log(1/frcpa(1+186/256))=  +5.47121e-001
+data8 0x3fe196c7bc4b1f38, 0x3cb6267acc4f4f4a // log(1/frcpa(1+187/256))=  +5.49656e-001
+data8 0x3fe1a4a738b7a33c, 0x3c858930213c987d // log(1/frcpa(1+188/256))=  +5.51349e-001
+data8 0x3fe1b981c0c9653c, 0x3c9bc2a4a30f697b // log(1/frcpa(1+189/256))=  +5.53895e-001
+data8 0x3fe1ce69e8bb1068, 0x3cb7ae6199cf2a00 // log(1/frcpa(1+190/256))=  +5.56447e-001
+data8 0x3fe1dc619de06944, 0x3c6b50bb38388177 // log(1/frcpa(1+191/256))=  +5.58152e-001
+data8 0x3fe1f160a2ad0da0, 0x3cbd05b2778a5e1d // log(1/frcpa(1+192/256))=  +5.60715e-001
+data8 0x3fe2066d7740737c, 0x3cb32e828f9c6bd6 // log(1/frcpa(1+193/256))=  +5.63285e-001
+data8 0x3fe2147dba47a390, 0x3cbd579851b8b672 // log(1/frcpa(1+194/256))=  +5.65001e-001
+data8 0x3fe229a1bc5ebac0, 0x3cbb321be5237ce8 // log(1/frcpa(1+195/256))=  +5.67582e-001
+data8 0x3fe237c1841a502c, 0x3cb3b56e0915ea64 // log(1/frcpa(1+196/256))=  +5.69306e-001
+data8 0x3fe24cfce6f80d98, 0x3cb34a4d1a422919 // log(1/frcpa(1+197/256))=  +5.71898e-001
+data8 0x3fe25b2c55cd5760, 0x3cb237401ea5015e // log(1/frcpa(1+198/256))=  +5.73630e-001
+data8 0x3fe2707f4d5f7c40, 0x3c9d30f20acc8341 // log(1/frcpa(1+199/256))=  +5.76233e-001
+data8 0x3fe285e0842ca380, 0x3cbc4d866d5f21c0 // log(1/frcpa(1+200/256))=  +5.78842e-001
+data8 0x3fe294294708b770, 0x3cb85e14d5dc54fa // log(1/frcpa(1+201/256))=  +5.80586e-001
+data8 0x3fe2a9a2670aff0c, 0x3c7e6f8f468bbf91 // log(1/frcpa(1+202/256))=  +5.83207e-001
+data8 0x3fe2b7fb2c8d1cc0, 0x3c930ffcf63c8b65 // log(1/frcpa(1+203/256))=  +5.84959e-001
+data8 0x3fe2c65a6395f5f4, 0x3ca0afe20b53d2d2 // log(1/frcpa(1+204/256))=  +5.86713e-001
+data8 0x3fe2dbf557b0df40, 0x3cb646be1188fbc9 // log(1/frcpa(1+205/256))=  +5.89350e-001
+data8 0x3fe2ea64c3f97654, 0x3c96516fa8df33b2 // log(1/frcpa(1+206/256))=  +5.91113e-001
+data8 0x3fe3001823684d70, 0x3cb96d64e16d1360 // log(1/frcpa(1+207/256))=  +5.93762e-001
+data8 0x3fe30e97e9a8b5cc, 0x3c98ef96bc97cca0 // log(1/frcpa(1+208/256))=  +5.95531e-001
+data8 0x3fe32463ebdd34e8, 0x3caef1dc9a56c1bf // log(1/frcpa(1+209/256))=  +5.98192e-001
+data8 0x3fe332f4314ad794, 0x3caa4f0ac5d5fa11 // log(1/frcpa(1+210/256))=  +5.99970e-001
+data8 0x3fe348d90e7464cc, 0x3cbe7889f0516acd // log(1/frcpa(1+211/256))=  +6.02643e-001
+data8 0x3fe35779f8c43d6c, 0x3ca96bbab7245411 // log(1/frcpa(1+212/256))=  +6.04428e-001
+data8 0x3fe36621961a6a98, 0x3ca31f32262db9fb // log(1/frcpa(1+213/256))=  +6.06217e-001
+data8 0x3fe37c299f3c3668, 0x3cb15c72c107ee29 // log(1/frcpa(1+214/256))=  +6.08907e-001
+data8 0x3fe38ae2171976e4, 0x3cba42a2554b2dd4 // log(1/frcpa(1+215/256))=  +6.10704e-001
+data8 0x3fe399a157a603e4, 0x3cb99c62286d8919 // log(1/frcpa(1+216/256))=  +6.12504e-001
+data8 0x3fe3afccfe77b9d0, 0x3ca11048f96a43bd // log(1/frcpa(1+217/256))=  +6.15210e-001
+data8 0x3fe3be9d503533b4, 0x3ca4022f47588c3e // log(1/frcpa(1+218/256))=  +6.17018e-001
+data8 0x3fe3cd7480b4a8a0, 0x3cb4ba7afc2dc56a // log(1/frcpa(1+219/256))=  +6.18830e-001
+data8 0x3fe3e3c43918f76c, 0x3c859673d064b8ba // log(1/frcpa(1+220/256))=  +6.21554e-001
+data8 0x3fe3f2acb27ed6c4, 0x3cb55c6b452a16a8 // log(1/frcpa(1+221/256))=  +6.23373e-001
+data8 0x3fe4019c2125ca90, 0x3cb8c367879c5a31 // log(1/frcpa(1+222/256))=  +6.25197e-001
+data8 0x3fe4181061389720, 0x3cb2c17a79c5cc6c // log(1/frcpa(1+223/256))=  +6.27937e-001
+data8 0x3fe42711518df544, 0x3ca5f38d47012fc5 // log(1/frcpa(1+224/256))=  +6.29769e-001
+data8 0x3fe436194e12b6bc, 0x3cb9854d65a9b426 // log(1/frcpa(1+225/256))=  +6.31604e-001
+data8 0x3fe445285d68ea68, 0x3ca3ff9b3a81cd81 // log(1/frcpa(1+226/256))=  +6.33442e-001
+data8 0x3fe45bcc464c8938, 0x3cb0a2d8011a6c05 // log(1/frcpa(1+227/256))=  +6.36206e-001
+data8 0x3fe46aed21f117fc, 0x3c8a2be41f8e9f3d // log(1/frcpa(1+228/256))=  +6.38053e-001
+data8 0x3fe47a1527e8a2d0, 0x3cba4a83594fab09 // log(1/frcpa(1+229/256))=  +6.39903e-001
+data8 0x3fe489445efffcc8, 0x3cbf306a23dcbcde // log(1/frcpa(1+230/256))=  +6.41756e-001
+data8 0x3fe4a018bcb69834, 0x3ca46c9285029fd1 // log(1/frcpa(1+231/256))=  +6.44543e-001
+data8 0x3fe4af5a0c9d65d4, 0x3cbbc1db897580e3 // log(1/frcpa(1+232/256))=  +6.46405e-001
+data8 0x3fe4bea2a5bdbe84, 0x3cb84d880d7ef775 // log(1/frcpa(1+233/256))=  +6.48271e-001
+data8 0x3fe4cdf28f10ac44, 0x3cb3ec4b7893ce1f // log(1/frcpa(1+234/256))=  +6.50140e-001
+data8 0x3fe4dd49cf994058, 0x3c897224d59d3408 // log(1/frcpa(1+235/256))=  +6.52013e-001
+data8 0x3fe4eca86e64a680, 0x3cbccf620f24f0cd // log(1/frcpa(1+236/256))=  +6.53889e-001
+data8 0x3fe503c43cd8eb68, 0x3c3f872c65971084 // log(1/frcpa(1+237/256))=  +6.56710e-001
+data8 0x3fe513356667fc54, 0x3cb9ca64cc3d52c8 // log(1/frcpa(1+238/256))=  +6.58595e-001
+data8 0x3fe522ae0738a3d4, 0x3cbe708164c75968 // log(1/frcpa(1+239/256))=  +6.60483e-001
+data8 0x3fe5322e26867854, 0x3cb9988ba4aea615 // log(1/frcpa(1+240/256))=  +6.62376e-001
+data8 0x3fe541b5cb979808, 0x3ca1662e3a6b95f5 // log(1/frcpa(1+241/256))=  +6.64271e-001
+data8 0x3fe55144fdbcbd60, 0x3cb3acd4ca45c1e0 // log(1/frcpa(1+242/256))=  +6.66171e-001
+data8 0x3fe560dbc45153c4, 0x3cb4988947959fed // log(1/frcpa(1+243/256))=  +6.68074e-001
+data8 0x3fe5707a26bb8c64, 0x3cb3017fe6607ba9 // log(1/frcpa(1+244/256))=  +6.69980e-001
+data8 0x3fe587f60ed5b8fc, 0x3cbe7a3266366ed4 // log(1/frcpa(1+245/256))=  +6.72847e-001
+data8 0x3fe597a7977c8f30, 0x3ca1e12b9959a90e // log(1/frcpa(1+246/256))=  +6.74763e-001
+data8 0x3fe5a760d634bb88, 0x3cb7c365e53d9602 // log(1/frcpa(1+247/256))=  +6.76682e-001
+data8 0x3fe5b721d295f10c, 0x3cb716c2551ccbf0 // log(1/frcpa(1+248/256))=  +6.78605e-001
+data8 0x3fe5c6ea94431ef8, 0x3ca02b2ed0e28261 // log(1/frcpa(1+249/256))=  +6.80532e-001
+data8 0x3fe5d6bb22ea86f4, 0x3caf43a8bbb2f974 // log(1/frcpa(1+250/256))=  +6.82462e-001
+data8 0x3fe5e6938645d38c, 0x3cbcedc98821b333 // log(1/frcpa(1+251/256))=  +6.84397e-001
+data8 0x3fe5f673c61a2ed0, 0x3caa385eef5f2789 // log(1/frcpa(1+252/256))=  +6.86335e-001
+data8 0x3fe6065bea385924, 0x3cb11624f165c5b4 // log(1/frcpa(1+253/256))=  +6.88276e-001
+data8 0x3fe6164bfa7cc068, 0x3cbad884f87073fa // log(1/frcpa(1+254/256))=  +6.90222e-001
+data8 0x3fe62643fecf9740, 0x3cb78c51da12f4df // log(1/frcpa(1+255/256))=  +6.92171e-001
+LOCAL_OBJECT_END(pow_Tt)
+
+
+// Table 1 is 2^(index_1/128) where
+// index_1 goes from 0 to 15
+LOCAL_OBJECT_START(pow_tbl1)
+data8 0x8000000000000000 , 0x00003FFF
+data8 0x80B1ED4FD999AB6C , 0x00003FFF
+data8 0x8164D1F3BC030773 , 0x00003FFF
+data8 0x8218AF4373FC25EC , 0x00003FFF
+data8 0x82CD8698AC2BA1D7 , 0x00003FFF
+data8 0x8383594EEFB6EE37 , 0x00003FFF
+data8 0x843A28C3ACDE4046 , 0x00003FFF
+data8 0x84F1F656379C1A29 , 0x00003FFF
+data8 0x85AAC367CC487B15 , 0x00003FFF
+data8 0x8664915B923FBA04 , 0x00003FFF
+data8 0x871F61969E8D1010 , 0x00003FFF
+data8 0x87DB357FF698D792 , 0x00003FFF
+data8 0x88980E8092DA8527 , 0x00003FFF
+data8 0x8955EE03618E5FDD , 0x00003FFF
+data8 0x8A14D575496EFD9A , 0x00003FFF
+data8 0x8AD4C6452C728924 , 0x00003FFF
+LOCAL_OBJECT_END(pow_tbl1)
+
+
+// Table 2 is 2^(index_1/8) where
+// index_2 goes from 0 to 7
+LOCAL_OBJECT_START(pow_tbl2)
+data8 0x8000000000000000 , 0x00003FFF
+data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
+data8 0x9837F0518DB8A96F , 0x00003FFF
+data8 0xA5FED6A9B15138EA , 0x00003FFF
+data8 0xB504F333F9DE6484 , 0x00003FFF
+data8 0xC5672A115506DADD , 0x00003FFF
+data8 0xD744FCCAD69D6AF4 , 0x00003FFF
+data8 0xEAC0C6E7DD24392F , 0x00003FFF
+LOCAL_OBJECT_END(pow_tbl2)
+
+.section .text
+WEAK_LIBM_ENTRY(pow)
+
+// Get exponent of x.  Will be used to calculate K.
+{ .mfi
+          getf.exp     pow_GR_signexp_X = f8
+          fms.s1 POW_Xm1 = f8,f1,f1     // Will be used for r1 if x>0
+          mov           pow_GR_17ones   = 0x1FFFF
+}
+{ .mfi
+          addl          pow_AD_P        = @ltoff(pow_table_P), gp
+          fma.s1 POW_Xp1 = f8,f1,f1     // Will be used for r1 if x<0
+          nop.i 999
+;;
+}
+
+// Get significand of x.  Will be used to get index to fetch T, Tt.
+{ .mfi
+          getf.sig      pow_GR_sig_X    = f8
+          frcpa.s1      POW_B, p6       = f1,f8
+          nop.i 999
+}
+{ .mfi
+          ld8 pow_AD_P = [pow_AD_P]
+          fma.s1        POW_NORM_X      = f8,f1,f0
+          mov          pow_GR_exp_2tom8 = 0xFFF7
+}
+;;
+
+// p13 = TRUE ==> X is unorm
+// DOUBLE 0x10033  exponent limit at which y is an integer
+{ .mfi
+          nop.m 999
+          fclass.m  p13,p0              = f8, 0x0b  // Test for x unorm
+          addl pow_GR_10033             = 0x10033, r0
+}
+{ .mfi
+          mov           pow_GR_16ones   = 0xFFFF
+          fma.s1        POW_NORM_Y      = f9,f1,f0
+          nop.i 999
+}
+;;
+
+// p14 = TRUE ==> X is ZERO
+{ .mfi
+          adds          pow_AD_Tt       = pow_Tt - pow_table_P,  pow_AD_P
+          fclass.m  p14,p0              = f8, 0x07
+          and           pow_GR_exp_X    = pow_GR_signexp_X, pow_GR_17ones
+}
+{ .mfi
+          adds          pow_AD_Q        = pow_table_Q - pow_table_P,  pow_AD_P
+          nop.f 999
+          nop.i 999
+}
+;;
+
+{ .mfi
+          ldfe          POW_P5          = [pow_AD_P], 16
+          fcmp.lt.s1 p8,p9 = f8, f0     // Test for x<0
+          nop.i 999
+}
+{ .mib
+          ldfe          POW_P4          = [pow_AD_Q], 16
+          sub       pow_GR_true_exp_X   = pow_GR_exp_X, pow_GR_16ones
+(p13)     br.cond.spnt POW_X_DENORM
+}
+;;
+
+// Continue normal and denormal paths here
+POW_COMMON:
+// p11 = TRUE ==> Y is a NAN
+{ .mfi
+          ldfe          POW_P3          = [pow_AD_P], 16
+          fclass.m  p11,p0              = f9, 0xc3
+          nop.i 999
+}
+{ .mfi
+          ldfe          POW_P2          = [pow_AD_Q], 16
+          nop.f 999
+          mov pow_GR_y_zero = 0
+}
+;;
+
+// Note POW_Xm1 and POW_r1 are used interchangeably
+{ .mfi
+          alloc         r32=ar.pfs,2,19,4,0
+          fms.s1        POW_r           = POW_B, POW_NORM_X,f1
+          nop.i 999
+}
+{ .mfi
+          setf.sig POW_int_K            = pow_GR_true_exp_X
+(p8)      fnma.s1        POW_Xm1        = POW_Xp1,f1,f0
+          nop.i 999
+}
+;;
+
+// p12 = TRUE if Y is ZERO
+// Compute xsq to decide later if |x|=1
+{ .mfi
+          ldfe          POW_P1          = [pow_AD_P], 16
+          fclass.m      p12,p0          = f9, 0x07
+          shl           pow_GR_offset   = pow_GR_sig_X, 1
+}
+{ .mfb
+          ldfe          POW_P0          = [pow_AD_Q], 16
+          fma.s1        POW_xsq = POW_NORM_X, POW_NORM_X, f0
+(p11)     br.cond.spnt  POW_Y_NAN       // Branch if y=nan
+}
+;;
+
+// Get exponent of |x|-1 to use in comparison to 2^-8
+{ .mfi
+          getf.exp  pow_GR_signexp_Xm1  = POW_Xm1
+          fcvt.fx.s1   POW_int_Y        = POW_NORM_Y
+          shr.u     pow_GR_offset       = pow_GR_offset,56
+}
+;;
+
+// p11 = TRUE ==> X is a NAN
+{ .mfi
+          ldfpd         POW_log2_hi, POW_log2_lo  = [pow_AD_Q], 16
+          fclass.m      p11,p0          = f8, 0xc3
+          shladd pow_AD_Tt = pow_GR_offset, 4, pow_AD_Tt
+}
+{ .mfi
+          ldfe          POW_inv_log2_by_128 = [pow_AD_P], 16
+          fma.s1 POW_delta              = f0,f0,f0 // delta=0 in case |x| near 1
+(p12)     mov pow_GR_y_zero = 1
+}
+;;
+
+{ .mfi
+          ldfpd  POW_Q2, POW_Q3         = [pow_AD_P], 16
+          fma.s1 POW_G                  = f0,f0,f0  // G=0 in case |x| near 1
+          and       pow_GR_exp_Xm1      = pow_GR_signexp_Xm1, pow_GR_17ones
+}
+;;
+
+// Determine if we will use the |x| near 1 path (p6) or normal path (p7)
+{ .mfi
+          getf.exp  pow_GR_signexp_Y    = POW_NORM_Y
+          nop.f 999
+          cmp.lt p6,p7                  = pow_GR_exp_Xm1, pow_GR_exp_2tom8
+}
+{ .mfb
+          ldfpd  POW_T, POW_Tt          = [pow_AD_Tt], 16
+          fma.s1        POW_rsq         = POW_r, POW_r,f0
+(p11)     br.cond.spnt  POW_X_NAN       // Branch if x=nan and y not nan
+}
+;;
+
+// If on the x near 1 path, assign r1 to r and r1*r1 to rsq
+{ .mfi
+          ldfpd  POW_Q0_half, POW_Q1    = [pow_AD_P], 16
+(p6)      fma.s1    POW_r               = POW_r1, f1, f0
+          nop.i 999
+}
+{ .mfb
+          nop.m 999
+(p6)      fma.s1    POW_rsq             = POW_r1, POW_r1, f0
+(p14)     br.cond.spnt POW_X_0          // Branch if x zero and y not nan
+}
+;;
+
+{ .mfi
+          ldfpd   POW_Q4, POW_RSHF      = [pow_AD_P], 16
+(p7)      fma.s1 POW_v6                 = POW_r,  POW_P5, POW_P4
+          nop.i 999
+}
+{ .mfi
+          mov pow_GR_exp_2toM63         = 0xffc0  // Exponent of 2^-63
+(p6)      fma.s1 POW_v6                 = POW_r1, POW_P5, POW_P4
+          nop.i 999
+}
+;;
+
+{ .mfi
+          setf.exp POW_2toM63 = pow_GR_exp_2toM63  // Form 2^-63 for test of q
+(p7)      fma.s1 POW_v4                 = POW_P3, POW_r,  POW_P2
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+(p6)      fma.s1 POW_v4                 = POW_P3, POW_r1, POW_P2
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fcvt.xf POW_K                 = POW_int_K
+          nop.i 999
+}
+;;
+
+{ .mfi
+          getf.sig pow_GR_sig_int_Y     = POW_int_Y
+          fnma.s1 POW_twoV              = POW_NORM_Y, POW_rsq,f0
+          and pow_GR_exp_Y              = pow_GR_signexp_Y, pow_GR_17ones
+}
+{ .mfb
+          andcm pow_GR_sign_Y           = pow_GR_signexp_Y, pow_GR_17ones
+          fma.s1 POW_U                  = POW_NORM_Y,POW_r,f0
+(p12)     br.cond.spnt POW_Y_0   // Branch if y=zero, x not zero or nan
+}
+;;
+
+// p11 = TRUE ==> X is NEGATIVE but not inf
+{ .mfi
+          ldfe      POW_log2_by_128_lo  = [pow_AD_P], 16
+          fclass.m  p11,p0              = f8, 0x1a
+          nop.i 999
+}
+{ .mfi
+          ldfe      POW_log2_by_128_hi  = [pow_AD_Q], 16
+          fma.s1 POW_v2                 = POW_P1, POW_r,  POW_P0
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fcvt.xf   POW_float_int_Y     = POW_int_Y
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_v3                 = POW_v6, POW_rsq,  POW_v4
+          adds          pow_AD_tbl1     = pow_tbl1 - pow_Tt,  pow_AD_Q
+}
+;;
+
+{ .mfi
+          nop.m 999
+(p7)      fma.s1 POW_delta              = POW_K, POW_log2_lo, POW_Tt
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+(p7)      fma.s1 POW_G                  = POW_K, POW_log2_hi, POW_T
+          adds pow_AD_tbl2              = pow_tbl2 - pow_tbl1,  pow_AD_tbl1
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fms.s1 POW_e2                 = POW_NORM_Y, POW_r, POW_U
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_Z2                 = POW_twoV, POW_Q0_half, POW_U
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_Yrcub              = POW_rsq, POW_U, f0
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_p                  = POW_rsq, POW_v3, POW_v2
+          nop.i 999
+}
+;;
+
+// p11 = TRUE ==> X is NEGATIVE but not inf
+//    p12 = TRUE ==> X is NEGATIVE  AND  Y  already even int
+//    p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
+{ .mfi
+          nop.m 999
+          fma.s1 POW_Z1                 = POW_NORM_Y, POW_G, f0
+(p11)     cmp.gt.unc  p12,p13           = pow_GR_exp_Y, pow_GR_10033
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_Gpr                = POW_G, f1, POW_r
+          nop.i 999
+}
+;;
+
+// By adding RSHF (1.1000...*2^63) we put integer part in rightmost significand
+{ .mfi
+          nop.m 999
+          fma.s1 POW_W2  = POW_Z2, POW_inv_log2_by_128, POW_RSHF
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fms.s1 POW_UmZ2               = POW_U, f1, POW_Z2
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_e3                 = POW_NORM_Y, POW_delta, f0
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_Z3                 = POW_p, POW_Yrcub, f0
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_GY_Z2              = POW_G, POW_NORM_Y, POW_Z2
+          nop.i 999
+}
+;;
+
+// By adding RSHF (1.1000...*2^63) we put integer part in rightmost significand
+{ .mfi
+          nop.m 999
+          fms.s1 POW_e1                 = POW_NORM_Y, POW_G, POW_Z1
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_W1  = POW_Z1, POW_inv_log2_by_128, POW_RSHF
+          nop.i 999
+}
+;;
+
+// p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
+//     p10 = TRUE ==> X is NEG and Y is an int
+//     p12 = TRUE ==> X is NEG and Y is not an int
+{ .mfi
+          nop.m 999
+(p13)     fcmp.eq.unc.s1 p10,p12        = POW_float_int_Y,  POW_NORM_Y
+          mov pow_GR_xneg_yodd = 0
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_Y_Gpr              = POW_NORM_Y, POW_Gpr, f0
+          nop.i 999
+}
+;;
+
+// By subtracting RSHF we get rounded integer POW_N2float
+{ .mfi
+          nop.m 999
+          fms.s1 POW_N2float  = POW_W2, f1, POW_RSHF
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_UmZ2pV             = POW_twoV,POW_Q0_half,POW_UmZ2
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_Z3sq               = POW_Z3, POW_Z3, f0
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_v4                 = POW_Z3, POW_Q3, POW_Q2
+          nop.i 999
+}
+;;
+
+// Extract rounded integer from rightmost significand of POW_W2
+// By subtracting RSHF we get rounded integer POW_N1float
+{ .mfi
+          getf.sig pow_GR_int_W2        = POW_W2
+          fms.s1 POW_N1float  = POW_W1, f1, POW_RSHF
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_v2                 = POW_Z3, POW_Q1, POW_Q0_half
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fnma.s1 POW_s2 = POW_N2float, POW_log2_by_128_hi, POW_Z2
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_e2                 = POW_e2,f1,POW_UmZ2pV
+          nop.i 999
+}
+;;
+
+// Extract rounded integer from rightmost significand of POW_W1
+// Test if x inf
+{ .mfi
+          getf.sig pow_GR_int_W1        = POW_W1
+          fclass.m p15,p0 = POW_NORM_X,  0x23
+          nop.i 999
+}
+{ .mfb
+          nop.m 999
+          fnma.s1 POW_f2  = POW_N2float, POW_log2_by_128_lo, f1
+(p12)     br.cond.spnt POW_X_NEG_Y_NONINT  // Branch if x neg, y not integer
+}
+;;
+
+// p11 = TRUE ==> X is +1.0
+// p12 = TRUE ==> X is NEGATIVE  AND Y is an odd integer
+{ .mfi
+          getf.exp pow_GR_signexp_Y_Gpr = POW_Y_Gpr
+          fcmp.eq.s1 p11,p0 = POW_NORM_X, f1
+(p10)     tbit.nz.unc  p12,p0           = pow_GR_sig_int_Y,0
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_v3                 = POW_Z3sq, POW_Q4, POW_v4
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fnma.s1 POW_f1  = POW_N1float, POW_log2_by_128_lo, f1
+          nop.i 999
+}
+{ .mfb
+          nop.m 999
+          fnma.s1 POW_s1  = POW_N1float, POW_log2_by_128_hi, POW_Z1
+(p15)     br.cond.spnt POW_X_INF
+}
+;;
+
+// Test x and y and flag denormal
+{ .mfi
+          nop.m 999
+          fcmp.eq.s0 p15,p0 = f8,f9
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_pYrcub_e3          = POW_p, POW_Yrcub, POW_e3
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fcmp.eq.s1 p7,p0 = POW_NORM_Y, f1  // Test for y=1.0
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1  POW_e12               = POW_e1,f1,POW_e2
+          nop.i 999
+}
+;;
+
+{ .mfi
+          add pow_GR_int_N              = pow_GR_int_W1, pow_GR_int_W2
+(p11)     fma.d.s0 f8 = f1,f1,f0    // If x=1, result is +1
+          nop.i 999
+}
+{ .mib
+(p12)     mov pow_GR_xneg_yodd = 1
+          nop.i 999
+(p11)     br.ret.spnt b0            // Early exit if x=1.0, result is +1
+}
+;;
+
+{ .mfi
+          and pow_GR_index1             = 0x0f, pow_GR_int_N
+          fma.s1 POW_q                  = POW_Z3sq, POW_v3, POW_v2
+          shr pow_int_GR_M              = pow_GR_int_N, 7    // M = N/128
+}
+{ .mib
+          and pow_GR_index2             = 0x70, pow_GR_int_N
+          cmp.eq p6, p0                 = pow_GR_xneg_yodd, r0
+(p7)      br.ret.spnt b0        // Early exit if y=1.0, result is x
+}
+;;
+
+{ .mfi
+          shladd pow_AD_T1              = pow_GR_index1, 4, pow_AD_tbl1
+          fma.s1 POW_s                  = POW_s1, f1, POW_s2
+          add pow_int_GR_M              = pow_GR_16ones, pow_int_GR_M
+}
+{ .mfi
+          add pow_AD_T2                 = pow_AD_tbl2, pow_GR_index2
+          fma.s1 POW_f12                = POW_f1, POW_f2,f0
+          and pow_GR_exp_Y_Gpr          = pow_GR_signexp_Y_Gpr, pow_GR_17ones
+}
+;;
+
+{ .mmi
+          ldfe POW_T1                   = [pow_AD_T1]
+          ldfe POW_T2                   = [pow_AD_T2]
+          sub pow_GR_true_exp_Y_Gpr     = pow_GR_exp_Y_Gpr, pow_GR_16ones
+}
+;;
+
+{ .mfi
+          setf.exp POW_2M               = pow_int_GR_M
+          fma.s1 POW_e123               = POW_e12, f1, POW_e3
+          nop.i 999
+}
+{ .mfb
+(p6)      cmp.gt p6, p0                 = -11, pow_GR_true_exp_Y_Gpr
+          fma.s1 POW_d                  = POW_GY_Z2, f1, POW_pYrcub_e3
+(p6)      br.cond.spnt POW_NEAR_ONE // branch if |y*log(x)| < 2^(-11)
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_q                  = POW_Z3sq, POW_q, POW_Z3
+          nop.i 999
+}
+;;
+
+// p8 TRUE ==> |Y(G + r)| >= 10
+
+// double
+//     -2^10  -2^9             2^9   2^10
+// -----+-----+----+ ... +-----+-----+-----
+//  p8  |             p9             |  p8
+//      |     |       p10      |     |
+
+// Form signexp of constants to indicate overflow
+{ .mfi
+          mov         pow_GR_big_pos    = 0x103ff
+          fma.s1 POW_ssq                = POW_s, POW_s, f0
+          cmp.le p8,p9                  = 10, pow_GR_true_exp_Y_Gpr
+}
+{ .mfi
+          mov         pow_GR_big_neg    = 0x303ff
+          fma.s1 POW_v4                 = POW_s, POW_Q3, POW_Q2
+          andcm pow_GR_sign_Y_Gpr       = pow_GR_signexp_Y_Gpr, pow_GR_17ones
+}
+;;
+
+// Form big positive and negative constants to test for possible overflow
+{ .mfi
+          setf.exp POW_big_pos          = pow_GR_big_pos
+          fma.s1 POW_v2                 = POW_s, POW_Q1, POW_Q0_half
+(p9)      cmp.le.unc p0,p10             = 9, pow_GR_true_exp_Y_Gpr
+}
+{ .mfb
+          setf.exp POW_big_neg          = pow_GR_big_neg
+          fma.s1 POW_1ps                = f1,f1,POW_s
+(p8)      br.cond.spnt POW_OVER_UNDER_X_NOT_INF
+}
+;;
+
+// f123 = f12*(e123+1) = f12*e123+f12
+{ .mfi
+          nop.m 999
+          fma.s1 POW_f123               = POW_e123,POW_f12,POW_f12
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_T1T2               = POW_T1, POW_T2, f0
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_v3                 = POW_ssq, POW_Q4, POW_v4
+          cmp.ne p12,p13 = pow_GR_xneg_yodd, r0
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_v21ps              = POW_ssq, POW_v2, POW_1ps
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_s4                 = POW_ssq, POW_ssq, f0
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+(p12)     fnma.s1 POW_A                 =  POW_2M, POW_f123, f0
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+(p13)     fma.s1 POW_A                  =  POW_2M, POW_f123, f0
+          cmp.eq p14,p11 = r0,r0   // Initialize p14 on, p11 off
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fmerge.s POW_abs_q = f0, POW_q // Form |q| so can test its size
+          nop.i 999
+}
+;;
+
+{ .mfi
+(p10)     cmp.eq p0,p14 = r0,r0    // Turn off p14 if no overflow
+          fma.s1 POW_es                 = POW_s4,  POW_v3, POW_v21ps
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_A                  = POW_A, POW_T1T2, f0
+          nop.i 999
+}
+;;
+
+{ .mfi
+// Test for |q| < 2^-63.  If so then reverse last two steps of the result
+// to avoid monotonicity problems for results near 1.0 in round up/down/zero.
+// p11 will be set if need to reverse the order, p14 if not.
+          nop.m 999
+(p10)     fcmp.lt.s0 p11,p14 = POW_abs_q, POW_2toM63 // Test |q| <2^-63
+          nop.i 999
+}
+;;
+
+.pred.rel "mutex",p11,p14
+{ .mfi
+          nop.m 999
+(p14)     fma.s1 POW_A                  = POW_A, POW_es, f0
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+(p11)     fma.s1 POW_A                  = POW_A, POW_q, POW_A
+          nop.i 999
+}
+;;
+
+// Dummy op to set inexact if |q| < 2^-63
+{ .mfi
+          nop.m 999
+(p11)     fma.d.s0 POW_tmp              = POW_A, POW_q, POW_A
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+(p14)     fma.d.s0 f8                   = POW_A, POW_q, POW_A
+          nop.i 999
+}
+{ .mfb
+          nop.m 999
+(p11)     fma.d.s0 f8                   = POW_A, POW_es, f0
+(p10)     br.ret.sptk     b0            // Exit main branch if no over/underflow
+}
+;;
+
+// POSSIBLE_OVER_UNDER
+// p6 = TRUE ==> Y_Gpr negative
+// Result is already computed.  We just need to know if over/underflow occurred.
+
+{ .mfb
+        cmp.eq p0,p6                    = pow_GR_sign_Y_Gpr, r0
+        nop.f 999
+(p6)    br.cond.spnt POW_POSSIBLE_UNDER
+}
+;;
+
+// POSSIBLE_OVER
+// We got an answer.
+// overflow is a possibility, not a certainty
+
+
+// We define an overflow when the answer with
+//    WRE set
+//    user-defined rounding mode
+
+// double
+// Largest double is 7FE (biased double)
+//                   7FE - 3FF + FFFF = 103FE
+// Create + largest_double_plus_ulp
+// Create - largest_double_plus_ulp
+// Calculate answer with WRE set.
+
+// single
+// Largest single is FE (biased double)
+//                   FE - 7F + FFFF = 1007E
+// Create + largest_single_plus_ulp
+// Create - largest_single_plus_ulp
+// Calculate answer with WRE set.
+
+// Cases when answer is ldn+1  are as follows:
+//  ldn                   ldn+1
+// --+----------|----------+------------
+//              |
+//    +inf          +inf      -inf
+//                  RN         RN
+//                             RZ
+
+// Put in s2 (td set, wre set)
+{ .mfi
+        nop.m 999
+        fsetc.s2 0x7F,0x42
+        nop.i 999
+}
+;;
+
+{ .mfi
+        nop.m 999
+        fma.d.s2 POW_wre_urm_f8         = POW_A, POW_q, POW_A
+        nop.i 999
+}
+;;
+
+// Return s2 to default
+{ .mfi
+        nop.m 999
+        fsetc.s2 0x7F,0x40
+        nop.i 999
+}
+;;
+
+// p7 = TRUE ==> yes, we have an overflow
+{ .mfi
+        nop.m 999
+        fcmp.ge.s1 p7, p8               =  POW_wre_urm_f8, POW_big_pos
+        nop.i 999
+}
+;;
+
+{ .mfi
+        nop.m 999
+(p8)    fcmp.le.s1 p7, p0               =  POW_wre_urm_f8, POW_big_neg
+        nop.i 999
+}
+;;
+
+{ .mbb
+(p7)   mov pow_GR_tag                   = 24
+(p7)   br.cond.spnt __libm_error_region // Branch if overflow
+       br.ret.sptk     b0               // Exit if did not overflow
+}
+;;
+
+// Here if |y*log(x)| < 2^(-11)
+// pow(x,y) ~ exp(d) ~ 1 + d + 0.5*d^2 + Q1*d^3 + Q2*d^4, where d = y*log(x)
+.align 32
+POW_NEAR_ONE:
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_d2                 = POW_d, POW_d, f0
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_poly_d_hi          = POW_d, POW_Q0_half, f1
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_poly_d_lo          = POW_d, POW_Q2, POW_Q1
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_poly_d             = POW_d2, POW_poly_d_lo, POW_poly_d_hi
+          nop.i 999
+}
+;;
+
+{ .mfb
+          nop.m 999
+          fma.d.s0 f8                   = POW_d, POW_poly_d, f1
+          br.ret.sptk b0 // exit function for arguments |y*log(x)| < 2^(-11)
+}
+;;
+
+POW_POSSIBLE_UNDER:
+// We got an answer. input was < -2^9 but > -2^10 (double)
+// We got an answer. input was < -2^6 but > -2^7  (float)
+// underflow is a possibility, not a certainty
+
+// We define an underflow when the answer with
+//    ftz set
+// is zero (tiny numbers become zero)
+// Notice (from below) that if we have an unlimited exponent range,
+// then there is an extra machine number E between the largest denormal and
+// the smallest normal.
+// So if with unbounded exponent we round to E or below, then we are
+// tiny and underflow has occurred.
+// But notice that you can be in a situation where we are tiny, namely
+// rounded to E, but when the exponent is bounded we round to smallest
+// normal. So the answer can be the smallest normal with underflow.
+//                           E
+// -----+--------------------+--------------------+-----
+//      |                    |                    |
+//   1.1...10 2^-3fff    1.1...11 2^-3fff    1.0...00 2^-3ffe
+//   0.1...11 2^-3ffe                                   (biased, 1)
+//    largest dn                               smallest normal
+
+// Put in s2 (td set, ftz set)
+{ .mfi
+        nop.m 999
+        fsetc.s2 0x7F,0x41
+        nop.i 999
+}
+;;
+
+{ .mfi
+        nop.m 999
+        fma.d.s2 POW_ftz_urm_f8         = POW_A, POW_q, POW_A
+        nop.i 999
+}
+;;
+
+// Return s2 to default
+{ .mfi
+        nop.m 999
+        fsetc.s2 0x7F,0x40
+        nop.i 999
+}
+;;
+
+// p7 = TRUE ==> yes, we have an underflow
+{ .mfi
+        nop.m 999
+        fcmp.eq.s1 p7, p0               =  POW_ftz_urm_f8, f0
+        nop.i 999
+}
+;;
+
+{ .mbb
+(p7)    mov pow_GR_tag                  = 25
+(p7)    br.cond.spnt __libm_error_region // Branch if underflow
+        br.ret.sptk     b0               // Exit if did not underflow
+}
+;;
+
+POW_X_DENORM:
+// Here if x unorm. Use the NORM_X for getf instructions, and then back
+// to normal path
+{ .mfi
+        getf.exp      pow_GR_signexp_X  = POW_NORM_X
+        nop.f 999
+        nop.i 999
+}
+;;
+
+{ .mmi
+        getf.sig      pow_GR_sig_X      = POW_NORM_X
+;;
+        and           pow_GR_exp_X      = pow_GR_signexp_X, pow_GR_17ones
+        nop.i 999
+}
+;;
+
+{ .mib
+        sub       pow_GR_true_exp_X     = pow_GR_exp_X, pow_GR_16ones
+        nop.i 999
+        br.cond.sptk    POW_COMMON
+}
+;;
+
+POW_X_0:
+// Here if x=0 and y not nan
+//
+// We have the following cases:
+//  p6  x=0  and  y>0 and is an integer (may be even or odd)
+//  p7  x=0  and  y>0 and is NOT an integer, return +0
+//  p8  x=0  and  y>0 and so big as to always be an even integer, return +0
+//  p9  x=0  and  y>0 and may not be integer
+//  p10 x=0  and  y>0 and is an odd  integer, return x
+//  p11 x=0  and  y>0 and is an even integer, return +0
+//  p12 used in dummy fcmp to set denormal flag if y=unorm
+//  p13 x=0  and  y>0
+//  p14 x=0  and  y=0, branch to code for calling error handling
+//  p15 x=0  and  y<0, branch to code for calling error handling
+//
+{ .mfi
+        getf.sig pow_GR_sig_int_Y = POW_int_Y // Get signif of int_Y
+        fcmp.lt.s1 p15,p13 = f9, f0           // Test for y<0
+        and pow_GR_exp_Y = pow_GR_signexp_Y, pow_GR_17ones
+}
+{ .mfb
+        cmp.ne p14,p0 = pow_GR_y_zero,r0      // Test for y=0
+        fcvt.xf   POW_float_int_Y = POW_int_Y
+(p14)   br.cond.spnt POW_X_0_Y_0              // Branch if x=0 and y=0
+}
+;;
+
+// If x=0 and y>0, test y and flag denormal
+{ .mfb
+(p13)   cmp.gt.unc p8,p9 = pow_GR_exp_Y, pow_GR_10033 // Test y +big = even int
+(p13)   fcmp.eq.s0 p12,p0 = f9,f0    // If x=0, y>0 dummy op to flag denormal
+(p15)   br.cond.spnt POW_X_0_Y_NEG // Branch if x=0 and y<0
+}
+;;
+
+// Here if x=0 and y>0
+{ .mfi
+        nop.m 999
+(p9)    fcmp.eq.unc.s1 p6,p7 = POW_float_int_Y,  POW_NORM_Y // Test y=int
+        nop.i 999
+}
+{ .mfi
+        nop.m 999
+(p8)    fma.d.s0 f8 = f0,f0,f0 // If x=0, y>0 and large even int, return +0
+        nop.i 999
+}
+;;
+
+{ .mfi
+        nop.m 999
+(p7)    fma.d.s0 f8  = f0,f0,f0   // Result +0 if x=0 and y>0 and not integer
+(p6)    tbit.nz.unc p10,p11 = pow_GR_sig_int_Y,0 // If y>0 int, test y even/odd
+}
+;;
+
+// Note if x=0, y>0 and odd integer, just return x
+{ .mfb
+        nop.m 999
+(p11)   fma.d.s0 f8  = f0,f0,f0   // Result +0 if x=0 and y even integer
+        br.ret.sptk b0            // Exit if x=0 and y>0
+}
+;;
+
+POW_X_0_Y_0:
+// When X is +-0 and Y is +-0, IEEE returns 1.0
+// We call error support with this value
+
+{ .mfb
+        mov pow_GR_tag                  = 26
+        fma.d.s0 f8                     = f1,f1,f0
+        br.cond.sptk __libm_error_region
+}
+;;
+
+POW_X_0_Y_NEG:
+// When X is +-0 and Y is negative, IEEE returns
+// X     Y           answer
+// +0    -odd int    +inf
+// -0    -odd int    -inf
+
+// +0    !-odd int   +inf
+// -0    !-odd int   +inf
+
+// p6 == Y is a floating point number outside the integer.
+//       Hence it is an integer and is even.
+//       return +inf
+
+// p7 == Y is a floating point number within the integer range.
+//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
+//           p11 odd
+//              return (sign_of_x)inf
+//           p12 even
+//              return +inf
+//      p10 == Y is not an integer
+//         return +inf
+//
+
+{ .mfi
+          nop.m 999
+          nop.f 999
+          cmp.gt  p6,p7                 = pow_GR_exp_Y, pow_GR_10033
+}
+;;
+
+{ .mfi
+          mov pow_GR_tag                = 27
+(p7)      fcmp.eq.unc.s1 p9,p10         = POW_float_int_Y,  POW_NORM_Y
+          nop.i 999
+}
+;;
+
+{ .mfb
+          nop.m 999
+(p6)      frcpa.s0 f8,p13               = f1, f0
+(p6)      br.cond.sptk __libm_error_region   // x=0, y<0, y large neg int
+}
+;;
+
+{ .mfb
+          nop.m 999
+(p10)     frcpa.s0 f8,p13               = f1, f0
+(p10)     br.cond.sptk __libm_error_region   // x=0, y<0, y not int
+}
+;;
+
+// x=0, y<0, y an int
+{ .mib
+          nop.m 999
+(p9)      tbit.nz.unc p11,p12           = pow_GR_sig_int_Y,0
+          nop.b 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+(p12)     frcpa.s0 f8,p13               = f1,f0
+          nop.i 999
+}
+;;
+
+{ .mfb
+          nop.m 999
+(p11)     frcpa.s0 f8,p13               = f1,f8
+          br.cond.sptk __libm_error_region
+}
+;;
+
+
+POW_Y_0:
+// Here for y zero, x anything but zero and nan
+// Set flag if x denormal
+// Result is +1.0
+{ .mfi
+        nop.m 999
+        fcmp.eq.s0 p6,p0 = f8,f0    // Sets flag if x denormal
+        nop.i 999
+}
+{ .mfb
+        nop.m 999
+        fma.d.s0 f8 = f1,f1,f0
+        br.ret.sptk b0
+}
+;;
+
+
+POW_X_INF:
+// Here when X is +-inf
+
+// X +inf  Y +inf             +inf
+// X -inf  Y +inf             +inf
+
+// X +inf  Y >0               +inf
+// X -inf  Y >0, !odd integer +inf     <== (-inf)^0.5 = +inf !!
+// X -inf  Y >0,  odd integer -inf
+
+// X +inf  Y -inf             +0
+// X -inf  Y -inf             +0
+
+// X +inf  Y <0               +0
+// X -inf  Y <0, !odd integer +0
+// X -inf  Y <0, odd integer  -0
+
+// X + inf Y=+0                +1
+// X + inf Y=-0                +1
+// X - inf Y=+0                +1
+// X - inf Y=-0                +1
+
+// p13 == Y negative
+// p14 == Y positive
+
+// p6 == Y is a floating point number outside the integer.
+//       Hence it is an integer and is even.
+//       p13 == (Y negative)
+//          return +inf
+//       p14 == (Y positive)
+//          return +0
+
+// p7 == Y is a floating point number within the integer range.
+//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
+//           p11 odd
+//              p13 == (Y negative)
+//                 return (sign_of_x)inf
+//              p14 == (Y positive)
+//                 return (sign_of_x)0
+//           pxx even
+//              p13 == (Y negative)
+//                 return +inf
+//              p14 == (Y positive)
+//                 return +0
+
+//      pxx == Y is not an integer
+//           p13 == (Y negative)
+//                 return +inf
+//           p14 == (Y positive)
+//                 return +0
+//
+
+// If x=inf, test y and flag denormal
+{ .mfi
+          nop.m 999
+          fcmp.eq.s0 p10,p11 = f9,f0
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fcmp.lt.s0 p13,p14            = POW_NORM_Y,f0
+          cmp.gt  p6,p7                 = pow_GR_exp_Y, pow_GR_10033
+}
+{ .mfi
+          nop.m 999
+          fclass.m p12,p0               = f9, 0x23 //@inf
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fclass.m p15,p0               = f9, 0x07 //@zero
+          nop.i 999
+}
+;;
+
+{ .mfb
+          nop.m 999
+(p15)     fmerge.s f8 = f1,f1      // Return +1.0 if x=inf, y=0
+(p15)     br.ret.spnt b0           // Exit if x=inf, y=0
+}
+;;
+
+{ .mfi
+          nop.m 999
+(p14)     frcpa.s1 f8,p10 = f1,f0  // If x=inf, y>0, assume result +inf
+          nop.i 999
+}
+{ .mfb
+          nop.m 999
+(p13)     fma.d.s0 f8 = f0,f0,f0   // If x=inf, y<0, assume result +0.0
+(p12)     br.ret.spnt b0           // Exit if x=inf, y=inf
+}
+;;
+
+// Here if x=inf, and 0 < |y| < inf.  Need to correct results if y odd integer.
+{ .mfi
+          nop.m 999
+(p7)      fcmp.eq.unc.s1 p9,p0 = POW_float_int_Y,  POW_NORM_Y // Is y integer?
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          nop.f 999
+(p9)      tbit.nz.unc p11,p0 = pow_GR_sig_int_Y,0  // Test for y odd integer
+}
+;;
+
+{ .mfb
+          nop.m 999
+(p11)     fmerge.s f8 = POW_NORM_X,f8    // If y odd integer use sign of x
+          br.ret.sptk b0                 // Exit for x=inf, 0 < |y| < inf
+}
+;;
+
+
+POW_X_NEG_Y_NONINT:
+// When X is negative and Y is a non-integer, IEEE
+// returns a qnan indefinite.
+// We call error support with this value
+
+{ .mfb
+         mov pow_GR_tag                 = 28
+         frcpa.s0 f8,p6                 = f0,f0
+         br.cond.sptk __libm_error_region
+}
+;;
+
+POW_X_NAN:
+// Here if x=nan, y not nan
+{ .mfi
+         nop.m 999
+         fclass.m  p9,p13 = f9, 0x07 // Test y=zero
+         nop.i 999
+}
+;;
+
+{ .mfb
+         nop.m 999
+(p13)    fma.d.s0 f8 = f8,f1,f0
+(p13)    br.ret.sptk  b0            // Exit if x nan, y anything but zero or nan
+}
+;;
+
+POW_X_NAN_Y_0:
+// When X is a NAN and Y is zero, IEEE returns 1.
+// We call error support with this value.
+{ .mfi
+         nop.m 999
+         fcmp.eq.s0 p6,p0 = f8,f0       // Dummy op to set invalid on snan
+         nop.i 999
+}
+{ .mfb
+         mov pow_GR_tag                 = 29
+         fma.d.s0 f8 = f0,f0,f1
+         br.cond.sptk __libm_error_region
+}
+;;
+
+
+POW_OVER_UNDER_X_NOT_INF:
+
+// p8 is TRUE for overflow
+// p9 is TRUE for underflow
+
+// if y is infinity, we should not over/underflow
+
+{ .mfi
+          nop.m 999
+          fcmp.eq.s1     p14, p13       = POW_xsq,f1  // Test |x|=1
+          cmp.eq p8,p9                  = pow_GR_sign_Y_Gpr, r0
+}
+;;
+
+{ .mfi
+          nop.m 999
+(p14)     fclass.m.unc       p15, p0    = f9, 0x23 // If |x|=1, test y=inf
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+(p13)     fclass.m.unc       p11,p0     = f9, 0x23 // If |x| not 1, test y=inf
+          nop.i 999
+}
+;;
+
+// p15 = TRUE if |x|=1, y=inf, return +1
+{ .mfb
+          nop.m 999
+(p15)     fma.d.s0          f8          = f1,f1,f0 // If |x|=1, y=inf, result +1
+(p15)     br.ret.spnt b0                // Exit if |x|=1, y=inf
+}
+;;
+
+.pred.rel "mutex",p8,p9
+{  .mfb
+(p8)      setf.exp           f8 = pow_GR_17ones // If exp(+big), result inf
+(p9)      fmerge.s           f8 = f0,f0         // If exp(-big), result 0
+(p11)     br.ret.sptk b0                // Exit if |x| not 1, y=inf
+}
+;;
+
+{ .mfb
+          nop.m 999
+          nop.f 999
+          br.cond.sptk POW_OVER_UNDER_ERROR // Branch if y not inf
+}
+;;
+
+
+POW_Y_NAN:
+// Here if y=nan, x anything
+// If x = +1 then result is +1, else result is quiet Y
+{ .mfi
+       nop.m 999
+       fcmp.eq.s1         p10,p9        = POW_NORM_X, f1
+       nop.i 999
+}
+;;
+
+{ .mfi
+       nop.m 999
+(p10)  fcmp.eq.s0 p6,p0 = f9,f1   // Set invalid, even if x=+1
+       nop.i 999
+}
+;;
+
+{ .mfi
+       nop.m 999
+(p10)  fma.d.s0 f8 = f1,f1,f0
+       nop.i 999
+}
+{ .mfb
+       nop.m 999
+(p9)   fma.d.s0 f8 = f9,f8,f0
+       br.ret.sptk b0             // Exit y=nan
+}
+;;
+
+
+POW_OVER_UNDER_ERROR:
+// Here if we have overflow or underflow.
+// Enter with p12 true if x negative and y odd int to force -0 or -inf
+
+{ .mfi
+         sub   pow_GR_17ones_m1         = pow_GR_17ones, r0, 1
+         nop.f 999
+         mov pow_GR_one                 = 0x1
+}
+;;
+
+// overflow, force inf with O flag
+{ .mmb
+(p8)     mov pow_GR_tag                 = 24
+(p8)     setf.exp POW_tmp               = pow_GR_17ones_m1
+         nop.b 999
+}
+;;
+
+// underflow, force zero with I, U flags
+{ .mmi
+(p9)    mov pow_GR_tag                  = 25
+(p9)    setf.exp POW_tmp                = pow_GR_one
+        nop.i 999
+}
+;;
+
+{ .mfi
+        nop.m 999
+        fma.d.s0 f8                     = POW_tmp, POW_tmp, f0
+        nop.i 999
+}
+;;
+
+// p12 x is negative and y is an odd integer, change sign of result
+{ .mfi
+        nop.m 999
+(p12)   fnma.d.s0 f8                    = POW_tmp, POW_tmp, f0
+        nop.i 999
+}
+;;
+
+WEAK_LIBM_END(pow)
+libm_alias_double_other (__pow, pow)
+#ifdef SHARED
+.symver pow,pow@@GLIBC_2.29
+.weak __pow_compat
+.set __pow_compat,__pow
+.symver __pow_compat,pow@GLIBC_2.2
+#endif
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp     // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs         // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                   // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp               // Save gp
+};;
+
+{ .mmi
+        stfd [GR_Parameter_Y] = POW_NORM_Y,16 // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp      // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0               // Save b0
+};;
+
+.body
+{ .mib
+        stfd [GR_Parameter_X] = POW_NORM_X // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y    // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = f8      // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support# // Call error handling function
+};;
+
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT] // Get return result off stack
+.restore sp
+        add   sp = 64,sp                 // Restore stack pointer
+        mov   b0 = GR_SAVE_B0            // Restore return address
+};;
+
+{ .mib
+        mov   gp = GR_SAVE_GP            // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS       // Restore ar.pfs
+        br.ret.sptk     b0               // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_pow_log_data.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_powf.S
@@ -0,0 +1,2071 @@
+.file "powf.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 02/03/00 Added p12 to definite over/under path. With odd power we did not
+//          maintain the sign of x in this path.
+// 04/04/00 Unwind support added
+// 04/19/00 pow(+-1,inf) now returns NaN
+//          pow(+-val, +-inf) returns 0 or inf, but now does not call error
+//          support
+//          Added s1 to fcvt.fx because invalid flag was incorrectly set.
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 09/07/00 Improved performance by eliminating bank conflicts and other stalls,
+//          and tweaking the critical path
+// 09/08/00 Per c99, pow(+-1,inf) now returns 1, and pow(+1,nan) returns 1
+// 09/28/00 Updated NaN**0 path
+// 01/20/01 Fixed denormal flag settings.
+// 02/13/01 Improved speed.
+// 03/19/01 Reordered exp polynomial to improve speed and eliminate monotonicity
+//          problem in round up, down, and to zero modes.  Also corrected
+//          overflow result when x negative, y odd in round up, down, zero.
+// 06/14/01 Added brace missing from bundle
+// 12/10/01 Corrected case where x negative, 2^23 <= |y| < 2^24, y odd integer.
+// 02/08/02 Fixed overflow/underflow cases that were not calling error support.
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 08/29/02 Improved Itanium 2 performance
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 10/09/03 Modified algorithm to improve performance, reduce table size, and
+//          fix boundary case powf(2.0,-150.0)
+// 03/31/05 Reformatted delimiters between data tables
+//
+// API
+//==============================================================
+// float powf(float x, float y)
+//
+// Overview of operation
+//==============================================================
+//
+// Three steps...
+// 1. Log(x)
+// 2. y Log(x)
+// 3. exp(y log(x))
+//
+// This means we work with the absolute value of x and merge in the sign later.
+//      Log(x) = G + delta + r -rsq/2 + p
+// G,delta depend on the exponent of x and table entries. The table entries are
+// indexed by the exponent of x, called K.
+//
+// The G and delta come out of the reduction; r is the reduced x.
+//
+// B = frcpa(x)
+// xB-1 is small means that B is the approximate inverse of x.
+//
+//      Log(x) = Log( (1/B)(Bx) )
+//             = Log(1/B) + Log(Bx)
+//             = Log(1/B) + Log( 1 + (Bx-1))
+//
+//      x  = 2^K 1.x_1x_2.....x_52
+//      B= frcpa(x) = 2^-k Cm
+//      Log(1/B) = Log(1/(2^-K Cm))
+//      Log(1/B) = Log((2^K/ Cm))
+//      Log(1/B) = K Log(2) + Log(1/Cm)
+//
+//      Log(x)   = K Log(2) + Log(1/Cm) + Log( 1 + (Bx-1))
+//
+// If you take the significand of x, set the exponent to true 0, then Cm is
+// the frcpa. We tabulate the Log(1/Cm) values. There are 256 of them.
+// The frcpa table is indexed by 8 bits, the x_1 thru x_8.
+// m = x_1x_2...x_8 is an 8-bit index.
+//
+//      Log(1/Cm) = log(1/frcpa(1+m/256)) where m goes from 0 to 255.
+//
+// We tabulate as one double, T for single precision power
+//
+//      Log(x)   = (K Log(2)_hi + T) + (K Log(2)_lo) + Log( 1 + (Bx-1))
+//      Log(x)   =  G                +     delta     + Log( 1 + (Bx-1))
+//
+// The Log( 1 + (Bx-1)) can be calculated as a series in r = Bx-1.
+//
+//      Log( 1 + (Bx-1)) = r - rsq/2 + p
+//        where p = r^3(P0 + P1*r + P2*r^2)
+//
+// Then,
+//
+//      yLog(x) = yG + y delta + y(r-rsq/2) + yp
+//      yLog(x) = Z1 + e3      + Z2         + Z3
+//
+//
+//     exp(yLog(x)) = exp(Z1 + Z2) exp(Z3) exp(e3)
+//
+//
+//       exp(Z3) is another series.
+//       exp(e3) is approximated as f3 = 1 +  e3
+//
+//       exp(Z1 + Z2) = exp(Z)
+//       Z (128/log2) = number of log2/128 in Z is N
+//
+//       s = Z - N log2/128
+//
+//       exp(Z)       = exp(s) exp(N log2/128)
+//
+//       exp(r)       = exp(Z - N log2/128)
+//
+//      r = s + d = (Z - N (log2/128)_hi) -N (log2/128)_lo
+//                =  Z - N (log2/128)
+//
+//      Z         = s+d +N (log2/128)
+//
+//      exp(Z)    = exp(s) (1+d) exp(N log2/128)
+//
+//      N = M 128 + n
+//
+//      N log2/128 = M log2 + n log2/128
+//
+//      n is 8 binary digits = n_7n_6...n_1
+//
+//      n log2/128 = n_7n_6n_5 16 log2/128 + n_4n_3n_2n_1 log2/128
+//      n log2/128 = n_7n_6n_5 log2/8 + n_4n_3n_2n_1 log2/128
+//      n log2/128 = I2 log2/8 + I1 log2/128
+//
+//      N log2/128 = M log2 + I2 log2/8 + I1 log2/128
+//
+//      exp(Z)    = exp(s) (1+d) exp(log(2^M) + log(2^I2/8) + log(2^I1/128))
+//      exp(Z)    = exp(s) f12 (2^M) 2^I2/8 2^I1/128
+//
+// I1, I2 are table indices. Use a series for exp(s).
+// Then get exp(Z)
+//
+//     exp(yLog(x)) = exp(Z) exp(Z3) f3
+//     exp(yLog(x)) = exp(Z)f3 exp(Z3)
+//     exp(yLog(x)) = A exp(Z3)
+//
+// We actually calculate exp(Z3) -1.
+// Then,
+//     exp(yLog(x)) = A + A( exp(Z3)   -1)
+//
+
+// Table Generation
+//==============================================================
+
+// The log values
+// ==============
+// The operation (K*log2_hi) must be exact. K is the true exponent of x.
+// If we allow gradual underflow (denormals), K can be represented in 12 bits
+// (as a two's complement number). We assume 13 bits as an engineering
+// precaution.
+//
+//           +------------+----------------+-+
+//           |  13 bits   | 50 bits        | |
+//           +------------+----------------+-+
+//           0            1                66
+//                        2                34
+//
+// So we want the lsb(log2_hi) to be 2^-50
+// We get log2 as a quad-extended (15-bit exponent, 128-bit significand)
+//
+//      0 fffe b17217f7d1cf79ab c9e3b39803f2f6af (4...)
+//
+// Consider numbering the bits left to right, starting at 0 thru 127.
+// Bit 0 is the 2^-1 bit; bit 49 is the 2^-50 bit.
+//
+//  ...79ab
+//     0111 1001 1010 1011
+//     44
+//     89
+//
+// So if we shift off the rightmost 14 bits, then (shift back only
+// the top half) we get
+//
+//      0 fffe b17217f7d1cf4000 e6af278ece600fcb dabc000000000000
+//
+// Put the right 64-bit signficand in an FR register, convert to double;
+// it is exact. Put the next 128 bits into a quad register and round to double.
+// The true exponent of the low part is -51.
+//
+// hi is 0 fffe b17217f7d1cf4000
+// lo is 0 ffcc e6af278ece601000
+//
+// Convert to double memory format and get
+//
+// hi is 0x3fe62e42fefa39e8
+// lo is 0x3cccd5e4f1d9cc02
+//
+// log2_hi + log2_lo is an accurate value for log2.
+//
+//
+// The T and t values
+// ==================
+// A similar method is used to generate the T and t values.
+//
+// K * log2_hi + T  must be exact.
+//
+// Smallest T,t
+// ----------
+// The smallest T,t is
+//       T                   t
+// 0x3f60040155d58800, 0x3c93bce0ce3ddd81  log(1/frcpa(1+0/256))=  +1.95503e-003
+//
+// The exponent is 0x3f6 (biased)  or -9 (true).
+// For the smallest T value, what we want is to clip the significand such that
+// when it is shifted right by 9, its lsb is in the bit for 2^-51. The 9 is the
+// specific for the first entry. In general, it is 0xffff - (biased 15-bit
+// exponent).
+
+// Independently, what we have calculated is the table value as a quad
+// precision number.
+// Table entry 1 is
+// 0 fff6 80200aaeac44ef38 338f77605fdf8000
+//
+// We store this quad precision number in a data structure that is
+//    sign:           1
+//    exponent:      15
+//    signficand_hi: 64 (includes explicit bit)
+//    signficand_lo: 49
+// Because the explicit bit is included, the significand is 113 bits.
+//
+// Consider significand_hi for table entry 1.
+//
+//
+// +-+--- ... -------+--------------------+
+// | |
+// +-+--- ... -------+--------------------+
+// 0 1               4444444455555555556666
+//                   2345678901234567890123
+//
+// Labeled as above, bit 0 is 2^0, bit 1 is 2^-1, etc.
+// Bit 42 is 2^-42. If we shift to the right by 9, the bit in
+// bit 42 goes in 51.
+//
+// So what we want to do is shift bits 43 thru 63 into significand_lo.
+// This is shifting bit 42 into bit 63, taking care to retain shifted-off bits.
+// Then shifting (just with signficaand_hi) back into bit 42.
+//
+// The shift_value is 63-42 = 21. In general, this is
+//      63 - (51 -(0xffff - 0xfff6))
+// For this example, it is
+//      63 - (51 - 9) = 63 - 42  = 21
+//
+// This means we are shifting 21 bits into significand_lo. We must maintain more
+// that a 128-bit signficand not to lose bits. So before the shift we put the
+// 128-bit significand into a 256-bit signficand and then shift.
+// The 256-bit significand has four parts: hh, hl, lh, and ll.
+//
+// Start off with
+//      hh         hl         lh         ll
+//      <64>       <49><15_0> <64_0>     <64_0>
+//
+// After shift by 21 (then return for significand_hi),
+//      <43><21_0> <21><43>   <6><58_0>  <64_0>
+//
+// Take the hh part and convert to a double. There is no rounding here.
+// The conversion is exact. The true exponent of the high part is the same as
+// the true exponent of the input quad.
+//
+// We have some 64 plus significand bits for the low part. In this example, we
+// have 70 bits. We want to round this to a double. Put them in a quad and then
+// do a quad fnorm.
+// For this example the true exponent of the low part is
+//      true_exponent_of_high - 43 = true_exponent_of_high - (64-21)
+// In general, this is
+//      true_exponent_of_high - (64 - shift_value)
+//
+//
+// Largest T,t
+// ----------
+// The largest T,t is
+// 0x3fe62643fecf9742, 0x3c9e3147684bd37d  log(1/frcpa(1+255/256))=+6.92171e-001
+//
+// Table entry 256 is
+// 0 fffe b1321ff67cba178c 51da12f4df5a0000
+//
+// The shift value is
+//      63 - (51 -(0xffff - 0xfffe)) = 13
+//
+// The true exponent of the low part is
+//      true_exponent_of_high - (64 - shift_value)
+//      -1 - (64-13) = -52
+// Biased as a double, this is 0x3cb
+//
+//
+//
+// So then lsb(T) must be >= 2^-51
+// msb(Klog2_hi) <= 2^12
+//
+//              +--------+---------+
+//              |       51 bits    | <== largest T
+//              +--------+---------+
+//              | 9 bits | 42 bits | <== smallest T
+// +------------+----------------+-+
+// |  13 bits   | 50 bits        | |
+// +------------+----------------+-+
+//
+// Note: For powf only the table of T is needed
+
+
+// Special Cases
+//==============================================================
+
+//                                   double     float
+// overflow                          error 24   30
+
+// underflow                         error 25   31
+
+// X zero  Y zero
+//  +0     +0                 +1     error 26   32
+//  -0     +0                 +1     error 26   32
+//  +0     -0                 +1     error 26   32
+//  -0     -0                 +1     error 26   32
+
+// X zero  Y negative
+//  +0     -odd integer       +inf   error 27   33  divide-by-zero
+//  -0     -odd integer       -inf   error 27   33  divide-by-zero
+//  +0     !-odd integer      +inf   error 27   33  divide-by-zero
+//  -0     !-odd integer      +inf   error 27   33  divide-by-zero
+//  +0     -inf               +inf   error 27   33  divide-by-zero
+//  -0     -inf               +inf   error 27   33  divide-by-zero
+
+// X zero  Y positive
+//  +0     +odd integer       +0
+//  -0     +odd integer       -0
+//  +0     !+odd integer      +0
+//  -0     !+odd integer      +0
+//  +0     +inf               +0
+//  -0     +inf               +0
+//  +0     Y NaN              quiet Y               invalid if Y SNaN
+//  -0     Y NaN              quiet Y               invalid if Y SNaN
+
+// X one
+//  -1     Y inf              +1
+//  -1     Y NaN              quiet Y               invalid if Y SNaN
+//  +1     Y NaN              +1                    invalid if Y SNaN
+//  +1     Y any else         +1
+
+// X -     Y not integer      QNAN   error 28   34  invalid
+
+// X NaN   Y 0                +1     error 29   35
+// X NaN   Y NaN              quiet X               invalid if X or Y SNaN
+// X NaN   Y any else         quiet X               invalid if X SNaN
+// X !+1   Y NaN              quiet Y               invalid if Y SNaN
+
+
+// X +inf  Y >0               +inf
+// X -inf  Y >0, !odd integer +inf
+// X -inf  Y >0, odd integer  -inf
+
+// X +inf  Y <0               +0
+// X -inf  Y <0, !odd integer +0
+// X -inf  Y <0, odd integer  -0
+
+// X +inf  Y =0               +1
+// X -inf  Y =0               +1
+
+// |X|<1   Y +inf             +0
+// |X|<1   Y -inf             +inf
+// |X|>1   Y +inf             +inf
+// |X|>1   Y -inf             +0
+
+// X any   Y =0               +1
+
+// Assembly macros
+//==============================================================
+
+// integer registers used
+
+pow_GR_exp_half           = r10
+pow_GR_signexp_Xm1        = r11
+pow_GR_tmp                = r11
+
+pow_GR_signexp_X          = r14
+pow_GR_17ones             = r15
+pow_GR_Fpsr               = r15
+pow_AD_P                  = r16
+pow_GR_rcs0_mask          = r16
+pow_GR_exp_2tom8          = r17
+pow_GR_rcs0               = r17
+pow_GR_sig_X              = r18
+pow_GR_10033              = r19
+pow_GR_16ones             = r20
+
+pow_AD_Tt                 = r21
+pow_GR_exp_X              = r22
+pow_AD_Q                  = r23
+pow_GR_true_exp_X         = r24
+pow_GR_y_zero             = r25
+
+pow_GR_exp_Y              = r26
+pow_AD_tbl1               = r27
+pow_AD_tbl2               = r28
+pow_GR_offset             = r29
+pow_GR_exp_Xm1            = r30
+pow_GR_xneg_yodd          = r31
+
+pow_GR_int_N              = r38
+pow_GR_index1             = r39
+pow_GR_index2             = r40
+
+pow_AD_T1                 = r41
+pow_AD_T2                 = r42
+pow_int_GR_M              = r43
+pow_GR_sig_int_Y          = r44
+pow_GR_sign_Y_Gpr         = r45
+
+pow_GR_17ones_m1          = r46
+pow_GR_one                = r47
+pow_GR_sign_Y             = r48
+pow_GR_signexp_Y_Gpr      = r49
+pow_GR_exp_Y_Gpr          = r50
+
+pow_GR_true_exp_Y_Gpr     = r51
+pow_GR_signexp_Y          = r52
+pow_GR_x_one              = r53
+pow_GR_big_pos            = r55
+
+pow_GR_big_neg            = r56
+
+GR_SAVE_B0                = r50
+GR_SAVE_GP                = r51
+GR_SAVE_PFS               = r52
+
+GR_Parameter_X            = r53
+GR_Parameter_Y            = r54
+GR_Parameter_RESULT       = r55
+pow_GR_tag                = r56
+
+
+// floating point registers used
+
+POW_B                     = f32
+POW_NORM_X                = f33
+POW_Xm1                   = f34
+POW_r1                    = f34
+
+POW_NORM_Y                = f37
+POW_Q2                    = f38
+POW_eps                   = f39
+POW_P2                    = f40
+
+POW_P0                    = f42
+POW_log2_lo               = f43
+POW_r                     = f44
+POW_Q0_half               = f45
+
+POW_tmp                   = f47
+POW_log2_hi               = f48
+POW_Q1                    = f49
+POW_P1                    = f50
+
+POW_log2_by_128_hi        = f51
+POW_inv_log2_by_128       = f52
+POW_rsq                   = f53
+POW_Yrcub                 = f54
+POW_log2_by_128_lo        = f55
+
+POW_xsq                   = f57
+POW_v2                    = f59
+POW_T                     = f60
+
+POW_RSHF                  = f62
+POW_v210                  = f63
+POW_twoV                  = f65
+
+POW_U                     = f66
+POW_G                     = f67
+POW_delta                 = f68
+POW_V                     = f70
+
+POW_p                     = f71
+POW_Z                     = f72
+POW_e3                    = f73
+POW_Z2                    = f75
+
+POW_W1                    = f77
+POW_Z3                    = f80
+
+POW_Z3sq                  = f85
+
+POW_Nfloat                = f87
+POW_f3                    = f89
+POW_q                     = f90
+
+POW_T1                    = f96
+POW_T2                    = f97
+POW_2M                    = f98
+POW_s                     = f99
+POW_f12                   = f100
+
+POW_ssq                   = f101
+POW_T1T2                  = f102
+POW_1ps                   = f103
+POW_A                     = f104
+POW_es                    = f105
+
+POW_Xp1                   = f106
+POW_int_K                 = f107
+POW_K                     = f108
+POW_f123                  = f109
+POW_Gpr                   = f110
+
+POW_Y_Gpr                 = f111
+POW_int_Y                 = f112
+POW_2Mqp1                 = f113
+
+POW_float_int_Y           = f116
+POW_ftz_urm_f8            = f117
+POW_wre_urm_f8            = f118
+POW_big_neg               = f119
+POW_big_pos               = f120
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(pow_table_P)
+data8 0x80000000000018E5, 0x0000BFFD  // P_1
+data8 0xb8aa3b295c17f0bc, 0x00004006  // inv_ln2_by_128
+//
+//
+data8 0x3FA5555555554A9E // Q_2
+data8 0x0000000000000000 // Pad
+data8 0x3FC5555555554733 // Q_1
+data8 0x43e8000000000000 // Right shift constant for exp
+data8 0xc9e3b39803f2f6af, 0x00003fb7  // ln2_by_128_lo
+LOCAL_OBJECT_END(pow_table_P)
+
+LOCAL_OBJECT_START(pow_table_Q)
+data8 0xCCCCCCCC4ED2BA7F, 0x00003FFC  // P_2
+data8 0xAAAAAAAAAAAAB505, 0x00003FFD  // P_0
+data8 0x3fe62e42fefa39e8, 0x3cccd5e4f1d9cc02 // log2 hi lo =  +6.93147e-001
+data8 0xb17217f7d1cf79ab, 0x00003ff7  // ln2_by_128_hi
+LOCAL_OBJECT_END(pow_table_Q)
+
+
+LOCAL_OBJECT_START(pow_Tt)
+data8 0x3f60040155d58800 // log(1/frcpa(1+0/256))=  +1.95503e-003
+data8 0x3f78121214586a00 // log(1/frcpa(1+1/256))=  +5.87661e-003
+data8 0x3f841929f9683200 // log(1/frcpa(1+2/256))=  +9.81362e-003
+data8 0x3f8c317384c75f00 // log(1/frcpa(1+3/256))=  +1.37662e-002
+data8 0x3f91a6b91ac73380 // log(1/frcpa(1+4/256))=  +1.72376e-002
+data8 0x3f95ba9a5d9ac000 // log(1/frcpa(1+5/256))=  +2.12196e-002
+data8 0x3f99d2a807432580 // log(1/frcpa(1+6/256))=  +2.52177e-002
+data8 0x3f9d6b2725979800 // log(1/frcpa(1+7/256))=  +2.87291e-002
+data8 0x3fa0c58fa19dfa80 // log(1/frcpa(1+8/256))=  +3.27573e-002
+data8 0x3fa2954c78cbce00 // log(1/frcpa(1+9/256))=  +3.62953e-002
+data8 0x3fa4a94d2da96c40 // log(1/frcpa(1+10/256))=  +4.03542e-002
+data8 0x3fa67c94f2d4bb40 // log(1/frcpa(1+11/256))=  +4.39192e-002
+data8 0x3fa85188b630f040 // log(1/frcpa(1+12/256))=  +4.74971e-002
+data8 0x3faa6b8abe73af40 // log(1/frcpa(1+13/256))=  +5.16017e-002
+data8 0x3fac441e06f72a80 // log(1/frcpa(1+14/256))=  +5.52072e-002
+data8 0x3fae1e6713606d00 // log(1/frcpa(1+15/256))=  +5.88257e-002
+data8 0x3faffa6911ab9300 // log(1/frcpa(1+16/256))=  +6.24574e-002
+data8 0x3fb0ec139c5da600 // log(1/frcpa(1+17/256))=  +6.61022e-002
+data8 0x3fb1dbd2643d1900 // log(1/frcpa(1+18/256))=  +6.97605e-002
+data8 0x3fb2cc7284fe5f00 // log(1/frcpa(1+19/256))=  +7.34321e-002
+data8 0x3fb3bdf5a7d1ee60 // log(1/frcpa(1+20/256))=  +7.71173e-002
+data8 0x3fb4b05d7aa012e0 // log(1/frcpa(1+21/256))=  +8.08161e-002
+data8 0x3fb580db7ceb5700 // log(1/frcpa(1+22/256))=  +8.39975e-002
+data8 0x3fb674f089365a60 // log(1/frcpa(1+23/256))=  +8.77219e-002
+data8 0x3fb769ef2c6b5680 // log(1/frcpa(1+24/256))=  +9.14602e-002
+data8 0x3fb85fd927506a40 // log(1/frcpa(1+25/256))=  +9.52125e-002
+data8 0x3fb9335e5d594980 // log(1/frcpa(1+26/256))=  +9.84401e-002
+data8 0x3fba2b0220c8e5e0 // log(1/frcpa(1+27/256))=  +1.02219e-001
+data8 0x3fbb0004ac1a86a0 // log(1/frcpa(1+28/256))=  +1.05469e-001
+data8 0x3fbbf968769fca00 // log(1/frcpa(1+29/256))=  +1.09274e-001
+data8 0x3fbccfedbfee13a0 // log(1/frcpa(1+30/256))=  +1.12548e-001
+data8 0x3fbda727638446a0 // log(1/frcpa(1+31/256))=  +1.15832e-001
+data8 0x3fbea3257fe10f60 // log(1/frcpa(1+32/256))=  +1.19677e-001
+data8 0x3fbf7be9fedbfde0 // log(1/frcpa(1+33/256))=  +1.22985e-001
+data8 0x3fc02ab352ff25f0 // log(1/frcpa(1+34/256))=  +1.26303e-001
+data8 0x3fc097ce579d2040 // log(1/frcpa(1+35/256))=  +1.29633e-001
+data8 0x3fc1178e8227e470 // log(1/frcpa(1+36/256))=  +1.33531e-001
+data8 0x3fc185747dbecf30 // log(1/frcpa(1+37/256))=  +1.36885e-001
+data8 0x3fc1f3b925f25d40 // log(1/frcpa(1+38/256))=  +1.40250e-001
+data8 0x3fc2625d1e6ddf50 // log(1/frcpa(1+39/256))=  +1.43627e-001
+data8 0x3fc2d1610c868130 // log(1/frcpa(1+40/256))=  +1.47015e-001
+data8 0x3fc340c597411420 // log(1/frcpa(1+41/256))=  +1.50414e-001
+data8 0x3fc3b08b6757f2a0 // log(1/frcpa(1+42/256))=  +1.53825e-001
+data8 0x3fc40dfb08378000 // log(1/frcpa(1+43/256))=  +1.56677e-001
+data8 0x3fc47e74e8ca5f70 // log(1/frcpa(1+44/256))=  +1.60109e-001
+data8 0x3fc4ef51f6466de0 // log(1/frcpa(1+45/256))=  +1.63553e-001
+data8 0x3fc56092e02ba510 // log(1/frcpa(1+46/256))=  +1.67010e-001
+data8 0x3fc5d23857cd74d0 // log(1/frcpa(1+47/256))=  +1.70478e-001
+data8 0x3fc6313a37335d70 // log(1/frcpa(1+48/256))=  +1.73377e-001
+data8 0x3fc6a399dabbd380 // log(1/frcpa(1+49/256))=  +1.76868e-001
+data8 0x3fc70337dd3ce410 // log(1/frcpa(1+50/256))=  +1.79786e-001
+data8 0x3fc77654128f6120 // log(1/frcpa(1+51/256))=  +1.83299e-001
+data8 0x3fc7e9d82a0b0220 // log(1/frcpa(1+52/256))=  +1.86824e-001
+data8 0x3fc84a6b759f5120 // log(1/frcpa(1+53/256))=  +1.89771e-001
+data8 0x3fc8ab47d5f5a300 // log(1/frcpa(1+54/256))=  +1.92727e-001
+data8 0x3fc91fe490965810 // log(1/frcpa(1+55/256))=  +1.96286e-001
+data8 0x3fc981634011aa70 // log(1/frcpa(1+56/256))=  +1.99261e-001
+data8 0x3fc9f6c407089660 // log(1/frcpa(1+57/256))=  +2.02843e-001
+data8 0x3fca58e729348f40 // log(1/frcpa(1+58/256))=  +2.05838e-001
+data8 0x3fcabb55c31693a0 // log(1/frcpa(1+59/256))=  +2.08842e-001
+data8 0x3fcb1e104919efd0 // log(1/frcpa(1+60/256))=  +2.11855e-001
+data8 0x3fcb94ee93e367c0 // log(1/frcpa(1+61/256))=  +2.15483e-001
+data8 0x3fcbf851c0675550 // log(1/frcpa(1+62/256))=  +2.18516e-001
+data8 0x3fcc5c0254bf23a0 // log(1/frcpa(1+63/256))=  +2.21558e-001
+data8 0x3fccc000c9db3c50 // log(1/frcpa(1+64/256))=  +2.24609e-001
+data8 0x3fcd244d99c85670 // log(1/frcpa(1+65/256))=  +2.27670e-001
+data8 0x3fcd88e93fb2f450 // log(1/frcpa(1+66/256))=  +2.30741e-001
+data8 0x3fcdedd437eaef00 // log(1/frcpa(1+67/256))=  +2.33820e-001
+data8 0x3fce530effe71010 // log(1/frcpa(1+68/256))=  +2.36910e-001
+data8 0x3fceb89a1648b970 // log(1/frcpa(1+69/256))=  +2.40009e-001
+data8 0x3fcf1e75fadf9bd0 // log(1/frcpa(1+70/256))=  +2.43117e-001
+data8 0x3fcf84a32ead7c30 // log(1/frcpa(1+71/256))=  +2.46235e-001
+data8 0x3fcfeb2233ea07c0 // log(1/frcpa(1+72/256))=  +2.49363e-001
+data8 0x3fd028f9c7035c18 // log(1/frcpa(1+73/256))=  +2.52501e-001
+data8 0x3fd05c8be0d96358 // log(1/frcpa(1+74/256))=  +2.55649e-001
+data8 0x3fd085eb8f8ae790 // log(1/frcpa(1+75/256))=  +2.58174e-001
+data8 0x3fd0b9c8e32d1910 // log(1/frcpa(1+76/256))=  +2.61339e-001
+data8 0x3fd0edd060b78080 // log(1/frcpa(1+77/256))=  +2.64515e-001
+data8 0x3fd122024cf00638 // log(1/frcpa(1+78/256))=  +2.67701e-001
+data8 0x3fd14be2927aecd0 // log(1/frcpa(1+79/256))=  +2.70257e-001
+data8 0x3fd180618ef18ad8 // log(1/frcpa(1+80/256))=  +2.73461e-001
+data8 0x3fd1b50bbe2fc638 // log(1/frcpa(1+81/256))=  +2.76675e-001
+data8 0x3fd1df4cc7cf2428 // log(1/frcpa(1+82/256))=  +2.79254e-001
+data8 0x3fd214456d0eb8d0 // log(1/frcpa(1+83/256))=  +2.82487e-001
+data8 0x3fd23ec5991eba48 // log(1/frcpa(1+84/256))=  +2.85081e-001
+data8 0x3fd2740d9f870af8 // log(1/frcpa(1+85/256))=  +2.88333e-001
+data8 0x3fd29ecdabcdfa00 // log(1/frcpa(1+86/256))=  +2.90943e-001
+data8 0x3fd2d46602adcce8 // log(1/frcpa(1+87/256))=  +2.94214e-001
+data8 0x3fd2ff66b04ea9d0 // log(1/frcpa(1+88/256))=  +2.96838e-001
+data8 0x3fd335504b355a30 // log(1/frcpa(1+89/256))=  +3.00129e-001
+data8 0x3fd360925ec44f58 // log(1/frcpa(1+90/256))=  +3.02769e-001
+data8 0x3fd38bf1c3337e70 // log(1/frcpa(1+91/256))=  +3.05417e-001
+data8 0x3fd3c25277333180 // log(1/frcpa(1+92/256))=  +3.08735e-001
+data8 0x3fd3edf463c16838 // log(1/frcpa(1+93/256))=  +3.11399e-001
+data8 0x3fd419b423d5e8c0 // log(1/frcpa(1+94/256))=  +3.14069e-001
+data8 0x3fd44591e0539f48 // log(1/frcpa(1+95/256))=  +3.16746e-001
+data8 0x3fd47c9175b6f0a8 // log(1/frcpa(1+96/256))=  +3.20103e-001
+data8 0x3fd4a8b341552b08 // log(1/frcpa(1+97/256))=  +3.22797e-001
+data8 0x3fd4d4f390890198 // log(1/frcpa(1+98/256))=  +3.25498e-001
+data8 0x3fd501528da1f960 // log(1/frcpa(1+99/256))=  +3.28206e-001
+data8 0x3fd52dd06347d4f0 // log(1/frcpa(1+100/256))=  +3.30921e-001
+data8 0x3fd55a6d3c7b8a88 // log(1/frcpa(1+101/256))=  +3.33644e-001
+data8 0x3fd5925d2b112a58 // log(1/frcpa(1+102/256))=  +3.37058e-001
+data8 0x3fd5bf406b543db0 // log(1/frcpa(1+103/256))=  +3.39798e-001
+data8 0x3fd5ec433d5c35a8 // log(1/frcpa(1+104/256))=  +3.42545e-001
+data8 0x3fd61965cdb02c18 // log(1/frcpa(1+105/256))=  +3.45300e-001
+data8 0x3fd646a84935b2a0 // log(1/frcpa(1+106/256))=  +3.48063e-001
+data8 0x3fd6740add31de90 // log(1/frcpa(1+107/256))=  +3.50833e-001
+data8 0x3fd6a18db74a58c0 // log(1/frcpa(1+108/256))=  +3.53610e-001
+data8 0x3fd6cf31058670e8 // log(1/frcpa(1+109/256))=  +3.56396e-001
+data8 0x3fd6f180e852f0b8 // log(1/frcpa(1+110/256))=  +3.58490e-001
+data8 0x3fd71f5d71b894e8 // log(1/frcpa(1+111/256))=  +3.61289e-001
+data8 0x3fd74d5aefd66d58 // log(1/frcpa(1+112/256))=  +3.64096e-001
+data8 0x3fd77b79922bd378 // log(1/frcpa(1+113/256))=  +3.66911e-001
+data8 0x3fd7a9b9889f19e0 // log(1/frcpa(1+114/256))=  +3.69734e-001
+data8 0x3fd7d81b037eb6a0 // log(1/frcpa(1+115/256))=  +3.72565e-001
+data8 0x3fd8069e33827230 // log(1/frcpa(1+116/256))=  +3.75404e-001
+data8 0x3fd82996d3ef8bc8 // log(1/frcpa(1+117/256))=  +3.77538e-001
+data8 0x3fd85855776dcbf8 // log(1/frcpa(1+118/256))=  +3.80391e-001
+data8 0x3fd8873658327cc8 // log(1/frcpa(1+119/256))=  +3.83253e-001
+data8 0x3fd8aa75973ab8c8 // log(1/frcpa(1+120/256))=  +3.85404e-001
+data8 0x3fd8d992dc8824e0 // log(1/frcpa(1+121/256))=  +3.88280e-001
+data8 0x3fd908d2ea7d9510 // log(1/frcpa(1+122/256))=  +3.91164e-001
+data8 0x3fd92c59e79c0e50 // log(1/frcpa(1+123/256))=  +3.93332e-001
+data8 0x3fd95bd750ee3ed0 // log(1/frcpa(1+124/256))=  +3.96231e-001
+data8 0x3fd98b7811a3ee58 // log(1/frcpa(1+125/256))=  +3.99138e-001
+data8 0x3fd9af47f33d4068 // log(1/frcpa(1+126/256))=  +4.01323e-001
+data8 0x3fd9df270c1914a0 // log(1/frcpa(1+127/256))=  +4.04245e-001
+data8 0x3fda0325ed14fda0 // log(1/frcpa(1+128/256))=  +4.06442e-001
+data8 0x3fda33440224fa78 // log(1/frcpa(1+129/256))=  +4.09379e-001
+data8 0x3fda57725e80c380 // log(1/frcpa(1+130/256))=  +4.11587e-001
+data8 0x3fda87d0165dd198 // log(1/frcpa(1+131/256))=  +4.14539e-001
+data8 0x3fdaac2e6c03f890 // log(1/frcpa(1+132/256))=  +4.16759e-001
+data8 0x3fdadccc6fdf6a80 // log(1/frcpa(1+133/256))=  +4.19726e-001
+data8 0x3fdb015b3eb1e790 // log(1/frcpa(1+134/256))=  +4.21958e-001
+data8 0x3fdb323a3a635948 // log(1/frcpa(1+135/256))=  +4.24941e-001
+data8 0x3fdb56fa04462908 // log(1/frcpa(1+136/256))=  +4.27184e-001
+data8 0x3fdb881aa659bc90 // log(1/frcpa(1+137/256))=  +4.30182e-001
+data8 0x3fdbad0bef3db160 // log(1/frcpa(1+138/256))=  +4.32437e-001
+data8 0x3fdbd21297781c28 // log(1/frcpa(1+139/256))=  +4.34697e-001
+data8 0x3fdc039236f08818 // log(1/frcpa(1+140/256))=  +4.37718e-001
+data8 0x3fdc28cb1e4d32f8 // log(1/frcpa(1+141/256))=  +4.39990e-001
+data8 0x3fdc4e19b84723c0 // log(1/frcpa(1+142/256))=  +4.42267e-001
+data8 0x3fdc7ff9c74554c8 // log(1/frcpa(1+143/256))=  +4.45311e-001
+data8 0x3fdca57b64e9db00 // log(1/frcpa(1+144/256))=  +4.47600e-001
+data8 0x3fdccb130a5ceba8 // log(1/frcpa(1+145/256))=  +4.49895e-001
+data8 0x3fdcf0c0d18f3268 // log(1/frcpa(1+146/256))=  +4.52194e-001
+data8 0x3fdd232075b5a200 // log(1/frcpa(1+147/256))=  +4.55269e-001
+data8 0x3fdd490246defa68 // log(1/frcpa(1+148/256))=  +4.57581e-001
+data8 0x3fdd6efa918d25c8 // log(1/frcpa(1+149/256))=  +4.59899e-001
+data8 0x3fdd9509707ae528 // log(1/frcpa(1+150/256))=  +4.62221e-001
+data8 0x3fddbb2efe92c550 // log(1/frcpa(1+151/256))=  +4.64550e-001
+data8 0x3fddee2f3445e4a8 // log(1/frcpa(1+152/256))=  +4.67663e-001
+data8 0x3fde148a1a2726c8 // log(1/frcpa(1+153/256))=  +4.70004e-001
+data8 0x3fde3afc0a49ff38 // log(1/frcpa(1+154/256))=  +4.72350e-001
+data8 0x3fde6185206d5168 // log(1/frcpa(1+155/256))=  +4.74702e-001
+data8 0x3fde882578823d50 // log(1/frcpa(1+156/256))=  +4.77060e-001
+data8 0x3fdeaedd2eac9908 // log(1/frcpa(1+157/256))=  +4.79423e-001
+data8 0x3fded5ac5f436be0 // log(1/frcpa(1+158/256))=  +4.81792e-001
+data8 0x3fdefc9326d16ab8 // log(1/frcpa(1+159/256))=  +4.84166e-001
+data8 0x3fdf2391a21575f8 // log(1/frcpa(1+160/256))=  +4.86546e-001
+data8 0x3fdf4aa7ee031928 // log(1/frcpa(1+161/256))=  +4.88932e-001
+data8 0x3fdf71d627c30bb0 // log(1/frcpa(1+162/256))=  +4.91323e-001
+data8 0x3fdf991c6cb3b378 // log(1/frcpa(1+163/256))=  +4.93720e-001
+data8 0x3fdfc07ada69a908 // log(1/frcpa(1+164/256))=  +4.96123e-001
+data8 0x3fdfe7f18eb03d38 // log(1/frcpa(1+165/256))=  +4.98532e-001
+data8 0x3fe007c053c5002c // log(1/frcpa(1+166/256))=  +5.00946e-001
+data8 0x3fe01b942198a5a0 // log(1/frcpa(1+167/256))=  +5.03367e-001
+data8 0x3fe02f74400c64e8 // log(1/frcpa(1+168/256))=  +5.05793e-001
+data8 0x3fe04360be7603ac // log(1/frcpa(1+169/256))=  +5.08225e-001
+data8 0x3fe05759ac47fe30 // log(1/frcpa(1+170/256))=  +5.10663e-001
+data8 0x3fe06b5f1911cf50 // log(1/frcpa(1+171/256))=  +5.13107e-001
+data8 0x3fe078bf0533c568 // log(1/frcpa(1+172/256))=  +5.14740e-001
+data8 0x3fe08cd9687e7b0c // log(1/frcpa(1+173/256))=  +5.17194e-001
+data8 0x3fe0a10074cf9018 // log(1/frcpa(1+174/256))=  +5.19654e-001
+data8 0x3fe0b5343a234474 // log(1/frcpa(1+175/256))=  +5.22120e-001
+data8 0x3fe0c974c89431cc // log(1/frcpa(1+176/256))=  +5.24592e-001
+data8 0x3fe0ddc2305b9884 // log(1/frcpa(1+177/256))=  +5.27070e-001
+data8 0x3fe0eb524bafc918 // log(1/frcpa(1+178/256))=  +5.28726e-001
+data8 0x3fe0ffb54213a474 // log(1/frcpa(1+179/256))=  +5.31214e-001
+data8 0x3fe114253da97d9c // log(1/frcpa(1+180/256))=  +5.33709e-001
+data8 0x3fe128a24f1d9afc // log(1/frcpa(1+181/256))=  +5.36210e-001
+data8 0x3fe1365252bf0864 // log(1/frcpa(1+182/256))=  +5.37881e-001
+data8 0x3fe14ae558b4a92c // log(1/frcpa(1+183/256))=  +5.40393e-001
+data8 0x3fe15f85a19c7658 // log(1/frcpa(1+184/256))=  +5.42910e-001
+data8 0x3fe16d4d38c119f8 // log(1/frcpa(1+185/256))=  +5.44592e-001
+data8 0x3fe18203c20dd130 // log(1/frcpa(1+186/256))=  +5.47121e-001
+data8 0x3fe196c7bc4b1f38 // log(1/frcpa(1+187/256))=  +5.49656e-001
+data8 0x3fe1a4a738b7a33c // log(1/frcpa(1+188/256))=  +5.51349e-001
+data8 0x3fe1b981c0c9653c // log(1/frcpa(1+189/256))=  +5.53895e-001
+data8 0x3fe1ce69e8bb1068 // log(1/frcpa(1+190/256))=  +5.56447e-001
+data8 0x3fe1dc619de06944 // log(1/frcpa(1+191/256))=  +5.58152e-001
+data8 0x3fe1f160a2ad0da0 // log(1/frcpa(1+192/256))=  +5.60715e-001
+data8 0x3fe2066d7740737c // log(1/frcpa(1+193/256))=  +5.63285e-001
+data8 0x3fe2147dba47a390 // log(1/frcpa(1+194/256))=  +5.65001e-001
+data8 0x3fe229a1bc5ebac0 // log(1/frcpa(1+195/256))=  +5.67582e-001
+data8 0x3fe237c1841a502c // log(1/frcpa(1+196/256))=  +5.69306e-001
+data8 0x3fe24cfce6f80d98 // log(1/frcpa(1+197/256))=  +5.71898e-001
+data8 0x3fe25b2c55cd5760 // log(1/frcpa(1+198/256))=  +5.73630e-001
+data8 0x3fe2707f4d5f7c40 // log(1/frcpa(1+199/256))=  +5.76233e-001
+data8 0x3fe285e0842ca380 // log(1/frcpa(1+200/256))=  +5.78842e-001
+data8 0x3fe294294708b770 // log(1/frcpa(1+201/256))=  +5.80586e-001
+data8 0x3fe2a9a2670aff0c // log(1/frcpa(1+202/256))=  +5.83207e-001
+data8 0x3fe2b7fb2c8d1cc0 // log(1/frcpa(1+203/256))=  +5.84959e-001
+data8 0x3fe2c65a6395f5f4 // log(1/frcpa(1+204/256))=  +5.86713e-001
+data8 0x3fe2dbf557b0df40 // log(1/frcpa(1+205/256))=  +5.89350e-001
+data8 0x3fe2ea64c3f97654 // log(1/frcpa(1+206/256))=  +5.91113e-001
+data8 0x3fe3001823684d70 // log(1/frcpa(1+207/256))=  +5.93762e-001
+data8 0x3fe30e97e9a8b5cc // log(1/frcpa(1+208/256))=  +5.95531e-001
+data8 0x3fe32463ebdd34e8 // log(1/frcpa(1+209/256))=  +5.98192e-001
+data8 0x3fe332f4314ad794 // log(1/frcpa(1+210/256))=  +5.99970e-001
+data8 0x3fe348d90e7464cc // log(1/frcpa(1+211/256))=  +6.02643e-001
+data8 0x3fe35779f8c43d6c // log(1/frcpa(1+212/256))=  +6.04428e-001
+data8 0x3fe36621961a6a98 // log(1/frcpa(1+213/256))=  +6.06217e-001
+data8 0x3fe37c299f3c3668 // log(1/frcpa(1+214/256))=  +6.08907e-001
+data8 0x3fe38ae2171976e4 // log(1/frcpa(1+215/256))=  +6.10704e-001
+data8 0x3fe399a157a603e4 // log(1/frcpa(1+216/256))=  +6.12504e-001
+data8 0x3fe3afccfe77b9d0 // log(1/frcpa(1+217/256))=  +6.15210e-001
+data8 0x3fe3be9d503533b4 // log(1/frcpa(1+218/256))=  +6.17018e-001
+data8 0x3fe3cd7480b4a8a0 // log(1/frcpa(1+219/256))=  +6.18830e-001
+data8 0x3fe3e3c43918f76c // log(1/frcpa(1+220/256))=  +6.21554e-001
+data8 0x3fe3f2acb27ed6c4 // log(1/frcpa(1+221/256))=  +6.23373e-001
+data8 0x3fe4019c2125ca90 // log(1/frcpa(1+222/256))=  +6.25197e-001
+data8 0x3fe4181061389720 // log(1/frcpa(1+223/256))=  +6.27937e-001
+data8 0x3fe42711518df544 // log(1/frcpa(1+224/256))=  +6.29769e-001
+data8 0x3fe436194e12b6bc // log(1/frcpa(1+225/256))=  +6.31604e-001
+data8 0x3fe445285d68ea68 // log(1/frcpa(1+226/256))=  +6.33442e-001
+data8 0x3fe45bcc464c8938 // log(1/frcpa(1+227/256))=  +6.36206e-001
+data8 0x3fe46aed21f117fc // log(1/frcpa(1+228/256))=  +6.38053e-001
+data8 0x3fe47a1527e8a2d0 // log(1/frcpa(1+229/256))=  +6.39903e-001
+data8 0x3fe489445efffcc8 // log(1/frcpa(1+230/256))=  +6.41756e-001
+data8 0x3fe4a018bcb69834 // log(1/frcpa(1+231/256))=  +6.44543e-001
+data8 0x3fe4af5a0c9d65d4 // log(1/frcpa(1+232/256))=  +6.46405e-001
+data8 0x3fe4bea2a5bdbe84 // log(1/frcpa(1+233/256))=  +6.48271e-001
+data8 0x3fe4cdf28f10ac44 // log(1/frcpa(1+234/256))=  +6.50140e-001
+data8 0x3fe4dd49cf994058 // log(1/frcpa(1+235/256))=  +6.52013e-001
+data8 0x3fe4eca86e64a680 // log(1/frcpa(1+236/256))=  +6.53889e-001
+data8 0x3fe503c43cd8eb68 // log(1/frcpa(1+237/256))=  +6.56710e-001
+data8 0x3fe513356667fc54 // log(1/frcpa(1+238/256))=  +6.58595e-001
+data8 0x3fe522ae0738a3d4 // log(1/frcpa(1+239/256))=  +6.60483e-001
+data8 0x3fe5322e26867854 // log(1/frcpa(1+240/256))=  +6.62376e-001
+data8 0x3fe541b5cb979808 // log(1/frcpa(1+241/256))=  +6.64271e-001
+data8 0x3fe55144fdbcbd60 // log(1/frcpa(1+242/256))=  +6.66171e-001
+data8 0x3fe560dbc45153c4 // log(1/frcpa(1+243/256))=  +6.68074e-001
+data8 0x3fe5707a26bb8c64 // log(1/frcpa(1+244/256))=  +6.69980e-001
+data8 0x3fe587f60ed5b8fc // log(1/frcpa(1+245/256))=  +6.72847e-001
+data8 0x3fe597a7977c8f30 // log(1/frcpa(1+246/256))=  +6.74763e-001
+data8 0x3fe5a760d634bb88 // log(1/frcpa(1+247/256))=  +6.76682e-001
+data8 0x3fe5b721d295f10c // log(1/frcpa(1+248/256))=  +6.78605e-001
+data8 0x3fe5c6ea94431ef8 // log(1/frcpa(1+249/256))=  +6.80532e-001
+data8 0x3fe5d6bb22ea86f4 // log(1/frcpa(1+250/256))=  +6.82462e-001
+data8 0x3fe5e6938645d38c // log(1/frcpa(1+251/256))=  +6.84397e-001
+data8 0x3fe5f673c61a2ed0 // log(1/frcpa(1+252/256))=  +6.86335e-001
+data8 0x3fe6065bea385924 // log(1/frcpa(1+253/256))=  +6.88276e-001
+data8 0x3fe6164bfa7cc068 // log(1/frcpa(1+254/256))=  +6.90222e-001
+data8 0x3fe62643fecf9740 // log(1/frcpa(1+255/256))=  +6.92171e-001
+LOCAL_OBJECT_END(pow_Tt)
+
+
+// Table 1 is 2^(index_1/128) where
+// index_1 goes from 0 to 15
+LOCAL_OBJECT_START(pow_tbl1)
+data8 0x8000000000000000 , 0x00003FFF
+data8 0x80B1ED4FD999AB6C , 0x00003FFF
+data8 0x8164D1F3BC030773 , 0x00003FFF
+data8 0x8218AF4373FC25EC , 0x00003FFF
+data8 0x82CD8698AC2BA1D7 , 0x00003FFF
+data8 0x8383594EEFB6EE37 , 0x00003FFF
+data8 0x843A28C3ACDE4046 , 0x00003FFF
+data8 0x84F1F656379C1A29 , 0x00003FFF
+data8 0x85AAC367CC487B15 , 0x00003FFF
+data8 0x8664915B923FBA04 , 0x00003FFF
+data8 0x871F61969E8D1010 , 0x00003FFF
+data8 0x87DB357FF698D792 , 0x00003FFF
+data8 0x88980E8092DA8527 , 0x00003FFF
+data8 0x8955EE03618E5FDD , 0x00003FFF
+data8 0x8A14D575496EFD9A , 0x00003FFF
+data8 0x8AD4C6452C728924 , 0x00003FFF
+LOCAL_OBJECT_END(pow_tbl1)
+
+
+// Table 2 is 2^(index_1/8) where
+// index_2 goes from 0 to 7
+LOCAL_OBJECT_START(pow_tbl2)
+data8 0x8000000000000000 , 0x00003FFF
+data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
+data8 0x9837F0518DB8A96F , 0x00003FFF
+data8 0xA5FED6A9B15138EA , 0x00003FFF
+data8 0xB504F333F9DE6484 , 0x00003FFF
+data8 0xC5672A115506DADD , 0x00003FFF
+data8 0xD744FCCAD69D6AF4 , 0x00003FFF
+data8 0xEAC0C6E7DD24392F , 0x00003FFF
+LOCAL_OBJECT_END(pow_tbl2)
+
+.section .text
+WEAK_LIBM_ENTRY(powf)
+
+// Get exponent of x.  Will be used to calculate K.
+{ .mfi
+          getf.exp     pow_GR_signexp_X = f8
+          fms.s1 POW_Xm1 = f8,f1,f1     // Will be used for r1 if x>0
+          mov           pow_GR_17ones   = 0x1FFFF
+}
+{ .mfi
+          addl          pow_AD_P        = @ltoff(pow_table_P), gp
+          fma.s1 POW_Xp1 = f8,f1,f1     // Will be used for r1 if x<0
+          nop.i 999
+}
+;;
+
+// Get significand of x.  Will be used to get index to fetch T, Tt.
+{ .mfi
+          getf.sig      pow_GR_sig_X    = f8
+          frcpa.s1      POW_B, p6       = f1,f8
+          mov           pow_GR_exp_half = 0xFFFE   // Exponent for 0.5
+}
+{ .mfi
+          ld8 pow_AD_P = [pow_AD_P]
+          fma.s1        POW_NORM_X      = f8,f1,f0
+          mov          pow_GR_exp_2tom8 = 0xFFF7
+}
+;;
+
+// DOUBLE 0x10033  exponent limit at which y is an integer
+{ .mfi
+          nop.m 999
+          fcmp.lt.s1 p8,p9 = f8, f0     // Test for x<0
+          addl pow_GR_10033             = 0x10033, r0
+}
+{ .mfi
+          mov           pow_GR_16ones   = 0xFFFF
+          fma.s1        POW_NORM_Y      = f9,f1,f0
+          nop.i 999
+}
+;;
+
+// p13 = TRUE ==> X is unorm
+{ .mfi
+          setf.exp      POW_Q0_half     = pow_GR_exp_half  // Form 0.5
+          fclass.m  p13,p0              = f8, 0x0b  // Test for x unorm
+          adds          pow_AD_Tt       = pow_Tt - pow_table_P,  pow_AD_P
+}
+{ .mfi
+          adds          pow_AD_Q        = pow_table_Q - pow_table_P,  pow_AD_P
+          nop.f 999
+          nop.i 999
+}
+;;
+
+// p14 = TRUE ==> X is ZERO
+{ .mfi
+          ldfe          POW_P2          = [pow_AD_Q], 16
+          fclass.m  p14,p0              = f8, 0x07
+          nop.i 999
+}
+// Note POW_Xm1 and POW_r1 are used interchangeably
+{ .mfb
+          nop.m 999
+(p8)      fnma.s1        POW_Xm1        = POW_Xp1,f1,f0
+(p13)     br.cond.spnt POW_X_DENORM
+}
+;;
+
+// Continue normal and denormal paths here
+POW_COMMON:
+// p11 = TRUE ==> Y is a NAN
+{ .mfi
+          and           pow_GR_exp_X    = pow_GR_signexp_X, pow_GR_17ones
+          fclass.m  p11,p0              = f9, 0xc3
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fms.s1        POW_r           = POW_B, POW_NORM_X,f1
+          mov pow_GR_y_zero = 0
+}
+;;
+
+// Get exponent of |x|-1 to use in comparison to 2^-8
+{ .mmi
+          getf.exp  pow_GR_signexp_Xm1  = POW_Xm1
+          sub       pow_GR_true_exp_X   = pow_GR_exp_X, pow_GR_16ones
+          extr.u        pow_GR_offset   = pow_GR_sig_X, 55, 8
+}
+;;
+
+{ .mfi
+          alloc         r32=ar.pfs,2,19,4,0
+          fcvt.fx.s1   POW_int_Y        = POW_NORM_Y
+          shladd pow_AD_Tt = pow_GR_offset, 3, pow_AD_Tt
+}
+{ .mfi
+          setf.sig POW_int_K            = pow_GR_true_exp_X
+          nop.f 999
+          nop.i 999
+}
+;;
+
+// p12 = TRUE if Y is ZERO
+// Compute xsq to decide later if |x|=1
+{ .mfi
+          ldfe          POW_P1          = [pow_AD_P], 16
+          fclass.m      p12,p0          = f9, 0x07
+          nop.i 999
+}
+{ .mfb
+          ldfe          POW_P0          = [pow_AD_Q], 16
+          fma.s1        POW_xsq = POW_NORM_X, POW_NORM_X, f0
+(p11)     br.cond.spnt  POW_Y_NAN       // Branch if y=nan
+}
+;;
+
+{ .mmf
+          getf.exp  pow_GR_signexp_Y    = POW_NORM_Y
+          ldfd  POW_T                   = [pow_AD_Tt]
+          fma.s1        POW_rsq         = POW_r, POW_r,f0
+}
+;;
+
+// p11 = TRUE ==> X is a NAN
+{ .mfi
+          ldfpd         POW_log2_hi, POW_log2_lo  = [pow_AD_Q], 16
+          fclass.m      p11,p0          = POW_NORM_X, 0xc3
+          nop.i 999
+}
+{ .mfi
+          ldfe          POW_inv_log2_by_128 = [pow_AD_P], 16
+          fma.s1 POW_delta              = f0,f0,f0 // delta=0 in case |x| near 1
+(p12)     mov pow_GR_y_zero = 1
+}
+;;
+
+{ .mfi
+          ldfd   POW_Q2                 = [pow_AD_P], 16
+          fnma.s1 POW_twoV              = POW_r, POW_Q0_half,f1
+          and       pow_GR_exp_Xm1      = pow_GR_signexp_Xm1, pow_GR_17ones
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_U                  = POW_NORM_Y,POW_r,f0
+          nop.i 999
+}
+;;
+
+// Determine if we will use the |x| near 1 path (p6) or normal path (p7)
+{ .mfi
+          nop.m 999
+          fcvt.xf POW_K                 = POW_int_K
+          cmp.lt p6,p7                  = pow_GR_exp_Xm1, pow_GR_exp_2tom8
+}
+{ .mfb
+          nop.m 999
+          fma.s1 POW_G                  = f0,f0,f0  // G=0 in case |x| near 1
+(p11)     br.cond.spnt  POW_X_NAN       // Branch if x=nan and y not nan
+}
+;;
+
+// If on the x near 1 path, assign r1 to r
+{ .mfi
+          ldfpd  POW_Q1, POW_RSHF       = [pow_AD_P], 16
+(p6)      fma.s1    POW_r               = POW_r1, f1, f0
+          nop.i 999
+}
+{ .mfb
+          nop.m 999
+(p6)      fma.s1    POW_rsq             = POW_r1, POW_r1, f0
+(p14)     br.cond.spnt POW_X_0          // Branch if x zero and y not nan
+}
+;;
+
+{ .mfi
+          getf.sig pow_GR_sig_int_Y     = POW_int_Y
+(p6)      fnma.s1 POW_twoV              = POW_r1, POW_Q0_half,f1
+          and pow_GR_exp_Y              = pow_GR_signexp_Y, pow_GR_17ones
+}
+{ .mfb
+          andcm pow_GR_sign_Y           = pow_GR_signexp_Y, pow_GR_17ones
+(p6)      fma.s1 POW_U                  = POW_NORM_Y,POW_r1,f0
+(p12)     br.cond.spnt POW_Y_0   // Branch if y=zero, x not zero or nan
+}
+;;
+
+{ .mfi
+          ldfe      POW_log2_by_128_lo  = [pow_AD_P], 16
+(p7)      fma.s1 POW_Z2                 = POW_twoV, POW_U, f0
+          nop.i 999
+}
+{ .mfi
+          ldfe      POW_log2_by_128_hi  = [pow_AD_Q], 16
+          nop.f 999
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fcvt.xf   POW_float_int_Y     = POW_int_Y
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+(p7)      fma.s1 POW_G                  = POW_K, POW_log2_hi, POW_T
+          adds          pow_AD_tbl1     = pow_tbl1 - pow_Tt,  pow_AD_Q
+}
+;;
+
+// p11 = TRUE ==> X is NEGATIVE but not inf
+{ .mfi
+          nop.m 999
+          fclass.m  p11,p0              = POW_NORM_X, 0x1a
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+(p7)      fma.s1 POW_delta              = POW_K, POW_log2_lo, f0
+          adds pow_AD_tbl2              = pow_tbl2 - pow_tbl1,  pow_AD_tbl1
+}
+;;
+
+{ .mfi
+          nop.m 999
+(p6)      fma.s1 POW_Z                  = POW_twoV, POW_U, f0
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_v2                 = POW_P1, POW_r,  POW_P0
+          nop.i 999
+}
+;;
+
+// p11 = TRUE ==> X is NEGATIVE but not inf
+//    p12 = TRUE ==> X is NEGATIVE  AND  Y  already even int
+//    p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
+{ .mfi
+          nop.m 999
+(p7)      fma.s1 POW_Z                  = POW_NORM_Y, POW_G, POW_Z2
+(p11)     cmp.gt.unc  p12,p13           = pow_GR_exp_Y, pow_GR_10033
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_Gpr                = POW_G, f1, POW_r
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_Yrcub              = POW_rsq, POW_U, f0
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_p                  = POW_rsq, POW_P2, POW_v2
+          nop.i 999
+}
+;;
+
+// Test if x inf
+{ .mfi
+          nop.m 999
+          fclass.m p15,p0 = POW_NORM_X,  0x23
+          nop.i 999
+}
+// By adding RSHF (1.1000...*2^63) we put integer part in rightmost significand
+{ .mfi
+          nop.m 999
+          fma.s1 POW_W1  = POW_Z, POW_inv_log2_by_128, POW_RSHF
+          nop.i 999
+}
+;;
+
+// p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
+//     p10 = TRUE ==> X is NEG and Y is an int
+//     p12 = TRUE ==> X is NEG and Y is not an int
+{ .mfi
+          nop.m 999
+(p13)     fcmp.eq.unc.s1 p10,p12        = POW_float_int_Y,  POW_NORM_Y
+          mov pow_GR_xneg_yodd = 0
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_Y_Gpr              = POW_NORM_Y, POW_Gpr, f0
+          nop.i 999
+}
+;;
+
+// p11 = TRUE ==> X is +1.0
+{ .mfi
+          nop.m 999
+          fcmp.eq.s1 p11,p0 = POW_NORM_X, f1
+          nop.i 999
+}
+;;
+
+// Extract rounded integer from rightmost significand of POW_W1
+// By subtracting RSHF we get rounded integer POW_Nfloat
+{ .mfi
+          getf.sig pow_GR_int_N        = POW_W1
+          fms.s1 POW_Nfloat  = POW_W1, f1, POW_RSHF
+          nop.i 999
+}
+{ .mfb
+          nop.m 999
+          fma.s1 POW_Z3                 = POW_p, POW_Yrcub, f0
+(p12)     br.cond.spnt POW_X_NEG_Y_NONINT  // Branch if x neg, y not integer
+}
+;;
+
+// p7  = TRUE ==> Y is +1.0
+// p12 = TRUE ==> X is NEGATIVE  AND Y is an odd integer
+{ .mfi
+          getf.exp pow_GR_signexp_Y_Gpr = POW_Y_Gpr
+          fcmp.eq.s1 p7,p0 = POW_NORM_Y, f1  // Test for y=1.0
+(p10)     tbit.nz.unc  p12,p0           = pow_GR_sig_int_Y,0
+}
+{ .mfb
+          nop.m 999
+(p11)     fma.s.s0 f8 = f1,f1,f0    // If x=1, result is +1
+(p15)     br.cond.spnt POW_X_INF
+}
+;;
+
+// Test x and y and flag denormal
+{ .mfi
+          nop.m 999
+          fcmp.eq.s0 p15,p0 = f8,f9
+          nop.i 999
+}
+{ .mfb
+          nop.m 999
+          fma.s1 POW_e3                 = POW_NORM_Y, POW_delta, f0
+(p11)     br.ret.spnt b0            // Early exit if x=1.0, result is +1
+}
+;;
+
+{ .mfi
+(p12)     mov pow_GR_xneg_yodd = 1
+          fnma.s1 POW_f12  = POW_Nfloat, POW_log2_by_128_lo, f1
+          nop.i 999
+}
+{ .mfb
+          nop.m 999
+          fnma.s1 POW_s  = POW_Nfloat, POW_log2_by_128_hi, POW_Z
+(p7)      br.ret.spnt b0        // Early exit if y=1.0, result is x
+}
+;;
+
+{ .mmi
+          and pow_GR_index1             = 0x0f, pow_GR_int_N
+          and pow_GR_index2             = 0x70, pow_GR_int_N
+          shr pow_int_GR_M              = pow_GR_int_N, 7    // M = N/128
+}
+;;
+
+{ .mfi
+          shladd pow_AD_T1              = pow_GR_index1, 4, pow_AD_tbl1
+          fma.s1 POW_q                  = POW_Z3, POW_Q1, POW_Q0_half
+          add pow_int_GR_M              = pow_GR_16ones, pow_int_GR_M
+}
+{ .mfi
+          add pow_AD_T2                 = pow_AD_tbl2, pow_GR_index2
+          fma.s1 POW_Z3sq               = POW_Z3, POW_Z3, f0
+          nop.i 999
+}
+;;
+
+{ .mmi
+          ldfe POW_T1                   = [pow_AD_T1]
+          ldfe POW_T2                   = [pow_AD_T2]
+          nop.i 999
+}
+;;
+
+// f123 = f12*(e3+1) = f12*e3+f12
+{ .mfi
+          setf.exp POW_2M               = pow_int_GR_M
+          fma.s1 POW_f123               = POW_e3,POW_f12,POW_f12
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_ssq                = POW_s, POW_s, f0
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_v2                 = POW_s, POW_Q2, POW_Q1
+          and pow_GR_exp_Y_Gpr          = pow_GR_signexp_Y_Gpr, pow_GR_17ones
+}
+;;
+
+{ .mfi
+          cmp.ne p12,p13 = pow_GR_xneg_yodd, r0
+          fma.s1 POW_q                  = POW_Z3sq, POW_q, POW_Z3
+          sub pow_GR_true_exp_Y_Gpr     = pow_GR_exp_Y_Gpr, pow_GR_16ones
+}
+;;
+
+// p8 TRUE ==> |Y(G + r)| >= 7
+
+// single
+//     -2^7   -2^6             2^6   2^7
+// -----+-----+----+ ... +-----+-----+-----
+//  p8  |             p9             |  p8
+//      |     |       p10      |     |
+
+// Form signexp of constants to indicate overflow
+{ .mfi
+          mov         pow_GR_big_pos    = 0x1007f
+          nop.f 999
+          cmp.le p8,p9                  = 7, pow_GR_true_exp_Y_Gpr
+}
+{ .mfi
+          mov         pow_GR_big_neg    = 0x3007f
+          nop.f 999
+          andcm pow_GR_sign_Y_Gpr       = pow_GR_signexp_Y_Gpr, pow_GR_17ones
+}
+;;
+
+// Form big positive and negative constants to test for possible overflow
+// Scale both terms of the polynomial by POW_f123
+{ .mfi
+          setf.exp POW_big_pos          = pow_GR_big_pos
+          fma.s1 POW_ssq                = POW_ssq, POW_f123, f0
+(p9)      cmp.le.unc p0,p10             = 6, pow_GR_true_exp_Y_Gpr
+}
+{ .mfb
+          setf.exp POW_big_neg          = pow_GR_big_neg
+          fma.s1 POW_1ps                = POW_s, POW_f123, POW_f123
+(p8)      br.cond.spnt POW_OVER_UNDER_X_NOT_INF
+}
+;;
+
+{ .mfi
+          nop.m 999
+(p12)     fnma.s1 POW_T1T2              = POW_T1, POW_T2, f0
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+(p13)     fma.s1 POW_T1T2               = POW_T1, POW_T2, f0
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_v210               = POW_s, POW_v2, POW_Q0_half
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_2Mqp1              = POW_2M, POW_q, POW_2M
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fma.s1 POW_es                 = POW_ssq, POW_v210, POW_1ps
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+          fma.s1 POW_A                  = POW_T1T2, POW_2Mqp1, f0
+          nop.i 999
+}
+;;
+
+// Dummy op to set inexact
+{ .mfi
+          nop.m 999
+          fma.s0 POW_tmp                = POW_2M, POW_q, POW_2M
+          nop.i 999
+}
+;;
+
+{ .mfb
+          nop.m 999
+          fma.s.s0 f8                   = POW_A, POW_es, f0
+(p10)     br.ret.sptk     b0            // Exit main branch if no over/underflow
+}
+;;
+
+// POSSIBLE_OVER_UNDER
+// p6 = TRUE ==> Y_Gpr negative
+// Result is already computed.  We just need to know if over/underflow occurred.
+
+{ .mfb
+        cmp.eq p0,p6                    = pow_GR_sign_Y_Gpr, r0
+        nop.f 999
+(p6)    br.cond.spnt POW_POSSIBLE_UNDER
+}
+;;
+
+// POSSIBLE_OVER
+// We got an answer.
+// overflow is a possibility, not a certainty
+
+
+// We define an overflow when the answer with
+//    WRE set
+//    user-defined rounding mode
+
+// double
+// Largest double is 7FE (biased double)
+//                   7FE - 3FF + FFFF = 103FE
+// Create + largest_double_plus_ulp
+// Create - largest_double_plus_ulp
+// Calculate answer with WRE set.
+
+// single
+// Largest single is FE (biased double)
+//                   FE - 7F + FFFF = 1007E
+// Create + largest_single_plus_ulp
+// Create - largest_single_plus_ulp
+// Calculate answer with WRE set.
+
+// Cases when answer is ldn+1  are as follows:
+//  ldn                   ldn+1
+// --+----------|----------+------------
+//              |
+//    +inf          +inf      -inf
+//                  RN         RN
+//                             RZ
+
+// Put in s2 (td set, wre set)
+{ .mfi
+        nop.m 999
+        fsetc.s2 0x7F,0x42
+        nop.i 999
+}
+;;
+
+{ .mfi
+        nop.m 999
+        fma.s.s2 POW_wre_urm_f8         = POW_A, POW_es, f0
+        nop.i 999
+}
+;;
+
+// Return s2 to default
+{ .mfi
+        nop.m 999
+        fsetc.s2 0x7F,0x40
+        nop.i 999
+}
+;;
+
+// p7 = TRUE ==> yes, we have an overflow
+{ .mfi
+        nop.m 999
+        fcmp.ge.s1 p7, p8               =  POW_wre_urm_f8, POW_big_pos
+        nop.i 999
+}
+;;
+
+{ .mfi
+        nop.m 999
+(p8)    fcmp.le.s1 p7, p0               =  POW_wre_urm_f8, POW_big_neg
+        nop.i 999
+}
+;;
+
+{ .mbb
+(p7)   mov pow_GR_tag                   = 30
+(p7)   br.cond.spnt __libm_error_region // Branch if overflow
+       br.ret.sptk     b0               // Exit if did not overflow
+}
+;;
+
+
+POW_POSSIBLE_UNDER:
+// We got an answer. input was < -2^9 but > -2^10 (double)
+// We got an answer. input was < -2^6 but > -2^7  (float)
+// underflow is a possibility, not a certainty
+
+// We define an underflow when the answer with
+//    ftz set
+// is zero (tiny numbers become zero)
+// Notice (from below) that if we have an unlimited exponent range,
+// then there is an extra machine number E between the largest denormal and
+// the smallest normal.
+// So if with unbounded exponent we round to E or below, then we are
+// tiny and underflow has occurred.
+// But notice that you can be in a situation where we are tiny, namely
+// rounded to E, but when the exponent is bounded we round to smallest
+// normal. So the answer can be the smallest normal with underflow.
+//                           E
+// -----+--------------------+--------------------+-----
+//      |                    |                    |
+//   1.1...10 2^-3fff    1.1...11 2^-3fff    1.0...00 2^-3ffe
+//   0.1...11 2^-3ffe                                   (biased, 1)
+//    largest dn                               smallest normal
+
+// Form small constant (2^-170) to correct underflow result near region of
+// smallest denormal in round-nearest.
+
+// Put in s2 (td set, ftz set)
+.pred.rel "mutex",p12,p13
+{ .mfi
+        mov pow_GR_Fpsr = ar40          // Read the fpsr--need to check rc.s0
+        fsetc.s2 0x7F,0x41
+        mov pow_GR_rcs0_mask            = 0x0c00 // Set mask for rc.s0
+}
+{ .mfi
+(p12)   mov pow_GR_tmp                  = 0x2ffff - 170
+        nop.f 999
+(p13)   mov pow_GR_tmp                  = 0x0ffff - 170
+}
+;;
+
+{ .mfi
+        setf.exp POW_eps                = pow_GR_tmp        // Form 2^-170
+        fma.s.s2 POW_ftz_urm_f8         = POW_A, POW_es, f0
+        nop.i 999
+}
+;;
+
+// Return s2 to default
+{ .mfi
+        nop.m 999
+        fsetc.s2 0x7F,0x40
+        nop.i 999
+}
+;;
+
+// p7 = TRUE ==> yes, we have an underflow
+{ .mfi
+        nop.m 999
+        fcmp.eq.s1 p7, p0               =  POW_ftz_urm_f8, f0
+        nop.i 999
+}
+;;
+
+{ .mmi
+(p7)    and pow_GR_rcs0  = pow_GR_rcs0_mask, pow_GR_Fpsr  // Isolate rc.s0
+;;
+(p7)    cmp.eq.unc p6,p0 = pow_GR_rcs0, r0    // Test for round to nearest
+        nop.i 999
+}
+;;
+
+// Tweak result slightly if underflow to get correct rounding near smallest
+// denormal if round-nearest
+{ .mfi
+        nop.m 999
+(p6)    fms.s.s0 f8                     = POW_A, POW_es, POW_eps
+        nop.i 999
+}
+{ .mbb
+(p7)    mov pow_GR_tag                  = 31
+(p7)    br.cond.spnt __libm_error_region // Branch if underflow
+        br.ret.sptk     b0               // Exit if did not underflow
+}
+;;
+
+POW_X_DENORM:
+// Here if x unorm. Use the NORM_X for getf instructions, and then back
+// to normal path
+{ .mfi
+        getf.exp      pow_GR_signexp_X  = POW_NORM_X
+        nop.f 999
+        nop.i 999
+}
+;;
+
+{ .mib
+        getf.sig      pow_GR_sig_X      = POW_NORM_X
+        nop.i 999
+        br.cond.sptk    POW_COMMON
+}
+;;
+
+POW_X_0:
+// Here if x=0 and y not nan
+//
+// We have the following cases:
+//  p6  x=0  and  y>0 and is an integer (may be even or odd)
+//  p7  x=0  and  y>0 and is NOT an integer, return +0
+//  p8  x=0  and  y>0 and so big as to always be an even integer, return +0
+//  p9  x=0  and  y>0 and may not be integer
+//  p10 x=0  and  y>0 and is an odd  integer, return x
+//  p11 x=0  and  y>0 and is an even integer, return +0
+//  p12 used in dummy fcmp to set denormal flag if y=unorm
+//  p13 x=0  and  y>0
+//  p14 x=0  and  y=0, branch to code for calling error handling
+//  p15 x=0  and  y<0, branch to code for calling error handling
+//
+{ .mfi
+        getf.sig pow_GR_sig_int_Y = POW_int_Y // Get signif of int_Y
+        fcmp.lt.s1 p15,p13 = f9, f0           // Test for y<0
+        and pow_GR_exp_Y = pow_GR_signexp_Y, pow_GR_17ones
+}
+{ .mfb
+        cmp.ne p14,p0 = pow_GR_y_zero,r0      // Test for y=0
+        fcvt.xf   POW_float_int_Y = POW_int_Y
+(p14)   br.cond.spnt POW_X_0_Y_0              // Branch if x=0 and y=0
+}
+;;
+
+// If x=0 and y>0, test y and flag denormal
+{ .mfb
+(p13)   cmp.gt.unc p8,p9 = pow_GR_exp_Y, pow_GR_10033 // Test y +big = even int
+(p13)   fcmp.eq.s0 p12,p0 = f9,f0    // If x=0, y>0 dummy op to flag denormal
+(p15)   br.cond.spnt POW_X_0_Y_NEG // Branch if x=0 and y<0
+}
+;;
+
+// Here if x=0 and y>0
+{ .mfi
+        nop.m 999
+(p9)    fcmp.eq.unc.s1 p6,p7 = POW_float_int_Y,  POW_NORM_Y // Test y=int
+        nop.i 999
+}
+{ .mfi
+        nop.m 999
+(p8)    fma.s.s0 f8 = f0,f0,f0 // If x=0, y>0 and large even int, return +0
+        nop.i 999
+}
+;;
+
+{ .mfi
+        nop.m 999
+(p7)    fma.s.s0 f8  = f0,f0,f0   // Result +0 if x=0 and y>0 and not integer
+(p6)    tbit.nz.unc p10,p11 = pow_GR_sig_int_Y,0 // If y>0 int, test y even/odd
+}
+;;
+
+// Note if x=0, y>0 and odd integer, just return x
+{ .mfb
+        nop.m 999
+(p11)   fma.s.s0 f8  = f0,f0,f0   // Result +0 if x=0 and y even integer
+        br.ret.sptk b0            // Exit if x=0 and y>0
+}
+;;
+
+POW_X_0_Y_0:
+// When X is +-0 and Y is +-0, IEEE returns 1.0
+// We call error support with this value
+
+{ .mfb
+        mov pow_GR_tag                  = 32
+        fma.s.s0 f8                     = f1,f1,f0
+        br.cond.sptk __libm_error_region
+}
+;;
+
+POW_X_0_Y_NEG:
+// When X is +-0 and Y is negative, IEEE returns
+// X     Y           answer
+// +0    -odd int    +inf
+// -0    -odd int    -inf
+
+// +0    !-odd int   +inf
+// -0    !-odd int   +inf
+
+// p6 == Y is a floating point number outside the integer.
+//       Hence it is an integer and is even.
+//       return +inf
+
+// p7 == Y is a floating point number within the integer range.
+//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
+//           p11 odd
+//              return (sign_of_x)inf
+//           p12 even
+//              return +inf
+//      p10 == Y is not an integer
+//         return +inf
+//
+
+{ .mfi
+          nop.m 999
+          nop.f 999
+          cmp.gt  p6,p7                 = pow_GR_exp_Y, pow_GR_10033
+}
+;;
+
+{ .mfi
+          mov pow_GR_tag                = 33
+(p7)      fcmp.eq.unc.s1 p9,p10         = POW_float_int_Y,  POW_NORM_Y
+          nop.i 999
+}
+;;
+
+{ .mfb
+          nop.m 999
+(p6)      frcpa.s0 f8,p13               = f1, f0
+(p6)      br.cond.sptk __libm_error_region   // x=0, y<0, y large neg int
+}
+;;
+
+{ .mfb
+          nop.m 999
+(p10)     frcpa.s0 f8,p13               = f1, f0
+(p10)     br.cond.sptk __libm_error_region   // x=0, y<0, y not int
+}
+;;
+
+// x=0, y<0, y an int
+{ .mib
+          nop.m 999
+(p9)      tbit.nz.unc p11,p12           = pow_GR_sig_int_Y,0
+          nop.b 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+(p12)     frcpa.s0 f8,p13               = f1,f0
+          nop.i 999
+}
+;;
+
+{ .mfb
+          nop.m 999
+(p11)     frcpa.s0 f8,p13               = f1,f8
+          br.cond.sptk __libm_error_region
+}
+;;
+
+
+POW_Y_0:
+// Here for y zero, x anything but zero and nan
+// Set flag if x denormal
+// Result is +1.0
+{ .mfi
+        nop.m 999
+        fcmp.eq.s0 p6,p0 = f8,f0    // Sets flag if x denormal
+        nop.i 999
+}
+{ .mfb
+        nop.m 999
+        fma.s.s0 f8 = f1,f1,f0
+        br.ret.sptk b0
+}
+;;
+
+
+POW_X_INF:
+// Here when X is +-inf
+
+// X +inf  Y +inf             +inf
+// X -inf  Y +inf             +inf
+
+// X +inf  Y >0               +inf
+// X -inf  Y >0, !odd integer +inf     <== (-inf)^0.5 = +inf !!
+// X -inf  Y >0,  odd integer -inf
+
+// X +inf  Y -inf             +0
+// X -inf  Y -inf             +0
+
+// X +inf  Y <0               +0
+// X -inf  Y <0, !odd integer +0
+// X -inf  Y <0, odd integer  -0
+
+// X + inf Y=+0                +1
+// X + inf Y=-0                +1
+// X - inf Y=+0                +1
+// X - inf Y=-0                +1
+
+// p13 == Y negative
+// p14 == Y positive
+
+// p6 == Y is a floating point number outside the integer.
+//       Hence it is an integer and is even.
+//       p13 == (Y negative)
+//          return +inf
+//       p14 == (Y positive)
+//          return +0
+
+// p7 == Y is a floating point number within the integer range.
+//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
+//           p11 odd
+//              p13 == (Y negative)
+//                 return (sign_of_x)inf
+//              p14 == (Y positive)
+//                 return (sign_of_x)0
+//           pxx even
+//              p13 == (Y negative)
+//                 return +inf
+//              p14 == (Y positive)
+//                 return +0
+
+//      pxx == Y is not an integer
+//           p13 == (Y negative)
+//                 return +inf
+//           p14 == (Y positive)
+//                 return +0
+//
+
+// If x=inf, test y and flag denormal
+{ .mfi
+          nop.m 999
+          fcmp.eq.s0 p10,p11 = f9,f0
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fcmp.lt.s0 p13,p14            = POW_NORM_Y,f0
+          cmp.gt  p6,p7                 = pow_GR_exp_Y, pow_GR_10033
+}
+{ .mfi
+          nop.m 999
+          fclass.m p12,p0               = f9, 0x23 //@inf
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          fclass.m p15,p0               = f9, 0x07 //@zero
+          nop.i 999
+}
+;;
+
+{ .mfb
+          nop.m 999
+(p15)     fmerge.s f8 = f1,f1      // Return +1.0 if x=inf, y=0
+(p15)     br.ret.spnt b0           // Exit if x=inf, y=0
+}
+;;
+
+{ .mfi
+          nop.m 999
+(p14)     frcpa.s1 f8,p10 = f1,f0  // If x=inf, y>0, assume result +inf
+          nop.i 999
+}
+{ .mfb
+          nop.m 999
+(p13)     fma.s.s0 f8 = f0,f0,f0   // If x=inf, y<0, assume result +0.0
+(p12)     br.ret.spnt b0           // Exit if x=inf, y=inf
+}
+;;
+
+// Here if x=inf, and 0 < |y| < inf.  Need to correct results if y odd integer.
+{ .mfi
+          nop.m 999
+(p7)      fcmp.eq.unc.s1 p9,p0 = POW_float_int_Y,  POW_NORM_Y // Is y integer?
+          nop.i 999
+}
+;;
+
+{ .mfi
+          nop.m 999
+          nop.f 999
+(p9)      tbit.nz.unc p11,p0 = pow_GR_sig_int_Y,0  // Test for y odd integer
+}
+;;
+
+{ .mfb
+          nop.m 999
+(p11)     fmerge.s f8 = POW_NORM_X,f8    // If y odd integer use sign of x
+          br.ret.sptk b0                 // Exit for x=inf, 0 < |y| < inf
+}
+;;
+
+
+POW_X_NEG_Y_NONINT:
+// When X is negative and Y is a non-integer, IEEE
+// returns a qnan indefinite.
+// We call error support with this value
+
+{ .mfb
+         mov pow_GR_tag                 = 34
+         frcpa.s0 f8,p6                 = f0,f0
+         br.cond.sptk __libm_error_region
+}
+;;
+
+POW_X_NAN:
+// Here if x=nan, y not nan
+{ .mfi
+         nop.m 999
+         fclass.m  p9,p13 = f9, 0x07 // Test y=zero
+         nop.i 999
+}
+;;
+
+{ .mfb
+         nop.m 999
+(p13)    fma.s.s0 f8 = f8,f1,f0
+(p13)    br.ret.sptk  b0            // Exit if x nan, y anything but zero or nan
+}
+;;
+
+POW_X_NAN_Y_0:
+// When X is a NAN and Y is zero, IEEE returns 1.
+// We call error support with this value.
+{ .mfi
+         nop.m 999
+         fcmp.eq.s0 p6,p0 = f8,f0       // Dummy op to set invalid on snan
+         nop.i 999
+}
+{ .mfb
+         mov pow_GR_tag                 = 35
+         fma.s.s0 f8 = f0,f0,f1
+         br.cond.sptk __libm_error_region
+}
+;;
+
+
+POW_OVER_UNDER_X_NOT_INF:
+
+// p8 is TRUE for overflow
+// p9 is TRUE for underflow
+
+// if y is infinity, we should not over/underflow
+
+{ .mfi
+          nop.m 999
+          fcmp.eq.s1     p14, p13       = POW_xsq,f1  // Test |x|=1
+          cmp.eq p8,p9                  = pow_GR_sign_Y_Gpr, r0
+}
+;;
+
+{ .mfi
+          nop.m 999
+(p14)     fclass.m.unc       p15, p0    = f9, 0x23 // If |x|=1, test y=inf
+          nop.i 999
+}
+{ .mfi
+          nop.m 999
+(p13)     fclass.m.unc       p11,p0     = f9, 0x23 // If |x| not 1, test y=inf
+          nop.i 999
+}
+;;
+
+// p15 = TRUE if |x|=1, y=inf, return +1
+{ .mfb
+          nop.m 999
+(p15)     fma.s.s0          f8          = f1,f1,f0 // If |x|=1, y=inf, result +1
+(p15)     br.ret.spnt b0                // Exit if |x|=1, y=inf
+}
+;;
+
+.pred.rel "mutex",p8,p9
+{  .mfb
+(p8)      setf.exp           f8 = pow_GR_17ones // If exp(+big), result inf
+(p9)      fmerge.s           f8 = f0,f0         // If exp(-big), result 0
+(p11)     br.ret.sptk b0                // Exit if |x| not 1, y=inf
+}
+;;
+
+{ .mfb
+          nop.m 999
+          nop.f 999
+          br.cond.sptk POW_OVER_UNDER_ERROR // Branch if y not inf
+}
+;;
+
+
+POW_Y_NAN:
+// Here if y=nan, x anything
+// If x = +1 then result is +1, else result is quiet Y
+{ .mfi
+       nop.m 999
+       fcmp.eq.s1         p10,p9        = POW_NORM_X, f1
+       nop.i 999
+}
+;;
+
+{ .mfi
+       nop.m 999
+(p10)  fcmp.eq.s0 p6,p0 = f9,f1   // Set invalid, even if x=+1
+       nop.i 999
+}
+;;
+
+{ .mfi
+       nop.m 999
+(p10)  fma.s.s0 f8 = f1,f1,f0
+       nop.i 999
+}
+{ .mfb
+       nop.m 999
+(p9)   fma.s.s0 f8 = f9,f8,f0
+       br.ret.sptk b0             // Exit y=nan
+}
+;;
+
+
+POW_OVER_UNDER_ERROR:
+// Here if we have overflow or underflow.
+// Enter with p12 true if x negative and y odd int to force -0 or -inf
+
+{ .mfi
+         sub   pow_GR_17ones_m1         = pow_GR_17ones, r0, 1
+         nop.f 999
+         mov pow_GR_one                 = 0x1
+}
+;;
+
+// overflow, force inf with O flag
+{ .mmb
+(p8)     mov pow_GR_tag                 = 30
+(p8)     setf.exp POW_tmp               = pow_GR_17ones_m1
+         nop.b 999
+}
+;;
+
+// underflow, force zero with I, U flags
+{ .mmi
+(p9)    mov pow_GR_tag                  = 31
+(p9)    setf.exp POW_tmp                = pow_GR_one
+        nop.i 999
+}
+;;
+
+{ .mfi
+        nop.m 999
+        fma.s.s0 f8                     = POW_tmp, POW_tmp, f0
+        nop.i 999
+}
+;;
+
+// p12 x is negative and y is an odd integer, change sign of result
+{ .mfi
+        nop.m 999
+(p12)   fnma.s.s0 f8                    = POW_tmp, POW_tmp, f0
+        nop.i 999
+}
+;;
+
+WEAK_LIBM_END(powf)
+libm_alias_float_other (__pow, pow)
+#ifdef SHARED
+.symver powf,powf@@GLIBC_2.27
+.weak __powf_compat
+.set __powf_compat,__powf
+.symver __powf_compat,powf@GLIBC_2.2
+#endif
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp     // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs         // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                   // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp               // Save gp
+};;
+
+{ .mmi
+        stfs [GR_Parameter_Y] = POW_NORM_Y,16 // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp      // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0               // Save b0
+};;
+
+.body
+{ .mib
+        stfs [GR_Parameter_X] = POW_NORM_X // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y    // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfs [GR_Parameter_Y] = f8      // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support# // Call error handling function
+};;
+
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+
+{ .mmi
+        ldfs  f8 = [GR_Parameter_RESULT] // Get return result off stack
+.restore sp
+        add   sp = 64,sp                 // Restore stack pointer
+        mov   b0 = GR_SAVE_B0            // Restore return address
+};;
+
+{ .mib
+        mov   gp = GR_SAVE_GP            // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS       // Restore ar.pfs
+        br.ret.sptk     b0               // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_powf_log2_data.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_powl.S
@@ -0,0 +1,2810 @@
+.file "powl.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// Function:   powl(x,y), where
+//                          y
+//             powl(x,y) = x , for double extended precision x and y values
+//
+//*********************************************************************
+//
+// History:
+// 02/02/00 (Hand Optimized)
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 01/22/01 Corrected results for powl(1,inf), powl(1,nan), and
+//          powl(snan,0) to be 1 per C99, not nan.  Fixed many flag settings.
+// 02/06/01 Call __libm_error support if over/underflow when y=2.
+// 04/17/01 Support added for y close to 1 and x a non-special value.
+//          Shared software under/overflow detection for all paths
+// 02/07/02 Corrected sf3 setting to disable traps
+// 05/13/02 Improved performance of all paths
+// 02/10/03 Reordered header: .section, .global, .proc, .align;
+//          used data8 for long double table values
+// 04/17/03 Added missing mutex directive
+// 10/13/03 Corrected .endp names to match .proc names
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers:
+//                        f8  (Input x and Return Value)
+//                        f9  (Input y)
+//                        f10-f15,f32-f79
+//
+//    General Purpose Registers:
+//                        Locals r14-24,r32-r65
+//                        Parameters to __libm_error_support r62,r63,r64,r65
+//
+//    Predicate Registers: p6-p15
+//
+//*********************************************************************
+//
+//  Special Cases and IEEE special conditions:
+//
+//    Denormal fault raised on denormal inputs
+//    Overflow exceptions raised when appropriate for pow
+//    Underflow exceptions raised when appropriate for pow
+//    (Error Handling Routine called for overflow and Underflow)
+//    Inexact raised when appropriate by algorithm
+//
+//  1.  (anything) ** NatVal or (NatVal) ** anything  is NatVal
+//  2.  X or Y unsupported or sNaN                    is qNaN/Invalid
+//  3.  (anything) ** 0  is 1
+//  4.  (anything) ** 1  is itself
+//  5.  (anything except 1) ** qNAN is qNAN
+//  6.  qNAN ** (anything except 0) is qNAN
+//  7.  +-(|x| > 1) **  +INF is +INF
+//  8.  +-(|x| > 1) **  -INF is +0
+//  9.  +-(|x| < 1) **  +INF is +0
+//  10. +-(|x| < 1) **  -INF is +INF
+//  11. +-1         ** +-INF is +1
+//  12. +0 ** (+anything except 0, NAN)               is +0
+//  13. -0 ** (+anything except 0, NAN, odd integer)  is +0
+//  14. +0 ** (-anything except 0, NAN)               is +INF/div_0
+//  15. -0 ** (-anything except 0, NAN, odd integer)  is +INF/div_0
+//  16. -0 ** (odd integer) = -( +0 ** (odd integer) )
+//  17. +INF ** (+anything except 0,NAN) is +INF
+//  18. +INF ** (-anything except 0,NAN) is +0
+//  19. -INF ** (anything except NAN)  = -0 ** (-anything)
+//  20. (-anything) ** (integer) is (-1)**(integer)*(+anything**integer)
+//  21. (-anything except 0 and inf) ** (non-integer) is qNAN/Invalid
+//  22. X or Y denorm/unorm and denorm/unorm operand trap is enabled,
+//      generate denorm/unorm fault except if invalid or div_0 raised.
+//
+//*********************************************************************
+//
+//  Algorithm
+//  =========
+//
+//  Special Cases
+//
+//    If Y = 2,    return X*X.
+//    If Y = 0.5,  return sqrt(X).
+//
+//  Compute log(X) to extra precision.
+//
+//  ker_log_80( X, logX_hi, logX_lo, Safe );
+//
+//   ...logX_hi + logX_lo approximates log(X) to roughly 80
+//   ...significant bits of accuracy.
+//
+//  Compute Y*log(X) to extra precision.
+//
+//    P_hi := Y * logX_hi
+//    P_lo := Y * logX_hi - P_hi       ...using FMA
+//    P_lo := Y * logX_lo + P_lo       ...using FMA
+//
+//  Compute exp(P_hi + P_lo)
+//
+//    Flag := 2;
+//    Expo_Range := 2; (assuming double-extended power function)
+//    ker_exp_64( P_hi, P_lo, Flag, Expo_Range,
+//                Z_hi, Z_lo, scale, Safe )
+//
+//    scale := sgn * scale
+//
+//    If (Safe) then ...result will not over/underflow
+//       return scale*Z_hi + (scale*Z_lo)
+//       quickly
+//    Else
+//       take necessary precaution in computing
+//       scale*Z_hi + (scale*Z_lo)
+//       to set possible exceptions correctly.
+//    End If
+//
+//  Case_Y_Special
+//
+//   ...Follow the order of the case checks
+//
+//   If Y is +-0, return +1 without raising any exception.
+//   If Y is +1,  return X  without raising any exception.
+//   If Y is qNaN, return Y without exception.
+//   If X is qNaN, return X without exception.
+//
+//   At this point, X is real and Y is +-inf.
+//   Thus |X| can only be 1, strictly bigger than 1, or
+//   strictly less than 1.
+//
+//   If |X| < 1, then
+//   return ( Y == +inf?  +0 : +inf )
+//   elseif |X| > 1, then
+//   return ( Y == +inf? +0 : +inf )
+//   else
+//   goto Case_Invalid
+//
+//  Case_X_Special
+//
+//   ...Follow the order of the case checks
+//   ...Note that Y is real, finite, non-zero, and not +1.
+//
+//   If X is qNaN, return X without exception.
+//
+//   If X is +-0,
+//   return ( Y > 0 ? +0 : +inf )
+//
+//   If X is +inf
+//   return ( Y > 0 ? +inf : +0 )
+//
+//   If X is -inf
+//   return -0 ** -Y
+//   return ( Y > 0 ? +inf : +0 )
+//
+//  Case_Invalid
+//
+//   Return 0 * inf to generate a quiet NaN together
+//   with an invalid exception.
+//
+//  Implementation
+//  ==============
+//
+//   We describe the quick branch since this part is important
+//   in reaching the normal case efficiently.
+//
+//  STAGE 1
+//  -------
+//   This stage contains two threads.
+//
+//   Stage1.Thread1
+//
+//     fclass.m   X_excep,  X_ok   = X, (NatVal or s/qNaN) or
+//                              +-0, +-infinity
+//
+//     fclass.nm  X_unsupp, X_supp = X, (NatVal or s/qNaN) or
+//                              +-(0, unnorm, norm, infinity)
+//
+//     X_norm := fnorm( X ) with traps disabled
+//
+//     If (X_excep)  goto Filtering (Step 2)
+//     If (X_unsupp) goto Filtering (Step 2)
+//
+//     Stage1.Thread2
+//     ..............
+//
+//     fclass.m   Y_excep,  Y_ok   = Y, (NatVal or s/qNaN) or
+//                              +-0, +-infinity
+//
+//     fclass.nm  Y_unsupp, Y_supp = Y, (NatVal or s/qNaN) or
+//                              +-(0, unnorm, norm, infinity)
+//
+//     Y_norm := fnorm( Y ) with traps disabled
+//
+//     If (Y_excep)  goto Filtering (Step 2)
+//     If (Y_unsupp) goto Filtering (Step 2)
+//
+//
+//  STAGE 2
+//  -------
+//  This stage contains two threads.
+//
+//     Stage2.Thread1
+//     ..............
+//
+//     Set X_lt_0 if X < 0 (using fcmp)
+//     sgn := +1.0
+//     If (X_lt_0) goto Filtering (Step 2)
+//
+//     Stage2.Thread2
+//     ..............
+//
+//     Set Y_is_1 if Y = +1 (using fcmp)
+//     If (Y_is_1) goto Filtering (Step 2)
+//
+//   STAGE 3
+//   -------
+//   This stage contains two threads.
+//
+//
+//   Stage3.Thread1
+//   ..............
+//
+//     X := fnorm(X) in prevailing traps
+//
+//
+//     Stage3.Thread2
+//     ..............
+//
+//     Y := fnorm(Y) in prevailing traps
+//
+//   STAGE 4
+//   -------
+//
+//   Go to Case_Normal.
+//
+
+
+// ************* DO NOT CHANGE ORDER OF THESE TABLES ********************
+
+// double-extended 1/ln(2)
+// 3fff b8aa 3b29 5c17 f0bb be87fed0691d3e88
+// 3fff b8aa 3b29 5c17 f0bc
+// For speed the significand will be loaded directly with a movl and setf.sig
+//   and the exponent will be bias+63 instead of bias+0.  Thus subsequent
+//   computations need to scale appropriately.
+// The constant 2^12/ln(2) is needed for the computation of N.  This is also
+//   obtained by scaling the computations.
+//
+// Two shifting constants are loaded directly with movl and setf.d.
+//   1. RSHF_2TO51 = 1.1000..00 * 2^(63-12)
+//        This constant is added to x*1/ln2 to shift the integer part of
+//        x*2^12/ln2 into the rightmost bits of the significand.
+//        The result of this fma is N_signif.
+//   2. RSHF       = 1.1000..00 * 2^(63)
+//        This constant is subtracted from N_signif * 2^(-51) to give
+//        the integer part of N, N_fix, as a floating-point number.
+//        The result of this fms is float_N.
+RODATA
+
+.align 16
+// L_hi, L_lo
+LOCAL_OBJECT_START(Constants_exp_64_Arg)
+data8 0xB17217F400000000,0x00003FF2 // L_hi = hi part log(2)/2^12
+data8 0xF473DE6AF278ECE6,0x00003FD4 // L_lo = lo part log(2)/2^12
+LOCAL_OBJECT_END(Constants_exp_64_Arg)
+
+LOCAL_OBJECT_START(Constants_exp_64_A)
+// Reversed
+data8 0xAAAAAAABB1B736A0,0x00003FFA
+data8 0xAAAAAAAB90CD6327,0x00003FFC
+data8 0xFFFFFFFFFFFFFFFF,0x00003FFD
+LOCAL_OBJECT_END(Constants_exp_64_A)
+
+LOCAL_OBJECT_START(Constants_exp_64_P)
+// Reversed
+data8 0xD00D6C8143914A8A,0x00003FF2
+data8 0xB60BC4AC30304B30,0x00003FF5
+data8 0x888888887474C518,0x00003FF8
+data8 0xAAAAAAAA8DAE729D,0x00003FFA
+data8 0xAAAAAAAAAAAAAF61,0x00003FFC
+data8 0x80000000000004C7,0x00003FFE
+LOCAL_OBJECT_END(Constants_exp_64_P)
+
+LOCAL_OBJECT_START(Constants_exp_64_T1)
+data4 0x3F800000,0x3F8164D2,0x3F82CD87,0x3F843A29
+data4 0x3F85AAC3,0x3F871F62,0x3F88980F,0x3F8A14D5
+data4 0x3F8B95C2,0x3F8D1ADF,0x3F8EA43A,0x3F9031DC
+data4 0x3F91C3D3,0x3F935A2B,0x3F94F4F0,0x3F96942D
+data4 0x3F9837F0,0x3F99E046,0x3F9B8D3A,0x3F9D3EDA
+data4 0x3F9EF532,0x3FA0B051,0x3FA27043,0x3FA43516
+data4 0x3FA5FED7,0x3FA7CD94,0x3FA9A15B,0x3FAB7A3A
+data4 0x3FAD583F,0x3FAF3B79,0x3FB123F6,0x3FB311C4
+data4 0x3FB504F3,0x3FB6FD92,0x3FB8FBAF,0x3FBAFF5B
+data4 0x3FBD08A4,0x3FBF179A,0x3FC12C4D,0x3FC346CD
+data4 0x3FC5672A,0x3FC78D75,0x3FC9B9BE,0x3FCBEC15
+data4 0x3FCE248C,0x3FD06334,0x3FD2A81E,0x3FD4F35B
+data4 0x3FD744FD,0x3FD99D16,0x3FDBFBB8,0x3FDE60F5
+data4 0x3FE0CCDF,0x3FE33F89,0x3FE5B907,0x3FE8396A
+data4 0x3FEAC0C7,0x3FED4F30,0x3FEFE4BA,0x3FF28177
+data4 0x3FF5257D,0x3FF7D0DF,0x3FFA83B3,0x3FFD3E0C
+LOCAL_OBJECT_END(Constants_exp_64_T1)
+
+LOCAL_OBJECT_START(Constants_exp_64_T2)
+data4 0x3F800000,0x3F80058C,0x3F800B18,0x3F8010A4
+data4 0x3F801630,0x3F801BBD,0x3F80214A,0x3F8026D7
+data4 0x3F802C64,0x3F8031F2,0x3F803780,0x3F803D0E
+data4 0x3F80429C,0x3F80482B,0x3F804DB9,0x3F805349
+data4 0x3F8058D8,0x3F805E67,0x3F8063F7,0x3F806987
+data4 0x3F806F17,0x3F8074A8,0x3F807A39,0x3F807FCA
+data4 0x3F80855B,0x3F808AEC,0x3F80907E,0x3F809610
+data4 0x3F809BA2,0x3F80A135,0x3F80A6C7,0x3F80AC5A
+data4 0x3F80B1ED,0x3F80B781,0x3F80BD14,0x3F80C2A8
+data4 0x3F80C83C,0x3F80CDD1,0x3F80D365,0x3F80D8FA
+data4 0x3F80DE8F,0x3F80E425,0x3F80E9BA,0x3F80EF50
+data4 0x3F80F4E6,0x3F80FA7C,0x3F810013,0x3F8105AA
+data4 0x3F810B41,0x3F8110D8,0x3F81166F,0x3F811C07
+data4 0x3F81219F,0x3F812737,0x3F812CD0,0x3F813269
+data4 0x3F813802,0x3F813D9B,0x3F814334,0x3F8148CE
+data4 0x3F814E68,0x3F815402,0x3F81599C,0x3F815F37
+LOCAL_OBJECT_END(Constants_exp_64_T2)
+
+LOCAL_OBJECT_START(Constants_exp_64_W1)
+data8 0x0000000000000000, 0xBE384454171EC4B4
+data8 0xBE6947414AA72766, 0xBE5D32B6D42518F8
+data8 0x3E68D96D3A319149, 0xBE68F4DA62415F36
+data8 0xBE6DDA2FC9C86A3B, 0x3E6B2E50F49228FE
+data8 0xBE49C0C21188B886, 0x3E64BFC21A4C2F1F
+data8 0xBE6A2FBB2CB98B54, 0x3E5DC5DE9A55D329
+data8 0x3E69649039A7AACE, 0x3E54728B5C66DBA5
+data8 0xBE62B0DBBA1C7D7D, 0x3E576E0409F1AF5F
+data8 0x3E6125001A0DD6A1, 0xBE66A419795FBDEF
+data8 0xBE5CDE8CE1BD41FC, 0xBE621376EA54964F
+data8 0x3E6370BE476E76EE, 0x3E390D1A3427EB92
+data8 0x3E1336DE2BF82BF8, 0xBE5FF1CBD0F7BD9E
+data8 0xBE60A3550CEB09DD, 0xBE5CA37E0980F30D
+data8 0xBE5C541B4C082D25, 0xBE5BBECA3B467D29
+data8 0xBE400D8AB9D946C5, 0xBE5E2A0807ED374A
+data8 0xBE66CB28365C8B0A, 0x3E3AAD5BD3403BCA
+data8 0x3E526055C7EA21E0, 0xBE442C75E72880D6
+data8 0x3E58B2BB85222A43, 0xBE5AAB79522C42BF
+data8 0xBE605CB4469DC2BC, 0xBE589FA7A48C40DC
+data8 0xBE51C2141AA42614, 0xBE48D087C37293F4
+data8 0x3E367A1CA2D673E0, 0xBE51BEBB114F7A38
+data8 0xBE6348E5661A4B48, 0xBDF526431D3B9962
+data8 0x3E3A3B5E35A78A53, 0xBE46C46C1CECD788
+data8 0xBE60B7EC7857D689, 0xBE594D3DD14F1AD7
+data8 0xBE4F9C304C9A8F60, 0xBE52187302DFF9D2
+data8 0xBE5E4C8855E6D68F, 0xBE62140F667F3DC4
+data8 0xBE36961B3BF88747, 0x3E602861C96EC6AA
+data8 0xBE3B5151D57FD718, 0x3E561CD0FC4A627B
+data8 0xBE3A5217CA913FEA, 0x3E40A3CC9A5D193A
+data8 0xBE5AB71310A9C312, 0x3E4FDADBC5F57719
+data8 0x3E361428DBDF59D5, 0x3E5DB5DB61B4180D
+data8 0xBE42AD5F7408D856, 0x3E2A314831B2B707
+LOCAL_OBJECT_END(Constants_exp_64_W1)
+
+LOCAL_OBJECT_START(Constants_exp_64_W2)
+data8 0x0000000000000000, 0xBE641F2537A3D7A2
+data8 0xBE68DD57AD028C40, 0xBE5C77D8F212B1B6
+data8 0x3E57878F1BA5B070, 0xBE55A36A2ECAE6FE
+data8 0xBE620608569DFA3B, 0xBE53B50EA6D300A3
+data8 0x3E5B5EF2223F8F2C, 0xBE56A0D9D6DE0DF4
+data8 0xBE64EEF3EAE28F51, 0xBE5E5AE2367EA80B
+data8 0x3E47CB1A5FCBC02D, 0xBE656BA09BDAFEB7
+data8 0x3E6E70C6805AFEE7, 0xBE6E0509A3415EBA
+data8 0xBE56856B49BFF529, 0x3E66DD3300508651
+data8 0x3E51165FC114BC13, 0x3E53333DC453290F
+data8 0x3E6A072B05539FDA, 0xBE47CD877C0A7696
+data8 0xBE668BF4EB05C6D9, 0xBE67C3E36AE86C93
+data8 0xBE533904D0B3E84B, 0x3E63E8D9556B53CE
+data8 0x3E212C8963A98DC8, 0xBE33138F032A7A22
+data8 0x3E530FA9BC584008, 0xBE6ADF82CCB93C97
+data8 0x3E5F91138370EA39, 0x3E5443A4FB6A05D8
+data8 0x3E63DACD181FEE7A, 0xBE62B29DF0F67DEC
+data8 0x3E65C4833DDE6307, 0x3E5BF030D40A24C1
+data8 0x3E658B8F14E437BE, 0xBE631C29ED98B6C7
+data8 0x3E6335D204CF7C71, 0x3E529EEDE954A79D
+data8 0x3E5D9257F64A2FB8, 0xBE6BED1B854ED06C
+data8 0x3E5096F6D71405CB, 0xBE3D4893ACB9FDF5
+data8 0xBDFEB15801B68349, 0x3E628D35C6A463B9
+data8 0xBE559725ADE45917, 0xBE68C29C042FC476
+data8 0xBE67593B01E511FA, 0xBE4A4313398801ED
+data8 0x3E699571DA7C3300, 0x3E5349BE08062A9E
+data8 0x3E5229C4755BB28E, 0x3E67E42677A1F80D
+data8 0xBE52B33F6B69C352, 0xBE6B3550084DA57F
+data8 0xBE6DB03FD1D09A20, 0xBE60CBC42161B2C1
+data8 0x3E56ED9C78A2B771, 0xBE508E319D0FA795
+data8 0xBE59482AFD1A54E9, 0xBE2A17CEB07FD23E
+data8 0x3E68BF5C17365712, 0x3E3956F9B3785569
+LOCAL_OBJECT_END(Constants_exp_64_W2)
+
+LOCAL_OBJECT_START(Constants_log_80_P)
+// P_8, P_7, ..., P_1
+data8 0xCCCE8B883B1042BC, 0x0000BFFB // P_8
+data8 0xE38997B7CADC2149, 0x00003FFB // P_7
+data8 0xFFFFFFFEB1ACB090, 0x0000BFFB // P_6
+data8 0x9249249806481C81, 0x00003FFC // P_5
+data8 0x0000000000000000, 0x00000000 // Pad for bank conflicts
+data8 0xAAAAAAAAAAAAB0EF, 0x0000BFFC // P_4
+data8 0xCCCCCCCCCCC91416, 0x00003FFC // P_3
+data8 0x8000000000000000, 0x0000BFFD // P_2
+data8 0xAAAAAAAAAAAAAAAB, 0x00003FFD // P_1
+LOCAL_OBJECT_END(Constants_log_80_P)
+
+LOCAL_OBJECT_START(Constants_log_80_Q)
+// log2_hi, log2_lo, Q_6, Q_5, Q_4, Q_3, Q_2, Q_1
+data8 0xB172180000000000,0x00003FFE
+data8 0x82E308654361C4C6,0x0000BFE2
+data8 0x92492453A51BE0AF,0x00003FFC
+data8 0xAAAAAB73A0CFD29F,0x0000BFFC
+data8 0xCCCCCCCCCCCE3872,0x00003FFC
+data8 0xFFFFFFFFFFFFB4FB,0x0000BFFC
+data8 0xAAAAAAAAAAAAAAAB,0x00003FFD
+data8 0x8000000000000000,0x0000BFFE
+LOCAL_OBJECT_END(Constants_log_80_Q)
+
+LOCAL_OBJECT_START(Constants_log_80_Z_G_H_h1)
+// Z1 - 16 bit fixed, G1 and H1 IEEE single, h1 IEEE double
+data4 0x00008000,0x3F800000,0x00000000,0x00000000
+data4 0x00000000,0x00000000,0x00000000,0x00000000
+data4 0x00007879,0x3F70F0F0,0x3D785196,0x00000000
+data4 0xEBA0E0D1,0x8B1D330B,0x00003FDA,0x00000000
+data4 0x000071C8,0x3F638E38,0x3DF13843,0x00000000
+data4 0x9EADD553,0xE2AF365E,0x00003FE2,0x00000000
+data4 0x00006BCB,0x3F579430,0x3E2FF9A0,0x00000000
+data4 0x752F34A2,0xF585FEC3,0x0000BFE3,0x00000000
+data4 0x00006667,0x3F4CCCC8,0x3E647FD6,0x00000000
+data4 0x893B03F3,0xF3546435,0x00003FE2,0x00000000
+data4 0x00006187,0x3F430C30,0x3E8B3AE7,0x00000000
+data4 0x39CDD2AC,0xBABA62E0,0x00003FE4,0x00000000
+data4 0x00005D18,0x3F3A2E88,0x3EA30C68,0x00000000
+data4 0x457978A1,0x8718789F,0x00003FE2,0x00000000
+data4 0x0000590C,0x3F321640,0x3EB9CEC8,0x00000000
+data4 0x3185E56A,0x9442DF96,0x0000BFE4,0x00000000
+data4 0x00005556,0x3F2AAAA8,0x3ECF9927,0x00000000
+data4 0x2BBE2CBD,0xCBF9A4BF,0x00003FE4,0x00000000
+data4 0x000051EC,0x3F23D708,0x3EE47FC5,0x00000000
+data4 0x852D5935,0xF3537535,0x00003FE3,0x00000000
+data4 0x00004EC5,0x3F1D89D8,0x3EF8947D,0x00000000
+data4 0x46CDF32F,0xA1F1E699,0x0000BFDF,0x00000000
+data4 0x00004BDB,0x3F17B420,0x3F05F3A1,0x00000000
+data4 0xD8484CE3,0x84A61856,0x00003FE4,0x00000000
+data4 0x00004925,0x3F124920,0x3F0F4303,0x00000000
+data4 0xFF28821B,0xC7DD97E0,0x0000BFE2,0x00000000
+data4 0x0000469F,0x3F0D3DC8,0x3F183EBF,0x00000000
+data4 0xEF1FD32F,0xD3C4A887,0x00003FE3,0x00000000
+data4 0x00004445,0x3F088888,0x3F20EC80,0x00000000
+data4 0x464C76DA,0x84672BE6,0x00003FE5,0x00000000
+data4 0x00004211,0x3F042108,0x3F29516A,0x00000000
+data4 0x18835FB9,0x9A43A511,0x0000BFE5,0x00000000
+LOCAL_OBJECT_END(Constants_log_80_Z_G_H_h1)
+
+LOCAL_OBJECT_START(Constants_log_80_Z_G_H_h2)
+// Z2 - 16 bit fixed, G2 and H2 IEEE single, h2 IEEE double
+data4 0x00008000,0x3F800000,0x00000000,0x00000000
+data4 0x00000000,0x00000000,0x00000000,0x00000000
+data4 0x00007F81,0x3F7F00F8,0x3B7F875D,0x00000000
+data4 0x211398BF,0xAD08B116,0x00003FDB,0x00000000
+data4 0x00007F02,0x3F7E03F8,0x3BFF015B,0x00000000
+data4 0xC376958E,0xB106790F,0x00003FDE,0x00000000
+data4 0x00007E85,0x3F7D08E0,0x3C3EE393,0x00000000
+data4 0x79A7679A,0xFD03F242,0x0000BFDA,0x00000000
+data4 0x00007E08,0x3F7C0FC0,0x3C7E0586,0x00000000
+data4 0x05E7AE08,0xF03F81C3,0x0000BFDF,0x00000000
+data4 0x00007D8D,0x3F7B1880,0x3C9E75D2,0x00000000
+data4 0x049EB22F,0xD1B87D3C,0x00003FDE,0x00000000
+data4 0x00007D12,0x3F7A2328,0x3CBDC97A,0x00000000
+data4 0x3A9E81E0,0xFABC8B95,0x00003FDF,0x00000000
+data4 0x00007C98,0x3F792FB0,0x3CDCFE47,0x00000000
+data4 0x7C4B5443,0xF5F3653F,0x00003FDF,0x00000000
+data4 0x00007C20,0x3F783E08,0x3CFC15D0,0x00000000
+data4 0xF65A1773,0xE78AB204,0x00003FE0,0x00000000
+data4 0x00007BA8,0x3F774E38,0x3D0D874D,0x00000000
+data4 0x7B8EF695,0xDB7CBFFF,0x0000BFE0,0x00000000
+data4 0x00007B31,0x3F766038,0x3D1CF49B,0x00000000
+data4 0xCF773FB3,0xC0241AEA,0x0000BFE0,0x00000000
+data4 0x00007ABB,0x3F757400,0x3D2C531D,0x00000000
+data4 0xC9539FDF,0xFC8F4D48,0x00003FE1,0x00000000
+data4 0x00007A45,0x3F748988,0x3D3BA322,0x00000000
+data4 0x954665C2,0x9CD035FB,0x0000BFE1,0x00000000
+data4 0x000079D1,0x3F73A0D0,0x3D4AE46F,0x00000000
+data4 0xDD367A30,0xEC9017C7,0x00003FE1,0x00000000
+data4 0x0000795D,0x3F72B9D0,0x3D5A1756,0x00000000
+data4 0xCB11189C,0xEE6625D3,0x0000BFE1,0x00000000
+data4 0x000078EB,0x3F71D488,0x3D693B9D,0x00000000
+data4 0xBE11C424,0xA49C8DB5,0x0000BFE0,0x00000000
+LOCAL_OBJECT_END(Constants_log_80_Z_G_H_h2)
+
+LOCAL_OBJECT_START(Constants_log_80_h3_G_H)
+// h3 IEEE double extended, H3 and G3 IEEE single
+data4 0x112666B0,0xAAACAAB1,0x00003FD3,0x3F7FFC00
+data4 0x9B7FAD21,0x90051030,0x00003FD8,0x3F7FF400
+data4 0xF4D783C4,0xA6B46F46,0x00003FDA,0x3F7FEC00
+data4 0x11C6DDCA,0xDA148D88,0x0000BFD8,0x3F7FE400
+data4 0xCA964D95,0xCE65C1D8,0x0000BFD8,0x3F7FDC00
+data4 0x23412D13,0x883838EE,0x0000BFDB,0x3F7FD400
+data4 0x983ED687,0xB7E5CFA1,0x00003FDB,0x3F7FCC08
+data4 0xE3C3930B,0xDBE23B16,0x0000BFD9,0x3F7FC408
+data4 0x48AA4DFC,0x9B92F1FC,0x0000BFDC,0x3F7FBC10
+data4 0xCE9C8F7E,0x9A8CEB15,0x0000BFD9,0x3F7FB410
+data4 0x0DECE74A,0x8C220879,0x00003FDC,0x3F7FAC18
+data4 0x2F053150,0xB25CA912,0x0000BFDA,0x3F7FA420
+data4 0xD9A5BE20,0xA5876555,0x00003FDB,0x3F7F9C20
+data4 0x2053F087,0xC919BB6E,0x00003FD9,0x3F7F9428
+data4 0x041E9A77,0xB70BDA79,0x00003FDC,0x3F7F8C30
+data4 0xEA1C9C30,0xF18A5C08,0x00003FDA,0x3F7F8438
+data4 0x796D89E5,0xA3790D84,0x0000BFDD,0x3F7F7C40
+data4 0xA2915A3A,0xE1852369,0x0000BFDD,0x3F7F7448
+data4 0xA39ED868,0xD803858F,0x00003FDC,0x3F7F6C50
+data4 0x9417EBB7,0xB2EEE356,0x0000BFDD,0x3F7F6458
+data4 0x9BB0D07F,0xED5C1F8A,0x0000BFDC,0x3F7F5C68
+data4 0xE87C740A,0xD6D201A0,0x0000BFDD,0x3F7F5470
+data4 0x1CA74025,0xE8DEBF5E,0x00003FDC,0x3F7F4C78
+data4 0x1F34A7EB,0x9A995A97,0x0000BFDC,0x3F7F4488
+data4 0x359EED97,0x9CB0F742,0x0000BFDA,0x3F7F3C90
+data4 0xBBC6A1C8,0xD6F833C2,0x0000BFDD,0x3F7F34A0
+data4 0xE71090EC,0xE1F68F2A,0x00003FDC,0x3F7F2CA8
+data4 0xC160A74F,0xD1881CF1,0x0000BFDB,0x3F7F24B8
+data4 0xD78CB5A4,0x9AD05AE2,0x00003FD6,0x3F7F1CC8
+data4 0x9A77DC4B,0xE658CB8E,0x0000BFDD,0x3F7F14D8
+data4 0x6BD6D312,0xBA281296,0x00003FDC,0x3F7F0CE0
+data4 0xF95210D0,0xB478BBEB,0x0000BFDB,0x3F7F04F0
+data4 0x38800100,0x39400480,0x39A00640,0x39E00C41 // H's start here
+data4 0x3A100A21,0x3A300F22,0x3A4FF51C,0x3A6FFC1D
+data4 0x3A87F20B,0x3A97F68B,0x3AA7EB86,0x3AB7E101
+data4 0x3AC7E701,0x3AD7DD7B,0x3AE7D474,0x3AF7CBED
+data4 0x3B03E1F3,0x3B0BDE2F,0x3B13DAAA,0x3B1BD766
+data4 0x3B23CC5C,0x3B2BC997,0x3B33C711,0x3B3BBCC6
+data4 0x3B43BAC0,0x3B4BB0F4,0x3B53AF6D,0x3B5BA620
+data4 0x3B639D12,0x3B6B9444,0x3B7393BC,0x3B7B8B6D
+LOCAL_OBJECT_END(Constants_log_80_h3_G_H)
+
+GR_sig_inv_ln2      = r14
+GR_rshf_2to51       = r15
+GR_exp_2tom51       = r16
+GR_rshf             = r17
+GR_exp_half         = r18
+GR_sign_mask        = r19
+GR_exp_square_oflow = r20
+GR_exp_square_uflow = r21
+GR_exp_ynear1_oflow = r22
+GR_exp_ynear1_uflow = r23
+GR_signif_Z         = r24
+
+GR_signexp_x        = r32
+
+GR_exp_x            = r33
+
+GR_Table_Ptr        = r34
+
+GR_Table_Ptr1       = r35
+
+GR_Index1           = r36
+
+GR_Index2           = r37
+GR_Expo_X           = r37
+
+GR_M                = r38
+
+GR_X_0              = r39
+GR_Mask             = r39
+
+GR_X_1              = r40
+GR_W1_ptr           = r40
+
+GR_W2_ptr           = r41
+GR_X_2              = r41
+
+GR_Z_1              = r42
+GR_M2               = r42
+
+GR_M1               = r43
+GR_Z_2              = r43
+
+GR_N                = r44
+GR_k                = r44
+
+GR_Big_Pos_Exp      = r45
+
+GR_exp_pos_max      = r46
+
+GR_exp_bias_p_k     = r47
+
+GR_Index3           = r48
+GR_temp             = r48
+
+GR_vsm_expo         = r49
+
+GR_T1_ptr           = r50
+GR_P_ptr1           = r50
+GR_T2_ptr           = r51
+GR_P_ptr2           = r51
+GR_N_fix            = r52
+GR_exp_y            = r53
+GR_signif_y         = r54
+GR_signexp_y        = r55
+GR_fraction_y       = r55
+GR_low_order_bit    = r56
+GR_exp_mask         = r57
+GR_exp_bias         = r58
+GR_y_sign           = r59
+GR_table_base       = r60
+GR_ptr_exp_Arg      = r61
+GR_Delta_Exp        = r62
+GR_Special_Exp      = r63
+GR_exp_neg_max      = r64
+GR_Big_Neg_Exp      = r65
+
+//** Registers for unwind support
+
+GR_SAVE_PFS         = r59
+GR_SAVE_B0          = r60
+GR_SAVE_GP          = r61
+GR_Parameter_X      = r62
+GR_Parameter_Y      = r63
+GR_Parameter_RESULT = r64
+GR_Parameter_TAG    = r65
+
+//**
+
+FR_Input_X          = f8
+FR_Result           = f8
+FR_Input_Y          = f9
+
+FR_Neg              = f10
+FR_P_hi             = f10
+FR_X                = f10
+
+FR_Half             = f11
+FR_h_3              = f11
+FR_poly_hi          = f11
+
+FR_Sgn              = f12
+
+FR_half_W           = f13
+
+FR_X_cor            = f14
+FR_P_lo             = f14
+
+FR_W                = f15
+
+FR_X_lo             = f32
+
+FR_S                = f33
+FR_W3               = f33
+
+FR_Y_hi             = f34
+FR_logx_hi          = f34
+
+FR_Z                = f35
+FR_logx_lo          = f35
+FR_GS_hi            = f35
+FR_Y_lo             = f35
+
+FR_r_cor            = f36
+FR_Scale            = f36
+
+FR_G_1              = f37
+FR_G                = f37
+FR_Wsq              = f37
+FR_temp             = f37
+
+FR_H_1              = f38
+FR_H                = f38
+FR_W4               = f38
+
+FR_h                = f39
+FR_h_1              = f39
+FR_N                = f39
+FR_P_7              = f39
+
+FR_G_2              = f40
+FR_P_8              = f40
+FR_L_hi             = f40
+
+FR_H_2              = f41
+FR_L_lo             = f41
+FR_A_1              = f41
+
+FR_h_2              = f42
+
+FR_W1               = f43
+
+FR_G_3              = f44
+FR_P_8              = f44
+FR_T1               = f44
+
+FR_log2_hi          = f45
+FR_W2               = f45
+
+FR_GS_lo            = f46
+FR_T2               = f46
+
+FR_W_1_p1           = f47
+FR_H_3              = f47
+
+FR_float_N          = f48
+
+FR_A_2              = f49
+
+FR_Q_4              = f50
+FR_r4               = f50
+
+FR_Q_3              = f51
+FR_A_3              = f51
+
+FR_Q_2              = f52
+FR_P_2              = f52
+
+FR_Q_1              = f53
+FR_P_1              = f53
+FR_T                = f53
+
+FR_Wp1              = f54
+FR_Q_5              = f54
+FR_P_3              = f54
+
+FR_Q_6              = f55
+
+FR_log2_lo          = f56
+FR_Two              = f56
+
+FR_Big              = f57
+
+FR_neg_2_mK         = f58
+
+FR_r                = f59
+
+FR_poly_lo          = f60
+
+FR_poly             = f61
+
+FR_P_5              = f62
+FR_Result_small     = f62
+
+FR_rsq              = f63
+
+FR_Delta            = f64
+
+FR_save_Input_X     = f65
+FR_norm_X           = f66
+FR_norm_Y           = f67
+FR_Y_lo_2           = f68
+
+FR_P_6              = f69
+FR_Result_big       = f69
+
+FR_RSHF_2TO51       = f70
+FR_INV_LN2_2TO63    = f71
+FR_2TOM51           = f72
+FR_RSHF             = f73
+FR_TMP1             = f74
+FR_TMP2             = f75
+FR_TMP3             = f76
+FR_Tscale           = f77
+FR_P_4              = f78
+FR_NBig             = f79
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(powl)
+//
+//     Get significand of x.  It is the critical path.
+//
+{ .mfi
+      getf.sig GR_signif_Z = FR_Input_X    // Get significand of x
+      fclass.m p11, p12 = FR_Input_X, 0x0b // Test x unorm
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fnorm.s1 FR_norm_X = FR_Input_X      // Normalize x
+      mov GR_exp_half = 0xffff - 1         // Exponent for 0.5
+}
+;;
+
+{ .mfi
+      alloc  r32 = ar.pfs,0,30,4,0
+      fclass.m p7, p0 =  FR_Input_Y, 0x1E7 // Test y natval, nan, inf, zero
+      mov GR_exp_pos_max = 0x13fff         // Max exponent for pos oflow test
+}
+{ .mfi
+      addl GR_table_base = @ltoff(Constants_exp_64_Arg#), gp // Ptr to tables
+      fnorm.s1 FR_norm_Y = FR_Input_Y      // Normalize y
+      mov GR_exp_neg_max = 0x33fff         // Max exponent for neg oflow test
+}
+;;
+
+{ .mfi
+      getf.exp GR_signexp_y = FR_Input_Y   // Get sign and exp of y
+(p12) fclass.m p11, p0 =  FR_Input_Y, 0x0b // Test y unorm
+      mov GR_sign_mask = 0x20000           // Sign mask
+}
+{ .mfi
+      ld8 GR_table_base = [GR_table_base]  // Get base address for tables
+      fadd.s1 FR_Two = f1, f1              // Form 2.0 for square test
+      mov GR_exp_mask = 0x1FFFF            // Exponent mask
+}
+;;
+
+{ .mfi
+      getf.sig GR_signif_y = FR_Input_Y    // Get significand of y
+      fclass.m p6, p0 =  FR_Input_X, 0x1E7 // Test x natval, nan, inf, zero
+      nop.i 999
+}
+;;
+
+{ .mfi
+      getf.exp GR_signexp_x = FR_Input_X   // Get signexp of x
+      fmerge.s FR_save_Input_X = FR_Input_X, FR_Input_X
+      extr.u GR_Index1 = GR_signif_Z, 59, 4  // Extract upper 4 signif bits of x
+}
+{ .mfb
+      setf.exp FR_Half = GR_exp_half       // Load half
+      nop.f 999
+(p11) br.cond.spnt  POWL_DENORM            // Branch if x or y denorm/unorm
+}
+;;
+
+// Return here from POWL_DENORM
+POWL_COMMON:
+{ .mfi
+      setf.exp FR_Big = GR_exp_pos_max     // Form big pos value for oflow test
+      fclass.nm p11, p0 = FR_Input_Y, 0x1FF // Test Y unsupported
+      shl GR_Index1 = GR_Index1,5          // Adjust index1 pointer x 32
+}
+{ .mfi
+      add GR_Table_Ptr = 0x7c0, GR_table_base // Constants_log_80_Z_G_H_h1
+      fma.s1 FR_Sgn = f1,f1,f0             // Assume result positive
+      mov GR_exp_bias = 0xFFFF             // Form exponent bias
+}
+;;
+
+//
+//     Identify NatVals, NaNs, Infs, and Zeros.
+//
+//
+//     Remove sign bit from exponent of y.
+//     Check for x = 1
+//     Branch on Infs, Nans, Zeros, and Natvals
+//     Check to see that exponent < 0
+//
+{ .mfi
+      setf.exp FR_NBig = GR_exp_neg_max    // Form big neg value for oflow test
+      fclass.nm p8, p0 =  FR_Input_X, 0x1FF  // Test X unsupported
+      and GR_exp_y = GR_exp_mask,GR_signexp_y // Get biased exponent of y
+}
+{ .mfb
+      add GR_Index1 = GR_Index1,GR_Table_Ptr
+      nop.f 999
+(p6)  br.cond.spnt POWL_64_SPECIAL         // Branch if x natval, nan, inf, zero
+}
+;;
+
+//     load Z_1 from Index1
+
+// There is logic starting here to determine if y is an integer when x < 0.
+// If 0 < |y| < 1 then clearly y is not an integer.
+// If |y| > 1, then the significand of y is shifted left by the size of
+//    the exponent of y.  This preserves the lsb of the integer part + the
+//    fractional bits.  The lsb of the integer can be tested to determine if
+//    the integer is even or odd.  The fractional bits can be tested.  If zero,
+//    then y is an integer.
+//
+{ .mfi
+      ld2 GR_Z_1 =[GR_Index1],4            // Load Z_1
+      fmerge.s FR_Z = f0, FR_norm_X        // Z = |x|
+      extr.u GR_X_0 = GR_signif_Z, 49, 15  // Extract X_0 from significand
+}
+{ .mfb
+      cmp.lt p9, p0 = GR_exp_y,GR_exp_bias // Test 0 < |y| < 1
+      nop.f 999
+(p7)  br.cond.spnt POWL_64_SPECIAL         // Branch if y natval, nan, inf, zero
+}
+;;
+
+{ .mfb
+      ldfs  FR_G_1 = [GR_Index1],4         // Load G_1
+      fcmp.eq.s1 p10, p0 =  FR_Input_Y, f1 // Test Y = +1.0
+(p8)  br.cond.spnt POWL_64_UNSUPPORT       // Branch if x unsupported
+}
+;;
+
+//
+//     X_0  = High order 15 bit of Z
+//
+{ .mfb
+      ldfs  FR_H_1 = [GR_Index1],8             // Load H_1
+(p9)  fcmp.lt.unc.s1 p9, p0 = FR_Input_X, f0   // Test x<0, 0 <|y|<1
+(p11) br.cond.spnt POWL_64_UNSUPPORT           // Branch if y unsupported
+}
+;;
+
+{ .mfi
+      ldfe FR_h_1 = [GR_Index1]                // Load h_1
+      fcmp.eq.s1 p7, p0 =  FR_Input_Y, FR_Two  // Test y = 2.0
+      pmpyshr2.u GR_X_1 = GR_X_0,GR_Z_1,15     // X_1 = X_0 * Z_1 (bits 15-30)
+                                               // Wait 4 cycles to use result
+}
+{ .mfi
+      add GR_Table_Ptr = 0x9c0, GR_table_base  // Constants_log_80_Z_G_H_h2
+      nop.f 999
+      sub GR_exp_y = GR_exp_y,GR_exp_bias      // Get true exponent of y
+}
+;;
+
+//
+//      Branch for (x < 0) and Y not an integer.
+//
+{ .mfb
+      nop.m 999
+      fcmp.lt.s1 p6, p0  =  FR_Input_X, f0     // Test x < 0
+(p9)  br.cond.spnt POWL_64_XNEG                // Branch if x < 0, 0 < |y| < 1
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fcmp.eq.s1 p12, p0 =  FR_Input_X, f1     // Test x=+1.0
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+      fsub.s1 FR_W = FR_Z, f1                  // W = Z - 1
+(p7)  br.cond.spnt POWL_64_SQUARE              // Branch if y=2
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p10) fmpy.s0 FR_Result = FR_Input_X, f1       // If y=+1.0, result=x
+(p6)  shl GR_fraction_y=  GR_signif_y,GR_exp_y // Get lsb of int + fraction
+                                               // Wait 4 cycles to use result
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p12) fma.s0 FR_Result = FR_Input_Y, f0, f1    // If x=1.0, result=1, chk denorm
+      extr.u GR_Index2 = GR_X_1, 6, 4          // Extract index2
+}
+;;
+
+//
+//     N = exponent of Z
+//
+{ .mib
+      getf.exp GR_N =  FR_Z                    // Get exponent of Z (also x)
+      shl GR_Index2=GR_Index2,5                // Index2  x 32 bytes
+(p10) br.ret.spnt  b0                          // Exit if y=+1.0
+}
+;;
+
+{ .mib
+      add GR_Index2 = GR_Index2, GR_Table_Ptr  // Pointer to table 2
+      nop.i 999
+(p12) br.ret.spnt  b0                          // Exit if x=+1.0
+}
+;;
+
+{ .mmi
+      ld2 GR_Z_2 =[GR_Index2],4                // Load Z_2
+;;
+      ldfs  FR_G_2 = [GR_Index2],4             // Load G_2
+      nop.i 999
+}
+;;
+
+{ .mii
+      ldfs  FR_H_2 = [GR_Index2],8             // Load H_2
+(p6)  tbit.nz.unc p9, p0 = GR_fraction_y, 63   // Test x<0 and y odd integer
+      add GR_Table_Ptr = 0xbcc, GR_table_base  // Constants_log_80_h3_G_H, G_3
+}
+;;
+
+//
+//      For x < 0 and y odd integer,, set sign = -1.
+//
+{ .mfi
+      getf.exp GR_M = FR_W                      // Get signexp of W
+      nop.f 999
+      pmpyshr2.u GR_X_2 = GR_X_1,GR_Z_2,15      // X_2 = X_1 * Z_2 (bits 15-30)
+}
+{ .mfi
+      ldfe FR_h_2 = [GR_Index2]                // Load h_2
+(p9)  fnma.s1 FR_Sgn = f1, f1, f0          // If x<0, y odd int, result negative
+      sub GR_N = GR_N, GR_exp_bias             // Get true exponent of x = N
+}
+;;
+
+{ .mfi
+      add GR_Table_Ptr1 = 0xdc0, GR_table_base // Ptr to H_3
+      fcmp.eq.s0 p11, p0 = FR_Input_Y, FR_Half // Test y=0.5, also set denorm
+(p6)  shl GR_fraction_y=  GR_fraction_y, 1     // Shift left 1 to get fraction
+}
+;;
+
+{ .mmb
+      setf.sig FR_float_N = GR_N
+(p6)  cmp.ne.unc p8, p0 = GR_fraction_y, r0    // Test x<0 and y not integer
+(p8)  br.cond.spnt POWL_64_XNEG                // Branch if x<0 and y not int
+}
+;;
+
+//
+//      Raise possible denormal operand exception for both X and Y.
+//      Set pointers in case |x| near 1
+//      Branch to embedded sqrt(x) if y=0.5
+//
+{ .mfi
+      add GR_P_ptr1 = 0x6b0, GR_table_base // Constants_log_80_P, P8, NEAR path
+      fcmp.eq.s0 p12, p0 =  FR_Input_X, FR_Input_Y // Dummy to set denormal
+      add GR_P_ptr2 = 0x700, GR_table_base // Constants_log_80_P, P4, NEAR path
+}
+{ .mfb
+      cmp.eq p15, p14 =  r0, r0            // Assume result safe (no over/under)
+      fsub.s1  FR_Delta = FR_Input_Y,f1    // Delta = y - 1.0
+(p11) br.cond.spnt POWL_64_SQRT            // Branch if y=0.5
+}
+;;
+
+//
+//     Computes ln( x ) to extra precision
+//     Input  FR 1: FR_X
+//     Output FR 2: FR_Y_hi
+//     Output FR 3: FR_Y_lo
+//     Output PR 1: PR_Safe
+//
+{ .mfi
+      and GR_M = GR_exp_mask, GR_M            // Mask to get exponent of W
+      nop.f 999
+      extr.u GR_Index3 = GR_X_2, 1, 5         // Get index3
+}
+;;
+
+{ .mmi
+      shladd GR_Table_Ptr1 = GR_Index3,2,GR_Table_Ptr1 // Ptr to H_3
+      shladd GR_Index3 = GR_Index3,4,GR_Table_Ptr      // Ptr to G_3
+      sub GR_M = GR_M, GR_exp_bias            // Get true exponent of W
+}
+;;
+
+{ .mib
+      ldfs FR_G_3 = [GR_Index3],-12           // Load G_3
+      cmp.gt  p7, p14 =  -8, GR_M             // Test if |x-1| < 2^-8
+(p7)  br.cond.spnt LOGL80_NEAR                // Branch if |x-1| < 2^-8
+}
+;;
+
+// Here if |x-1| >= 2^-8
+{ .mmf
+      ldfs FR_H_3 = [GR_Table_Ptr1]           // Load H_3
+      nop.m 999
+      nop.f 999
+}
+;;
+
+{ .mfi
+      ldfe FR_h_3 = [GR_Index3]               // Load h_3
+      fmerge.se FR_S =  f1,FR_Z               // S = merge of 1.0 and signif(Z)
+      nop.i 999
+}
+{ .mfi
+      add GR_Table_Ptr = 0x740, GR_table_base // Constants_log_80_Q
+      fmpy.s1 FR_G = FR_G_1, FR_G_2           // G = G_1 * G_2
+      nop.i 999
+}
+;;
+
+//
+//     Begin Loading Q's -  load log2_hi part
+//
+{ .mfi
+      ldfe FR_log2_hi = [GR_Table_Ptr],16     // Load log2_hi
+      fadd.s1 FR_H = FR_H_1, FR_H_2           // H = H_1 + H_2
+      nop.i 999
+};;
+
+//
+//     h = h_1 + h_2
+//
+{ .mfi
+      ldfe FR_log2_lo = [GR_Table_Ptr],16     // Load log2_lo
+      fadd.s1 FR_h = FR_h_1, FR_h_2           // h = h_1 + h_2
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe FR_Q_6 = [GR_Table_Ptr],16         // Load Q_6
+      fcvt.xf FR_float_N = FR_float_N
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe FR_Q_5 = [GR_Table_Ptr],16         // Load Q_5
+      nop.f 999
+      nop.i 999
+}
+;;
+
+//
+//     G = G_1 * G_2 * G_3
+//
+{ .mfi
+      ldfe FR_Q_4 = [GR_Table_Ptr],16         // Load Q_4
+      fmpy.s1 FR_G = FR_G, FR_G_3
+      nop.i 999
+}
+;;
+
+//
+//     H = H_1 + H_2 + H_3
+//
+{ .mfi
+      ldfe FR_Q_3 = [GR_Table_Ptr],16         // Load Q_3
+      fadd.s1 FR_H = FR_H, FR_H_3
+      nop.i 999
+}
+;;
+
+//
+//     Y_lo = poly + Y_lo
+//
+//     h = h_1 + h_2 + h_3
+//
+{ .mfi
+      ldfe FR_Q_2 = [GR_Table_Ptr],16         // Load Q_2
+      fadd.s1 FR_h = FR_h, FR_h_3
+      nop.i 999
+}
+;;
+
+//
+//     GS_hi = G*S
+//     r = G*S -1
+//
+{ .mfi
+      ldfe FR_Q_1 = [GR_Table_Ptr],16         // Load Q_1
+      fmpy.s1 FR_GS_hi = FR_G, FR_S
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fms.s1 FR_r = FR_G, FR_S, f1
+      nop.i 999
+}
+;;
+
+//
+//     poly_lo = Q_5 + r * Q_6
+//
+{ .mfi
+      getf.exp GR_Delta_Exp =  FR_Delta     // Get signexp of y-1 for exp calc
+      fma.s1 FR_poly_lo = FR_r, FR_Q_6, FR_Q_5
+      nop.i 999
+}
+//
+//     r_cor = GS_hi -1
+//
+{ .mfi
+      nop.m 999
+      fsub.s1 FR_r_cor = FR_GS_hi, f1
+      nop.i 999
+}
+;;
+
+//
+//     GS_lo  = G*S - GS_hi
+//
+{ .mfi
+      nop.m 999
+      fms.s1 FR_GS_lo = FR_G, FR_S, FR_GS_hi
+      nop.i 999
+}
+;;
+
+//
+//     rsq = r * r
+//
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_rsq = FR_r, FR_r
+      nop.i 999
+}
+//
+//     G = float_N*log2_hi + H
+//
+{ .mfi
+      nop.m 999
+      fma.s1 FR_G = FR_float_N, FR_log2_hi, FR_H
+      nop.i 999
+}
+;;
+
+//
+//     Y_lo = float_N*log2_lo + h
+//
+{ .mfi
+      nop.m 999
+      fma.s1 FR_Y_lo = FR_float_N, FR_log2_lo, FR_h
+      nop.i 999
+}
+;;
+
+//
+//      poly_lo = Q_4 + r * poly_lo
+//      r_cor = r_cor - r
+//
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly_lo = FR_r, FR_poly_lo, FR_Q_4
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fsub.s1 FR_r_cor = FR_r_cor, FR_r
+      nop.i 999
+}
+;;
+
+//
+//      poly_hi = r * Q_2 + Q_1
+//      Y_hi = G + r
+//
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly = FR_r, FR_Q_2, FR_Q_1
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_Y_hi = FR_G, FR_r
+      nop.i 999
+}
+;;
+
+//
+//      poly_lo = Q_3 + r * poly_lo
+//      r_cor = r_cor + GS_lo
+//
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly_lo = FR_r, FR_poly_lo, FR_Q_3
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_r_cor = FR_r_cor, FR_GS_lo
+      nop.i 999
+}
+;;
+
+//
+//      Y_lo = G - Y_hi
+//
+{ .mfi
+      nop.m 999
+      fsub.s1 FR_Y_lo_2 = FR_G, FR_Y_hi
+      nop.i 999
+}
+;;
+
+//
+//      r_cor = r_cor + Y_lo
+//      poly = poly_hi + rsq * poly_lo
+//
+{ .mfi
+      add  GR_Table_Ptr   = 0x0, GR_table_base   // Constants_exp_64_Arg
+      fadd.s1 FR_r_cor = FR_r_cor, FR_Y_lo
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly = FR_rsq, FR_poly_lo, FR_poly
+      nop.i 999
+}
+;;
+
+//
+//      Load L_hi
+//      Load L_lo
+//      all long before they are needed.
+//      They are used in LOGL_RETURN PATH
+//
+//      Y_lo =  Y_lo + r
+//      poly = rsq * poly + r_cor
+//
+{ .mfi
+      ldfe FR_L_hi = [GR_Table_Ptr],16           // Load L_hi
+      fadd.s1 FR_Y_lo = FR_Y_lo_2, FR_r
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly = FR_rsq, FR_poly, FR_r_cor
+      nop.i 999
+}
+;;
+
+{ .mfb
+      ldfe FR_L_lo = [GR_Table_Ptr],16           // Load L_lo
+      fadd.s1 FR_Y_lo = FR_Y_lo, FR_poly
+      br.cond.sptk LOGL_RETURN                   // Branch to common code
+}
+;;
+
+
+LOGL80_NEAR:
+// Here if |x-1| < 2^-8
+//
+//     Branch LOGL80_NEAR
+//
+
+{ .mmf
+      ldfe FR_P_8 = [GR_P_ptr1],16           // Load P_8
+      ldfe FR_P_4 = [GR_P_ptr2],16           // Load P_4
+      fmpy.s1 FR_Wsq = FR_W, FR_W
+}
+;;
+
+{ .mmi
+      ldfe FR_P_7 = [GR_P_ptr1],16           // Load P_7
+      ldfe FR_P_3 = [GR_P_ptr2],16           // Load P_3
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ldfe FR_P_6 = [GR_P_ptr1],16           // Load P_6
+      ldfe FR_P_2 = [GR_P_ptr2],16           // Load P_2
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ldfe FR_P_5 = [GR_P_ptr1],16           // Load P_5
+      ldfe FR_P_1 = [GR_P_ptr2],16           // Load P_1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      getf.exp GR_Delta_Exp =  FR_Delta      // Get signexp of y-1 for exp calc
+      fmpy.s1 FR_W4 = FR_Wsq, FR_Wsq
+      nop.i 999
+}
+{ .mfi
+      add  GR_Table_Ptr = 0x0, GR_table_base // Constants_exp_64_Arg
+      fmpy.s1 FR_W3 = FR_Wsq, FR_W
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_half_W = FR_Half, FR_W
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe FR_L_hi = [GR_Table_Ptr],16
+      fma.s1 FR_poly_lo = FR_W, FR_P_8,FR_P_7
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly = FR_W, FR_P_4, FR_P_3
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe FR_L_lo = [GR_Table_Ptr],16
+      fnma.s1 FR_Y_hi = FR_W, FR_half_W, FR_W
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly_lo = FR_W, FR_poly_lo, FR_P_6
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly = FR_W, FR_poly, FR_P_2
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fsub.s1 FR_Y_lo = FR_W, FR_Y_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly_lo = FR_W, FR_poly_lo, FR_P_5
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly = FR_W, FR_poly, FR_P_1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fnma.s1 FR_Y_lo = FR_W, FR_half_W, FR_Y_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly = FR_poly_lo, FR_W4, FR_poly
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_Y_lo = FR_poly, FR_W3, FR_Y_lo
+      nop.i 999
+}
+;;
+
+
+LOGL_RETURN:
+// Common code for completion of both logx paths
+
+//
+//     L_hi, L_lo already loaded.
+//
+//
+//     kernel_log_80 computed ln(X)
+//     and return logX_hi and logX_lo as results.
+//     PR_pow_Safe set as well.
+//
+//
+//     Compute Y * (logX_hi + logX_lo)
+//     P_hi -> X
+//     P_lo -> X_cor
+//     (Manipulate names so that inputs are in
+//     the place kernel_exp expects them)
+//
+//     This function computes exp( x  + x_cor)
+//     Input  FR 1: FR_X
+//     Input  FR 2: FR_X_cor
+//     Output FR 3: FR_Y_hi
+//     Output FR 4: FR_Y_lo
+//     Output FR 5: FR_Scale
+//     Output PR 1: PR_Safe
+//
+//     P15 is True
+//
+// Load constants used in computing N using right-shift technique
+{ .mlx
+      mov GR_exp_2tom51 = 0xffff-51
+      movl GR_sig_inv_ln2 = 0xb8aa3b295c17f0bc  // significand of 1/ln2
+}
+{ .mlx
+      add  GR_Special_Exp = -50,GR_exp_bias
+      movl GR_rshf_2to51 = 0x4718000000000000   // 1.10000 2^(63+51)
+}
+;;
+
+//
+//     Point to Table of W1s
+//     Point to Table of W2s
+//
+{ .mmi
+      add GR_W1_ptr   = 0x2b0, GR_table_base    // Constants_exp_64_W1
+      add GR_W2_ptr   = 0x4b0, GR_table_base    // Constants_exp_64_W2
+      cmp.le p6,p0= GR_Delta_Exp,GR_Special_Exp
+};;
+
+// Form two constants we need
+//  1/ln2 * 2^63  to compute  w = x * 1/ln2 * 128
+//  1.1000..000 * 2^(63+63-12) to right shift int(N) into the significand
+
+{ .mfi
+      setf.sig  FR_INV_LN2_2TO63 = GR_sig_inv_ln2 // form 1/ln2 * 2^63
+      nop.f 999
+      and GR_Delta_Exp=GR_Delta_Exp,GR_exp_mask  // Get exponent of y-1
+}
+{ .mlx
+      setf.d  FR_RSHF_2TO51 = GR_rshf_2to51    // Form const 1.1000 * 2^(63+51)
+      movl GR_rshf = 0x43e8000000000000        // 1.10000 2^63 for right shift
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_X_lo = FR_Input_Y, FR_logx_lo // logx_lo is Y_lo
+      cmp.eq  p15, p0=  r0, r0                 // Set p15, assume safe
+};;
+
+{ .mmi
+      setf.exp FR_2TOM51 = GR_exp_2tom51 // Form 2^-51 for scaling float_N
+      setf.d  FR_RSHF = GR_rshf          // Form right shift const 1.1000 * 2^63
+      add GR_Table_Ptr1   = 0x50, GR_table_base // Constants_exp_64_P for
+                                                // EXPL_SMALL path
+}
+;;
+
+{ .mmi
+      ldfe FR_P_6 = [GR_Table_Ptr1],16          // Load P_6 for EXPL_SMALL path
+;;
+      ldfe FR_P_5 = [GR_Table_Ptr1],16          // Load P_5 for EXPL_SMALL path
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe FR_P_4 = [GR_Table_Ptr1],16          // Load P_4 for EXPL_SMALL path
+      fma.s1 FR_P_hi = FR_Input_Y, FR_logx_hi,FR_X_lo  // logx_hi ix Y_hi
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ldfe FR_P_3 = [GR_Table_Ptr1],16          // Load P_3 for EXPL_SMALL path
+;;
+      ldfe FR_P_2 = [GR_Table_Ptr1],16          // Load P_2 for EXPL_SMALL path
+      nop.i 999
+}
+;;
+
+// N = X * Inv_log2_by_2^12
+// By adding 1.10...0*2^63 we shift and get round_int(N_signif) in significand.
+// We actually add 1.10...0*2^51 to X * Inv_log2 to do the same thing.
+{ .mfi
+      ldfe FR_P_1 = [GR_Table_Ptr1]             // Load P_1 for EXPL_SMALL path
+      fma.s1 FR_N = FR_X, FR_INV_LN2_2TO63, FR_RSHF_2TO51
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+      fms.s1 FR_P_lo= FR_Input_Y, FR_logx_hi, FR_P_hi  // P_hi is X
+(p6)  br.cond.spnt POWL_Y_ALMOST_1              // Branch if |y-1| < 2^-50
+}
+;;
+
+{ .mmi
+      getf.exp GR_Expo_X = FR_X
+      add GR_T1_ptr   = 0x0b0, GR_table_base    // Constants_exp_64_T1
+      add GR_T2_ptr   = 0x1b0, GR_table_base    // Constants_exp_64_T2
+}
+;;
+
+// float_N = round_int(N)
+// The signficand of N contains the rounded integer part of X * 2^12/ln2,
+// as a twos complement number in the lower bits (that is, it may be negative).
+// That twos complement number (called N) is put into GR_N_fix.
+
+// Since N is scaled by 2^51, it must be multiplied by 2^-51
+// before the shift constant 1.10000 * 2^63 is subtracted to yield float_N.
+// Thus, float_N contains the floating point version of N
+
+
+{ .mfi
+      add  GR_Table_Ptr   = 0x20, GR_table_base    // Constants_exp_64_A
+      fms.s1 FR_float_N = FR_N, FR_2TOM51, FR_RSHF // Form float_N
+      nop.i 999
+}
+//     Create low part of Y(ln(x)_hi + ln(x)_lo) as P_lo
+{ .mfi
+      mov GR_Big_Pos_Exp = 0x3ffe               // 16382, largest safe exponent
+      fadd.s1 FR_P_lo = FR_P_lo, FR_X_lo
+      mov GR_Big_Neg_Exp = -0x3ffd              // -16381 smallest safe exponent
+};;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_rsq = FR_X, FR_X               // rsq = X*X for EXPL_SMALL path
+      mov GR_vsm_expo = -70                     // Exponent for very small path
+}
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly_lo = FR_P_6, FR_X, FR_P_5  // poly_lo for EXPL_SMALL path
+      add GR_temp = 0x1,r0                      // For tiny signif if small path
+}
+;;
+
+//
+//      If expo_X < -6 goto exp_small
+//
+{ .mmi
+      getf.sig GR_N_fix = FR_N
+      ldfe FR_A_3 = [GR_Table_Ptr],16         // Load A_3
+      and GR_Expo_X = GR_Expo_X, GR_exp_mask  // Get exponent of X
+}
+;;
+
+{ .mfi
+      ldfe FR_A_2 = [GR_Table_Ptr],16         // Load A_2
+      nop.f 999
+      sub GR_Expo_X = GR_Expo_X, GR_exp_bias  // Get true exponent of X
+}
+;;
+
+//
+//     If -6 > Expo_X, set P9 and branch
+//
+{ .mfb
+      cmp.gt  p9, p0  =  -6, GR_Expo_X
+      fnma.s1 FR_r = FR_L_hi, FR_float_N, FR_X // r = X - L_hi * float_N
+(p9)  br.cond.spnt EXPL_SMALL                  // Branch if |X| < 2^-6
+}
+;;
+
+//
+//     If 14 <= Expo_X, set P10
+//
+{ .mib
+      cmp.le  p10, p0 =  14, GR_Expo_X
+      nop.i 999
+(p10) br.cond.spnt EXPL_HUGE                   // Branch if |X| >= 2^14
+}
+;;
+
+//
+//      Load single T1
+//      Load single T2
+//      W_1_p1 = W_1 + 1
+//
+{ .mmi
+      nop.m 999
+      nop.m 999
+      extr.u GR_M1 = GR_N_fix, 6, 6            // Extract index M_1
+}
+;;
+
+//
+//      k = extr.u(N_fix,0,6)
+//
+{ .mmi
+      shladd GR_W1_ptr = GR_M1,3,GR_W1_ptr     // Point to W1
+      shladd GR_T1_ptr = GR_M1,2,GR_T1_ptr     // Point to T1
+      extr.u GR_M2 = GR_N_fix, 0, 6            // Extract index M_2
+}
+;;
+
+// N_fix is only correct up to 50 bits because of our right shift technique.
+// Actually in the normal path we will have restricted K to about 14 bits.
+// Somewhat arbitrarily we extract 32 bits.
+{ .mmi
+      ldfd  FR_W1 = [GR_W1_ptr]
+      shladd GR_W2_ptr = GR_M2,3,GR_W2_ptr     // Point to W2
+      extr GR_k = GR_N_fix, 12, 32             // Extract k
+}
+;;
+
+{ .mfi
+      ldfs  FR_T1 = [GR_T1_ptr]
+      fnma.s1 FR_r = FR_L_lo, FR_float_N, FR_r
+      shladd GR_T2_ptr = GR_M2,2,GR_T2_ptr     // Point to T2
+}
+{ .mfi
+      add GR_exp_bias_p_k = GR_exp_bias, GR_k
+      nop.f 999
+      cmp.gt  p14,p15 = GR_k,GR_Big_Pos_Exp
+}
+;;
+
+//
+//      if k < big_neg_exp, set p14 and Safe=False
+//
+{ .mmi
+      ldfs  FR_T2 = [GR_T2_ptr]
+(p15) cmp.lt p14,p15 = GR_k,GR_Big_Neg_Exp
+      nop.i 999
+}
+;;
+
+{ .mmi
+      setf.exp FR_Scale = GR_exp_bias_p_k
+      ldfd  FR_W2 = [GR_W2_ptr]
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe FR_A_1 = [GR_Table_Ptr],16
+      fadd.s1 FR_r = FR_r, FR_X_cor
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_W_1_p1 = FR_W1, f1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly = FR_r, FR_A_3, FR_A_2
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_rsq = FR_r, FR_r
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_T = FR_T1, FR_T2
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_W = FR_W2, FR_W_1_p1, FR_W1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_TMP1 = FR_Scale, FR_Sgn, f0
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly = FR_r, FR_poly, FR_A_1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_TMP2 = FR_T, f1, f0            // TMP2 = Y_hi = T
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_Wp1 = FR_W, f1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly = FR_rsq, FR_poly,FR_r
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_Tscale = FR_T, FR_TMP1, f0    // Scale * Sgn * T
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 FR_Y_lo = FR_Wp1, FR_poly, FR_W
+      nop.i 999
+}
+;;
+
+{ .mfb
+      nop.m 999
+      fmpy.s1 FR_TMP3 = FR_Y_lo, FR_Tscale
+      br.cond.sptk POWL_64_SHARED
+}
+;;
+
+
+EXPL_SMALL:
+// Here if |ylogx| < 2^-6
+//
+//     Begin creating lsb to perturb final result
+//
+{ .mfi
+      setf.sig FR_temp = GR_temp
+      fma.s1 FR_poly_lo = FR_poly_lo, FR_X, FR_P_4
+      cmp.lt  p12, p0 =  GR_Expo_X, GR_vsm_expo   // Test |ylogx| < 2^-70
+}
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly_hi = FR_P_2, FR_X, FR_P_1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_TMP2 = f1, f1
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_TMP1 = FR_Sgn, f1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_r4 = FR_rsq, FR_rsq
+(p12) cmp.eq  p15, p0 =  r0, r0                   // Set safe if |ylogx| < 2^-70
+}
+{ .mfb
+      nop.m 999
+(p12) fmpy.s1 FR_TMP3 = FR_Sgn, FR_X
+(p12) br.cond.spnt POWL_64_SHARED                 // Branch if |ylogx| < 2^-70
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly_lo = FR_poly_lo, FR_X, FR_P_3
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 FR_poly_hi = FR_poly_hi, FR_rsq, FR_X
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 FR_Y_lo = FR_poly_lo, FR_r4, FR_poly_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_TMP3 = FR_Y_lo, FR_TMP1      // Add sign info
+      nop.i 999
+}
+;;
+
+//
+//     Toggle on last bit of Y_lo
+//     Set lsb of Y_lo to 1
+//
+{ .mfi
+      nop.m 999
+      for FR_temp = FR_Y_lo,FR_temp
+      nop.i 999
+}
+;;
+
+{ .mfb
+      nop.m 999
+      fmerge.se FR_TMP3 = FR_TMP3,FR_temp
+      br.cond.sptk POWL_64_SHARED
+}
+;;
+
+
+EXPL_HUGE:
+// Here if |ylogx| >= 2^14
+{ .mfi
+      mov GR_temp = 0x0A1DC               // If X < 0, exponent -24100
+      fcmp.gt.s1 p12, p13 =  FR_X, f0     // Test X > 0
+      cmp.eq  p14, p15 =  r0, r0          // Set Safe to false
+}
+;;
+
+{ .mmi
+(p12) mov GR_Mask = 0x15DC0               // If X > 0, exponent +24000
+(p13) mov GR_Mask = 0x0A240               // If X < 0, exponent -24000
+      nop.i 999
+}
+;;
+
+{ .mmf
+      setf.exp FR_TMP2 = GR_Mask          // Form Y_hi = TMP2
+(p13) setf.exp FR_Y_lo = GR_temp          // If X < 0, Y_lo = 2^-24100
+(p12) mov FR_Y_lo = f1                    // IF X > 0, Y_lo = 1.0
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_TMP1 = FR_TMP2, FR_Sgn   // TMP1 = Y_hi * Sgn
+      nop.i 999
+}
+;;
+
+{ .mfb
+      nop.m 999
+      fmpy.s1 FR_TMP3 = FR_Y_lo,FR_TMP1   // TMP3 = Y_lo * (Y_hi * Sgn)
+      br.cond.sptk POWL_64_SHARED
+}
+;;
+
+POWL_Y_ALMOST_1:
+// Here if delta = |y-1| < 2^-50
+//
+//  x**(1 + delta) = x * e (ln(x)*delta) = x ( 1 + ln(x) * delta)
+//
+// Computation will be safe for 2^-16381 <= x < 2^16383
+
+{ .mfi
+       mov GR_exp_ynear1_oflow = 0xffff + 16383
+       fma.s1 FR_TMP1 = FR_Input_X,FR_Delta,f0
+       and GR_exp_x = GR_exp_mask, GR_signexp_x
+}
+;;
+
+{ .mfi
+       cmp.lt  p15, p14 =  GR_exp_x, GR_exp_ynear1_oflow
+       fma.s1 FR_TMP2 = FR_logx_hi,f1,FR_X_lo
+       mov GR_exp_ynear1_uflow = 0xffff - 16381
+}
+;;
+
+{ .mfb
+(p15)  cmp.ge  p15, p14 =  GR_exp_x, GR_exp_ynear1_uflow
+       fma.s1 FR_TMP3 = FR_Input_X,f1,f0
+       br.cond.sptk POWL_64_SHARED
+};;
+
+POWL_64_SQUARE:
+//
+//      Here if x not zero and y=2.
+//
+//      Setup for multipath code
+//
+{ .mfi
+      mov GR_exp_square_oflow = 0xffff + 8192   // Exponent where x*x overflows
+      fmerge.se FR_TMP1 = FR_Input_X, FR_Input_X
+      and GR_exp_x = GR_exp_mask, GR_signexp_x  // Get exponent of x
+}
+;;
+
+{ .mfi
+      cmp.lt  p15, p14 =  GR_exp_x, GR_exp_square_oflow // Decide safe/unsafe
+      fmerge.se FR_TMP2 = FR_Input_X, FR_Input_X
+      mov GR_exp_square_uflow = 0xffff - 8191   // Exponent where x*x underflows
+}
+;;
+
+{ .mfi
+(p15) cmp.ge  p15, p14 =  GR_exp_x, GR_exp_square_uflow // Decide safe/unsafe
+      fma.s1 FR_TMP3 = f0,f0,f0
+      nop.i 999
+}
+;;
+
+//
+//      This is the shared path that will set overflow and underflow.
+//
+POWL_64_SHARED:
+
+//
+//      Return if no danger of over or underflow.
+//
+{ .mfb
+      nop.m 999
+      fma.s0 FR_Result = FR_TMP1, FR_TMP2, FR_TMP3
+(p15) br.ret.sptk  b0      // Main path return if certain no over/underflow
+}
+;;
+
+//
+//      S0 user supplied status
+//      S2 user supplied status + WRE + TD  (Overflows)
+//      S2 user supplied status + FZ + TD   (Underflows)
+//
+//
+//     If (Safe) is true, then
+//        Compute result using user supplied status field.
+//        No overflow or underflow here, but perhaps inexact.
+//        Return
+//     Else
+//       Determine if overflow or underflow was raised.
+//       Fetch +/- overflow threshold for IEEE double extended
+
+{ .mfi
+      nop.m 999
+      fsetc.s2 0x7F,0x41       // For underflow test, set S2=User+TD+FTZ
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s2 FR_Result_small = FR_TMP1, FR_TMP2, FR_TMP3
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fsetc.s2 0x7F,0x42       // For overflow test, set S2=User+TD+WRE
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s2 FR_Result_big = FR_TMP1, FR_TMP2,FR_TMP3
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fsetc.s2 0x7F,0x40       // Reset S2=User
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m p11, p0 = FR_Result_small, 0x00F // Test small result unorm/zero
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fcmp.ge.s1 p8, p0 = FR_Result_big , FR_Big // Test >= + oflow threshold
+      nop.i 999
+}
+;;
+
+{ .mfb
+(p11) mov   GR_Parameter_TAG = 19                // Set tag for underflow
+      fcmp.le.s1 p9, p0 = FR_Result_big, FR_NBig // Test <= - oflow threshold
+(p11) br.cond.spnt __libm_error_region           // Branch if pow underflowed
+}
+;;
+
+{ .mfb
+(p8)  mov   GR_Parameter_TAG = 18                // Set tag for overflow
+      nop.f 999
+(p8)  br.cond.spnt __libm_error_region           // Branch if pow +overflow
+}
+;;
+
+{ .mbb
+(p9)  mov   GR_Parameter_TAG = 18                // Set tag for overflow
+(p9)  br.cond.spnt __libm_error_region           // Branch if pow -overflow
+      br.ret.sptk  b0                            // Branch if result really ok
+}
+;;
+
+
+POWL_64_SPECIAL:
+// Here if x or y is NatVal, nan, inf, or zero
+{ .mfi
+      nop.m 999
+      fcmp.eq.s1 p15, p0 =  FR_Input_X, f1  // Test x=+1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m p8, p0 =  FR_Input_X, 0x143  // Test x natval, snan
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p15) fcmp.eq.unc.s0 p6,p0 = FR_Input_Y, f0 // If x=1, flag invalid if y=SNaN
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+(p15) fmpy.s0 FR_Result = f1,f1             // If x=1, result=1
+(p15) br.ret.spnt b0                        // Exit if x=1
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m p6, p0 =  FR_Input_Y, 0x007  // Test y zero
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m p9, p0 =  FR_Input_Y, 0x143  // Test y natval, snan
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m p10, p0 =  FR_Input_X, 0x083 // Test x qnan
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p8)  fmpy.s0 FR_Result = FR_Input_Y, FR_Input_X // If x=snan, result=qnan
+(p6)  cmp.ne p8,p0 = r0,r0     // Don't exit if x=snan, y=0 ==> result=+1
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p6)  fclass.m.unc p15, p0 =  FR_Input_X,0x007   // Test x=0, y=0
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+(p9)  fmpy.s0 FR_Result = FR_Input_Y, FR_Input_X // If y=snan, result=qnan
+(p8)  br.ret.spnt b0                             // Exit if x=snan, y not 0,
+                                                 //   result=qnan
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fcmp.eq.s1 p7, p0 =  FR_Input_Y, f1        // Test y +1.0
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+(p10) fmpy.s0 FR_Result = FR_Input_X, f0         // If x=qnan, result=qnan
+(p9)  br.ret.spnt b0                             // Exit if y=snan, result=qnan
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p6)  fclass.m.unc p8, p0 =  FR_Input_X,0x0C3    // Test x=nan, y=0
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p6)  fcmp.eq.s0 p9,p0 = FR_Input_X, f0          // If y=0, flag if x denormal
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p6)  fadd.s0 FR_Result = f1, f0                 // If y=0, result=1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m p11, p0 =  FR_Input_Y, 0x083      // Test y qnan
+      nop.i 999
+}
+{ .mfb
+(p15) mov GR_Parameter_TAG = 20                  // Error tag for x=0, y=0
+(p7)  fmpy.s0 FR_Result = FR_Input_X,f1          // If y=1, result=x
+(p15) br.cond.spnt __libm_error_region           // Branch if x=0, y=0, result=1
+}
+;;
+
+{ .mfb
+(p8)  mov GR_Parameter_TAG = 23                  // Error tag for x=nan, y=0
+      fclass.m p14, p0 =  FR_Input_Y, 0x023      // Test y inf
+(p8)  br.cond.spnt __libm_error_region           // Branch if x=snan, y=0,
+                                                 //   result=1
+}
+;;
+
+{ .mfb
+      nop.m 999
+      fclass.m p13, p0 =  FR_Input_X, 0x023      // Test x inf
+(p6)  br.ret.spnt b0                             // Exit y=0, x not nan or 0,
+                                                 //   result=1
+}
+;;
+
+{ .mfb
+      nop.m 999
+(p14) fcmp.eq.unc.s1 p0,p14 = FR_Input_X,f0      // Test x not 0, y=inf
+(p7)  br.ret.spnt b0                             // Exit y=1, x not snan,
+                                                 //   result=x
+}
+;;
+
+{ .mfb
+      nop.m 999
+(p10) fmpy.s0 FR_Result = FR_Input_Y,FR_Input_X  // If x=qnan, y not snan,
+                                                 //   result=qnan
+(p10) br.ret.spnt b0                             // Exit x=qnan, y not snan,
+                                                 //   result=qnan
+}
+;;
+
+{ .mfb
+      nop.m 999
+(p11) fmpy.s0 FR_Result = FR_Input_Y,FR_Input_X  // If y=qnan, x not nan or 1,
+                                                 //   result=qnan
+(p11) br.ret.spnt b0                             // Exit y=qnan, x not nan or 1,
+                                                 //   result=qnan
+}
+;;
+
+{ .mbb
+      nop.m 999
+(p14) br.cond.spnt POWL_64_Y_IS_INF           // Branch if y=inf, x not 1 or nan
+(p13) br.cond.spnt POWL_64_X_IS_INF           // Branch if x=inf, y not 1 or nan
+}
+;;
+
+
+POWL_64_X_IS_ZERO:
+// Here if x=0, y not nan or 1 or inf or 0
+
+// There is logic starting here to determine if y is an integer when x = 0.
+// If 0 < |y| < 1 then clearly y is not an integer.
+// If |y| > 1, then the significand of y is shifted left by the size of
+//    the exponent of y.  This preserves the lsb of the integer part + the
+//    fractional bits.  The lsb of the integer can be tested to determine if
+//    the integer is even or odd.  The fractional bits can be tested.  If zero,
+//    then y is an integer.
+//
+{ .mfi
+      and GR_exp_y = GR_exp_mask,GR_signexp_y   // Get biased exponent of y
+      nop.f 999
+      and GR_y_sign = GR_sign_mask,GR_signexp_y // Get sign of y
+}
+;;
+
+//
+//     Maybe y is < 1 already, so
+//     can never be an integer.
+//
+{ .mfi
+      cmp.lt  p9, p8 = GR_exp_y,GR_exp_bias     // Test 0 < |y| < 1
+      nop.f 999
+      sub GR_exp_y = GR_exp_y,GR_exp_bias       // Get true exponent of y
+}
+;;
+
+//
+//     Shift significand of y looking for nonzero bits
+//     For y > 1, shift signif_y exp_y bits to the left
+//     For y < 1, turn on 4 low order bits of significand of y
+//     so that the fraction will always be non-zero
+//
+{ .mmi
+(p9)  or  GR_exp_y=  0xF,GR_signif_y            // Force nonzero fraction if y<1
+;;
+      nop.m 999
+(p8)  shl GR_exp_y=  GR_signif_y,GR_exp_y       // Get lsb of int + fraction
+                                                // Wait 4 cycles to use result
+}
+;;
+
+{ .mmi
+      nop.m 999
+;;
+      nop.m 999
+      nop.i 999
+}
+;;
+
+{ .mmi
+      nop.m 999
+;;
+      nop.m 999
+      shl GR_fraction_y=  GR_exp_y,1            // Shift left 1 to get fraction
+}
+;;
+
+//
+//     Integer part of y  shifted off.
+//     Get y's low even or odd bit - y might not be an int.
+//
+{ .mii
+      cmp.eq  p13,p0  =  GR_fraction_y, r0      // Test for y integer
+      cmp.eq  p8,p0 =  GR_y_sign, r0            // Test for y > 0
+;;
+(p13) tbit.nz.unc p13,p0 = GR_exp_y, 63         // Test if y an odd integer
+}
+;;
+
+{ .mfi
+(p13) cmp.eq.unc p13,p14 =  GR_y_sign, r0   // Test y pos odd integer
+(p8)  fcmp.eq.s0 p12,p0 = FR_Input_Y, f0    // If x=0 and y>0 flag if y denormal
+      nop.i 999
+}
+;;
+
+//
+//     Return +/-0 when x=+/-0 and y is positive odd integer
+//
+{ .mfb
+      nop.m 999
+(p13) mov FR_Result = FR_Input_X            // If x=0,  y pos odd int, result=x
+(p13) br.ret.spnt b0                        // Exit x=0, y pos odd int, result=x
+}
+;;
+
+//
+//     Return +/-inf when x=+/-0 and y is negative odd int
+//
+{ .mfb
+(p14) mov GR_Parameter_TAG = 21
+(p14) frcpa.s0 FR_Result, p0 = f1, FR_Input_X  // Result +-inf, set Z flag
+(p14) br.cond.spnt __libm_error_region
+}
+;;
+
+//
+//     Return +0 when x=+/-0 and y positive and not an odd integer
+//
+{ .mfb
+      nop.m 999
+(p8)  mov FR_Result = f0      // If x=0, y>0 and not odd integer, result=+0
+(p8)  br.ret.sptk b0          // Exit x=0, y>0 and not odd integer, result=+0
+}
+;;
+
+//
+//     Return +inf when x=+/-0 and y is negative and not odd int
+//
+{ .mfb
+      mov GR_Parameter_TAG = 21
+      frcpa.s0 FR_Result, p10 = f1,f0   // Result +inf, raise Z flag
+      br.cond.sptk __libm_error_region
+}
+;;
+
+
+POWL_64_X_IS_INF:
+//
+// Here if x=inf, y not 1 or nan
+//
+{ .mfi
+      and GR_exp_y = GR_exp_mask,GR_signexp_y   // Get biased exponent y
+      fclass.m p13, p0 =  FR_Input_X,0x022      // Test x=-inf
+      nop.i 999
+}
+;;
+
+{ .mfi
+      and GR_y_sign = GR_sign_mask,GR_signexp_y // Get sign of y
+      fcmp.eq.s0 p9,p0 = FR_Input_Y, f0         // Dummy to set flag if y denorm
+      nop.i 999
+}
+;;
+
+//
+//     Maybe y is < 1 already, so
+//     isn't an int.
+//
+{ .mfi
+(p13) cmp.lt.unc  p9, p8 = GR_exp_y,GR_exp_bias // Test 0 < |y| < 1 if x=-inf
+      fclass.m p11, p0 =  FR_Input_X,0x021      // Test x=+inf
+      sub GR_exp_y = GR_exp_y,GR_exp_bias       // Get true exponent y
+}
+;;
+
+//
+//     Shift significand of y looking for nonzero bits
+//     For y > 1, shift signif_y exp_y bits to the left
+//     For y < 1, turn on 4 low order bits of significand of y
+//     so that the fraction will always be non-zero
+//
+{ .mmi
+(p9)  or  GR_exp_y=  0xF,GR_signif_y          // Force nonzero fraction if y<1
+;;
+(p11) cmp.eq.unc  p14,p12 = GR_y_sign, r0     // Test x=+inf, y>0
+(p8)  shl GR_exp_y=  GR_signif_y,GR_exp_y     // Get lsb of int + fraction
+                                              // Wait 4 cycles to use result
+}
+;;
+
+//
+//     Return +inf for x=+inf, y > 0
+//     Return +0   for x=+inf, y < 0
+//
+{ .mfi
+      nop.m 999
+(p12) mov FR_Result = f0                      // If x=+inf, y<0, result=+0
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+(p14) fma.s0 FR_Result = FR_Input_X,f1,f0     // If x=+inf, y>0, result=+inf
+(p11) br.ret.sptk b0                          // Exit x=+inf
+}
+;;
+
+//
+// Here only if x=-inf.  Wait until can use result of shl...
+//
+{ .mmi
+      nop.m 999
+;;
+      nop.m 999
+      nop.i 999
+}
+;;
+
+{ .mfi
+      cmp.eq  p8,p9 = GR_y_sign, r0           // Test y pos
+      nop.f 999
+      shl GR_fraction_y = GR_exp_y,1          // Shift left 1 to get fraction
+}
+;;
+
+{ .mmi
+      cmp.eq  p13,p0 = GR_fraction_y, r0      // Test y integer
+;;
+      nop.m 999
+(p13) tbit.nz.unc  p13,p0 = GR_exp_y, 63      // Test y odd integer
+}
+;;
+
+//
+//     Is y even or odd?
+//
+{ .mii
+(p13) cmp.eq.unc  p14,p10 = GR_y_sign, r0     // Test x=-inf, y pos odd int
+(p13) cmp.ne.and  p8,p9 = r0,r0               // If y odd int, turn off p8,p9
+      nop.i 999
+}
+;;
+
+//
+//     Return -0   for x = -inf and y < 0 and odd int.
+//     Return -Inf for x = -inf and y > 0 and odd int.
+//
+{ .mfi
+      nop.m 999
+(p10) fmerge.ns FR_Result = f0, f0      // If x=-inf, y neg odd int, result=-0
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p14) fmpy.s0 FR_Result = FR_Input_X,f1 // If x=-inf, y pos odd int, result=-inf
+      nop.i 999
+}
+;;
+
+//
+//     Return Inf for x = -inf and y > 0 not an odd int.
+//     Return +0  for x = -inf and y < 0 not an odd int.
+//
+.pred.rel "mutex",p8,p9
+{ .mfi
+      nop.m 999
+(p8)  fmerge.ns FR_Result = FR_Input_X, FR_Input_X // If x=-inf, y>0 not odd int
+                                                   //   result=+inf
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+(p9)  fmpy.s0 FR_Result = f0,f0                    // If x=-inf, y<0 not odd int
+                                                   //   result=+0
+      br.ret.sptk b0                               // Exit for x=-inf
+}
+;;
+
+
+POWL_64_Y_IS_INF:
+// Here if y=inf, x not 1 or nan
+//
+//     For y = +Inf and |x| < 1  returns 0
+//     For y = +Inf and |x| > 1  returns Inf
+//     For y = -Inf and |x| < 1  returns Inf
+//     For y = -Inf and |x| > 1  returns 0
+//     For y =  Inf and |x| = 1  returns 1
+//
+{ .mfi
+      nop.m 999
+      fclass.m p8, p0 =  FR_Input_Y, 0x021    // Test y=+inf
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m p9, p0 =  FR_Input_Y, 0x022    // Test y=-inf
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fabs FR_X = FR_Input_X                  // Form |x|
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fcmp.eq.s0 p10,p0 = FR_Input_X, f0      // flag if x denormal
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p8)  fcmp.lt.unc.s1 p6, p0  =  FR_X, f1      // Test y=+inf, |x|<1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p8)  fcmp.gt.unc.s1 p7, p0  =  FR_X, f1      // Test y=+inf, |x|>1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fcmp.lt.unc.s1 p12, p0 =  FR_X, f1      // Test y=-inf, |x|<1
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p6)  fmpy.s0 FR_Result = f0,f0               // If y=+inf, |x|<1, result=+0
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fcmp.gt.unc.s1 p13, p0 =  FR_X, f1      // Test y=-inf, |x|>1
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p7)  fmpy.s0 FR_Result = FR_Input_Y, f1      // If y=+inf, |x|>1, result=+inf
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fcmp.eq.s1 p14, p0 =  FR_X, f1          // Test y=inf, |x|=1
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p12) fnma.s0 FR_Result = FR_Input_Y, f1, f0  // If y=-inf, |x|<1, result=+inf
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p13) mov FR_Result = f0                      // If y=-inf, |x|>1, result=+0
+      nop.i 999
+}
+;;
+
+{ .mfb
+      nop.m 999
+(p14) fmpy.s0 FR_Result = f1,f1               // If y=inf, |x|=1, result=+1
+      br.ret.sptk b0                          // Common return for y=inf
+}
+;;
+
+
+// Here if x or y denorm/unorm
+POWL_DENORM:
+{ .mmi
+      getf.sig GR_signif_Z = FR_norm_X   // Get significand of x
+;;
+      getf.exp GR_signexp_y = FR_norm_Y  // Get sign and exp of y
+      nop.i 999
+}
+;;
+
+{ .mfi
+      getf.sig GR_signif_y = FR_norm_Y   // Get significand of y
+      nop.f 999
+      nop.i 999
+}
+;;
+
+{ .mib
+      getf.exp GR_signexp_x = FR_norm_X  // Get sign and exp of x
+      extr.u GR_Index1 = GR_signif_Z, 59, 4  // Extract upper 4 signif bits of x
+      br.cond.sptk  POWL_COMMON          // Branch back to main path
+}
+;;
+
+
+POWL_64_UNSUPPORT:
+//
+//     Raise exceptions for specific
+//     values - pseudo NaN and
+//     infinities.
+//     Return NaN and raise invalid
+//
+{ .mfb
+      nop.m 999
+      fmpy.s0 FR_Result = FR_Input_X,f0
+      br.ret.sptk b0
+}
+;;
+
+POWL_64_XNEG:
+//
+//     Raise invalid for x < 0  and
+//     y not an integer
+//
+{ .mfi
+      nop.m 999
+      frcpa.s0 FR_Result, p8 =  f0, f0
+      mov GR_Parameter_TAG = 22
+}
+{ .mib
+      nop.m 999
+      nop.i 999
+      br.cond.sptk __libm_error_region
+}
+;;
+
+POWL_64_SQRT:
+{ .mfi
+      nop.m 999
+      frsqrta.s0 FR_Result,p10 = FR_save_Input_X
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fma.s1   f62=FR_Half,FR_save_Input_X,f0
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fma.s1   f63=FR_Result,FR_Result,f0
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fnma.s1  f32=f63,f62,FR_Half
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fma.s1   f33=f32,FR_Result,FR_Result
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fma.s1   f34=f33,f62,f0
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fnma.s1  f35=f34,f33,FR_Half
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fma.s1   f63=f35,f33,f33
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fma.s1   f32=FR_save_Input_X,f63,f0
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p10) fma.s1   FR_Result=f63,f62,f0
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fma.s1   f33=f11,f63,f0
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fnma.s1  f34=f32,f32,FR_save_Input_X
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p10) fnma.s1  f35=FR_Result,f63,FR_Half
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fma.s1   f62=f33,f34,f32
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p10) fma.s1   f63=f33,f35,f33
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10) fnma.s1  f32=f62,f62,FR_save_Input_X
+      nop.i 999 ;;
+}
+{ .mfb
+      nop.m 999
+(p10) fma.s0 FR_Result=f32,f63,f62
+      br.ret.sptk   b0                // Exit for x > 0, y = 0.5
+}
+;;
+
+GLOBAL_LIBM_END(powl)
+libm_alias_ldouble_other (pow, pow)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfe [GR_Parameter_Y] = FR_Input_Y,16   // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfe [GR_Parameter_X] = FR_save_Input_X // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfe [GR_Parameter_Y] = FR_Result       // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]        // Get return result off stack
+.restore sp
+        add   sp = 64,sp                        // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                   // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region#)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_rem_pio2l.c
@@ -0,0 +1 @@
+/* Not needed. */
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_remainder.S
@@ -0,0 +1,589 @@
+.file "remainder.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//====================================================================
+// 02/02/00 Initial version
+// 03/02/00 New Algorithm
+// 04/04/00 Unwind support added
+// 07/21/00 Fixed quotient=2^{24*m+23}*1.q1...q23 1 bug
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 11/29/00 Set FR_Y to f9
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+// API
+//====================================================================
+// double remainder(double,double);
+//
+// Overview of operation
+//====================================================================
+//  remainder(a,b)=a-i*b,
+//  where i is an integer such that, if b!=0 and a is finite,
+//  |a/b-i|<=1/2. If |a/b-i|=1/2, i is even.
+//
+// Algorithm
+//====================================================================
+// a). eliminate special cases
+// b). if |a/b|<0.25 (first quotient estimate), return a
+// c). use single precision divide algorithm to get quotient q
+//     rounded to 24 bits of precision
+// d). calculate partial remainders (using both q and q-ulp);
+//     select one and RZ(a/b) based on the sign of |a|-|b|*q
+// e). if the exponent difference (exponent(a)-exponent(b))
+//     is less than 24 (quotient estimate<2^{24}-2), use RZ(a/b)
+//     and sticky bits to round to integer; exit loop and
+//     calculate final remainder
+// f). if exponent(a)-exponent(b)>=24, select new value of a as
+//     the partial remainder calculated using RZ(a/b);
+//     repeat from c).
+//
+// Special cases
+//====================================================================
+// a=+/- Inf, or b=+/-0: return NaN, call libm_error_support
+// a=NaN or b=NaN: return NaN
+
+// Registers used
+//====================================================================
+// Predicate registers: p6-p14
+// General registers:   r2,r3,r28,r29,r32 (ar.pfs), r33-r39
+// Floating point registers: f6-f15,f32
+
+GR_SAVE_B0                    = r33
+GR_SAVE_PFS                   = r34
+GR_SAVE_GP                    = r35
+GR_SAVE_SP                    = r36
+
+GR_Parameter_X                = r37
+GR_Parameter_Y                = r38
+GR_Parameter_RESULT           = r39
+GR_Parameter_TAG              = r40
+
+FR_X             = f10
+FR_Y             = f9
+FR_RESULT        = f8
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(remainder)
+
+// inputs in f8, f9
+// result in f8
+
+{ .mfi
+  alloc r32=ar.pfs,1,4,4,0
+  // f13=|a|
+  fmerge.s f13=f0,f8
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // f14=|b|
+  fmerge.s f14=f0,f9
+  nop.i 0;;
+}
+ {.mlx
+  mov r28=0x2ffdd
+  // r2=2^{23}
+  movl r3=0x4b000000;;
+}
+
+// Y +-NAN, +-inf, +-0?     p11
+{ .mfi
+	  setf.exp f32=r28
+      fclass.m.unc  p11,p0 = f9, 0xe7
+      nop.i 999
+}
+// qnan snan inf norm     unorm 0 -+
+// 1    1    1   0        0     0 11
+// e                      3
+// X +-NAN, +-inf, ?        p9
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p0 = f8, 0xe3
+      nop.i 999;;
+}
+
+{.mfi
+  nop.m 0
+  mov f12=f0
+  nop.i 0
+}
+{ .mfi
+  // set p7=1
+  cmp.eq.unc p7,p0=r0,r0
+  // Step (1)
+  // y0 = 1 / b in f10
+  frcpa.s1 f10,p6=f13,f14
+  nop.i 0;;
+}
+
+{.bbb
+  (p9) br.cond.spnt FREM_X_NAN_INF
+  (p11) br.cond.spnt FREM_Y_NAN_INF_ZERO
+  nop.b 0
+}  {.mfi
+   nop.m 0
+   // set D flag if a (f8) is denormal
+   fnma.s0 f6=f8,f1,f8
+   nop.i 0;;
+}
+
+
+remloop24:
+  { .mfi
+  nop.m 0
+  // Step (2)
+  // q0 = a * y0 in f12
+  (p6) fma.s1 f12=f13,f10,f0
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (3)
+  // e0 = 1 - b * y0 in f7
+  (p6) fnma.s1 f7=f14,f10,f1
+  nop.i 0;;
+}  {.mlx
+  nop.m 0
+  // r2=1.25*2^{-24}
+  movl r2=0x33a00000;;
+}
+
+{.mfi
+  nop.m 0
+  // q1=q0*(1+e0)
+  (p6) fma.s1 f15=f12,f7,f12
+  nop.i 0
+}
+{ .mfi
+  nop.m 0
+  // Step (4)
+  // e1 = e0 * e0 + E in f7
+  (p6) fma.s1 f7=f7,f7,f32
+  nop.i 0;;
+}
+ {.mii
+  (p7) getf.exp r29=f12
+  (p7) mov r28=0xfffd
+  nop.i 0;;
+}
+ { .mfi
+  // f12=2^{23}
+  setf.s f12=r3
+  // Step (5)
+  // q2 = q1 + e1 * q1 in f11
+  (p6) fma.s.s1 f11=f7,f15,f15
+  nop.i 0
+} { .mfi
+   nop.m 0
+  // Step (6)
+  // q2 = q1 + e1 * q1 in f6
+  (p6) fma.s1 f6=f7,f15,f15
+  nop.i 0;;
+}
+
+ {.mmi
+  // f15=1.25*2^{-24}
+  setf.s f15=r2
+  // q<1/4 ? (i.e. expon< -2)
+  (p7) cmp.gt p7,p0=r28,r29
+  nop.i 0;;
+}
+
+{.mfb
+  // r29= -32+bias
+  mov r29=0xffdf
+ // if |a/b|<1/4, set D flag before returning
+ (p7) fma.d.s0 f9=f9,f0,f8
+  nop.b 0;;
+}
+ {.mfb
+ nop.m 0
+ // can be combined with bundle above if sign of 0 or
+ // FTZ enabled are not important
+ (p7) fmerge.s f8=f8,f9
+ // return if |a|<4*|b| (estimated quotient < 1/4)
+ (p7) br.ret.spnt b0;;
+}
+  {.mfi
+  // f7=2^{-32}
+  setf.exp f7=r29
+  // set f8 to current a value | sign
+  fmerge.s f8=f8,f13
+  nop.i 0;;
+}
+
+
+  {.mfi
+  getf.exp r28=f6
+  // last step ? (q<2^{23})
+  fcmp.lt.unc.s1 p0,p12=f6,f12
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // r=a-b*q
+  fnma.s1 f6=f14,f11,f13
+  nop.i 0
+} {.mfi
+  // r2=23+bias
+  mov r2=0xffff+23
+  // q'=q-q*(1.25*2^{-24})   (q'=q-ulp)
+  fnma.s.s1 f15=f11,f15,f11
+  nop.i 0;;
+}
+  {.mmi
+  nop.m 0
+  cmp.eq p11,p14=r2,r28
+  nop.i 0;;
+}
+
+.pred.rel "mutex",p11,p14
+  {.mfi
+  nop.m 0
+  // if exp_q=2^23, then r=a-b*2^{23}
+  (p11) fnma.s1 f13=f12,f14,f13
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // r2=a-b*q'
+  (p14) fnma.s1 f13=f14,f15,f13
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // r>0 iff q=RZ(a/b) and inexact
+  fcmp.gt.unc.s1 p8,p0=f6,f0
+  nop.i 0
+} {.mfi
+  nop.m 0
+  // r<0 iff q'=RZ(a/b) and inexact
+  (p14) fcmp.lt.unc.s1 p9,p10=f6,f0
+  nop.i 0;;
+}
+
+.pred.rel "mutex",p8,p9
+  {.mfi
+   nop.m 0
+  // (p8) Q=q+(last iteration ? sticky bits:0)
+  // i.e. Q=q+q*x  (x=2^{-32} or 0)
+  (p8) fma.s1 f11=f11,f7,f11
+  nop.i 0
+} {.mfi
+  nop.m 0
+  // (p9) Q=q'+(last iteration ? sticky bits:0)
+  // i.e. Q=q'+q'*x  (x=2^{-32} or 0)
+  (p9) fma.s1 f11=f15,f7,f15
+  nop.i 0;;
+}
+
+  {.mfb
+  nop.m 0
+  //  (p9) set r=r2 (new a, if not last iteration)
+  // (p10) new a =r
+  (p10) mov f13=f6
+  (p12) br.cond.sptk remloop24;;
+}
+
+// last iteration
+  {.mfi
+  nop.m 0
+  // set f9=|b|*sgn(a)
+  fmerge.s f9=f8,f9
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // round to integer
+  fcvt.fx.s1 f11=f11
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // save sign of a
+  fmerge.s f7=f8,f8
+  nop.i 0
+} {.mfi
+  nop.m 0
+  // normalize
+  fcvt.xf f11=f11
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // This can be removed if sign of 0 is not important
+  // get remainder using sf1
+  fnma.d.s1 f12=f9,f11,f8
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // get remainder
+  fnma.d.s0 f8=f9,f11,f8
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // f12=0?
+  // This can be removed if sign of 0 is not important
+  fcmp.eq.unc.s1 p8,p0=f12,f0
+  nop.i 0;;
+}
+  {.mfb
+  nop.m 0
+  // if f8=0, set sign correctly
+  // This can be removed if sign of 0 is not important
+  (p8) fmerge.s f8=f7,f8
+  // return
+  br.ret.sptk b0;;
+}
+
+
+FREM_X_NAN_INF:
+
+// Y zero ?
+{.mfi
+  nop.m 0
+  fma.s1 f10=f9,f1,f0
+  nop.i 0;;
+}
+{.mfi
+ nop.m 0
+ fcmp.eq.unc.s1 p11,p0=f10,f0
+ nop.i 0;;
+}
+{.mib
+  nop.m 0
+  nop.i 0
+  // if Y zero
+  (p11) br.cond.spnt FREM_Y_ZERO;;
+}
+
+// X infinity? Return QNAN indefinite
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p8,p0 = f8, 0x23
+      nop.i 999
+}
+// X infinity? Return QNAN indefinite
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p11,p0 = f8, 0x23
+      nop.i 999;;
+}
+// Y NaN ?
+{.mfi
+	 nop.m 999
+(p8) fclass.m.unc p0,p8=f9,0xc3
+	 nop.i 0;;
+}
+{.mfi
+	nop.m 999
+	// also set Denormal flag if necessary
+(p8) fma.s0 f9=f9,f1,f0
+    nop.i 0
+}
+{ .mfi
+      nop.m 999
+(p8)  frcpa.s0 f8,p7 = f8,f8
+      nop.i 999 ;;
+}
+
+{.mfi
+      nop.m 999
+(p11) mov f10=f8
+	  nop.i 0
+}
+{ .mfi
+      nop.m 999
+(p8) fma.d.s0 f8=f8,f1,f0
+	  nop.i 0 ;;
+}
+
+{ .mfb
+      nop.m 999
+      frcpa.s0 f8,p7=f8,f9
+	  (p11) br.cond.spnt EXP_ERROR_RETURN;;
+}
+{ .mib
+	nop.m 0
+	nop.i 0
+	br.ret.spnt    b0 ;;
+}
+
+
+FREM_Y_NAN_INF_ZERO:
+
+// Y INF
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p7,p0 = f9, 0x23
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p7)  fma.d.s0 f8=f8,f1,f0
+(p7)  br.ret.spnt    b0 ;;
+}
+
+// Y NAN?
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p0 = f9, 0xc3
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p9)  fma.d.s0 f8=f9,f1,f0
+(p9)  br.ret.spnt    b0 ;;
+}
+
+FREM_Y_ZERO:
+// Y zero? Must be zero at this point
+// because it is the only choice left.
+// Return QNAN indefinite
+
+// X NAN?
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p10 = f8, 0xc3
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10)  fclass.nm  p9,p10 = f8, 0xff
+      nop.i 999 ;;
+}
+
+{.mfi
+ nop.m 999
+ (p9) frcpa.s0 f11,p7=f8,f0
+ nop.i 0;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)  frcpa.s0         f11,p7 = f0,f0
+	  nop.i 999;;
+}
+
+{ .mfi
+      nop.m 999
+      fmerge.s      f10 = f8, f8
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+      fma.d.s0 f8=f11,f1,f0
+      nop.i 999
+}
+
+
+EXP_ERROR_RETURN:
+
+{ .mib
+      mov   GR_Parameter_TAG = 124
+	  nop.i 999
+      br.sptk __libm_error_region;;
+}
+
+GLOBAL_IEEE754_END(remainder)
+libm_alias_double_other (__remainder, remainder)
+weak_alias (__remainder, drem)
+
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfd [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfd [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+	nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfd [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#  // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_remainderf.S
@@ -0,0 +1,607 @@
+.file "remainderf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//====================================================================
+// 02/02/00 Initial version
+// 03/02/00 New algorithm
+// 04/04/00 Unwind support added
+// 07/21/00 Fixed quotient=2^{24*m+23} bug
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 11/29/00 Set FR_Y to f9
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+// API
+//====================================================================
+// float remainderf(float,float);
+//
+// Overview of operation
+//====================================================================
+//  remainder(a,b)=a-i*b,
+//  where i is an integer such that, if b!=0 and a is finite,
+//  |a/b-i|<=1/2. If |a/b-i|=1/2, i is even.
+//
+// Algorithm
+//====================================================================
+// a). eliminate special cases
+// b). if |a/b|<0.25 (first quotient estimate), return a
+// c). use single precision divide algorithm to get quotient q
+//     rounded to 24 bits of precision
+// d). calculate partial remainders (using both q and q-ulp);
+//     select one and RZ(a/b) based on the sign of |a|-|b|*q
+// e). if the exponent difference (exponent(a)-exponent(b))
+//     is less than 24 (quotient estimate<2^{24}-2), use RZ(a/b)
+//     and sticky bits to round to integer; exit loop and
+//     calculate final remainder
+// f). if exponent(a)-exponent(b)>=24, select new value of a as
+//     the partial remainder calculated using RZ(a/b);
+//     repeat from c).
+//
+// Special cases
+//====================================================================
+// a=+/- Inf, or b=+/-0: return NaN, call libm_error_support
+// a=NaN or b=NaN: return NaN
+//
+// Registers used
+//====================================================================
+// Predicate registers: p6-p12
+// General registers:   r2,r3,r28,r29,r32 (ar.pfs), r33-r39
+// Floating point registers: f6-f15
+//
+
+GR_SAVE_B0                    = r33
+GR_SAVE_PFS                   = r34
+GR_SAVE_GP                    = r35
+GR_SAVE_SP                    = r36
+
+GR_Parameter_X                = r37
+GR_Parameter_Y                = r38
+GR_Parameter_RESULT           = r39
+GR_Parameter_TAG              = r40
+
+FR_X             = f10
+FR_Y             = f9
+FR_RESULT        = f8
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(remainderf)
+
+// inputs in f8, f9
+// result in f8
+
+{ .mfi
+  alloc r32=ar.pfs,1,4,4,0
+  // f13=|a|
+  fmerge.s f13=f0,f8
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // f14=|b|
+  fmerge.s f14=f0,f9
+  nop.i 0;;
+}
+ {.mlx
+  nop.m 0
+  // r2=2^{24}-2
+  movl r3=0x4b7ffffe;;
+}
+
+// Y +-NAN, +-inf, +-0?     p11
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p11,p0 = f9, 0xe7
+      nop.i 999
+}
+// qnan snan inf norm     unorm 0 -+
+// 1    1    1   0        0     0 11
+// e                      3
+// X +-NAN, +-inf, ?        p9
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p0 = f8, 0xe3
+      nop.i 999;;
+}
+
+{.mfi
+  nop.m 0
+  mov f15=f0
+  nop.i 0
+}
+{ .mfi
+  // set p7=1
+  cmp.eq.unc p7,p0=r0,r0
+  // Step (1)
+  // y0 = 1 / b in f10
+  frcpa.s1 f10,p6=f13,f14
+  nop.i 0;;
+}
+{.bbb
+  (p9) br.cond.spnt FREM_X_NAN_INF
+  (p11) br.cond.spnt FREM_Y_NAN_INF_ZERO
+  nop.b 0
+}  {.mfi
+   nop.m 0
+   // set D flag if a (f8) is denormal
+   fnma.s0 f6=f8,f1,f8
+   nop.i 0;;
+}
+
+.align 32
+remloop24:
+  { .mfi
+  // f12=2^{24}-2
+  setf.s f12=r3
+  // Step (2)
+  // q0 = a * y0 in f15
+  (p6) fma.s1 f15=f13,f10,f0
+  nop.i 0
+}
+{ .mfi
+  nop.m 0
+  // Step (3)
+  // e0 = 1 - b * y0 in f7
+  (p6) fnma.s1 f7=f14,f10,f1
+  nop.i 0;;
+}
+{.mlx
+  nop.m 0
+  // r2=1.25*2^{-24}
+  movl r2=0x33a00000;;
+}
+  { .mfi
+  nop.m 0
+  // Step (4)
+  // q1 = q0 + e0 * q0 in f6
+  (p6) fma.s1 f6=f7,f15,f15
+  nop.i 0
+}
+{ .mfi
+  nop.m 0
+  // Step (5)
+  // e1 = e0 * e0 in f7
+  (p6) fma.s1 f7=f7,f7,f0
+  nop.i 0;;
+}
+ {.mii
+  (p7) getf.exp r29=f15
+  (p7) mov r28=0xfffd
+  nop.i 0;;
+}
+
+ { .mfi
+  // f15=1.25*2^{-24}
+  setf.s f15=r2
+  // Step (6)
+  // q2 = q1 + e1 * q1 in f6
+  (p6) fma.s1 f6=f7,f6,f6
+  nop.i 0
+}
+{ .mfi
+  mov r2=0x3e7
+  // Step (7)
+  // e2 = e1 * e1 in f7
+  (p6) fma.s1 f7=f7,f7,f0
+  nop.i 0;;
+}
+
+ {.mmi
+  // q<1/4 ? (i.e. expon< -2)
+  (p7) cmp.gt.unc p7,p0=r28,r29
+  nop.m 0
+  // r2=0x3e7000000
+  shl r2=r2,24;;
+}
+
+{.mfb
+  // r2=0x3e7000001
+  add r2=1,r2
+ // if |a/b|<1/4, set D flag before returning
+ (p7) fma.s.s0 f9=f9,f0,f8
+  nop.b 0;;
+}
+ {.mfb
+ nop.m 0
+ // can be combined with bundle above if sign of 0 or
+ // FTZ enabled are not important
+ (p7) fmerge.s f8=f8,f9
+ // return if |a|<4*|b| (estimated quotient < 1/4)
+ (p7) br.ret.spnt b0;;
+}
+  {.mfi
+  nop.m 0
+  // set f8 to current a value | sign
+  fmerge.s f8=f8,f13
+  // r2=2^{-24}+2^{-48} (double prec.)
+  shl r2=r2,28;;
+}
+
+
+{ .mfi
+  // r29= -32+bias
+  mov r29=0xffdf
+  // Step (8)
+  // q3 = q2 + e2 * q2 in f6
+  (p6) fma.d.s1 f6=f7,f6,f6
+  nop.i 0;;
+}
+{ .mfi
+  nop.m 0
+  // Step (9)
+  // q = q3 in f11
+  (p6) fma.s.s1 f11=f6,f1,f0
+  nop.i 0;;
+}
+  {.mfi
+  // f7=2^{-24}
+  setf.d f7=r2
+  // last step ? (q3<2^{24}-2 --> q<2^{24})
+  fcmp.lt.unc.s1 p0,p12=f6,f12
+  nop.i 0
+} {.mfi
+  // f12=2^{-32}
+   setf.exp f12=r29
+   nop.f 0
+   nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // r=a-b*q
+  fnma.s1 f6=f14,f11,f13
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // q'=q-q*(1.25*2^{-24})   (q'=q-ulp)
+  fnma.s.s1 f15=f11,f15,f11
+  nop.i 0;;
+}
+
+  {.mfi
+  nop.m 0
+  // r2=a-b*q'
+  fnma.s1 f13=f14,f15,f13
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // r>0 iff q=RZ(a/b) and inexact
+  fcmp.gt.unc.s1 p8,p0=f6,f0
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // r<0 iff q'=RZ(a/b) and inexact
+  fcmp.lt.unc.s1 p9,p10=f6,f0
+  nop.i 0;;
+}
+.pred.rel "mutex",p8,p9
+  {.mfi
+  nop.m 0
+  // (p8) Q=q+(last iteration ? sticky bits:0)
+  // i.e. Q=q+q*x  (x=2^{-32} or 0)
+  (p8) fma.s1 f11=f11,f12,f11
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // (p9) Q=q'+(last iteration ? sticky bits:0)
+  // i.e. Q=q'+q'*x  (x=2^{-24} or 0: if expon. difference=23, want to round back to q)
+  (p9) fma.s1 f11=f15,f7,f15
+  nop.i 0;;
+}
+
+  {.mfb
+  nop.m 0
+  // (p9) set r=r2 (new a, if not last iteration)
+  // (p10) new a =r
+  (p10) mov f13=f6
+  (p12) br.cond.sptk remloop24;;
+}
+
+// last iteration
+  {.mfi
+  nop.m 0
+  // set f9=|b|*sgn(a)
+  fmerge.s f9=f8,f9
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // round to integer
+  fcvt.fx.s1 f11=f11
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // save sign of a
+  fmerge.s f7=f8,f8
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // normalize
+  fcvt.xf f11=f11
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // This can be removed if sign of 0 is not important
+  // get remainder using sf1
+  fnma.s.s1 f12=f9,f11,f8
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // get remainder
+  fnma.s.s0 f8=f9,f11,f8
+  nop.i 0;;
+}
+
+
+
+  {.mfi
+  nop.m 0
+  // f12=0?
+  // This can be removed if sign of 0 is not important
+  fcmp.eq.unc.s1 p8,p0=f12,f0
+  nop.i 0;;
+}
+  {.mfb
+  nop.m 0
+  // if f8=0, set sign correctly
+  // This can be removed if sign of 0 is not important
+  (p8) fmerge.s f8=f7,f8
+  // return
+  br.ret.sptk b0;;
+}
+
+
+FREM_X_NAN_INF:
+
+// Y zero ?
+{.mfi
+  nop.m 0
+  fma.s1 f10=f9,f1,f0
+  nop.i 0;;
+}
+{.mfi
+ nop.m 0
+ fcmp.eq.unc.s1 p11,p0=f10,f0
+ nop.i 0;;
+}
+{.mib
+  nop.m 0
+  nop.i 0
+  // if Y zero
+  (p11) br.cond.spnt FREM_Y_ZERO;;
+}
+
+// X infinity? Return QNAN indefinite
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p8,p0 = f8, 0x23
+      nop.i 999
+}
+// X infinity? Return QNAN indefinite
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p11,p0 = f8, 0x23
+      nop.i 999;;
+}
+// Y NaN ?
+{.mfi
+	 nop.m 999
+(p8) fclass.m.unc p0,p8=f9,0xc3
+	 nop.i 0;;
+}
+{.mfi
+	nop.m 999
+	// also set Denormal flag if necessary
+(p8) fma.s0 f9=f9,f1,f0
+    nop.i 0
+}
+{ .mfi
+      nop.m 999
+(p8)  frcpa.s0 f8,p7 = f8,f8
+      nop.i 999 ;;
+}
+
+{.mfi
+      nop.m 999
+(p11) mov f10=f8
+	  nop.i 0
+}
+{ .mfi
+      nop.m 999
+(p8) fma.s.s0 f8=f8,f1,f0
+	  nop.i 0 ;;
+}
+
+{ .mfb
+      nop.m 999
+      frcpa.s0 f8,p7=f8,f9
+	  (p11) br.cond.spnt EXP_ERROR_RETURN;;
+}
+{ .mib
+	nop.m 0
+	nop.i 0
+	br.ret.spnt    b0 ;;
+}
+
+
+FREM_Y_NAN_INF_ZERO:
+
+// Y INF
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p7,p0 = f9, 0x23
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p7)  fma.s.s0 f8=f8,f1,f0
+(p7)  br.ret.spnt    b0 ;;
+}
+
+// Y NAN?
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p0 = f9, 0xc3
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p9)  fma.s.s0 f8=f9,f1,f0
+(p9)  br.ret.spnt    b0 ;;
+}
+
+FREM_Y_ZERO:
+// Y zero? Must be zero at this point
+// because it is the only choice left.
+// Return QNAN indefinite
+
+// X NAN?
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p10 = f8, 0xc3
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10)  fclass.nm  p9,p10 = f8, 0xff
+      nop.i 999 ;;
+}
+
+{.mfi
+ nop.m 999
+ (p9) frcpa.s0 f11,p7=f8,f0
+ nop.i 0;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)  frcpa.s0         f11,p7 = f0,f0
+nop.i 999;;
+}
+
+{ .mfi
+      nop.m 999
+      fmerge.s      f10 = f8, f8
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+      fma.s.s0 f8=f11,f1,f0
+      nop.i 999
+}
+
+
+EXP_ERROR_RETURN:
+
+{ .mib
+      mov   GR_Parameter_TAG = 125
+	  nop.i 999
+      br.sptk __libm_error_region;;
+}
+
+GLOBAL_IEEE754_END(remainderf)
+libm_alias_float_other (__remainder, remainder)
+weak_alias (__remainderf, dremf)
+
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfs [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+	nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfs [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#;;  // Call error handling function
+}
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_remainderl.S
@@ -0,0 +1,614 @@
+.file "remainderl.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//====================================================================
+// 02/02/00 Initial version
+// 03/02/00 New algorithm
+// 04/04/00 Unwind support added
+// 07/21/00 Fixed quotient=2^{24*m+23}*1.q1...q23 1 bug
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 11/29/00 Set FR_Y to f9
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+// API
+//====================================================================
+// long double remainderl(long double,long double);
+//
+// Overview of operation
+//====================================================================
+//  remainder(a,b)=a-i*b,
+//  where i is an integer such that, if b!=0 and a is finite,
+//  |a/b-i|<=1/2. If |a/b-i|=1/2, i is even.
+//
+// Algorithm
+//====================================================================
+// a). eliminate special cases
+// b). if |a/b|<0.25 (first quotient estimate), return a
+// c). use single precision divide algorithm to get quotient q
+//     rounded to 24 bits of precision
+// d). calculate partial remainders (using both q and q-ulp);
+//     select one and RZ(a/b) based on the sign of |a|-|b|*q
+// e). if the exponent difference (exponent(a)-exponent(b))
+//     is less than 24 (quotient estimate<2^{24}-2), use RZ(a/b)
+//     and sticky bits to round to integer; exit loop and
+//     calculate final remainder
+// f). if exponent(a)-exponent(b)>=24, select new value of a as
+//     the partial remainder calculated using RZ(a/b);
+//     repeat from c).
+//
+// Special cases
+//====================================================================
+// a=+/- Inf, or b=+/-0: return NaN, call libm_error_support
+// a=NaN or b=NaN: return NaN
+//
+// Registers used
+//====================================================================
+// Predicate registers: p6-p14
+// General registers:   r2,r3,r28,r29,r32 (ar.pfs), r33-r39
+// Floating point registers: f6-f15,f32
+//
+
+GR_SAVE_B0                    = r33
+GR_SAVE_PFS                   = r34
+GR_SAVE_GP                    = r35
+GR_SAVE_SP                    = r36
+
+GR_Parameter_X                = r37
+GR_Parameter_Y                = r38
+GR_Parameter_RESULT           = r39
+GR_Parameter_TAG              = r40
+
+FR_X             = f10
+FR_Y             = f9
+FR_RESULT        = f8
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(remainderl)
+
+// inputs in f8, f9
+// result in f8
+
+{ .mfi
+  alloc r32=ar.pfs,1,4,4,0
+  // f13=|a|
+  fmerge.s f13=f0,f8
+  nop.i 0
+}
+  {.mfi
+  getf.sig r29=f9
+  // f14=|b|
+  fmerge.s f14=f0,f9
+  nop.i 0;;
+}
+ {.mlx
+  mov r28=0x2ffdd
+  // r2=2^{23}
+  movl r3=0x4b000000;;
+}
+
+
+{.mmi
+setf.exp f32=r28
+nop.m 0
+// y pseudo-zero ?
+cmp.eq p11,p10=r29,r0;;
+}
+
+// Y +-NAN, +-inf, +-0?     p11
+{ .mfi
+      nop.m 999
+(p10)  fclass.m  p11,p10 = f9, 0xe7
+      nop.i 999
+}
+// qnan snan inf norm     unorm 0 -+
+// 1    1    1   0        0     0 11
+// e                      3
+// X +-NAN, +-inf, ?        p9
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p8 = f8, 0xe3
+      nop.i 999;;
+}
+
+{.mfi
+  nop.m 0
+  mov f12=f0
+  nop.i 0
+}
+{ .mfi
+  // set p7=1
+  cmp.eq.unc p7,p0=r0,r0
+  // Step (1)
+  // y0 = 1 / b in f10
+  frcpa.s1 f10,p6=f13,f14
+  nop.i 0;;
+}
+// Y +-NAN, +-inf, +-0?     p11
+{ .mfi
+      nop.m 999
+	  // pseudo-NaN ?
+(p10)  fclass.nm  p11,p0 = f9, 0xff
+      nop.i 999
+}
+
+// qnan snan inf norm     unorm 0 -+
+// 1    1    1   0        0     0 11
+// e                      3
+// X +-NAN, +-inf, ?        p9
+
+{ .mfi
+      nop.m 999
+(p8)  fclass.nm  p9,p0 = f8, 0xff
+      nop.i 999;;
+}
+
+{.bbb
+  (p9) br.cond.spnt FREM_X_NAN_INF
+  (p11) br.cond.spnt FREM_Y_NAN_INF_ZERO
+  nop.b 0
+}  {.mfi
+   nop.m 0
+   // set D flag if a (f8) is denormal
+   fnma.s0 f6=f8,f1,f8
+   nop.i 0;;
+}
+
+remloop24:
+  { .mfi
+  nop.m 0
+  // Step (2)
+  // q0 = a * y0 in f15
+  (p6) fma.s1 f12=f13,f10,f0
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (3)
+  // e0 = 1 - b * y0 in f7
+  (p6) fnma.s1 f7=f14,f10,f1
+  nop.i 0;;
+}  {.mlx
+  nop.m 0
+  // r2=1.25*2^{-24}
+  movl r2=0x33a00000;;
+}
+
+{.mfi
+  nop.m 0
+  // q1=q0*(1+e0)
+  (p6) fma.s1 f15=f12,f7,f12
+  nop.i 0
+}
+{ .mfi
+  nop.m 0
+  // Step (4)
+  // e1 = e0 * e0 + E in f7
+  (p6) fma.s1 f7=f7,f7,f32
+  nop.i 0;;
+}
+ {.mii
+  (p7) getf.exp r29=f12
+  (p7) mov r28=0xfffd
+  nop.i 0;;
+}
+
+ { .mfi
+  // f12=2^{23}
+  setf.s f12=r3
+  // Step (5)
+  // q2 = q1 + e1 * q1 in f11
+  (p6) fma.s.s1 f11=f7,f15,f15
+  nop.i 0
+} { .mfi
+   nop.m 0
+  // Step (6)
+  // q2 = q1 + e1 * q1 in f6
+  (p6) fma.s1 f6=f7,f15,f15
+  nop.i 0;;
+}
+
+ {.mmi
+  // f15=1.25*2^{-24}
+  setf.s f15=r2
+  // q<1/4 ? (i.e. expon< -2)
+  (p7) cmp.gt p7,p0=r28,r29
+  nop.i 0;;
+}
+
+{.mfb
+  // r29= -32+bias
+  mov r29=0xffdf
+ // if |a/b|<1/4, set D flag before returning
+ (p7) fma.s0 f9=f9,f0,f8
+  nop.b 0;;
+}
+ {.mfb
+ nop.m 0
+ // can be combined with bundle above if sign of 0 or
+ // FTZ enabled are not important
+ (p7) fmerge.s f8=f8,f9
+ // return if |a|<4*|b| (estimated quotient < 1/4)
+ (p7) br.ret.spnt b0;;
+}
+  {.mfi
+  // f7=2^{-32}
+  setf.exp f7=r29
+  // set f8 to current a value | sign
+  fmerge.s f8=f8,f13
+  nop.i 0;;
+}
+  {.mfi
+  getf.exp r28=f6
+  // last step ? (q<2^{23})
+  fcmp.lt.unc.s1 p0,p12=f6,f12
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // r=a-b*q
+  fnma.s1 f6=f14,f11,f13
+  nop.i 0
+} {.mfi
+  // r2=23+bias
+  mov r2=0xffff+23
+  // q'=q-q*(1.25*2^{-24})   (q'=q-ulp)
+  fnma.s.s1 f15=f11,f15,f11
+  nop.i 0;;
+}
+  {.mmi
+  nop.m 0
+  cmp.eq p11,p14=r2,r28
+  nop.i 0;;
+}
+
+.pred.rel "mutex",p11,p14
+  {.mfi
+  nop.m 0
+  // if exp_q=2^23, then r=a-b*2^{23}
+  (p11) fnma.s1 f13=f12,f14,f13
+  nop.i 0
+}
+{.mfi
+  nop.m 0
+  // r2=a-b*q'
+  (p14) fnma.s1 f13=f14,f15,f13
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // r>0 iff q=RZ(a/b) and inexact
+  fcmp.gt.unc.s1 p8,p0=f6,f0
+  nop.i 0
+} {.mfi
+  nop.m 0
+  // r<0 iff q'=RZ(a/b) and inexact
+  (p14) fcmp.lt.unc.s1 p9,p10=f6,f0
+  nop.i 0;;
+}
+
+.pred.rel "mutex",p8,p9
+  {.mfi
+   nop.m 0
+  // (p8) Q=q+(last iteration ? sticky bits:0)
+  // i.e. Q=q+q*x  (x=2^{-32} or 0)
+  (p8) fma.s1 f11=f11,f7,f11
+  nop.i 0
+} {.mfi
+  nop.m 0
+  // (p9) Q=q'+(last iteration ? sticky bits:0)
+  // i.e. Q=q'+q'*x  (x=2^{-32} or 0)
+  (p9) fma.s1 f11=f15,f7,f15
+  nop.i 0;;
+}
+
+  {.mfb
+  nop.m 0
+  //  (p9) set r=r2 (new a, if not last iteration)
+  // (p10) new a =r
+  (p10) mov f13=f6
+  (p12) br.cond.sptk remloop24;;
+}
+
+// last iteration
+  {.mfi
+  nop.m 0
+  // set f9=|b|*sgn(a)
+  fmerge.s f9=f8,f9
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // round to integer
+  fcvt.fx.s1 f11=f11
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // save sign of a
+  fmerge.s f7=f8,f8
+  nop.i 0
+} {.mfi
+  nop.m 0
+  // normalize
+  fcvt.xf f11=f11
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // This can be removed if sign of 0 is not important
+  // get remainder using sf1
+  fnma.s1 f12=f9,f11,f8
+  nop.i 0
+}
+  {.mfi
+  nop.m 0
+  // get remainder
+  fnma.s0 f8=f9,f11,f8
+  nop.i 0;;
+}
+  {.mfi
+  nop.m 0
+  // f12=0?
+  // This can be removed if sign of 0 is not important
+  fcmp.eq.unc.s1 p8,p0=f12,f0
+  nop.i 0;;
+}
+  {.mfb
+  nop.m 0
+  // if f8=0, set sign correctly
+  // This can be removed if sign of 0 is not important
+  (p8) fmerge.s f8=f7,f8
+  // return
+  br.ret.sptk b0;;
+}
+
+
+
+FREM_X_NAN_INF:
+
+// Y zero ?
+{.mfi
+  nop.m 0
+  fma.s1 f10=f9,f1,f0
+  nop.i 0;;
+}
+{.mfi
+ nop.m 0
+ fcmp.eq.unc.s1 p11,p0=f10,f0
+ nop.i 0;;
+}
+{.mib
+  nop.m 0
+  nop.i 0
+  // if Y zero
+  (p11) br.cond.spnt FREM_Y_ZERO;;
+}
+
+// X infinity? Return QNAN indefinite
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p8,p0 = f8, 0x23
+      nop.i 999
+}
+// X infinity? Return QNAN indefinite
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p11,p0 = f8, 0x23
+      nop.i 999;;
+}
+// Y NaN ?
+{.mfi
+	 nop.m 999
+(p8) fclass.m.unc p0,p8=f9,0xc3
+	 nop.i 0;;
+}
+{.mfi
+	nop.m 999
+	// also set Denormal flag if necessary
+(p8) fnma.s0 f9=f9,f1,f9
+    nop.i 0
+}
+{ .mfi
+      nop.m 999
+(p8)  frcpa.s0 f8,p7 = f8,f8
+      nop.i 999 ;;
+}
+
+{.mfi
+      nop.m 999
+(p11) mov f10=f8
+	  nop.i 0
+}
+{ .mfi
+     nop.m 999
+(p8) fma.s0 f8=f8,f1,f0
+	 nop.i 0 ;;
+}
+
+{ .mfb
+      nop.m 999
+      frcpa.s0 f8,p7=f8,f9
+	  (p11) br.cond.spnt EXP_ERROR_RETURN;;
+}
+{ .mib
+	nop.m 0
+	nop.i 0
+	br.ret.spnt    b0 ;;
+}
+
+
+FREM_Y_NAN_INF_ZERO:
+// Y INF
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p7,p0 = f9, 0x23
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p7)  fma.s0 f8=f8,f1,f0
+(p7)  br.ret.spnt    b0 ;;
+}
+
+// Y NAN?
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p10 = f9, 0xc3
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10)  fclass.nm  p9,p0 = f9, 0xff
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p9)  fma.s0 f8=f9,f1,f0
+(p9)  br.ret.spnt    b0 ;;
+}
+
+FREM_Y_ZERO:
+// Y zero? Must be zero at this point
+// because it is the only choice left.
+// Return QNAN indefinite
+
+// X NAN?
+{ .mfi
+      nop.m 999
+      fclass.m.unc  p9,p10 = f8, 0xc3
+      nop.i 999 ;;
+}
+{ .mfi
+      nop.m 999
+(p10)  fclass.nm  p9,p10 = f8, 0xff
+      nop.i 999 ;;
+}
+
+{.mfi
+ nop.m 999
+ (p9) frcpa.s0 f11,p7=f8,f0
+ nop.i 0;;
+}
+{ .mfi
+      nop.m 999
+(p10)  frcpa.s0   f11,p7 = f0,f0
+	  nop.i 999;;
+}
+
+{ .mfi
+      nop.m 999
+      fmerge.s      f10 = f8, f8
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+      fma.s0 f8=f11,f1,f0
+      nop.i 999;;
+}
+
+EXP_ERROR_RETURN:
+
+{ .mib
+      mov   GR_Parameter_TAG = 123
+	  nop.i 999
+      br.sptk __libm_error_region;;
+}
+
+GLOBAL_IEEE754_END(remainderl)
+libm_alias_ldouble_other (__remainder, remainder)
+weak_alias (__remainderl, dreml)
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfe [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfe [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+	nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfe [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#  // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_scalb.S
@@ -0,0 +1,598 @@
+.file "scalb.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 01/26/01 Scalb completely reworked and now standalone version
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 08/06/03 Improved performance
+//
+// API
+//==============================================================
+// double = scalb  (double x, double n)
+// input  floating point f8 and floating point f9
+// output floating point f8
+//
+// int_type = 0 if int is 32 bits
+// int_type = 1 if int is 64 bits
+//
+// Returns x* 2**n using an fma and detects overflow
+// and underflow.
+//
+//
+// Strategy:
+//  Compute biased exponent of result exp_Result = N + exp_X
+//  Break into ranges:
+//   exp_Result > 0x103fe                 -> Certain overflow
+//   exp_Result = 0x103fe                 -> Possible overflow
+//   0x0fc01 <= exp_Result < 0x103fe      -> No over/underflow (main path)
+//   0x0fc01 - 52 <= exp_Result < 0x0fc01 -> Possible underflow
+//   exp_Result < 0x0fc01 - 52            -> Certain underflow
+
+FR_Big         = f6
+FR_NBig        = f7
+FR_Floating_X  = f8
+FR_Result      = f8
+FR_Floating_N  = f9
+FR_Result2     = f9
+FR_Result3     = f10
+FR_Norm_X      = f11
+FR_Two_N       = f12
+FR_N_float_int = f13
+FR_Norm_N      = f14
+
+GR_neg_ov_limit= r14
+GR_big_exp     = r14
+GR_N_Biased    = r15
+GR_Big         = r16
+GR_exp_Result  = r18
+GR_pos_ov_limit= r19
+GR_exp_sure_ou = r19
+GR_Bias        = r20
+GR_N_as_int    = r21
+GR_signexp_X   = r22
+GR_exp_X       = r23
+GR_exp_mask    = r24
+GR_max_exp     = r25
+GR_min_exp     = r26
+GR_min_den_exp = r27
+GR_Scratch     = r28
+GR_signexp_N   = r29
+GR_exp_N       = r30
+
+GR_SAVE_B0          = r32
+GR_SAVE_GP          = r33
+GR_SAVE_PFS         = r34
+GR_Parameter_X      = r35
+GR_Parameter_Y      = r36
+GR_Parameter_RESULT = r37
+GR_Tag              = r38
+
+.section .text
+GLOBAL_IEEE754_ENTRY(scalb)
+
+//
+//   Is x NAN, INF, ZERO, +-?
+//   Build the exponent Bias
+//
+{    .mfi
+     getf.exp      GR_signexp_N = FR_Floating_N // Get signexp of n
+     fclass.m      p6,p0 = FR_Floating_X, 0xe7  // @snan | @qnan | @inf | @zero
+     mov           GR_Bias = 0x0ffff
+}
+{    .mfi
+     mov           GR_Big = 35000      // If N this big then certain overflow
+     fcvt.fx.trunc.s1   FR_N_float_int = FR_Floating_N // Get N in significand
+     nop.i         0
+}
+;;
+
+{    .mfi
+     getf.exp      GR_signexp_X = FR_Floating_X // Get signexp of x
+     fclass.m      p7,p0 = FR_Floating_N, 0x0b  // Test for n=unorm
+     nop.i         0
+}
+//
+//   Normalize n
+//
+{    .mfi
+     mov           GR_exp_mask = 0x1ffff     // Exponent mask
+     fnorm.s1      FR_Norm_N = FR_Floating_N
+     nop.i         0
+}
+;;
+
+//
+//   Is n NAN, INF, ZERO, +-?
+//
+{    .mfi
+     mov           GR_big_exp = 0x1003e      // Exponent at which n is integer
+     fclass.m      p9,p0 = FR_Floating_N, 0xe7  // @snan | @qnan | @inf | @zero
+     mov           GR_max_exp = 0x103fe      // Exponent of maximum double
+}
+//
+//   Normalize x
+//
+{ .mfb
+     nop.m         0
+     fnorm.s1      FR_Norm_X = FR_Floating_X
+(p7) br.cond.spnt  SCALB_N_UNORM             // Branch if n=unorm
+}
+;;
+
+SCALB_COMMON1:
+// Main path continues.  Also return here from u=unorm path.
+//   Handle special cases if x = Nan, Inf, Zero
+{ .mfb
+     nop.m         0
+     fcmp.lt.s1    p7,p0 = FR_Floating_N, f0  // Test N negative
+(p6) br.cond.spnt  SCALB_NAN_INF_ZERO
+}
+;;
+
+//   Handle special cases if n = Nan, Inf, Zero
+{    .mfi
+     getf.sig      GR_N_as_int = FR_N_float_int // Get n from significand
+     fclass.m      p8,p0 = FR_Floating_X, 0x0b // Test for x=unorm
+     mov           GR_exp_sure_ou = 0x1000e // Exp_N where x*2^N sure over/under
+}
+{    .mfb
+     mov           GR_min_exp = 0x0fc01      // Exponent of minimum double
+     fcvt.xf       FR_N_float_int = FR_N_float_int // Convert N to FP integer
+(p9) br.cond.spnt  SCALB_NAN_INF_ZERO
+}
+;;
+
+{    .mmi
+     and           GR_exp_N = GR_exp_mask, GR_signexp_N // Get exponent of N
+(p7) sub           GR_Big = r0, GR_Big          // Limit for N
+     nop.i         0
+}
+;;
+
+{    .mib
+     cmp.lt        p9,p0 = GR_exp_N, GR_big_exp // N possible non-integer?
+     cmp.ge        p6,p0 = GR_exp_N, GR_exp_sure_ou // N certain over/under?
+(p8) br.cond.spnt  SCALB_X_UNORM             // Branch if x=unorm
+}
+;;
+
+SCALB_COMMON2:
+// Main path continues.  Also return here from x=unorm path.
+//   Create biased exponent for 2**N
+{    .mmi
+(p6) mov           GR_N_as_int = GR_Big      // Limit N
+;;
+     add           GR_N_Biased = GR_Bias,GR_N_as_int
+     nop.i         0
+}
+;;
+
+{    .mfi
+     setf.exp      FR_Two_N = GR_N_Biased               // Form 2**N
+(p9) fcmp.neq.unc.s1 p9,p0 = FR_Norm_N, FR_N_float_int  // Test if N an integer
+     and           GR_exp_X = GR_exp_mask, GR_signexp_X // Get exponent of X
+}
+;;
+
+//
+//   Compute biased result exponent
+//   Branch if N is not an integer
+//
+{    .mib
+     add           GR_exp_Result = GR_exp_X, GR_N_as_int
+     mov           GR_min_den_exp = 0x0fc01 - 52 // Exponent of min denorm dble
+(p9) br.cond.spnt  SCALB_N_NOT_INT
+}
+;;
+
+//
+//   Raise Denormal operand flag with compare
+//   Do final operation
+//
+{    .mfi
+     cmp.lt        p7,p6 = GR_exp_Result, GR_max_exp  // Test no overflow
+     fcmp.ge.s0    p0,p11 = FR_Floating_X,FR_Floating_N  // Dummy to set denorm
+     cmp.lt        p9,p0 = GR_exp_Result, GR_min_den_exp // Test sure underflow
+}
+{    .mfb
+     nop.m         0
+     fma.d.s0      FR_Result = FR_Two_N,FR_Norm_X,f0
+(p9) br.cond.spnt  SCALB_UNDERFLOW           // Branch if certain underflow
+}
+;;
+
+{    .mib
+(p6) cmp.gt.unc    p6,p8 = GR_exp_Result, GR_max_exp  // Test sure overflow
+(p7) cmp.ge.unc    p7,p9 = GR_exp_Result, GR_min_exp  // Test no over/underflow
+(p7) br.ret.sptk   b0                         // Return from main path
+}
+;;
+
+{    .bbb
+(p6) br.cond.spnt  SCALB_OVERFLOW            // Branch if certain overflow
+(p8) br.cond.spnt  SCALB_POSSIBLE_OVERFLOW   // Branch if possible overflow
+(p9) br.cond.spnt  SCALB_POSSIBLE_UNDERFLOW  // Branch if possible underflow
+}
+;;
+
+// Here if possible underflow.
+// Resulting exponent: 0x0fc01-52 <= exp_Result < 0x0fc01
+SCALB_POSSIBLE_UNDERFLOW:
+//
+// Here if possible overflow.
+// Resulting exponent: 0x103fe = exp_Result
+SCALB_POSSIBLE_OVERFLOW:
+
+//   Set up necessary status fields
+//
+//   S0 user supplied status
+//   S2 user supplied status + WRE + TD  (Overflows)
+//   S3 user supplied status + FZ + TD   (Underflows)
+//
+{    .mfi
+     mov           GR_pos_ov_limit = 0x103ff // Exponent for positive overflow
+     fsetc.s3      0x7F,0x41
+     nop.i         0
+}
+{    .mfi
+     mov           GR_neg_ov_limit = 0x303ff // Exponent for negative overflow
+     fsetc.s2      0x7F,0x42
+     nop.i         0
+}
+;;
+
+//
+//   Do final operation with s2 and s3
+//
+{    .mfi
+     setf.exp      FR_NBig = GR_neg_ov_limit
+     fma.d.s3      FR_Result3 = FR_Two_N,FR_Norm_X,f0
+     nop.i         0
+}
+{    .mfi
+     setf.exp      FR_Big = GR_pos_ov_limit
+     fma.d.s2      FR_Result2 = FR_Two_N,FR_Norm_X,f0
+     nop.i         0
+}
+;;
+
+//   Check for overflow or underflow.
+//   Restore s3
+//   Restore s2
+//
+{    .mfi
+     nop.m         0
+     fsetc.s3      0x7F,0x40
+     nop.i         0
+}
+{    .mfi
+     nop.m         0
+     fsetc.s2      0x7F,0x40
+     nop.i         0
+}
+;;
+
+//
+//   Is the result zero?
+//
+{    .mfi
+     nop.m         0
+     fclass.m      p6, p0 =  FR_Result3, 0x007
+     nop.i         0
+}
+{    .mfi
+     nop.m         0
+     fcmp.ge.s1    p7, p8 = FR_Result2 , FR_Big
+     nop.i         0
+}
+;;
+
+//
+//   Detect masked underflow - Tiny + Inexact Only
+//
+{    .mfi
+     nop.m         0
+(p6) fcmp.neq.unc.s1 p6, p0 = FR_Result , FR_Result2
+     nop.i         0
+}
+;;
+
+//
+//   Is result bigger the allowed range?
+//   Branch out for underflow
+//
+{    .mfb
+     nop.m          0
+(p8) fcmp.le.unc.s1 p9, p10 = FR_Result2 , FR_NBig
+(p6) br.cond.spnt   SCALB_UNDERFLOW
+}
+;;
+
+//
+//   Branch out for overflow
+//
+{ .bbb
+(p7) br.cond.spnt   SCALB_OVERFLOW
+(p9) br.cond.spnt   SCALB_OVERFLOW
+     br.ret.sptk    b0             //   Return from main path.
+}
+;;
+
+// Here if result overflows
+SCALB_OVERFLOW:
+{ .mib
+     alloc         r32=ar.pfs,3,0,4,0
+     addl          GR_Tag = 53, r0     // Set error tag for overflow
+     br.cond.sptk  __libm_error_region // Call error support for overflow
+}
+;;
+
+// Here if result underflows
+SCALB_UNDERFLOW:
+{ .mib
+     alloc         r32=ar.pfs,3,0,4,0
+     addl          GR_Tag = 54, r0     // Set error tag for underflow
+     br.cond.sptk  __libm_error_region // Call error support for underflow
+}
+;;
+
+SCALB_NAN_INF_ZERO:
+
+//
+//   Before entry, N has been converted to a fp integer in significand of
+//     FR_N_float_int
+//
+//   Convert  N_float_int to floating point value
+//
+{    .mfi
+     getf.sig     GR_N_as_int = FR_N_float_int
+     fclass.m     p6,p0 = FR_Floating_N, 0xc3 //@snan | @qnan
+     nop.i        0
+}
+{    .mfi
+     addl         GR_Scratch = 1,r0
+     fcvt.xf      FR_N_float_int = FR_N_float_int
+     nop.i        0
+}
+;;
+
+{    .mfi
+     nop.m        0
+     fclass.m     p7,p0 = FR_Floating_X, 0xc3 //@snan | @qnan
+     shl          GR_Scratch = GR_Scratch,63
+}
+;;
+
+{    .mfi
+     nop.m        0
+     fclass.m     p8,p0 = FR_Floating_N, 0x21 // @inf
+     nop.i        0
+}
+{    .mfi
+     nop.m        0
+     fclass.m     p9,p0 = FR_Floating_N, 0x22 // @-inf
+     nop.i        0
+}
+;;
+
+//
+//   Either X or N is a Nan, return result and possible raise invalid.
+//
+{    .mfb
+     nop.m        0
+(p6) fma.d.s0     FR_Result = FR_Floating_N,FR_Floating_X,f0
+(p6) br.ret.spnt  b0
+}
+;;
+
+{    .mfb
+     nop.m        0
+(p7) fma.d.s0     FR_Result = FR_Floating_N,FR_Floating_X,f0
+(p7) br.ret.spnt  b0
+}
+;;
+
+//
+//   If N + Inf do something special
+//   For N = -Inf, create Int
+//
+{    .mfb
+     nop.m        0
+(p8) fma.d.s0     FR_Result = FR_Floating_X, FR_Floating_N,f0
+(p8) br.ret.spnt  b0
+}
+{    .mfi
+     nop.m        0
+(p9) fnma.d.s0    FR_Floating_N = FR_Floating_N, f1, f0
+     nop.i        0
+}
+;;
+
+//
+//   If N==-Inf,return x/(-N)
+//
+{    .mfb
+     cmp.ne       p7,p0 = GR_N_as_int,GR_Scratch
+(p9) frcpa.s0     FR_Result,p0 = FR_Floating_X,FR_Floating_N
+(p9) br.ret.spnt  b0
+}
+;;
+
+//
+//   Is N an integer.
+//
+{    .mfi
+     nop.m        0
+(p7) fcmp.neq.unc.s1 p7,p0 = FR_Norm_N, FR_N_float_int
+     nop.i        0
+}
+;;
+
+//
+//   If N not an int, return NaN and raise invalid.
+//
+{    .mfb
+     nop.m        0
+(p7) frcpa.s0     FR_Result,p0 = f0,f0
+(p7) br.ret.spnt  b0
+}
+;;
+
+//
+//   Always return x in other path.
+//
+{    .mfb
+     nop.m        0
+     fma.d.s0     FR_Result = FR_Floating_X,f1,f0
+     br.ret.sptk  b0
+}
+;;
+
+// Here if n not int
+// Return NaN and raise invalid.
+SCALB_N_NOT_INT:
+{    .mfb
+     nop.m        0
+     frcpa.s0     FR_Result,p0 = f0,f0
+     br.ret.sptk  b0
+}
+;;
+
+// Here if n=unorm
+SCALB_N_UNORM:
+{ .mfb
+     getf.exp      GR_signexp_N = FR_Norm_N // Get signexp of normalized n
+     fcvt.fx.trunc.s1   FR_N_float_int = FR_Norm_N // Get N in significand
+     br.cond.sptk  SCALB_COMMON1            // Return to main path
+}
+;;
+
+// Here if x=unorm
+SCALB_X_UNORM:
+{ .mib
+     getf.exp      GR_signexp_X = FR_Norm_X // Get signexp of normalized x
+     nop.i         0
+     br.cond.sptk  SCALB_COMMON2            // Return to main path
+}
+;;
+
+GLOBAL_IEEE754_END(scalb)
+LOCAL_LIBM_ENTRY(__libm_error_region)
+
+//
+// Get stack address of N
+//
+.prologue
+{ .mfi
+    add   GR_Parameter_Y=-32,sp
+    nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+    mov  GR_SAVE_PFS=ar.pfs
+}
+//
+// Adjust sp
+//
+{ .mfi
+.fframe 64
+   add sp=-64,sp
+   nop.f 0
+   mov GR_SAVE_GP=gp
+};;
+
+//
+//  Store N on stack in correct position
+//  Locate the address of x on stack
+//
+{ .mmi
+   stfd [GR_Parameter_Y] = FR_Norm_N,16
+   add GR_Parameter_X = 16,sp
+.save   b0, GR_SAVE_B0
+   mov GR_SAVE_B0=b0
+};;
+
+//
+// Store x on the stack.
+// Get address for result on stack.
+//
+.body
+{ .mib
+   stfd [GR_Parameter_X] = FR_Norm_X
+   add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+   nop.b 0
+}
+{ .mib
+   stfd [GR_Parameter_Y] = FR_Result
+   add   GR_Parameter_Y = -16,GR_Parameter_Y
+   br.call.sptk b0=__libm_error_support#
+};;
+
+//
+//  Get location of result on stack
+//
+{ .mmi
+   add   GR_Parameter_RESULT = 48,sp
+   nop.m 0
+   nop.i 0
+};;
+
+//
+//  Get the new result
+//
+{ .mmi
+   ldfd  FR_Result = [GR_Parameter_RESULT]
+.restore sp
+   add   sp = 64,sp
+   mov   b0 = GR_SAVE_B0
+};;
+
+//
+//  Restore gp, ar.pfs and return
+//
+{ .mib
+   mov   gp = GR_SAVE_GP
+   mov   ar.pfs = GR_SAVE_PFS
+   br.ret.sptk     b0
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_scalbf.S
@@ -0,0 +1,598 @@
+.file "scalbf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 01/26/01 Scalb completely reworked and now standalone version
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 08/06/03 Improved performance
+//
+// API
+//==============================================================
+// float = scalbf  (float x, float n)
+// input  floating point f8 and floating point f9
+// output floating point f8
+//
+// int_type = 0 if int is 32 bits
+// int_type = 1 if int is 64 bits
+//
+// Returns x* 2**n using an fma and detects overflow
+// and underflow.
+//
+//
+// Strategy:
+//  Compute biased exponent of result exp_Result = N + exp_X
+//  Break into ranges:
+//   exp_Result > 0x1007e                 -> Certain overflow
+//   exp_Result = 0x1007e                 -> Possible overflow
+//   0x0ff81 <= exp_Result < 0x1007e      -> No over/underflow (main path)
+//   0x0ff81 - 23 <= exp_Result < 0x0ff81 -> Possible underflow
+//   exp_Result < 0x0ff81 - 23            -> Certain underflow
+
+FR_Big         = f6
+FR_NBig        = f7
+FR_Floating_X  = f8
+FR_Result      = f8
+FR_Floating_N  = f9
+FR_Result2     = f9
+FR_Result3     = f10
+FR_Norm_X      = f11
+FR_Two_N       = f12
+FR_N_float_int = f13
+FR_Norm_N      = f14
+
+GR_neg_ov_limit= r14
+GR_big_exp     = r14
+GR_N_Biased    = r15
+GR_Big         = r16
+GR_exp_Result  = r18
+GR_pos_ov_limit= r19
+GR_exp_sure_ou = r19
+GR_Bias        = r20
+GR_N_as_int    = r21
+GR_signexp_X   = r22
+GR_exp_X       = r23
+GR_exp_mask    = r24
+GR_max_exp     = r25
+GR_min_exp     = r26
+GR_min_den_exp = r27
+GR_Scratch     = r28
+GR_signexp_N   = r29
+GR_exp_N       = r30
+
+GR_SAVE_B0          = r32
+GR_SAVE_GP          = r33
+GR_SAVE_PFS         = r34
+GR_Parameter_X      = r35
+GR_Parameter_Y      = r36
+GR_Parameter_RESULT = r37
+GR_Tag              = r38
+
+.section .text
+GLOBAL_IEEE754_ENTRY(scalbf)
+
+//
+//   Is x NAN, INF, ZERO, +-?
+//   Build the exponent Bias
+//
+{    .mfi
+     getf.exp      GR_signexp_N = FR_Floating_N // Get signexp of n
+     fclass.m      p6,p0 = FR_Floating_X, 0xe7  // @snan | @qnan | @inf | @zero
+     mov           GR_Bias = 0x0ffff
+}
+{    .mfi
+     mov           GR_Big = 35000      // If N this big then certain overflow
+     fcvt.fx.trunc.s1   FR_N_float_int = FR_Floating_N // Get N in significand
+     nop.i         0
+}
+;;
+
+{    .mfi
+     getf.exp      GR_signexp_X = FR_Floating_X // Get signexp of x
+     fclass.m      p7,p0 = FR_Floating_N, 0x0b  // Test for n=unorm
+     nop.i         0
+}
+//
+//   Normalize n
+//
+{    .mfi
+     mov           GR_exp_mask = 0x1ffff     // Exponent mask
+     fnorm.s1      FR_Norm_N = FR_Floating_N
+     nop.i         0
+}
+;;
+
+//
+//   Is n NAN, INF, ZERO, +-?
+//
+{    .mfi
+     mov           GR_big_exp = 0x1003e      // Exponent at which n is integer
+     fclass.m      p9,p0 = FR_Floating_N, 0xe7  // @snan | @qnan | @inf | @zero
+     mov           GR_max_exp = 0x1007e      // Exponent of maximum float
+}
+//
+//   Normalize x
+//
+{ .mfb
+     nop.m         0
+     fnorm.s1      FR_Norm_X = FR_Floating_X
+(p7) br.cond.spnt  SCALBF_N_UNORM             // Branch if n=unorm
+}
+;;
+
+SCALBF_COMMON1:
+// Main path continues.  Also return here from u=unorm path.
+//   Handle special cases if x = Nan, Inf, Zero
+{ .mfb
+     nop.m         0
+     fcmp.lt.s1    p7,p0 = FR_Floating_N, f0  // Test N negative
+(p6) br.cond.spnt  SCALBF_NAN_INF_ZERO
+}
+;;
+
+//   Handle special cases if n = Nan, Inf, Zero
+{    .mfi
+     getf.sig      GR_N_as_int = FR_N_float_int // Get n from significand
+     fclass.m      p8,p0 = FR_Floating_X, 0x0b // Test for x=unorm
+     mov           GR_exp_sure_ou = 0x1000e // Exp_N where x*2^N sure over/under
+}
+{    .mfb
+     mov           GR_min_exp = 0x0ff81      // Exponent of minimum float
+     fcvt.xf       FR_N_float_int = FR_N_float_int // Convert N to FP integer
+(p9) br.cond.spnt  SCALBF_NAN_INF_ZERO
+}
+;;
+
+{    .mmi
+     and           GR_exp_N = GR_exp_mask, GR_signexp_N // Get exponent of N
+(p7) sub           GR_Big = r0, GR_Big          // Limit for N
+     nop.i         0
+}
+;;
+
+{    .mib
+     cmp.lt        p9,p0 = GR_exp_N, GR_big_exp // N possible non-integer?
+     cmp.ge        p6,p0 = GR_exp_N, GR_exp_sure_ou // N certain over/under?
+(p8) br.cond.spnt  SCALBF_X_UNORM             // Branch if x=unorm
+}
+;;
+
+SCALBF_COMMON2:
+// Main path continues.  Also return here from x=unorm path.
+//   Create biased exponent for 2**N
+{    .mmi
+(p6) mov           GR_N_as_int = GR_Big      // Limit N
+;;
+     add           GR_N_Biased = GR_Bias,GR_N_as_int
+     nop.i         0
+}
+;;
+
+{    .mfi
+     setf.exp      FR_Two_N = GR_N_Biased               // Form 2**N
+(p9) fcmp.neq.unc.s1 p9,p0 = FR_Norm_N, FR_N_float_int  // Test if N an integer
+     and           GR_exp_X = GR_exp_mask, GR_signexp_X // Get exponent of X
+}
+;;
+
+//
+//   Compute biased result exponent
+//   Branch if N is not an integer
+//
+{    .mib
+     add           GR_exp_Result = GR_exp_X, GR_N_as_int
+     mov           GR_min_den_exp = 0x0ff81 - 23 // Exponent of min denorm float
+(p9) br.cond.spnt  SCALBF_N_NOT_INT
+}
+;;
+
+//
+//   Raise Denormal operand flag with compare
+//   Do final operation
+//
+{    .mfi
+     cmp.lt        p7,p6 = GR_exp_Result, GR_max_exp  // Test no overflow
+     fcmp.ge.s0    p0,p11 = FR_Floating_X,FR_Floating_N  // Dummy to set denorm
+     cmp.lt        p9,p0 = GR_exp_Result, GR_min_den_exp // Test sure underflow
+}
+{    .mfb
+     nop.m         0
+     fma.s.s0      FR_Result = FR_Two_N,FR_Norm_X,f0
+(p9) br.cond.spnt  SCALBF_UNDERFLOW           // Branch if certain underflow
+}
+;;
+
+{    .mib
+(p6) cmp.gt.unc    p6,p8 = GR_exp_Result, GR_max_exp  // Test sure overflow
+(p7) cmp.ge.unc    p7,p9 = GR_exp_Result, GR_min_exp  // Test no over/underflow
+(p7) br.ret.sptk   b0                         // Return from main path
+}
+;;
+
+{    .bbb
+(p6) br.cond.spnt  SCALBF_OVERFLOW            // Branch if certain overflow
+(p8) br.cond.spnt  SCALBF_POSSIBLE_OVERFLOW   // Branch if possible overflow
+(p9) br.cond.spnt  SCALBF_POSSIBLE_UNDERFLOW  // Branch if possible underflow
+}
+;;
+
+// Here if possible underflow.
+// Resulting exponent: 0x0ff81-23 <= exp_Result < 0x0ff81
+SCALBF_POSSIBLE_UNDERFLOW:
+//
+// Here if possible overflow.
+// Resulting exponent: 0x1007e = exp_Result
+SCALBF_POSSIBLE_OVERFLOW:
+
+//   Set up necessary status fields
+//
+//   S0 user supplied status
+//   S2 user supplied status + WRE + TD  (Overflows)
+//   S3 user supplied status + FZ + TD   (Underflows)
+//
+{    .mfi
+     mov           GR_pos_ov_limit = 0x1007f // Exponent for positive overflow
+     fsetc.s3      0x7F,0x41
+     nop.i         0
+}
+{    .mfi
+     mov           GR_neg_ov_limit = 0x3007f // Exponent for negative overflow
+     fsetc.s2      0x7F,0x42
+     nop.i         0
+}
+;;
+
+//
+//   Do final operation with s2 and s3
+//
+{    .mfi
+     setf.exp      FR_NBig = GR_neg_ov_limit
+     fma.s.s3      FR_Result3 = FR_Two_N,FR_Norm_X,f0
+     nop.i         0
+}
+{    .mfi
+     setf.exp      FR_Big = GR_pos_ov_limit
+     fma.s.s2      FR_Result2 = FR_Two_N,FR_Norm_X,f0
+     nop.i         0
+}
+;;
+
+//   Check for overflow or underflow.
+//   Restore s3
+//   Restore s2
+//
+{    .mfi
+     nop.m         0
+     fsetc.s3      0x7F,0x40
+     nop.i         0
+}
+{    .mfi
+     nop.m         0
+     fsetc.s2      0x7F,0x40
+     nop.i         0
+}
+;;
+
+//
+//   Is the result zero?
+//
+{    .mfi
+     nop.m         0
+     fclass.m      p6, p0 =  FR_Result3, 0x007
+     nop.i         0
+}
+{    .mfi
+     nop.m         0
+     fcmp.ge.s1    p7, p8 = FR_Result2 , FR_Big
+     nop.i         0
+}
+;;
+
+//
+//   Detect masked underflow - Tiny + Inexact Only
+//
+{    .mfi
+     nop.m         0
+(p6) fcmp.neq.unc.s1 p6, p0 = FR_Result , FR_Result2
+     nop.i         0
+}
+;;
+
+//
+//   Is result bigger the allowed range?
+//   Branch out for underflow
+//
+{    .mfb
+     nop.m          0
+(p8) fcmp.le.unc.s1 p9, p10 = FR_Result2 , FR_NBig
+(p6) br.cond.spnt   SCALBF_UNDERFLOW
+}
+;;
+
+//
+//   Branch out for overflow
+//
+{ .bbb
+(p7) br.cond.spnt   SCALBF_OVERFLOW
+(p9) br.cond.spnt   SCALBF_OVERFLOW
+     br.ret.sptk    b0             //   Return from main path.
+}
+;;
+
+// Here if result overflows
+SCALBF_OVERFLOW:
+{ .mib
+     alloc         r32=ar.pfs,3,0,4,0
+     addl          GR_Tag = 55, r0     // Set error tag for overflow
+     br.cond.sptk  __libm_error_region // Call error support for overflow
+}
+;;
+
+// Here if result underflows
+SCALBF_UNDERFLOW:
+{ .mib
+     alloc         r32=ar.pfs,3,0,4,0
+     addl          GR_Tag = 56, r0     // Set error tag for underflow
+     br.cond.sptk  __libm_error_region // Call error support for underflow
+}
+;;
+
+SCALBF_NAN_INF_ZERO:
+
+//
+//   Before entry, N has been converted to a fp integer in significand of
+//     FR_N_float_int
+//
+//   Convert  N_float_int to floating point value
+//
+{    .mfi
+     getf.sig     GR_N_as_int = FR_N_float_int
+     fclass.m     p6,p0 = FR_Floating_N, 0xc3 //@snan | @qnan
+     nop.i        0
+}
+{    .mfi
+     addl         GR_Scratch = 1,r0
+     fcvt.xf      FR_N_float_int = FR_N_float_int
+     nop.i        0
+}
+;;
+
+{    .mfi
+     nop.m        0
+     fclass.m     p7,p0 = FR_Floating_X, 0xc3 //@snan | @qnan
+     shl          GR_Scratch = GR_Scratch,63
+}
+;;
+
+{    .mfi
+     nop.m        0
+     fclass.m     p8,p0 = FR_Floating_N, 0x21 // @inf
+     nop.i        0
+}
+{    .mfi
+     nop.m        0
+     fclass.m     p9,p0 = FR_Floating_N, 0x22 // @-inf
+     nop.i        0
+}
+;;
+
+//
+//   Either X or N is a Nan, return result and possible raise invalid.
+//
+{    .mfb
+     nop.m        0
+(p6) fma.s.s0     FR_Result = FR_Floating_N,FR_Floating_X,f0
+(p6) br.ret.spnt  b0
+}
+;;
+
+{    .mfb
+     nop.m        0
+(p7) fma.s.s0     FR_Result = FR_Floating_N,FR_Floating_X,f0
+(p7) br.ret.spnt  b0
+}
+;;
+
+//
+//   If N + Inf do something special
+//   For N = -Inf, create Int
+//
+{    .mfb
+     nop.m        0
+(p8) fma.s.s0     FR_Result = FR_Floating_X, FR_Floating_N,f0
+(p8) br.ret.spnt  b0
+}
+{    .mfi
+     nop.m        0
+(p9) fnma.s.s0    FR_Floating_N = FR_Floating_N, f1, f0
+     nop.i        0
+}
+;;
+
+//
+//   If N==-Inf,return x/(-N)
+//
+{    .mfb
+     cmp.ne       p7,p0 = GR_N_as_int,GR_Scratch
+(p9) frcpa.s0     FR_Result,p0 = FR_Floating_X,FR_Floating_N
+(p9) br.ret.spnt  b0
+}
+;;
+
+//
+//   Is N an integer.
+//
+{    .mfi
+     nop.m        0
+(p7) fcmp.neq.unc.s1 p7,p0 = FR_Norm_N, FR_N_float_int
+     nop.i        0
+}
+;;
+
+//
+//   If N not an int, return NaN and raise invalid.
+//
+{    .mfb
+     nop.m        0
+(p7) frcpa.s0     FR_Result,p0 = f0,f0
+(p7) br.ret.spnt  b0
+}
+;;
+
+//
+//   Always return x in other path.
+//
+{    .mfb
+     nop.m        0
+     fma.s.s0     FR_Result = FR_Floating_X,f1,f0
+     br.ret.sptk  b0
+}
+;;
+
+// Here if n not int
+// Return NaN and raise invalid.
+SCALBF_N_NOT_INT:
+{    .mfb
+     nop.m        0
+     frcpa.s0     FR_Result,p0 = f0,f0
+     br.ret.sptk  b0
+}
+;;
+
+// Here if n=unorm
+SCALBF_N_UNORM:
+{ .mfb
+     getf.exp      GR_signexp_N = FR_Norm_N // Get signexp of normalized n
+     fcvt.fx.trunc.s1   FR_N_float_int = FR_Norm_N // Get N in significand
+     br.cond.sptk  SCALBF_COMMON1            // Return to main path
+}
+;;
+
+// Here if x=unorm
+SCALBF_X_UNORM:
+{ .mib
+     getf.exp      GR_signexp_X = FR_Norm_X // Get signexp of normalized x
+     nop.i         0
+     br.cond.sptk  SCALBF_COMMON2            // Return to main path
+}
+;;
+
+GLOBAL_IEEE754_END(scalbf)
+LOCAL_LIBM_ENTRY(__libm_error_region)
+
+//
+// Get stack address of N
+//
+.prologue
+{ .mfi
+    add   GR_Parameter_Y=-32,sp
+    nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+    mov  GR_SAVE_PFS=ar.pfs
+}
+//
+// Adjust sp
+//
+{ .mfi
+.fframe 64
+   add sp=-64,sp
+   nop.f 0
+   mov GR_SAVE_GP=gp
+};;
+
+//
+//  Store N on stack in correct position
+//  Locate the address of x on stack
+//
+{ .mmi
+   stfs [GR_Parameter_Y] = FR_Norm_N,16
+   add GR_Parameter_X = 16,sp
+.save   b0, GR_SAVE_B0
+   mov GR_SAVE_B0=b0
+};;
+
+//
+// Store x on the stack.
+// Get address for result on stack.
+//
+.body
+{ .mib
+   stfs [GR_Parameter_X] = FR_Norm_X
+   add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+   nop.b 0
+}
+{ .mib
+   stfs [GR_Parameter_Y] = FR_Result
+   add   GR_Parameter_Y = -16,GR_Parameter_Y
+   br.call.sptk b0=__libm_error_support#
+};;
+
+//
+//  Get location of result on stack
+//
+{ .mmi
+   add   GR_Parameter_RESULT = 48,sp
+   nop.m 0
+   nop.i 0
+};;
+
+//
+//  Get the new result
+//
+{ .mmi
+   ldfs  FR_Result = [GR_Parameter_RESULT]
+.restore sp
+   add   sp = 64,sp
+   mov   b0 = GR_SAVE_B0
+};;
+
+//
+//  Restore gp, ar.pfs and return
+//
+{ .mib
+   mov   gp = GR_SAVE_GP
+   mov   ar.pfs = GR_SAVE_PFS
+   br.ret.sptk     b0
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_scalbl.S
@@ -0,0 +1,598 @@
+.file "scalbl.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 01/26/01 Scalb completely reworked and now standalone version
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 08/06/03 Improved performance
+//
+// API
+//==============================================================
+// long double = scalbl  (long double x, long double n)
+// input  floating point f8 and floating point f9
+// output floating point f8
+//
+// int_type = 0 if int is 32 bits
+// int_type = 1 if int is 64 bits
+//
+// Returns x* 2**n using an fma and detects overflow
+// and underflow.
+//
+//
+// Strategy:
+//  Compute biased exponent of result exp_Result = N + exp_X
+//  Break into ranges:
+//   exp_Result > 0x13ffe                 -> Certain overflow
+//   exp_Result = 0x13ffe                 -> Possible overflow
+//   0x0c001 <= exp_Result < 0x13ffe      -> No over/underflow (main path)
+//   0x0c001 - 63 <= exp_Result < 0x0c001 -> Possible underflow
+//   exp_Result < 0x0c001 - 63            -> Certain underflow
+
+FR_Big         = f6
+FR_NBig        = f7
+FR_Floating_X  = f8
+FR_Result      = f8
+FR_Floating_N  = f9
+FR_Result2     = f9
+FR_Result3     = f10
+FR_Norm_X      = f11
+FR_Two_N       = f12
+FR_N_float_int = f13
+FR_Norm_N      = f14
+
+GR_neg_ov_limit= r14
+GR_big_exp     = r14
+GR_N_Biased    = r15
+GR_Big         = r16
+GR_exp_Result  = r18
+GR_pos_ov_limit= r19
+GR_exp_sure_ou = r19
+GR_Bias        = r20
+GR_N_as_int    = r21
+GR_signexp_X   = r22
+GR_exp_X       = r23
+GR_exp_mask    = r24
+GR_max_exp     = r25
+GR_min_exp     = r26
+GR_min_den_exp = r27
+GR_Scratch     = r28
+GR_signexp_N   = r29
+GR_exp_N       = r30
+
+GR_SAVE_B0          = r32
+GR_SAVE_GP          = r33
+GR_SAVE_PFS         = r34
+GR_Parameter_X      = r35
+GR_Parameter_Y      = r36
+GR_Parameter_RESULT = r37
+GR_Tag              = r38
+
+.section .text
+GLOBAL_IEEE754_ENTRY(scalbl)
+
+//
+//   Is x NAN, INF, ZERO, +-?
+//   Build the exponent Bias
+//
+{    .mfi
+     getf.exp      GR_signexp_N = FR_Floating_N // Get signexp of n
+     fclass.m      p6,p0 = FR_Floating_X, 0xe7  // @snan | @qnan | @inf | @zero
+     mov           GR_Bias = 0x0ffff
+}
+{    .mfi
+     mov           GR_Big = 35000      // If N this big then certain overflow
+     fcvt.fx.trunc.s1   FR_N_float_int = FR_Floating_N // Get N in significand
+     nop.i         0
+}
+;;
+
+{    .mfi
+     getf.exp      GR_signexp_X = FR_Floating_X // Get signexp of x
+     fclass.m      p7,p0 = FR_Floating_N, 0x0b  // Test for n=unorm
+     nop.i         0
+}
+//
+//   Normalize n
+//
+{    .mfi
+     mov           GR_exp_mask = 0x1ffff     // Exponent mask
+     fnorm.s1      FR_Norm_N = FR_Floating_N
+     nop.i         0
+}
+;;
+
+//
+//   Is n NAN, INF, ZERO, +-?
+//
+{    .mfi
+     mov           GR_big_exp = 0x1003e      // Exponent at which n is integer
+     fclass.m      p9,p0 = FR_Floating_N, 0xe7  // @snan | @qnan | @inf | @zero
+     mov           GR_max_exp = 0x13ffe      // Exponent of maximum long double
+}
+//
+//   Normalize x
+//
+{ .mfb
+     nop.m         0
+     fnorm.s1      FR_Norm_X = FR_Floating_X
+(p7) br.cond.spnt  SCALBL_N_UNORM             // Branch if n=unorm
+}
+;;
+
+SCALBL_COMMON1:
+// Main path continues.  Also return here from u=unorm path.
+//   Handle special cases if x = Nan, Inf, Zero
+{ .mfb
+     nop.m         0
+     fcmp.lt.s1    p7,p0 = FR_Floating_N, f0  // Test N negative
+(p6) br.cond.spnt  SCALBL_NAN_INF_ZERO
+}
+;;
+
+//   Handle special cases if n = Nan, Inf, Zero
+{    .mfi
+     getf.sig      GR_N_as_int = FR_N_float_int // Get n from significand
+     fclass.m      p8,p0 = FR_Floating_X, 0x0b // Test for x=unorm
+     mov           GR_exp_sure_ou = 0x1000e // Exp_N where x*2^N sure over/under
+}
+{    .mfb
+     mov           GR_min_exp = 0x0c001      // Exponent of minimum long double
+     fcvt.xf       FR_N_float_int = FR_N_float_int // Convert N to FP integer
+(p9) br.cond.spnt  SCALBL_NAN_INF_ZERO
+}
+;;
+
+{    .mmi
+     and           GR_exp_N = GR_exp_mask, GR_signexp_N // Get exponent of N
+(p7) sub           GR_Big = r0, GR_Big          // Limit for N
+     nop.i         0
+}
+;;
+
+{    .mib
+     cmp.lt        p9,p0 = GR_exp_N, GR_big_exp // N possible non-integer?
+     cmp.ge        p6,p0 = GR_exp_N, GR_exp_sure_ou // N certain over/under?
+(p8) br.cond.spnt  SCALBL_X_UNORM             // Branch if x=unorm
+}
+;;
+
+SCALBL_COMMON2:
+// Main path continues.  Also return here from x=unorm path.
+//   Create biased exponent for 2**N
+{    .mmi
+(p6) mov           GR_N_as_int = GR_Big      // Limit N
+;;
+     add           GR_N_Biased = GR_Bias,GR_N_as_int
+     nop.i         0
+}
+;;
+
+{    .mfi
+     setf.exp      FR_Two_N = GR_N_Biased               // Form 2**N
+(p9) fcmp.neq.unc.s1 p9,p0 = FR_Norm_N, FR_N_float_int  // Test if N an integer
+     and           GR_exp_X = GR_exp_mask, GR_signexp_X // Get exponent of X
+}
+;;
+
+//
+//   Compute biased result exponent
+//   Branch if N is not an integer
+//
+{    .mib
+     add           GR_exp_Result = GR_exp_X, GR_N_as_int
+     mov           GR_min_den_exp = 0x0c001 - 63 // Exp of min denorm long dble
+(p9) br.cond.spnt  SCALBL_N_NOT_INT
+}
+;;
+
+//
+//   Raise Denormal operand flag with compare
+//   Do final operation
+//
+{    .mfi
+     cmp.lt        p7,p6 = GR_exp_Result, GR_max_exp  // Test no overflow
+     fcmp.ge.s0    p0,p11 = FR_Floating_X,FR_Floating_N  // Dummy to set denorm
+     cmp.lt        p9,p0 = GR_exp_Result, GR_min_den_exp // Test sure underflow
+}
+{    .mfb
+     nop.m         0
+     fma.s0        FR_Result = FR_Two_N,FR_Norm_X,f0
+(p9) br.cond.spnt  SCALBL_UNDERFLOW           // Branch if certain underflow
+}
+;;
+
+{    .mib
+(p6) cmp.gt.unc    p6,p8 = GR_exp_Result, GR_max_exp  // Test sure overflow
+(p7) cmp.ge.unc    p7,p9 = GR_exp_Result, GR_min_exp  // Test no over/underflow
+(p7) br.ret.sptk   b0                         // Return from main path
+}
+;;
+
+{    .bbb
+(p6) br.cond.spnt  SCALBL_OVERFLOW            // Branch if certain overflow
+(p8) br.cond.spnt  SCALBL_POSSIBLE_OVERFLOW   // Branch if possible overflow
+(p9) br.cond.spnt  SCALBL_POSSIBLE_UNDERFLOW  // Branch if possible underflow
+}
+;;
+
+// Here if possible underflow.
+// Resulting exponent: 0x0c001-63 <= exp_Result < 0x0c001
+SCALBL_POSSIBLE_UNDERFLOW:
+//
+// Here if possible overflow.
+// Resulting exponent: 0x13ffe = exp_Result
+SCALBL_POSSIBLE_OVERFLOW:
+
+//   Set up necessary status fields
+//
+//   S0 user supplied status
+//   S2 user supplied status + WRE + TD  (Overflows)
+//   S3 user supplied status + FZ + TD   (Underflows)
+//
+{    .mfi
+     mov           GR_pos_ov_limit = 0x13fff // Exponent for positive overflow
+     fsetc.s3      0x7F,0x41
+     nop.i         0
+}
+{    .mfi
+     mov           GR_neg_ov_limit = 0x33fff // Exponent for negative overflow
+     fsetc.s2      0x7F,0x42
+     nop.i         0
+}
+;;
+
+//
+//   Do final operation with s2 and s3
+//
+{    .mfi
+     setf.exp      FR_NBig = GR_neg_ov_limit
+     fma.s3        FR_Result3 = FR_Two_N,FR_Norm_X,f0
+     nop.i         0
+}
+{    .mfi
+     setf.exp      FR_Big = GR_pos_ov_limit
+     fma.s2        FR_Result2 = FR_Two_N,FR_Norm_X,f0
+     nop.i         0
+}
+;;
+
+//   Check for overflow or underflow.
+//   Restore s3
+//   Restore s2
+//
+{    .mfi
+     nop.m         0
+     fsetc.s3      0x7F,0x40
+     nop.i         0
+}
+{    .mfi
+     nop.m         0
+     fsetc.s2      0x7F,0x40
+     nop.i         0
+}
+;;
+
+//
+//   Is the result zero?
+//
+{    .mfi
+     nop.m         0
+     fclass.m      p6, p0 =  FR_Result3, 0x007
+     nop.i         0
+}
+{    .mfi
+     nop.m         0
+     fcmp.ge.s1    p7, p8 = FR_Result2 , FR_Big
+     nop.i         0
+}
+;;
+
+//
+//   Detect masked underflow - Tiny + Inexact Only
+//
+{    .mfi
+     nop.m         0
+(p6) fcmp.neq.unc.s1 p6, p0 = FR_Result , FR_Result2
+     nop.i         0
+}
+;;
+
+//
+//   Is result bigger the allowed range?
+//   Branch out for underflow
+//
+{    .mfb
+     nop.m          0
+(p8) fcmp.le.unc.s1 p9, p10 = FR_Result2 , FR_NBig
+(p6) br.cond.spnt   SCALBL_UNDERFLOW
+}
+;;
+
+//
+//   Branch out for overflow
+//
+{ .bbb
+(p7) br.cond.spnt   SCALBL_OVERFLOW
+(p9) br.cond.spnt   SCALBL_OVERFLOW
+     br.ret.sptk    b0             //   Return from main path.
+}
+;;
+
+// Here if result overflows
+SCALBL_OVERFLOW:
+{ .mib
+     alloc         r32=ar.pfs,3,0,4,0
+     addl          GR_Tag = 51, r0     // Set error tag for overflow
+     br.cond.sptk  __libm_error_region // Call error support for overflow
+}
+;;
+
+// Here if result underflows
+SCALBL_UNDERFLOW:
+{ .mib
+     alloc         r32=ar.pfs,3,0,4,0
+     addl          GR_Tag = 52, r0     // Set error tag for underflow
+     br.cond.sptk  __libm_error_region // Call error support for underflow
+}
+;;
+
+SCALBL_NAN_INF_ZERO:
+
+//
+//   Before entry, N has been converted to a fp integer in significand of
+//     FR_N_float_int
+//
+//   Convert  N_float_int to floating point value
+//
+{    .mfi
+     getf.sig     GR_N_as_int = FR_N_float_int
+     fclass.m     p6,p0 = FR_Floating_N, 0xc3 //@snan | @qnan
+     nop.i        0
+}
+{    .mfi
+     addl         GR_Scratch = 1,r0
+     fcvt.xf      FR_N_float_int = FR_N_float_int
+     nop.i        0
+}
+;;
+
+{    .mfi
+     nop.m        0
+     fclass.m     p7,p0 = FR_Floating_X, 0xc3 //@snan | @qnan
+     shl          GR_Scratch = GR_Scratch,63
+}
+;;
+
+{    .mfi
+     nop.m        0
+     fclass.m     p8,p0 = FR_Floating_N, 0x21 // @inf
+     nop.i        0
+}
+{    .mfi
+     nop.m        0
+     fclass.m     p9,p0 = FR_Floating_N, 0x22 // @-inf
+     nop.i        0
+}
+;;
+
+//
+//   Either X or N is a Nan, return result and possible raise invalid.
+//
+{    .mfb
+     nop.m        0
+(p6) fma.s0       FR_Result = FR_Floating_N,FR_Floating_X,f0
+(p6) br.ret.spnt  b0
+}
+;;
+
+{    .mfb
+     nop.m        0
+(p7) fma.s0       FR_Result = FR_Floating_N,FR_Floating_X,f0
+(p7) br.ret.spnt  b0
+}
+;;
+
+//
+//   If N + Inf do something special
+//   For N = -Inf, create Int
+//
+{    .mfb
+     nop.m        0
+(p8) fma.s0       FR_Result = FR_Floating_X, FR_Floating_N,f0
+(p8) br.ret.spnt  b0
+}
+{    .mfi
+     nop.m        0
+(p9) fnma.s0      FR_Floating_N = FR_Floating_N, f1, f0
+     nop.i        0
+}
+;;
+
+//
+//   If N==-Inf,return x/(-N)
+//
+{    .mfb
+     cmp.ne       p7,p0 = GR_N_as_int,GR_Scratch
+(p9) frcpa.s0     FR_Result,p0 = FR_Floating_X,FR_Floating_N
+(p9) br.ret.spnt  b0
+}
+;;
+
+//
+//   Is N an integer.
+//
+{    .mfi
+     nop.m        0
+(p7) fcmp.neq.unc.s1 p7,p0 = FR_Norm_N, FR_N_float_int
+     nop.i        0
+}
+;;
+
+//
+//   If N not an int, return NaN and raise invalid.
+//
+{    .mfb
+     nop.m        0
+(p7) frcpa.s0     FR_Result,p0 = f0,f0
+(p7) br.ret.spnt  b0
+}
+;;
+
+//
+//   Always return x in other path.
+//
+{    .mfb
+     nop.m        0
+     fma.s0       FR_Result = FR_Floating_X,f1,f0
+     br.ret.sptk  b0
+}
+;;
+
+// Here if n not int
+// Return NaN and raise invalid.
+SCALBL_N_NOT_INT:
+{    .mfb
+     nop.m        0
+     frcpa.s0     FR_Result,p0 = f0,f0
+     br.ret.sptk  b0
+}
+;;
+
+// Here if n=unorm
+SCALBL_N_UNORM:
+{ .mfb
+     getf.exp      GR_signexp_N = FR_Norm_N // Get signexp of normalized n
+     fcvt.fx.trunc.s1   FR_N_float_int = FR_Norm_N // Get N in significand
+     br.cond.sptk  SCALBL_COMMON1            // Return to main path
+}
+;;
+
+// Here if x=unorm
+SCALBL_X_UNORM:
+{ .mib
+     getf.exp      GR_signexp_X = FR_Norm_X // Get signexp of normalized x
+     nop.i         0
+     br.cond.sptk  SCALBL_COMMON2            // Return to main path
+}
+;;
+
+GLOBAL_IEEE754_END(scalbl)
+LOCAL_LIBM_ENTRY(__libm_error_region)
+
+//
+// Get stack address of N
+//
+.prologue
+{ .mfi
+    add   GR_Parameter_Y=-32,sp
+    nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+    mov  GR_SAVE_PFS=ar.pfs
+}
+//
+// Adjust sp
+//
+{ .mfi
+.fframe 64
+   add sp=-64,sp
+   nop.f 0
+   mov GR_SAVE_GP=gp
+};;
+
+//
+//  Store N on stack in correct position
+//  Locate the address of x on stack
+//
+{ .mmi
+   stfe [GR_Parameter_Y] = FR_Norm_N,16
+   add GR_Parameter_X = 16,sp
+.save   b0, GR_SAVE_B0
+   mov GR_SAVE_B0=b0
+};;
+
+//
+// Store x on the stack.
+// Get address for result on stack.
+//
+.body
+{ .mib
+   stfe [GR_Parameter_X] = FR_Norm_X
+   add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+   nop.b 0
+}
+{ .mib
+   stfe [GR_Parameter_Y] = FR_Result
+   add   GR_Parameter_Y = -16,GR_Parameter_Y
+   br.call.sptk b0=__libm_error_support#
+};;
+
+//
+//  Get location of result on stack
+//
+{ .mmi
+   add   GR_Parameter_RESULT = 48,sp
+   nop.m 0
+   nop.i 0
+};;
+
+//
+//  Get the new result
+//
+{ .mmi
+   ldfe  FR_Result = [GR_Parameter_RESULT]
+.restore sp
+   add   sp = 64,sp
+   mov   b0 = GR_SAVE_B0
+};;
+
+//
+//  Restore gp, ar.pfs and return
+//
+{ .mib
+   mov   gp = GR_SAVE_GP
+   mov   ar.pfs = GR_SAVE_PFS
+   br.ret.sptk     b0
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_sinh.S
@@ -0,0 +1,905 @@
+.file "sinh.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 10/12/00 Update to set denormal operand and underflow flags
+// 01/22/01 Fixed to set inexact flag for small args.
+// 05/02/01 Reworked to improve speed of all paths
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 11/20/02 Improved speed with new algorithm
+// 03/31/05 Reformatted delimiters between data tables
+
+// API
+//==============================================================
+// double sinh(double)
+
+// Overview of operation
+//==============================================================
+// Case 1:  0 < |x| < 2^-60
+//  Result = x, computed by x+sgn(x)*x^2) to handle flags and rounding
+//
+// Case 2:  2^-60 < |x| < 0.25
+//  Evaluate sinh(x) by a 13th order polynomial
+//  Care is take for the order of multiplication; and A1 is not exactly 1/3!,
+//  A2 is not exactly 1/5!, etc.
+//  sinh(x) = x + (A1*x^3 + A2*x^5 + A3*x^7 + A4*x^9 + A5*x^11 + A6*x^13)
+//
+// Case 3:  0.25 < |x| < 710.47586
+//  Algorithm is based on the identity sinh(x) = ( exp(x) - exp(-x) ) / 2.
+//  The algorithm for exp is described as below.  There are a number of
+//  economies from evaluating both exp(x) and exp(-x).  Although we
+//  are evaluating both quantities, only where the quantities diverge do we
+//  duplicate the computations.  The basic algorithm for exp(x) is described
+//  below.
+//
+// Take the input x. w is "how many log2/128 in x?"
+//  w = x * 128/log2
+//  n = int(w)
+//  x = n log2/128 + r + delta
+
+//  n = 128M + index_1 + 2^4 index_2
+//  x = M log2 + (log2/128) index_1 + (log2/8) index_2 + r + delta
+
+//  exp(x) = 2^M  2^(index_1/128)  2^(index_2/8) exp(r) exp(delta)
+//       Construct 2^M
+//       Get 2^(index_1/128) from table_1;
+//       Get 2^(index_2/8)   from table_2;
+//       Calculate exp(r) by 5th order polynomial
+//          r = x - n (log2/128)_high
+//          delta = - n (log2/128)_low
+//       Calculate exp(delta) as 1 + delta
+
+
+// Special values
+//==============================================================
+// sinh(+0)    = +0
+// sinh(-0)    = -0
+
+// sinh(+qnan) = +qnan
+// sinh(-qnan) = -qnan
+// sinh(+snan) = +qnan
+// sinh(-snan) = -qnan
+
+// sinh(-inf)  = -inf
+// sinh(+inf)  = +inf
+
+// Overflow and Underflow
+//=======================
+// sinh(x) = largest double normal when
+//     |x| = 710.47586 = 0x408633ce8fb9f87d
+//
+// Underflow is handled as described in case 1 above
+
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input, output
+// f6 -> f15,  f32 -> f61
+
+// General registers used:
+// r14 -> r40
+
+// Predicate registers used:
+// p6 -> p15
+
+// Assembly macros
+//==============================================================
+
+rRshf                 = r14
+rN_neg                = r14
+rAD_TB1               = r15
+rAD_TB2               = r16
+rAD_P                 = r17
+rN                    = r18
+rIndex_1              = r19
+rIndex_2_16           = r20
+rM                    = r21
+rBiased_M             = r21
+rSig_inv_ln2          = r22
+rIndex_1_neg          = r22
+rExp_bias             = r23
+rExp_bias_minus_1     = r23
+rExp_mask             = r24
+rTmp                  = r24
+rGt_ln                = r24
+rIndex_2_16_neg       = r24
+rM_neg                = r25
+rBiased_M_neg         = r25
+rRshf_2to56           = r26
+rAD_T1_neg            = r26
+rExp_2tom56           = r28
+rAD_T2_neg            = r28
+rAD_T1                = r29
+rAD_T2                = r30
+rSignexp_x            = r31
+rExp_x                = r31
+
+GR_SAVE_B0            = r33
+GR_SAVE_PFS           = r34
+GR_SAVE_GP            = r35
+
+GR_Parameter_X        = r37
+GR_Parameter_Y        = r38
+GR_Parameter_RESULT   = r39
+GR_Parameter_TAG      = r40
+
+
+FR_X                  = f10
+FR_Y                  = f1
+FR_RESULT             = f8
+
+fRSHF_2TO56           = f6
+fINV_LN2_2TO63        = f7
+fW_2TO56_RSH          = f9
+f2TOM56               = f11
+fP5                   = f12
+fP4                   = f13
+fP3                   = f14
+fP2                   = f15
+
+fLn2_by_128_hi        = f33
+fLn2_by_128_lo        = f34
+
+fRSHF                 = f35
+fNfloat               = f36
+fNormX                = f37
+fR                    = f38
+fF                    = f39
+
+fRsq                  = f40
+f2M                   = f41
+fS1                   = f42
+fT1                   = f42
+fS2                   = f43
+fT2                   = f43
+fS                    = f43
+fWre_urm_f8           = f44
+fAbsX                 = f44
+
+fMIN_DBL_OFLOW_ARG    = f45
+fMAX_DBL_NORM_ARG     = f46
+fXsq                  = f47
+fX4                   = f48
+fGt_pln               = f49
+fTmp                  = f49
+
+fP54                  = f50
+fP5432                = f50
+fP32                  = f51
+fP                    = f52
+fP54_neg              = f53
+fP5432_neg            = f53
+fP32_neg              = f54
+fP_neg                = f55
+fF_neg                = f56
+
+f2M_neg               = f57
+fS1_neg               = f58
+fT1_neg               = f58
+fS2_neg               = f59
+fT2_neg               = f59
+fS_neg                = f59
+fExp                  = f60
+fExp_neg              = f61
+
+fA6                   = f50
+fA65                  = f50
+fA6543                = f50
+fA654321              = f50
+fA5                   = f51
+fA4                   = f52
+fA43                  = f52
+fA3                   = f53
+fA2                   = f54
+fA21                  = f54
+fA1                   = f55
+fX3                   = f56
+
+// Data tables
+//==============================================================
+
+RODATA
+.align 16
+
+// ************* DO NOT CHANGE ORDER OF THESE TABLES ********************
+
+// double-extended 1/ln(2)
+// 3fff b8aa 3b29 5c17 f0bb be87fed0691d3e88
+// 3fff b8aa 3b29 5c17 f0bc
+// For speed the significand will be loaded directly with a movl and setf.sig
+//   and the exponent will be bias+63 instead of bias+0.  Thus subsequent
+//   computations need to scale appropriately.
+// The constant 128/ln(2) is needed for the computation of w.  This is also
+//   obtained by scaling the computations.
+//
+// Two shifting constants are loaded directly with movl and setf.d.
+//   1. fRSHF_2TO56 = 1.1000..00 * 2^(63-7)
+//        This constant is added to x*1/ln2 to shift the integer part of
+//        x*128/ln2 into the rightmost bits of the significand.
+//        The result of this fma is fW_2TO56_RSH.
+//   2. fRSHF       = 1.1000..00 * 2^(63)
+//        This constant is subtracted from fW_2TO56_RSH * 2^(-56) to give
+//        the integer part of w, n, as a floating-point number.
+//        The result of this fms is fNfloat.
+
+
+LOCAL_OBJECT_START(exp_table_1)
+data8 0x408633ce8fb9f87e // smallest dbl overflow arg
+data8 0x408633ce8fb9f87d // largest dbl arg to give normal dbl result
+data8 0xb17217f7d1cf79ab , 0x00003ff7 // ln2/128 hi
+data8 0xc9e3b39803f2f6af , 0x00003fb7 // ln2/128 lo
+//
+// Table 1 is 2^(index_1/128) where
+// index_1 goes from 0 to 15
+//
+data8 0x8000000000000000 , 0x00003FFF
+data8 0x80B1ED4FD999AB6C , 0x00003FFF
+data8 0x8164D1F3BC030773 , 0x00003FFF
+data8 0x8218AF4373FC25EC , 0x00003FFF
+data8 0x82CD8698AC2BA1D7 , 0x00003FFF
+data8 0x8383594EEFB6EE37 , 0x00003FFF
+data8 0x843A28C3ACDE4046 , 0x00003FFF
+data8 0x84F1F656379C1A29 , 0x00003FFF
+data8 0x85AAC367CC487B15 , 0x00003FFF
+data8 0x8664915B923FBA04 , 0x00003FFF
+data8 0x871F61969E8D1010 , 0x00003FFF
+data8 0x87DB357FF698D792 , 0x00003FFF
+data8 0x88980E8092DA8527 , 0x00003FFF
+data8 0x8955EE03618E5FDD , 0x00003FFF
+data8 0x8A14D575496EFD9A , 0x00003FFF
+data8 0x8AD4C6452C728924 , 0x00003FFF
+LOCAL_OBJECT_END(exp_table_1)
+
+// Table 2 is 2^(index_1/8) where
+// index_2 goes from 0 to 7
+LOCAL_OBJECT_START(exp_table_2)
+data8 0x8000000000000000 , 0x00003FFF
+data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
+data8 0x9837F0518DB8A96F , 0x00003FFF
+data8 0xA5FED6A9B15138EA , 0x00003FFF
+data8 0xB504F333F9DE6484 , 0x00003FFF
+data8 0xC5672A115506DADD , 0x00003FFF
+data8 0xD744FCCAD69D6AF4 , 0x00003FFF
+data8 0xEAC0C6E7DD24392F , 0x00003FFF
+LOCAL_OBJECT_END(exp_table_2)
+
+
+LOCAL_OBJECT_START(exp_p_table)
+data8 0x3f8111116da21757 //P5
+data8 0x3fa55555d787761c //P4
+data8 0x3fc5555555555414 //P3
+data8 0x3fdffffffffffd6a //P2
+LOCAL_OBJECT_END(exp_p_table)
+
+LOCAL_OBJECT_START(sinh_p_table)
+data8 0xB08AF9AE78C1239F, 0x00003FDE  // A6
+data8 0xB8EF1D28926D8891, 0x00003FEC  // A4
+data8 0x8888888888888412, 0x00003FF8  // A2
+data8 0xD732377688025BE9, 0x00003FE5  // A5
+data8 0xD00D00D00D4D39F2, 0x00003FF2  // A3
+data8 0xAAAAAAAAAAAAAAAB, 0x00003FFC  // A1
+LOCAL_OBJECT_END(sinh_p_table)
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(sinh)
+
+{ .mlx
+      getf.exp        rSignexp_x = f8  // Must recompute if x unorm
+      movl            rSig_inv_ln2 = 0xb8aa3b295c17f0bc  // significand of 1/ln2
+}
+{ .mlx
+      addl            rAD_TB1    = @ltoff(exp_table_1), gp
+      movl            rRshf_2to56 = 0x4768000000000000   // 1.10000 2^(63+56)
+}
+;;
+
+{ .mfi
+      ld8             rAD_TB1    = [rAD_TB1]
+      fclass.m        p6,p0 = f8,0x0b  // Test for x=unorm
+      mov             rExp_mask = 0x1ffff
+}
+{ .mfi
+      mov             rExp_bias = 0xffff
+      fnorm.s1        fNormX   = f8
+      mov             rExp_2tom56 = 0xffff-56
+}
+;;
+
+// Form two constants we need
+//  1/ln2 * 2^63  to compute  w = x * 1/ln2 * 128
+//  1.1000..000 * 2^(63+63-7) to right shift int(w) into the significand
+
+{ .mfi
+      setf.sig        fINV_LN2_2TO63 = rSig_inv_ln2 // form 1/ln2 * 2^63
+      fclass.m        p8,p0 = f8,0x07  // Test for x=0
+      nop.i 999
+}
+{ .mlx
+      setf.d          fRSHF_2TO56 = rRshf_2to56 // Form const 1.100 * 2^(63+56)
+      movl            rRshf = 0x43e8000000000000 // 1.10000 2^63 for right shift
+}
+;;
+
+{ .mfi
+      ldfpd           fMIN_DBL_OFLOW_ARG, fMAX_DBL_NORM_ARG = [rAD_TB1],16
+      fclass.m        p10,p0 = f8,0x1e3  // Test for x=inf, nan, NaT
+      nop.i           0
+}
+{ .mfb
+      setf.exp        f2TOM56 = rExp_2tom56 // form 2^-56 for scaling Nfloat
+      nop.f           0
+(p6)  br.cond.spnt    SINH_UNORM            // Branch if x=unorm
+}
+;;
+
+SINH_COMMON:
+{ .mfi
+      ldfe            fLn2_by_128_hi  = [rAD_TB1],16
+      nop.f           0
+      nop.i           0
+}
+{ .mfb
+      setf.d          fRSHF = rRshf // Form right shift const 1.100 * 2^63
+      nop.f           0
+(p8)  br.ret.spnt     b0                    // Exit for x=0, result=x
+}
+;;
+
+{ .mfi
+      ldfe            fLn2_by_128_lo  = [rAD_TB1],16
+      nop.f           0
+      nop.i           0
+}
+{ .mfb
+      and             rExp_x = rExp_mask, rSignexp_x // Biased exponent of x
+(p10) fma.d.s0        f8 = f8,f1,f0  // Result if x=inf, nan, NaT
+(p10) br.ret.spnt     b0               // quick exit for x=inf, nan, NaT
+}
+;;
+
+// After that last load rAD_TB1 points to the beginning of table 1
+{ .mfi
+      nop.m           0
+      fcmp.eq.s0      p6,p0 = f8, f0       // Dummy to set D
+      sub             rExp_x = rExp_x, rExp_bias // True exponent of x
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fmerge.s        fAbsX = f0, fNormX   // Form |x|
+      nop.i           0
+}
+{ .mfb
+      cmp.gt          p7, p0 = -2, rExp_x      // Test |x| < 2^(-2)
+      fma.s1          fXsq = fNormX, fNormX, f0  // x*x for small path
+(p7)  br.cond.spnt    SINH_SMALL               // Branch if 0 < |x| < 2^-2
+}
+;;
+
+// W = X * Inv_log2_by_128
+// By adding 1.10...0*2^63 we shift and get round_int(W) in significand.
+// We actually add 1.10...0*2^56 to X * Inv_log2 to do the same thing.
+
+{ .mfi
+      add             rAD_P = 0x180, rAD_TB1
+      fma.s1          fW_2TO56_RSH  = fNormX, fINV_LN2_2TO63, fRSHF_2TO56
+      add             rAD_TB2 = 0x100, rAD_TB1
+}
+;;
+
+// Divide arguments into the following categories:
+//  Certain Safe                - 0.25 <= |x| <= MAX_DBL_NORM_ARG
+//  Possible Overflow       p14 - MAX_DBL_NORM_ARG < |x| < MIN_DBL_OFLOW_ARG
+//  Certain Overflow        p15 - MIN_DBL_OFLOW_ARG <= |x| < +inf
+//
+// If the input is really a double arg, then there will never be
+// "Possible Overflow" arguments.
+//
+
+{ .mfi
+      ldfpd           fP5, fP4  = [rAD_P] ,16
+      fcmp.ge.s1      p15,p14 = fAbsX,fMIN_DBL_OFLOW_ARG
+      nop.i           0
+}
+;;
+
+// Nfloat = round_int(W)
+// The signficand of fW_2TO56_RSH contains the rounded integer part of W,
+// as a twos complement number in the lower bits (that is, it may be negative).
+// That twos complement number (called N) is put into rN.
+
+// Since fW_2TO56_RSH is scaled by 2^56, it must be multiplied by 2^-56
+// before the shift constant 1.10000 * 2^63 is subtracted to yield fNfloat.
+// Thus, fNfloat contains the floating point version of N
+
+{ .mfi
+      ldfpd           fP3, fP2  = [rAD_P]
+(p14) fcmp.gt.unc.s1  p14,p0 = fAbsX,fMAX_DBL_NORM_ARG
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+      fms.s1          fNfloat = fW_2TO56_RSH, f2TOM56, fRSHF
+(p15) br.cond.spnt    SINH_CERTAIN_OVERFLOW
+}
+;;
+
+{ .mfi
+      getf.sig        rN        = fW_2TO56_RSH
+      nop.f           0
+      mov             rExp_bias_minus_1 = 0xfffe
+}
+;;
+
+// rIndex_1 has index_1
+// rIndex_2_16 has index_2 * 16
+// rBiased_M has M
+
+// rM has true M
+// r = x - Nfloat * ln2_by_128_hi
+// f = 1 - Nfloat * ln2_by_128_lo
+{ .mfi
+      and             rIndex_1 = 0x0f, rN
+      fnma.s1         fR   = fNfloat, fLn2_by_128_hi, fNormX
+      shr             rM = rN,  0x7
+}
+{ .mfi
+      and             rIndex_2_16 = 0x70, rN
+      fnma.s1         fF   = fNfloat, fLn2_by_128_lo, f1
+      sub             rN_neg = r0, rN
+}
+;;
+
+{ .mmi
+      and             rIndex_1_neg = 0x0f, rN_neg
+      add             rBiased_M = rExp_bias_minus_1, rM
+      shr             rM_neg = rN_neg,  0x7
+}
+{ .mmi
+      and             rIndex_2_16_neg = 0x70, rN_neg
+      add             rAD_T2 = rAD_TB2, rIndex_2_16
+      shladd          rAD_T1 = rIndex_1, 4, rAD_TB1
+}
+;;
+
+// rAD_T1 has address of T1
+// rAD_T2 has address if T2
+
+{ .mmi
+      setf.exp        f2M = rBiased_M
+      ldfe            fT2  = [rAD_T2]
+      nop.i           0
+}
+{ .mmi
+      add             rBiased_M_neg = rExp_bias_minus_1, rM_neg
+      add             rAD_T2_neg = rAD_TB2, rIndex_2_16_neg
+      shladd          rAD_T1_neg = rIndex_1_neg, 4, rAD_TB1
+}
+;;
+
+// Create Scale = 2^M
+// Load T1 and T2
+{ .mmi
+      ldfe            fT1  = [rAD_T1]
+      nop.m           0
+      nop.i           0
+}
+{ .mmf
+      setf.exp        f2M_neg = rBiased_M_neg
+      ldfe            fT2_neg  = [rAD_T2_neg]
+      fma.s1          fF_neg   = fNfloat, fLn2_by_128_lo, f1
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fRsq = fR, fR, f0
+      nop.i           0
+}
+{ .mfi
+      ldfe            fT1_neg  = [rAD_T1_neg]
+      fma.s1          fP54 = fR, fP5, fP4
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fP32 = fR, fP3, fP2
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fnma.s1         fP54_neg = fR, fP5, fP4
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fnma.s1         fP32_neg = fR, fP3, fP2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fP5432  = fRsq, fP54, fP32
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fS2  = fF,fT2,f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fS1  = f2M,fT1,f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fP5432_neg  = fRsq, fP54_neg, fP32_neg
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fS1_neg  = f2M_neg,fT1_neg,f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fS2_neg  = fF_neg,fT2_neg,f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fP     = fRsq, fP5432, fR
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fS   = fS1,fS2,f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fms.s1          fP_neg     = fRsq, fP5432_neg, fR
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fS_neg   = fS1_neg,fS2_neg,f0
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fmpy.s0         fTmp = fLn2_by_128_lo, fLn2_by_128_lo // Force inexact
+(p14) br.cond.spnt    SINH_POSSIBLE_OVERFLOW
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fExp = fS, fP, fS
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fExp_neg = fS_neg, fP_neg, fS_neg
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fms.d.s0        f8 = fExp, f1, fExp_neg
+      br.ret.sptk     b0                  // Normal path exit
+}
+;;
+
+// Here if 0 < |x| < 0.25
+SINH_SMALL:
+{ .mfi
+      add             rAD_T1 = 0x1a0, rAD_TB1
+      fcmp.lt.s1      p7, p8 = fNormX, f0       // Test sign of x
+      cmp.gt          p6, p0 = -60, rExp_x      // Test |x| < 2^(-60)
+}
+{ .mfi
+      add             rAD_T2 = 0x1d0, rAD_TB1
+      nop.f           0
+      nop.i           0
+}
+;;
+
+{ .mmb
+      ldfe            fA6 = [rAD_T1],16
+      ldfe            fA5 = [rAD_T2],16
+(p6)  br.cond.spnt    SINH_VERY_SMALL           // Branch if |x| < 2^(-60)
+}
+;;
+
+{ .mmi
+      ldfe            fA4 = [rAD_T1],16
+      ldfe            fA3 = [rAD_T2],16
+      nop.i           0
+}
+;;
+
+{ .mmi
+      ldfe            fA2 = [rAD_T1]
+      ldfe            fA1 = [rAD_T2]
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fX3 = fNormX, fXsq, f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fX4 = fXsq, fXsq, f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA65 = fXsq, fA6, fA5
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fA43 = fXsq, fA4, fA3
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA21 = fXsq, fA2, fA1
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA6543 = fX4, fA65, fA43
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA654321 = fX4, fA6543, fA21
+      nop.i           0
+}
+;;
+
+// Dummy multiply to generate inexact
+{ .mfi
+      nop.m           0
+      fmpy.s0         fTmp = fA6, fA6
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+      fma.d.s0        f8 = fA654321, fX3, fNormX
+      br.ret.sptk     b0                // Exit if 2^-60 < |x| < 0.25
+}
+;;
+
+SINH_VERY_SMALL:
+// Here if 0 < |x| < 2^-60
+// Compute result by x + sgn(x)*x^2 to get properly rounded result
+.pred.rel "mutex",p7,p8
+{ .mfi
+      nop.m           0
+(p7)  fnma.d.s0       f8 = fNormX, fNormX, fNormX // If x<0 result ~ x-x^2
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+(p8)  fma.d.s0        f8 = fNormX, fNormX, fNormX // If x>0 result ~ x+x^2
+      br.ret.sptk     b0                          // Exit if |x| < 2^-60
+}
+;;
+
+
+SINH_POSSIBLE_OVERFLOW:
+
+// Here if fMAX_DBL_NORM_ARG < |x| < fMIN_DBL_OFLOW_ARG
+// This cannot happen if input is a double, only if input higher precision.
+// Overflow is a possibility, not a certainty.
+
+// Recompute result using status field 2 with user's rounding mode,
+// and wre set.  If result is larger than largest double, then we have
+// overflow
+
+{ .mfi
+      mov             rGt_ln  = 0x103ff // Exponent for largest dbl + 1 ulp
+      fsetc.s2        0x7F,0x42         // Get user's round mode, set wre
+      nop.i           0
+}
+;;
+
+{ .mfi
+      setf.exp        fGt_pln = rGt_ln  // Create largest double + 1 ulp
+      fma.d.s2        fWre_urm_f8 = fS, fP, fS    // Result with wre set
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fsetc.s2        0x7F,0x40                   // Turn off wre in sf2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.ge.s1      p6, p0 =  fWre_urm_f8, fGt_pln // Test for overflow
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      nop.f           0
+(p6)  br.cond.spnt    SINH_CERTAIN_OVERFLOW // Branch if overflow
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fma.d.s0        f8 = fS, fP, fS
+      br.ret.sptk     b0                     // Exit if really no overflow
+}
+;;
+
+SINH_CERTAIN_OVERFLOW:
+{ .mfi
+      sub             rTmp = rExp_mask, r0, 1
+      fcmp.lt.s1      p6, p7 = fNormX, f0    // Test for x < 0
+      nop.i           0
+}
+;;
+
+{ .mmf
+      alloc           r32=ar.pfs,1,4,4,0
+      setf.exp        fTmp = rTmp
+      fmerge.s        FR_X = f8,f8
+}
+;;
+
+{ .mfi
+      mov             GR_Parameter_TAG = 127
+(p6)  fnma.d.s0       FR_RESULT = fTmp, fTmp, f0    // Set I,O and -INF result
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+(p7)  fma.d.s0        FR_RESULT = fTmp, fTmp, f0    // Set I,O and +INF result
+      br.cond.sptk    __libm_error_region
+}
+;;
+
+// Here if x unorm
+SINH_UNORM:
+{ .mfb
+      getf.exp        rSignexp_x = fNormX    // Must recompute if x unorm
+      fcmp.eq.s0      p6, p0 = f8, f0        // Set D flag
+      br.cond.sptk    SINH_COMMON
+}
+;;
+
+GLOBAL_IEEE754_END(sinh)
+libm_alias_double_other (__sinh, sinh)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfd [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfd [GR_Parameter_X] = FR_X            // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = FR_RESULT       // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_sinhf.S
@@ -0,0 +1,748 @@
+.file "sinhf.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+
+// History
+//*********************************************************************
+// 02/02/00 Initial version
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 10/12/00 Update to set denormal operand and underflow flags
+// 01/22/01 Fixed to set inexact flag for small args.
+// 05/02/01 Reworked to improve speed of all paths
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 11/20/02 Improved algorithm based on expf
+// 03/31/05 Reformatted delimiters between data tables
+//
+// API
+//*********************************************************************
+// float sinhf(float)
+//
+// Overview of operation
+//*********************************************************************
+// Case 1:  0 < |x| < 2^-60
+//  Result = x, computed by x+sgn(x)*x^2) to handle flags and rounding
+//
+// Case 2:  2^-60 < |x| < 0.25
+//  Evaluate sinh(x) by a 9th order polynomial
+//  Care is take for the order of multiplication; and A2 is not exactly 1/5!,
+//  A3 is not exactly 1/7!, etc.
+//  sinh(x) = x + (A1*x^3 + A2*x^5 + A3*x^7 + A4*x^9)
+//
+// Case 3:  0.25 < |x| < 89.41598
+//  Algorithm is based on the identity sinh(x) = ( exp(x) - exp(-x) ) / 2.
+//  The algorithm for exp is described as below.  There are a number of
+//  economies from evaluating both exp(x) and exp(-x).  Although we
+//  are evaluating both quantities, only where the quantities diverge do we
+//  duplicate the computations.  The basic algorithm for exp(x) is described
+//  below.
+//
+// Take the input x. w is "how many log2/128 in x?"
+//  w = x * 64/log2
+//  NJ = int(w)
+//  x = NJ*log2/64 + R
+
+//  NJ = 64*n + j
+//  x = n*log2 + (log2/64)*j + R
+//
+//  So, exp(x) = 2^n * 2^(j/64)* exp(R)
+//
+//  T =  2^n * 2^(j/64)
+//       Construct 2^n
+//       Get 2^(j/64) table
+//           actually all the entries of 2^(j/64) table are stored in DP and
+//           with exponent bits set to 0 -> multiplication on 2^n can be
+//           performed by doing logical "or" operation with bits presenting 2^n
+
+//  exp(R) = 1 + (exp(R) - 1)
+//  P = exp(R) - 1 approximated by Taylor series of 3rd degree
+//      P = A3*R^3 + A2*R^2 + R, A3 = 1/6, A2 = 1/2
+//
+
+//  The final result is reconstructed as follows
+//  exp(x) = T + T*P
+
+// Special values
+//*********************************************************************
+// sinhf(+0)    = +0
+// sinhf(-0)    = -0
+
+// sinhf(+qnan) = +qnan
+// sinhf(-qnan) = -qnan
+// sinhf(+snan) = +qnan
+// sinhf(-snan) = -qnan
+
+// sinhf(-inf)  = -inf
+// sinhf(+inf)  = +inf
+
+// Overflow and Underflow
+//*********************************************************************
+// sinhf(x) = largest single normal when
+//     x = 89.41598 = 0x42b2d4fc
+//
+// Underflow is handled as described in case 1 above
+
+// Registers used
+//*********************************************************************
+// Floating Point registers used:
+// f8 input, output
+// f6,f7, f9 -> f15,  f32 -> f45
+
+// General registers used:
+// r2, r3, r16 -> r38
+
+// Predicate registers used:
+// p6 -> p15
+
+// Assembly macros
+//*********************************************************************
+// integer registers used
+// scratch
+rNJ                   = r2
+rNJ_neg               = r3
+
+rJ_neg                = r16
+rN_neg                = r17
+rSignexp_x            = r18
+rExp_x                = r18
+rExp_mask             = r19
+rExp_bias             = r20
+rAd1                  = r21
+rAd2                  = r22
+rJ                    = r23
+rN                    = r24
+rTblAddr              = r25
+rA3                   = r26
+rExpHalf              = r27
+rLn2Div64             = r28
+rGt_ln                = r29
+r17ones_m1            = r29
+rRightShifter         = r30
+rJ_mask               = r30
+r64DivLn2             = r31
+rN_mask               = r31
+// stacked
+GR_SAVE_PFS           = r32
+GR_SAVE_B0            = r33
+GR_SAVE_GP            = r34
+GR_Parameter_X        = r35
+GR_Parameter_Y        = r36
+GR_Parameter_RESULT   = r37
+GR_Parameter_TAG      = r38
+
+// floating point registers used
+FR_X                  = f10
+FR_Y                  = f1
+FR_RESULT             = f8
+// scratch
+fRightShifter         = f6
+f64DivLn2             = f7
+fNormX                = f9
+fNint                 = f10
+fN                    = f11
+fR                    = f12
+fLn2Div64             = f13
+fA2                   = f14
+fA3                   = f15
+// stacked
+fP                    = f32
+fT                    = f33
+fMIN_SGL_OFLOW_ARG    = f34
+fMAX_SGL_NORM_ARG     = f35
+fRSqr                 = f36
+fA1                   = f37
+fA21                  = f37
+fA4                   = f38
+fA43                  = f38
+fA4321                = f38
+fX4                   = f39
+fTmp                  = f39
+fGt_pln               = f39
+fWre_urm_f8           = f40
+fXsq                  = f40
+fP_neg                = f41
+fX3                   = f41
+fT_neg                = f42
+fExp                  = f43
+fExp_neg              = f44
+fAbsX                 = f45
+
+
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(_sinhf_table)
+data4 0x42b2d4fd         // Smallest single arg to overflow single result
+data4 0x42b2d4fc         // Largest single arg to give normal single result
+data4 0x00000000         // pad
+data4 0x00000000         // pad
+//
+// 2^(j/64) table, j goes from 0 to 63
+data8 0x0000000000000000 // 2^(0/64)
+data8 0x00002C9A3E778061 // 2^(1/64)
+data8 0x000059B0D3158574 // 2^(2/64)
+data8 0x0000874518759BC8 // 2^(3/64)
+data8 0x0000B5586CF9890F // 2^(4/64)
+data8 0x0000E3EC32D3D1A2 // 2^(5/64)
+data8 0x00011301D0125B51 // 2^(6/64)
+data8 0x0001429AAEA92DE0 // 2^(7/64)
+data8 0x000172B83C7D517B // 2^(8/64)
+data8 0x0001A35BEB6FCB75 // 2^(9/64)
+data8 0x0001D4873168B9AA // 2^(10/64)
+data8 0x0002063B88628CD6 // 2^(11/64)
+data8 0x0002387A6E756238 // 2^(12/64)
+data8 0x00026B4565E27CDD // 2^(13/64)
+data8 0x00029E9DF51FDEE1 // 2^(14/64)
+data8 0x0002D285A6E4030B // 2^(15/64)
+data8 0x000306FE0A31B715 // 2^(16/64)
+data8 0x00033C08B26416FF // 2^(17/64)
+data8 0x000371A7373AA9CB // 2^(18/64)
+data8 0x0003A7DB34E59FF7 // 2^(19/64)
+data8 0x0003DEA64C123422 // 2^(20/64)
+data8 0x0004160A21F72E2A // 2^(21/64)
+data8 0x00044E086061892D // 2^(22/64)
+data8 0x000486A2B5C13CD0 // 2^(23/64)
+data8 0x0004BFDAD5362A27 // 2^(24/64)
+data8 0x0004F9B2769D2CA7 // 2^(25/64)
+data8 0x0005342B569D4F82 // 2^(26/64)
+data8 0x00056F4736B527DA // 2^(27/64)
+data8 0x0005AB07DD485429 // 2^(28/64)
+data8 0x0005E76F15AD2148 // 2^(29/64)
+data8 0x0006247EB03A5585 // 2^(30/64)
+data8 0x0006623882552225 // 2^(31/64)
+data8 0x0006A09E667F3BCD // 2^(32/64)
+data8 0x0006DFB23C651A2F // 2^(33/64)
+data8 0x00071F75E8EC5F74 // 2^(34/64)
+data8 0x00075FEB564267C9 // 2^(35/64)
+data8 0x0007A11473EB0187 // 2^(36/64)
+data8 0x0007E2F336CF4E62 // 2^(37/64)
+data8 0x00082589994CCE13 // 2^(38/64)
+data8 0x000868D99B4492ED // 2^(39/64)
+data8 0x0008ACE5422AA0DB // 2^(40/64)
+data8 0x0008F1AE99157736 // 2^(41/64)
+data8 0x00093737B0CDC5E5 // 2^(42/64)
+data8 0x00097D829FDE4E50 // 2^(43/64)
+data8 0x0009C49182A3F090 // 2^(44/64)
+data8 0x000A0C667B5DE565 // 2^(45/64)
+data8 0x000A5503B23E255D // 2^(46/64)
+data8 0x000A9E6B5579FDBF // 2^(47/64)
+data8 0x000AE89F995AD3AD // 2^(48/64)
+data8 0x000B33A2B84F15FB // 2^(49/64)
+data8 0x000B7F76F2FB5E47 // 2^(50/64)
+data8 0x000BCC1E904BC1D2 // 2^(51/64)
+data8 0x000C199BDD85529C // 2^(52/64)
+data8 0x000C67F12E57D14B // 2^(53/64)
+data8 0x000CB720DCEF9069 // 2^(54/64)
+data8 0x000D072D4A07897C // 2^(55/64)
+data8 0x000D5818DCFBA487 // 2^(56/64)
+data8 0x000DA9E603DB3285 // 2^(57/64)
+data8 0x000DFC97337B9B5F // 2^(58/64)
+data8 0x000E502EE78B3FF6 // 2^(59/64)
+data8 0x000EA4AFA2A490DA // 2^(60/64)
+data8 0x000EFA1BEE615A27 // 2^(61/64)
+data8 0x000F50765B6E4540 // 2^(62/64)
+data8 0x000FA7C1819E90D8 // 2^(63/64)
+LOCAL_OBJECT_END(_sinhf_table)
+
+LOCAL_OBJECT_START(sinh_p_table)
+data8 0x3ec749d84bc96d7d // A4
+data8 0x3f2a0168d09557cf // A3
+data8 0x3f811111326ed15a // A2
+data8 0x3fc55555552ed1e2 // A1
+LOCAL_OBJECT_END(sinh_p_table)
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(sinhf)
+
+{ .mlx
+      getf.exp        rSignexp_x = f8  // Must recompute if x unorm
+      movl            r64DivLn2 = 0x40571547652B82FE // 64/ln(2)
+}
+{ .mlx
+      addl            rTblAddr = @ltoff(_sinhf_table),gp
+      movl            rRightShifter = 0x43E8000000000000 // DP Right Shifter
+}
+;;
+
+{ .mfi
+      // point to the beginning of the table
+      ld8             rTblAddr = [rTblAddr]
+      fclass.m        p6, p0 = f8, 0x0b   // Test for x=unorm
+      addl            rA3 = 0x3E2AA, r0   // high bits of 1.0/6.0 rounded to SP
+}
+{ .mfi
+      nop.m           0
+      fnorm.s1        fNormX = f8 // normalized x
+      addl            rExpHalf = 0xFFFE, r0 // exponent of 1/2
+}
+;;
+
+{ .mfi
+      setf.d          f64DivLn2 = r64DivLn2 // load 64/ln(2) to FP reg
+      fclass.m        p15, p0 = f8, 0x1e3   // test for NaT,NaN,Inf
+      nop.i           0
+}
+{ .mlx
+      // load Right Shifter to FP reg
+      setf.d          fRightShifter = rRightShifter
+      movl            rLn2Div64 = 0x3F862E42FEFA39EF // DP ln(2)/64 in GR
+}
+;;
+
+{ .mfi
+      mov             rExp_mask = 0x1ffff
+      fcmp.eq.s1      p13, p0 = f0, f8 // test for x = 0.0
+      shl             rA3 = rA3, 12    // 0x3E2AA000, approx to 1.0/6.0 in SP
+}
+{ .mfb
+      nop.m           0
+      nop.f           0
+(p6)  br.cond.spnt    SINH_UNORM            // Branch if x=unorm
+}
+;;
+
+SINH_COMMON:
+{ .mfi
+      setf.exp        fA2 = rExpHalf        // load A2 to FP reg
+      nop.f           0
+      mov             rExp_bias = 0xffff
+}
+{ .mfb
+      setf.d          fLn2Div64 = rLn2Div64 // load ln(2)/64 to FP reg
+(p15) fma.s.s0        f8 = f8, f1, f0       // result if x = NaT,NaN,Inf
+(p15) br.ret.spnt     b0                    // exit here if x = NaT,NaN,Inf
+}
+;;
+
+{ .mfi
+      // min overflow and max normal threshold
+      ldfps           fMIN_SGL_OFLOW_ARG, fMAX_SGL_NORM_ARG = [rTblAddr], 8
+      nop.f           0
+      and             rExp_x = rExp_mask, rSignexp_x // Biased exponent of x
+}
+{ .mfb
+      setf.s          fA3 = rA3                  // load A3 to FP reg
+      nop.f           0
+(p13) br.ret.spnt     b0                         // exit here if x=0.0, return x
+}
+;;
+
+{ .mfi
+      sub             rExp_x = rExp_x, rExp_bias // True exponent of x
+      fmerge.s        fAbsX = f0, fNormX         // Form |x|
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      // x*(64/ln(2)) + Right Shifter
+      fma.s1          fNint = fNormX, f64DivLn2, fRightShifter
+      add             rTblAddr = 8, rTblAddr
+}
+{ .mfb
+      cmp.gt          p7, p0 = -2, rExp_x        // Test |x| < 2^(-2)
+      fma.s1          fXsq = fNormX, fNormX, f0  // x*x for small path
+(p7)  br.cond.spnt    SINH_SMALL                 // Branch if 0 < |x| < 2^-2
+}
+;;
+
+{ .mfi
+      nop.m           0
+      // check for overflow
+      fcmp.ge.s1      p12, p13 = fAbsX, fMIN_SGL_OFLOW_ARG
+      mov             rJ_mask = 0x3f             // 6-bit mask for J
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fms.s1          fN = fNint, f1, fRightShifter // n in FP register
+      // branch out if overflow
+(p12) br.cond.spnt    SINH_CERTAIN_OVERFLOW
+}
+;;
+
+{ .mfi
+      getf.sig        rNJ = fNint                   // bits of n, j
+      // check for possible overflow
+      fcmp.gt.s1      p13, p0 = fAbsX, fMAX_SGL_NORM_ARG
+      nop.i           0
+}
+;;
+
+{ .mfi
+      addl            rN = 0xFFBF - 63, rNJ      // biased and shifted n-1,j
+      fnma.s1         fR = fLn2Div64, fN, fNormX // R = x - N*ln(2)/64
+      and             rJ = rJ_mask, rNJ          // bits of j
+}
+{ .mfi
+      sub             rNJ_neg = r0, rNJ          // bits of n, j for -x
+      nop.f           0
+      andcm           rN_mask = -1, rJ_mask      // 0xff...fc0 to mask N
+}
+;;
+
+{ .mfi
+      shladd          rJ = rJ, 3, rTblAddr // address in the 2^(j/64) table
+      nop.f           0
+      and             rN = rN_mask, rN     // biased, shifted n-1
+}
+{ .mfi
+      addl            rN_neg = 0xFFBF - 63, rNJ_neg // -x biased, shifted n-1,j
+      nop.f           0
+      and             rJ_neg = rJ_mask, rNJ_neg     // bits of j for -x
+}
+;;
+
+{ .mfi
+      ld8             rJ = [rJ]                    // Table value
+      nop.f           0
+      shl             rN = rN, 46 // 2^(n-1) bits in DP format
+}
+{ .mfi
+      shladd          rJ_neg = rJ_neg, 3, rTblAddr // addr in 2^(j/64) table -x
+      nop.f           0
+      and             rN_neg = rN_mask, rN_neg     // biased, shifted n-1 for -x
+}
+;;
+
+{ .mfi
+      ld8             rJ_neg = [rJ_neg]            // Table value for -x
+      nop.f           0
+      shl             rN_neg = rN_neg, 46 // 2^(n-1) bits in DP format for -x
+}
+;;
+
+{ .mfi
+      or              rN = rN, rJ // bits of 2^n * 2^(j/64) in DP format
+      nop.f           0
+      nop.i           0
+}
+;;
+
+{ .mmf
+      setf.d          fT = rN            // 2^(n-1) * 2^(j/64)
+      or              rN_neg = rN_neg, rJ_neg // -x bits of 2^n * 2^(j/64) in DP
+      fma.s1          fRSqr = fR, fR, f0 // R^2
+}
+;;
+
+{ .mfi
+      setf.d          fT_neg = rN_neg    // 2^(n-1) * 2^(j/64) for -x
+      fma.s1          fP = fA3, fR, fA2  // A3*R + A2
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fnma.s1         fP_neg = fA3, fR, fA2  // A3*R + A2 for -x
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fP = fP, fRSqr, fR // P = (A3*R + A2)*R^2 + R
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fms.s1          fP_neg = fP_neg, fRSqr, fR // P = (A3*R + A2)*R^2 + R, -x
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fmpy.s0         fTmp = fLn2Div64, fLn2Div64       // Force inexact
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fExp = fP, fT, fT                 // exp(x)/2
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+      fma.s1          fExp_neg = fP_neg, fT_neg, fT_neg // exp(-x)/2
+      // branch out if possible overflow result
+(p13) br.cond.spnt    SINH_POSSIBLE_OVERFLOW
+}
+;;
+
+{ .mfb
+      nop.m           0
+      // final result in the absence of overflow
+      fms.s.s0        f8 = fExp, f1, fExp_neg  // result = (exp(x)-exp(-x))/2
+      // exit here in the absence of overflow
+      br.ret.sptk     b0              // Exit main path, 0.25 <= |x| < 89.41598
+}
+;;
+
+// Here if 0 < |x| < 0.25.  Evaluate 9th order polynomial.
+SINH_SMALL:
+{ .mfi
+      add             rAd1 = 0x200, rTblAddr
+      fcmp.lt.s1      p7, p8 = fNormX, f0       // Test sign of x
+      cmp.gt          p6, p0 = -60, rExp_x      // Test |x| < 2^(-60)
+}
+{ .mfi
+      add             rAd2 = 0x210, rTblAddr
+      nop.f           0
+      nop.i           0
+}
+;;
+
+{ .mmb
+      ldfpd           fA4, fA3 = [rAd1]
+      ldfpd           fA2, fA1 = [rAd2]
+(p6)  br.cond.spnt    SINH_VERY_SMALL           // Branch if |x| < 2^(-60)
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fX3 = fXsq, fNormX, f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fX4 = fXsq, fXsq, f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA43 = fXsq, fA4, fA3
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          fA21 = fXsq, fA2, fA1
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          fA4321 = fX4, fA43, fA21
+      nop.i           0
+}
+;;
+
+// Dummy multiply to generate inexact
+{ .mfi
+      nop.m           0
+      fmpy.s0         fTmp = fA4, fA4
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+      fma.s.s0        f8 = fA4321, fX3, fNormX
+      br.ret.sptk     b0                // Exit if 2^-60 < |x| < 0.25
+}
+;;
+
+SINH_VERY_SMALL:
+// Here if 0 < |x| < 2^-60
+// Compute result by x + sgn(x)*x^2 to get properly rounded result
+.pred.rel "mutex",p7,p8
+{ .mfi
+      nop.m           0
+(p7)  fnma.s.s0       f8 = fNormX, fNormX, fNormX // If x<0 result ~ x-x^2
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+(p8)  fma.s.s0        f8 = fNormX, fNormX, fNormX // If x>0 result ~ x+x^2
+      br.ret.sptk     b0                          // Exit if |x| < 2^-60
+}
+;;
+
+SINH_POSSIBLE_OVERFLOW:
+
+// Here if fMAX_SGL_NORM_ARG < x < fMIN_SGL_OFLOW_ARG
+// This cannot happen if input is a single, only if input higher precision.
+// Overflow is a possibility, not a certainty.
+
+// Recompute result using status field 2 with user's rounding mode,
+// and wre set.  If result is larger than largest single, then we have
+// overflow
+
+{ .mfi
+      mov             rGt_ln  = 0x1007f // Exponent for largest single + 1 ulp
+      fsetc.s2        0x7F,0x42         // Get user's round mode, set wre
+      nop.i           0
+}
+;;
+
+{ .mfi
+      setf.exp        fGt_pln = rGt_ln  // Create largest single + 1 ulp
+      fma.s.s2        fWre_urm_f8 = fP, fT, fT    // Result with wre set
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fsetc.s2        0x7F,0x40                   // Turn off wre in sf2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.ge.s1      p6, p0 =  fWre_urm_f8, fGt_pln // Test for overflow
+      nop.i           0
+}
+;;
+
+{ .mfb
+      nop.m           0
+      nop.f           0
+(p6)  br.cond.spnt    SINH_CERTAIN_OVERFLOW // Branch if overflow
+}
+;;
+
+{ .mfb
+      nop.m           0
+      fma.s.s0        f8 = fP, fT, fT
+      br.ret.sptk     b0                     // Exit if really no overflow
+}
+;;
+
+// here if overflow
+SINH_CERTAIN_OVERFLOW:
+{ .mfi
+      addl            r17ones_m1 = 0x1FFFE, r0
+      fcmp.lt.s1      p6, p7 = fNormX, f0     // Test for x < 0
+      nop.i           0
+}
+;;
+
+{ .mmf
+      alloc           r32 = ar.pfs, 0, 3, 4, 0 // get some registers
+      setf.exp        fTmp = r17ones_m1
+      fmerge.s        FR_X = f8,f8
+}
+;;
+
+{ .mfi
+      mov             GR_Parameter_TAG = 128
+(p6)  fnma.s.s0       FR_RESULT = fTmp, fTmp, f0 // Set I,O and -INF result
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+(p7)  fma.s.s0        FR_RESULT = fTmp, fTmp, f0 // Set I,O and +INF result
+      br.cond.sptk    __libm_error_region
+}
+;;
+
+// Here if x unorm
+SINH_UNORM:
+{ .mfb
+      getf.exp        rSignexp_x = fNormX    // Must recompute if x unorm
+      fcmp.eq.s0      p6, p0 = f8, f0        // Set D flag
+      br.cond.sptk    SINH_COMMON            // Return to main path
+}
+;;
+
+GLOBAL_IEEE754_END(sinhf)
+libm_alias_float_other (__sinh, sinh)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+      add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+      nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+      mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+      add sp=-64,sp                           // Create new stack
+      nop.f 0
+      mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+      stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
+      add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+      mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mfi
+      stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+      nop.f 0
+      add   GR_Parameter_RESULT = 0,GR_Parameter_Y // Parameter 3 address
+}
+{ .mib
+      stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
+      add   GR_Parameter_Y = -16,GR_Parameter_Y
+      br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+
+{ .mmi
+      add   GR_Parameter_RESULT = 48,sp
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mmi
+      ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+      add   sp = 64,sp                       // Restore stack pointer
+      mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+      mov   gp = GR_SAVE_GP                  // Restore gp
+      mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+      br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_sinhl.S
@@ -0,0 +1,1117 @@
+.file "sinhl.s"
+
+
+// Copyright (c) 2000 - 2002, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 10/12/00 Update to set denormal operand and underflow flags
+// 01/22/01 Fixed to set inexact flag for small args.  Fixed incorrect
+//          call to __libm_error_support for 710.476 < x < 11357.2166.
+// 05/02/01 Reworked to improve speed of all paths
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 12/04/02 Improved performance
+//
+// API
+//==============================================================
+// long double = sinhl(long double)
+// input  floating point f8
+// output floating point f8
+//
+// Registers used
+//==============================================================
+// general registers:
+// r14 -> r40
+// predicate registers used:
+// p6 -> p11
+// floating-point registers used:
+// f9 -> f15; f32 -> f90;
+// f8 has input, then output
+//
+// Overview of operation
+//==============================================================
+// There are seven paths
+// 1. 0 < |x| < 0.25          SINH_BY_POLY
+// 2. 0.25 <=|x| < 32         SINH_BY_TBL
+// 3. 32 <= |x| < 11357.21655 SINH_BY_EXP (merged path with SINH_BY_TBL)
+// 4. |x| >= 11357.21655      SINH_HUGE
+// 5. x=0                     Done with early exit
+// 6. x=inf,nan               Done with early exit
+// 7. x=denormal              SINH_DENORM
+//
+// For double extended we get overflow for x >= 400c b174 ddc0 31ae c0ea
+//                                           >= 11357.21655
+//
+//
+// 1. SINH_BY_POLY   0 < |x| < 0.25
+// ===============
+// Evaluate sinh(x) by a 13th order polynomial
+// Care is take for the order of multiplication; and P_1 is not exactly 1/3!,
+// P_2 is not exactly 1/5!, etc.
+// sinh(x) = sign * (series(e^x) - series(e^-x))/2
+//         = sign * (ax + ax^3/3! + ax^5/5! + ax^7/7! + ax^9/9! + ax^11/11!
+//                        + ax^13/13!)
+//         = sign * (ax   + ax * ( ax^2 * (1/3! + ax^4 * (1/7! + ax^4*1/11!)) )
+//                        + ax * ( ax^4 * (1/5! + ax^4 * (1/9! + ax^4*1/13!)) ))
+//         = sign * (ax   + ax*p_odd + (ax*p_even))
+//         = sign * (ax   + Y_lo)
+// sinh(x) = sign * (Y_hi + Y_lo)
+// Note that ax = |x|
+//
+// 2. SINH_BY_TBL   0.25 <= |x| < 32.0
+// =============
+// sinh(x) = sinh(B+R)
+//         = sinh(B)cosh(R) + cosh(B)sinh(R)
+//
+// ax = |x| = M*log2/64 + R
+// B = M*log2/64
+// M = 64*N + j
+//   We will calculate M and get N as (M-j)/64
+//   The division is a shift.
+// exp(B)  = exp(N*log2 + j*log2/64)
+//         = 2^N * 2^(j*log2/64)
+// sinh(B) = 1/2(e^B -e^-B)
+//         = 1/2(2^N * 2^(j*log2/64) - 2^-N * 2^(-j*log2/64))
+// sinh(B) = (2^(N-1) * 2^(j*log2/64) - 2^(-N-1) * 2^(-j*log2/64))
+// cosh(B) = (2^(N-1) * 2^(j*log2/64) + 2^(-N-1) * 2^(-j*log2/64))
+// 2^(j*log2/64) is stored as Tjhi + Tjlo , j= -32,....,32
+// Tjhi is double-extended (80-bit) and Tjlo is single(32-bit)
+//
+// R = ax - M*log2/64
+// R = ax - M*log2_by_64_hi - M*log2_by_64_lo
+// exp(R) = 1 + R +R^2(1/2! + R(1/3! + R(1/4! + ... + R(1/n!)...)
+//        = 1 + p_odd + p_even
+//        where the p_even uses the A coefficients and the p_even uses
+//        the B coefficients
+//
+// So sinh(R) = 1 + p_odd + p_even -(1 -p_odd -p_even)/2 = p_odd
+//    cosh(R) = 1 + p_even
+//    sinh(B) = S_hi + S_lo
+//    cosh(B) = C_hi
+// sinh(x) = sinh(B)cosh(R) + cosh(B)sinh(R)
+//
+// 3. SINH_BY_EXP   32.0 <= |x| < 11357.21655  ( 400c b174 ddc0 31ae c0ea )
+// ==============
+// Can approximate result by exp(x)/2 in this region.
+// Y_hi = Tjhi
+// Y_lo = Tjhi * (p_odd + p_even) + Tjlo
+// sinh(x) = Y_hi + Y_lo
+//
+// 4. SINH_HUGE     |x| >= 11357.21655  ( 400c b174 ddc0 31ae c0ea )
+// ============
+// Set error tag and call error support
+//
+//
+// Assembly macros
+//==============================================================
+r_ad5                 = r14
+r_rshf_2to57          = r15
+r_exp_denorm          = r15
+r_ad_mJ_lo            = r15
+r_ad_J_lo             = r16
+r_2Nm1                = r17
+r_2mNm1               = r18
+r_exp_x               = r18
+r_ad_J_hi             = r19
+r_ad2o                = r19
+r_ad_mJ_hi            = r20
+r_mj                  = r21
+r_ad2e                = r22
+r_ad3                 = r23
+r_ad1                 = r24
+r_Mmj                 = r24
+r_rshf                = r25
+r_M                   = r25
+r_N                   = r25
+r_jshf                = r26
+r_exp_2tom57          = r26
+r_j                   = r26
+r_exp_mask            = r27
+r_signexp_x           = r28
+r_signexp_sgnx_0_5    = r28
+r_exp_0_25            = r29
+r_sig_inv_ln2         = r30
+r_exp_32              = r30
+r_exp_huge            = r30
+r_ad4                 = r31
+
+GR_SAVE_PFS           = r34
+GR_SAVE_B0            = r35
+GR_SAVE_GP            = r36
+
+GR_Parameter_X        = r37
+GR_Parameter_Y        = r38
+GR_Parameter_RESULT   = r39
+GR_Parameter_TAG      = r40
+
+
+f_ABS_X               = f9
+f_X2                  = f10
+f_X4                  = f11
+f_tmp                 = f14
+f_RSHF                = f15
+
+f_Inv_log2by64        = f32
+f_log2by64_lo         = f33
+f_log2by64_hi         = f34
+f_A1                  = f35
+
+f_A2                  = f36
+f_A3                  = f37
+f_Rcub                = f38
+f_M_temp              = f39
+f_R_temp              = f40
+
+f_Rsq                 = f41
+f_R                   = f42
+f_M                   = f43
+f_B1                  = f44
+f_B2                  = f45
+
+f_B3                  = f46
+f_peven_temp1         = f47
+f_peven_temp2         = f48
+f_peven               = f49
+f_podd_temp1          = f50
+
+f_podd_temp2          = f51
+f_podd                = f52
+f_poly65              = f53
+f_poly6543            = f53
+f_poly6to1            = f53
+f_poly43              = f54
+f_poly21              = f55
+
+f_X3                  = f56
+f_INV_LN2_2TO63       = f57
+f_RSHF_2TO57          = f58
+f_2TOM57              = f59
+f_smlst_oflow_input   = f60
+
+f_pre_result          = f61
+f_huge                = f62
+f_spos                = f63
+f_sneg                = f64
+f_Tjhi                = f65
+
+f_Tjlo                = f66
+f_Tmjhi               = f67
+f_Tmjlo               = f68
+f_S_hi                = f69
+f_SC_hi_temp          = f70
+
+f_S_lo_temp1          = f71
+f_S_lo_temp2          = f72
+f_S_lo_temp3          = f73
+f_S_lo_temp4          = f73
+f_S_lo                = f74
+f_C_hi                = f75
+
+f_Y_hi                = f77
+f_Y_lo_temp           = f78
+f_Y_lo                = f79
+f_NORM_X              = f80
+
+f_P1                  = f81
+f_P2                  = f82
+f_P3                  = f83
+f_P4                  = f84
+f_P5                  = f85
+
+f_P6                  = f86
+f_Tjhi_spos           = f87
+f_Tjlo_spos           = f88
+f_huge                = f89
+f_signed_hi_lo        = f90
+
+
+// Data tables
+//==============================================================
+
+// DO NOT CHANGE ORDER OF THESE TABLES
+RODATA
+
+.align 16
+LOCAL_OBJECT_START(sinh_arg_reduction)
+//   data8 0xB8AA3B295C17F0BC, 0x00004005  // 64/log2 -- signif loaded with setf
+   data8 0xB17217F7D1000000, 0x00003FF8  // log2/64 high part
+   data8 0xCF79ABC9E3B39804, 0x00003FD0  // log2/64 low part
+   data8 0xb174ddc031aec0ea, 0x0000400c  // Smallest x to overflow (11357.21655)
+LOCAL_OBJECT_END(sinh_arg_reduction)
+
+LOCAL_OBJECT_START(sinh_p_table)
+   data8 0xB08AF9AE78C1239F, 0x00003FDE  // P6
+   data8 0xB8EF1D28926D8891, 0x00003FEC  // P4
+   data8 0x8888888888888412, 0x00003FF8  // P2
+   data8 0xD732377688025BE9, 0x00003FE5  // P5
+   data8 0xD00D00D00D4D39F2, 0x00003FF2  // P3
+   data8 0xAAAAAAAAAAAAAAAB, 0x00003FFC  // P1
+LOCAL_OBJECT_END(sinh_p_table)
+
+LOCAL_OBJECT_START(sinh_ab_table)
+   data8 0xAAAAAAAAAAAAAAAC, 0x00003FFC  // A1
+   data8 0x88888888884ECDD5, 0x00003FF8  // A2
+   data8 0xD00D0C6DCC26A86B, 0x00003FF2  // A3
+   data8 0x8000000000000002, 0x00003FFE  // B1
+   data8 0xAAAAAAAAAA402C77, 0x00003FFA  // B2
+   data8 0xB60B6CC96BDB144D, 0x00003FF5  // B3
+LOCAL_OBJECT_END(sinh_ab_table)
+
+LOCAL_OBJECT_START(sinh_j_hi_table)
+   data8 0xB504F333F9DE6484, 0x00003FFE
+   data8 0xB6FD91E328D17791, 0x00003FFE
+   data8 0xB8FBAF4762FB9EE9, 0x00003FFE
+   data8 0xBAFF5AB2133E45FB, 0x00003FFE
+   data8 0xBD08A39F580C36BF, 0x00003FFE
+   data8 0xBF1799B67A731083, 0x00003FFE
+   data8 0xC12C4CCA66709456, 0x00003FFE
+   data8 0xC346CCDA24976407, 0x00003FFE
+   data8 0xC5672A115506DADD, 0x00003FFE
+   data8 0xC78D74C8ABB9B15D, 0x00003FFE
+   data8 0xC9B9BD866E2F27A3, 0x00003FFE
+   data8 0xCBEC14FEF2727C5D, 0x00003FFE
+   data8 0xCE248C151F8480E4, 0x00003FFE
+   data8 0xD06333DAEF2B2595, 0x00003FFE
+   data8 0xD2A81D91F12AE45A, 0x00003FFE
+   data8 0xD4F35AABCFEDFA1F, 0x00003FFE
+   data8 0xD744FCCAD69D6AF4, 0x00003FFE
+   data8 0xD99D15C278AFD7B6, 0x00003FFE
+   data8 0xDBFBB797DAF23755, 0x00003FFE
+   data8 0xDE60F4825E0E9124, 0x00003FFE
+   data8 0xE0CCDEEC2A94E111, 0x00003FFE
+   data8 0xE33F8972BE8A5A51, 0x00003FFE
+   data8 0xE5B906E77C8348A8, 0x00003FFE
+   data8 0xE8396A503C4BDC68, 0x00003FFE
+   data8 0xEAC0C6E7DD24392F, 0x00003FFE
+   data8 0xED4F301ED9942B84, 0x00003FFE
+   data8 0xEFE4B99BDCDAF5CB, 0x00003FFE
+   data8 0xF281773C59FFB13A, 0x00003FFE
+   data8 0xF5257D152486CC2C, 0x00003FFE
+   data8 0xF7D0DF730AD13BB9, 0x00003FFE
+   data8 0xFA83B2DB722A033A, 0x00003FFE
+   data8 0xFD3E0C0CF486C175, 0x00003FFE
+   data8 0x8000000000000000, 0x00003FFF // Center of table
+   data8 0x8164D1F3BC030773, 0x00003FFF
+   data8 0x82CD8698AC2BA1D7, 0x00003FFF
+   data8 0x843A28C3ACDE4046, 0x00003FFF
+   data8 0x85AAC367CC487B15, 0x00003FFF
+   data8 0x871F61969E8D1010, 0x00003FFF
+   data8 0x88980E8092DA8527, 0x00003FFF
+   data8 0x8A14D575496EFD9A, 0x00003FFF
+   data8 0x8B95C1E3EA8BD6E7, 0x00003FFF
+   data8 0x8D1ADF5B7E5BA9E6, 0x00003FFF
+   data8 0x8EA4398B45CD53C0, 0x00003FFF
+   data8 0x9031DC431466B1DC, 0x00003FFF
+   data8 0x91C3D373AB11C336, 0x00003FFF
+   data8 0x935A2B2F13E6E92C, 0x00003FFF
+   data8 0x94F4EFA8FEF70961, 0x00003FFF
+   data8 0x96942D3720185A00, 0x00003FFF
+   data8 0x9837F0518DB8A96F, 0x00003FFF
+   data8 0x99E0459320B7FA65, 0x00003FFF
+   data8 0x9B8D39B9D54E5539, 0x00003FFF
+   data8 0x9D3ED9A72CFFB751, 0x00003FFF
+   data8 0x9EF5326091A111AE, 0x00003FFF
+   data8 0xA0B0510FB9714FC2, 0x00003FFF
+   data8 0xA27043030C496819, 0x00003FFF
+   data8 0xA43515AE09E6809E, 0x00003FFF
+   data8 0xA5FED6A9B15138EA, 0x00003FFF
+   data8 0xA7CD93B4E965356A, 0x00003FFF
+   data8 0xA9A15AB4EA7C0EF8, 0x00003FFF
+   data8 0xAB7A39B5A93ED337, 0x00003FFF
+   data8 0xAD583EEA42A14AC6, 0x00003FFF
+   data8 0xAF3B78AD690A4375, 0x00003FFF
+   data8 0xB123F581D2AC2590, 0x00003FFF
+   data8 0xB311C412A9112489, 0x00003FFF
+   data8 0xB504F333F9DE6484, 0x00003FFF
+LOCAL_OBJECT_END(sinh_j_hi_table)
+
+LOCAL_OBJECT_START(sinh_j_lo_table)
+   data4 0x1EB2FB13
+   data4 0x1CE2CBE2
+   data4 0x1DDC3CBC
+   data4 0x1EE9AA34
+   data4 0x9EAEFDC1
+   data4 0x9DBF517B
+   data4 0x1EF88AFB
+   data4 0x1E03B216
+   data4 0x1E78AB43
+   data4 0x9E7B1747
+   data4 0x9EFE3C0E
+   data4 0x9D36F837
+   data4 0x9DEE53E4
+   data4 0x9E24AE8E
+   data4 0x1D912473
+   data4 0x1EB243BE
+   data4 0x1E669A2F
+   data4 0x9BBC610A
+   data4 0x1E761035
+   data4 0x9E0BE175
+   data4 0x1CCB12A1
+   data4 0x1D1BFE90
+   data4 0x1DF2F47A
+   data4 0x1EF22F22
+   data4 0x9E3F4A29
+   data4 0x1EC01A5B
+   data4 0x1E8CAC3A
+   data4 0x9DBB3FAB
+   data4 0x1EF73A19
+   data4 0x9BB795B5
+   data4 0x1EF84B76
+   data4 0x9EF5818B
+   data4 0x00000000 // Center of table
+   data4 0x1F77CACA
+   data4 0x1EF8A91D
+   data4 0x1E57C976
+   data4 0x9EE8DA92
+   data4 0x1EE85C9F
+   data4 0x1F3BF1AF
+   data4 0x1D80CA1E
+   data4 0x9D0373AF
+   data4 0x9F167097
+   data4 0x1EB70051
+   data4 0x1F6EB029
+   data4 0x1DFD6D8E
+   data4 0x9EB319B0
+   data4 0x1EBA2BEB
+   data4 0x1F11D537
+   data4 0x1F0D5A46
+   data4 0x9E5E7BCA
+   data4 0x9F3AAFD1
+   data4 0x9E86DACC
+   data4 0x9F3EDDC2
+   data4 0x1E496E3D
+   data4 0x9F490BF6
+   data4 0x1DD1DB48
+   data4 0x1E65EBFB
+   data4 0x9F427496
+   data4 0x1F283C4A
+   data4 0x1F4B0047
+   data4 0x1F130152
+   data4 0x9E8367C0
+   data4 0x9F705F90
+   data4 0x1EFB3C53
+   data4 0x1F32FB13
+LOCAL_OBJECT_END(sinh_j_lo_table)
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(sinhl)
+
+{ .mlx
+      getf.exp        r_signexp_x = f8   // Get signexp of x, must redo if unorm
+      movl            r_sig_inv_ln2 = 0xb8aa3b295c17f0bc // significand of 1/ln2
+}
+{ .mlx
+      addl            r_ad1 = @ltoff(sinh_arg_reduction), gp
+      movl            r_rshf_2to57 = 0x4778000000000000 // 1.10000 2^(63+57)
+}
+;;
+
+{ .mfi
+      ld8             r_ad1 = [r_ad1]
+      fmerge.s        f_ABS_X    = f0,f8
+      mov             r_exp_0_25 = 0x0fffd    // Form exponent for 0.25
+}
+{ .mfi
+      nop.m           0
+      fnorm.s1        f_NORM_X = f8
+      mov             r_exp_2tom57 = 0xffff-57
+}
+;;
+
+{ .mfi
+      setf.d          f_RSHF_2TO57 = r_rshf_2to57 // Form const 1.100 * 2^120
+      fclass.m        p10,p0 = f8, 0x0b           // Test for denorm
+      mov             r_exp_mask = 0x1ffff
+}
+{ .mlx
+      setf.sig        f_INV_LN2_2TO63 = r_sig_inv_ln2 // Form 1/ln2 * 2^63
+      movl            r_rshf = 0x43e8000000000000 // 1.1000 2^63 for right shift
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fclass.m        p7,p0 = f8, 0x07  // Test if x=0
+      nop.i           0
+}
+{ .mfi
+      setf.exp        f_2TOM57 = r_exp_2tom57 // Form 2^-57 for scaling
+      nop.f           0
+      add             r_ad3 = 0x90, r_ad1  // Point to ab_table
+}
+;;
+
+{ .mfi
+      setf.d          f_RSHF = r_rshf     // Form right shift const 1.100 * 2^63
+      fclass.m        p6,p0 = f8, 0xe3     // Test if x nan, inf
+      add             r_ad4 = 0x2f0, r_ad1 // Point to j_hi_table midpoint
+}
+{ .mib
+      add             r_ad2e = 0x20, r_ad1 // Point to p_table
+      nop.i           0
+(p10) br.cond.spnt    SINH_DENORM          // Branch if x denorm
+}
+;;
+
+// Common path -- return here from SINH_DENORM if x is unnorm
+SINH_COMMON:
+{ .mfi
+      ldfe            f_smlst_oflow_input = [r_ad2e],16
+      nop.f           0
+      add             r_ad5 = 0x580, r_ad1 // Point to j_lo_table midpoint
+}
+{ .mib
+      ldfe            f_log2by64_hi  = [r_ad1],16
+      and             r_exp_x = r_exp_mask, r_signexp_x
+(p7)  br.ret.spnt     b0                  // Exit if x=0
+}
+;;
+
+// Get the A coefficients for SINH_BY_TBL
+{ .mfi
+      ldfe            f_A1 = [r_ad3],16
+      fcmp.lt.s1      p8,p9 = f8,f0           // Test for x<0
+      cmp.lt          p7,p0 = r_exp_x, r_exp_0_25  // Test x < 0.25
+}
+{ .mfb
+      add             r_ad2o = 0x30, r_ad2e  // Point to p_table odd coeffs
+(p6)  fma.s0          f8 = f8,f1,f0          // Result for x nan, inf
+(p6)  br.ret.spnt     b0                     // Exit for x nan, inf
+}
+;;
+
+// Calculate X2 = ax*ax for SINH_BY_POLY
+{ .mfi
+      ldfe            f_log2by64_lo  = [r_ad1],16
+      nop.f           0
+      nop.i           0
+}
+{ .mfb
+      ldfe            f_A2 = [r_ad3],16
+      fma.s1          f_X2 = f_NORM_X, f_NORM_X, f0
+(p7)  br.cond.spnt    SINH_BY_POLY
+}
+;;
+
+// Here if |x| >= 0.25
+SINH_BY_TBL:
+// ******************************************************
+// STEP 1 (TBL and EXP) - Argument reduction
+// ******************************************************
+// Get the following constants.
+// Inv_log2by64
+// log2by64_hi
+// log2by64_lo
+
+
+// We want 2^(N-1) and 2^(-N-1). So bias N-1 and -N-1 and
+// put them in an exponent.
+// f_spos = 2^(N-1) and f_sneg = 2^(-N-1)
+// 0xffff + (N-1)  = 0xffff +N -1
+// 0xffff - (N +1) = 0xffff -N -1
+
+
+// Calculate M and keep it as integer and floating point.
+// M = round-to-integer(x*Inv_log2by64)
+// f_M = M = truncate(ax/(log2/64))
+// Put the integer representation of M in r_M
+//    and the floating point representation of M in f_M
+
+// Get the remaining A,B coefficients
+{ .mmi
+      ldfe            f_A3 = [r_ad3],16
+      nop.m           0
+      nop.i           0
+}
+;;
+
+.pred.rel "mutex",p8,p9
+// Use constant (1.100*2^(63-6)) to get rounded M into rightmost significand
+// |x| * 64 * 1/ln2 * 2^(63-6) + 1.1000 * 2^(63+(63-6))
+{ .mfi
+(p8)  mov             r_signexp_sgnx_0_5 = 0x2fffe // signexp of -0.5
+      fma.s1          f_M_temp = f_ABS_X, f_INV_LN2_2TO63, f_RSHF_2TO57
+(p9)  mov             r_signexp_sgnx_0_5 = 0x0fffe // signexp of +0.5
+}
+;;
+
+// Test for |x| >= overflow limit
+{ .mfi
+      ldfe            f_B1 = [r_ad3],16
+      fcmp.ge.s1      p6,p0 = f_ABS_X, f_smlst_oflow_input
+      nop.i           0
+}
+;;
+
+{ .mfi
+      ldfe            f_B2 = [r_ad3],16
+      nop.f           0
+      mov             r_exp_32 = 0x10004
+}
+;;
+
+// Subtract RSHF constant to get rounded M as a floating point value
+// M_temp * 2^(63-6) - 2^63
+{ .mfb
+      ldfe            f_B3 = [r_ad3],16
+      fms.s1          f_M = f_M_temp, f_2TOM57, f_RSHF
+(p6)  br.cond.spnt    SINH_HUGE  // Branch if result will overflow
+}
+;;
+
+{ .mfi
+      getf.sig        r_M = f_M_temp
+      nop.f           0
+      cmp.ge          p7,p6 = r_exp_x, r_exp_32 // Test if x >= 32
+}
+;;
+
+// Calculate j. j is the signed extension of the six lsb of M. It
+// has a range of -32 thru 31.
+
+// Calculate R
+// ax - M*log2by64_hi
+// R = (ax - M*log2by64_hi) - M*log2by64_lo
+
+{ .mfi
+      nop.m           0
+      fnma.s1         f_R_temp = f_M, f_log2by64_hi, f_ABS_X
+      and             r_j = 0x3f, r_M
+}
+;;
+
+{ .mii
+      nop.m           0
+      shl             r_jshf = r_j, 0x2 // Shift j so can sign extend it
+;;
+      sxt1            r_jshf = r_jshf
+}
+;;
+
+{ .mii
+      nop.m           0
+      shr             r_j = r_jshf, 0x2    // Now j has range -32 to 31
+      nop.i           0
+}
+;;
+
+{ .mmi
+      shladd          r_ad_J_hi = r_j, 4, r_ad4 // pointer to Tjhi
+      sub             r_Mmj = r_M, r_j          // M-j
+      sub             r_mj = r0, r_j            // Form -j
+}
+;;
+
+// The TBL and EXP branches are merged and predicated
+// If TBL, p6 true, 0.25 <= |x| < 32
+// If EXP, p7 true, 32 <= |x| < overflow_limit
+//
+// N = (M-j)/64
+{ .mfi
+      ldfe            f_Tjhi = [r_ad_J_hi]
+      fnma.s1         f_R = f_M, f_log2by64_lo, f_R_temp
+      shr             r_N = r_Mmj, 0x6            // N = (M-j)/64
+}
+{ .mfi
+      shladd          r_ad_mJ_hi = r_mj, 4, r_ad4 // pointer to Tmjhi
+      nop.f           0
+      shladd          r_ad_mJ_lo = r_mj, 2, r_ad5 // pointer to Tmjlo
+}
+;;
+
+{ .mfi
+      sub             r_2mNm1 = r_signexp_sgnx_0_5, r_N // signexp sgnx*2^(-N-1)
+      nop.f           0
+      shladd          r_ad_J_lo = r_j, 2, r_ad5   // pointer to Tjlo
+}
+{ .mfi
+      ldfe            f_Tmjhi = [r_ad_mJ_hi]
+      nop.f           0
+      add             r_2Nm1 = r_signexp_sgnx_0_5, r_N // signexp sgnx*2^(N-1)
+}
+;;
+
+{ .mmf
+      ldfs            f_Tmjlo = [r_ad_mJ_lo]
+      setf.exp        f_sneg = r_2mNm1            // Form sgnx * 2^(-N-1)
+      nop.f           0
+}
+;;
+
+{ .mmf
+      ldfs            f_Tjlo  = [r_ad_J_lo]
+      setf.exp        f_spos = r_2Nm1             // Form sgnx * 2^(N-1)
+      nop.f           0
+}
+;;
+
+// ******************************************************
+// STEP 2 (TBL and EXP)
+// ******************************************************
+// Calculate Rsquared and Rcubed in preparation for p_even and p_odd
+
+{ .mmf
+      nop.m           0
+      nop.m           0
+      fma.s1          f_Rsq  = f_R, f_R, f0
+}
+;;
+
+
+// Calculate p_even
+// B_2 + Rsq *B_3
+// B_1 + Rsq * (B_2 + Rsq *B_3)
+// p_even = Rsq * (B_1 + Rsq * (B_2 + Rsq *B_3))
+{ .mfi
+      nop.m           0
+      fma.s1          f_peven_temp1 = f_Rsq, f_B3, f_B2
+      nop.i           0
+}
+// Calculate p_odd
+// A_2 + Rsq *A_3
+// A_1 + Rsq * (A_2 + Rsq *A_3)
+// podd = R + Rcub * (A_1 + Rsq * (A_2 + Rsq *A_3))
+{ .mfi
+      nop.m           0
+      fma.s1          f_podd_temp1 = f_Rsq, f_A3, f_A2
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_Rcub = f_Rsq, f_R, f0
+      nop.i           0
+}
+;;
+
+//
+// If TBL,
+// Calculate S_hi and S_lo, and C_hi
+// SC_hi_temp = sneg * Tmjhi
+// S_hi = spos * Tjhi - SC_hi_temp
+// S_hi = spos * Tjhi - (sneg * Tmjhi)
+// C_hi = spos * Tjhi + SC_hi_temp
+// C_hi = spos * Tjhi + (sneg * Tmjhi)
+
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_SC_hi_temp = f_sneg, f_Tmjhi, f0
+      nop.i           0
+}
+;;
+
+// If TBL,
+// S_lo_temp3 = sneg * Tmjlo
+// S_lo_temp4 = spos * Tjlo - S_lo_temp3
+// S_lo_temp4 = spos * Tjlo -(sneg * Tmjlo)
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_S_lo_temp3 =  f_sneg, f_Tmjlo, f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_peven_temp2 = f_Rsq, f_peven_temp1, f_B1
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          f_podd_temp2 = f_Rsq, f_podd_temp1, f_A1
+      nop.i           0
+}
+;;
+
+// If EXP,
+// Compute sgnx * 2^(N-1) * Tjhi and sgnx * 2^(N-1) * Tjlo
+{ .mfi
+      nop.m           0
+(p7)  fma.s1          f_Tjhi_spos = f_Tjhi, f_spos, f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+(p7)  fma.s1          f_Tjlo_spos = f_Tjlo, f_spos, f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+(p6)  fms.s1          f_S_hi = f_spos, f_Tjhi, f_SC_hi_temp
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_C_hi = f_spos, f_Tjhi, f_SC_hi_temp
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+(p6)  fms.s1          f_S_lo_temp4 = f_spos, f_Tjlo, f_S_lo_temp3
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_peven = f_Rsq, f_peven_temp2, f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          f_podd = f_podd_temp2, f_Rcub, f_R
+      nop.i           0
+}
+;;
+
+// If TBL,
+// S_lo_temp1 =  spos * Tjhi - S_hi
+// S_lo_temp2 = -sneg * Tmjlo + S_lo_temp1
+// S_lo_temp2 = -sneg * Tmjlo + (spos * Tjhi - S_hi)
+
+{ .mfi
+      nop.m           0
+(p6)  fms.s1          f_S_lo_temp1 =  f_spos, f_Tjhi,  f_S_hi
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+(p6)  fnma.s1         f_S_lo_temp2 = f_sneg, f_Tmjhi, f_S_lo_temp1
+      nop.i           0
+}
+;;
+
+// If EXP,
+// Y_hi = sgnx * 2^(N-1) * Tjhi
+// Y_lo = sgnx * 2^(N-1) * Tjhi * (p_odd + p_even) + sgnx * 2^(N-1) * Tjlo
+{ .mfi
+      nop.m           0
+(p7)  fma.s1          f_Y_lo_temp =  f_peven, f1, f_podd
+      nop.i           0
+}
+;;
+
+// If TBL,
+// S_lo = S_lo_temp4 + S_lo_temp2
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_S_lo = f_S_lo_temp4, f1, f_S_lo_temp2
+      nop.i           0
+}
+;;
+
+// If TBL,
+// Y_hi = S_hi
+// Y_lo = C_hi*p_odd + (S_hi*p_even + S_lo)
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_Y_lo_temp = f_S_hi, f_peven, f_S_lo
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+(p7)  fma.s1          f_Y_lo = f_Tjhi_spos, f_Y_lo_temp, f_Tjlo_spos
+      nop.i           0
+}
+;;
+
+// Dummy multiply to generate inexact
+{ .mfi
+      nop.m           0
+      fmpy.s0         f_tmp = f_B2, f_B2
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+(p6)  fma.s1          f_Y_lo = f_C_hi, f_podd, f_Y_lo_temp
+      nop.i           0
+}
+;;
+
+// f8 = answer = Y_hi + Y_lo
+{ .mfi
+      nop.m           0
+(p7)  fma.s0          f8 = f_Y_lo,  f1, f_Tjhi_spos
+      nop.i           0
+}
+;;
+
+// f8 = answer = Y_hi + Y_lo
+{ .mfb
+      nop.m           0
+(p6)  fma.s0          f8 = f_Y_lo, f1, f_S_hi
+      br.ret.sptk     b0      // Exit for SINH_BY_TBL and SINH_BY_EXP
+}
+;;
+
+
+// Here if 0 < |x| < 0.25
+SINH_BY_POLY:
+{ .mmf
+      ldfe            f_P6 = [r_ad2e],16
+      ldfe            f_P5 = [r_ad2o],16
+      nop.f           0
+}
+;;
+
+{ .mmi
+      ldfe            f_P4 = [r_ad2e],16
+      ldfe            f_P3 = [r_ad2o],16
+      nop.i           0
+}
+;;
+
+{ .mmi
+      ldfe            f_P2 = [r_ad2e],16
+      ldfe            f_P1 = [r_ad2o],16
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_X3 = f_NORM_X, f_X2, f0
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          f_X4 = f_X2, f_X2, f0
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_poly65 = f_X2, f_P6, f_P5
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+      fma.s1          f_poly43 = f_X2, f_P4, f_P3
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_poly21 = f_X2, f_P2, f_P1
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_poly6543 = f_X4, f_poly65, f_poly43
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s1          f_poly6to1 = f_X4, f_poly6543, f_poly21
+      nop.i           0
+}
+;;
+
+// Dummy multiply to generate inexact
+{ .mfi
+      nop.m           0
+      fmpy.s0         f_tmp = f_P6, f_P6
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+      fma.s0          f8 = f_poly6to1, f_X3, f_NORM_X
+      br.ret.sptk     b0                // Exit SINH_BY_POLY
+}
+;;
+
+
+// Here if x denorm or unorm
+SINH_DENORM:
+// Determine if x really a denorm and not a unorm
+{ .mmf
+      getf.exp        r_signexp_x = f_NORM_X
+      mov             r_exp_denorm = 0x0c001   // Real denorms have exp < this
+      fmerge.s        f_ABS_X = f0, f_NORM_X
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fcmp.eq.s0      p10,p0 = f8, f0  // Set denorm flag
+      nop.i           0
+}
+;;
+
+// Set p8 if really a denorm
+{ .mmi
+      and             r_exp_x = r_exp_mask, r_signexp_x
+;;
+      cmp.lt          p8,p9 = r_exp_x, r_exp_denorm
+      nop.i           0
+}
+;;
+
+// Identify denormal operands.
+{ .mfb
+      nop.m           0
+(p8)  fcmp.ge.unc.s1  p6,p7 = f8, f0   // Test sign of denorm
+(p9)  br.cond.sptk    SINH_COMMON    // Return to main path if x unorm
+}
+;;
+
+{ .mfi
+      nop.m           0
+(p6)  fma.s0          f8 =  f8,f8,f8  // If x +denorm, result=x+x^2
+      nop.i           0
+}
+{ .mfb
+      nop.m           0
+(p7)  fnma.s0         f8 =  f8,f8,f8  // If x -denorm, result=x-x^2
+      br.ret.sptk     b0            // Exit if x denorm
+}
+;;
+
+
+// Here if |x| >= overflow limit
+SINH_HUGE:
+// for SINH_HUGE, put 24000 in exponent; take sign from input
+{ .mmi
+      mov             r_exp_huge = 0x15dbf
+;;
+      setf.exp        f_huge  = r_exp_huge
+      nop.i           0
+}
+;;
+
+.pred.rel "mutex",p8,p9
+{ .mfi
+      alloc           r32 = ar.pfs,0,5,4,0
+(p8)  fnma.s1         f_signed_hi_lo = f_huge, f1, f1
+      nop.i           0
+}
+{ .mfi
+      nop.m           0
+(p9)  fma.s1          f_signed_hi_lo = f_huge, f1, f1
+      nop.i           0
+}
+;;
+
+{ .mfi
+      nop.m           0
+      fma.s0          f_pre_result = f_signed_hi_lo, f_huge, f0
+      mov             GR_Parameter_TAG = 126
+}
+;;
+
+GLOBAL_IEEE754_END(sinhl)
+libm_alias_ldouble_other (__sinh, sinh)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+
+{ .mfi
+        add   GR_Parameter_Y=-32,sp              // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                  // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                            // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                        // Save gp
+};;
+
+{ .mmi
+        stfe [GR_Parameter_Y] = f0,16            // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp               // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                        // Save b0
+};;
+
+.body
+{ .mib
+        stfe [GR_Parameter_X] = f8               // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y   // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfe [GR_Parameter_Y] = f_pre_result     // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#    // Call error handling function
+};;
+
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 0
+        nop.i 0
+};;
+
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]         // Get return result off stack
+.restore sp
+        add   sp = 64,sp                         // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                    // Restore return address
+};;
+
+{ .mib
+        mov   gp = GR_SAVE_GP                    // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS               // Restore ar.pfs
+        br.ret.sptk     b0                       // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_sqrt.S
@@ -0,0 +1,343 @@
+.file "sqrt.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//********************************************************************
+// History
+//********************************************************************
+// 02/02/00 Initial version
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+//********************************************************************
+//
+// Function:   Combined sqrt(x), where
+//                        _
+//             sqrt(x) = |x, for double precision x values
+//
+//********************************************************************
+//
+// Accuracy:       Correctly Rounded
+//
+//********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8  (Input and Return Value)
+//                              f7 -f14
+//
+//    General Purpose Registers:
+//      r32-r36 (Locals)
+//      r37-r40 (Used to pass arguments to error handling routine)
+//
+//    Predicate Registers:      p6, p7, p8
+//
+//*********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    All faults and exceptions should be raised correctly.
+//    sqrt(QNaN) = QNaN
+//    sqrt(SNaN) = QNaN
+//    sqrt(+/-0) = +/-0
+//    sqrt(negative) = QNaN and error handling is called
+//
+//*********************************************************************
+//
+// Implementation:
+//
+//  Modified Newton-Raphson Algorithm
+//
+//*********************************************************************
+
+GR_SAVE_PFS          = r33
+GR_SAVE_B0           = r34
+GR_SAVE_GP           = r35
+
+GR_Parameter_X       = r37
+GR_Parameter_Y       = r38
+GR_Parameter_RESULT  = r39
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(sqrt)
+{ .mfi
+  alloc r32= ar.pfs,0,5,4,0
+  frsqrta.s0 f7,p6=f8
+  nop.i 0
+} { .mlx
+  // BEGIN DOUBLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
+  nop.m 0
+  // exponent of +1/2 in r2
+  movl r2 = 0x0fffe;;
+} { .mmi
+  // +1/2 in f9
+  setf.exp f9 = r2
+  nop.m 0
+  nop.i 0
+} { .mlx
+  nop.m 0
+  // 3/2 in r3
+  movl r3=0x3fc00000;;
+} { .mfi
+  setf.s f10=r3
+  // Step (1)
+  // y0 = 1/sqrt(a) in f7
+  fclass.m.unc p7,p8 = f8,0x3A
+  nop.i 0;;
+} { .mlx
+  nop.m 0
+  // 5/2 in r2
+  movl r2 = 0x40200000
+} { .mlx
+  nop.m 0
+  // 63/8 in r3
+  movl r3 = 0x40fc0000;;
+} { .mfi
+  setf.s f11=r2
+  // Step (2)
+  // h = +1/2 * y0 in f6
+  (p6) fma.s1 f6=f9,f7,f0
+  nop.i 0
+} { .mfi
+  setf.s f12=r3
+  // Step (3)
+  // g = a * y0 in f7
+  (p6) fma.s1 f7=f8,f7,f0
+  nop.i 0
+} { .mfi
+  nop.m 0
+  mov   f15 = f8
+  nop.i 0;;
+} { .mlx
+  nop.m 0
+  // 231/16 in r2
+  movl r2 = 0x41670000;;
+} { .mfi
+  setf.s f13=r2
+  // Step (4)
+  // e = 1/2 - g * h in f9
+  (p6) fnma.s1 f9=f7,f6,f9
+  nop.i 0
+} { .mlx
+  nop.m 0
+  // 35/8 in r3
+  movl r3 = 0x408c0000;;
+} { .mfi
+  setf.s f14=r3
+  // Step (5)
+  // S = 3/2 + 5/2 * e in f10
+  (p6) fma.s1 f10=f11,f9,f10
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (6)
+  // e2 = e * e in f11
+  (p6) fma.s1 f11=f9,f9,f0
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (7)
+  // t = 63/8 + 231/16 * e in f12
+  (p6) fma.s1 f12=f13,f9,f12
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (8)
+  // S1 = e + e2 * S in f10
+  (p6) fma.s1 f10=f11,f10,f9
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (9)
+  // e4 = e2 * e2 in f11
+  (p6) fma.s1 f11=f11,f11,f0
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (10)
+  // t1 = 35/8 + e * t in f9
+  (p6) fma.s1 f9=f9,f12,f14
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (11)
+  // G = g + S1 * g in f12
+  (p6) fma.s1 f12=f10,f7,f7
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (12)
+  // E = g * e4 in f7
+  (p6) fma.s1 f7=f7,f11,f0
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (13)
+  // u = S1 + e4 * t1 in f10
+  (p6) fma.s1 f10=f11,f9,f10
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (14)
+  // g1 = G + t1 * E in f7
+  (p6) fma.d.s1 f7=f9,f7,f12
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (15)
+  // h1 = h + u * h in f6
+  (p6) fma.s1 f6=f10,f6,f6
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (16)
+  // d = a - g1 * g1 in f9
+  (p6) fnma.s1 f9=f7,f7,f8
+  nop.i 0;;
+} { .mfb
+  nop.m 0
+  // Step (17)
+  // g2 = g1 + d * h1 in f7
+  (p6) fma.d.s0 f8=f9,f6,f7
+  (p6) br.ret.sptk b0 ;;
+}
+
+{ .mfb
+  nop.m 0
+       mov   f8 = f7
+  (p8) br.ret.sptk b0 ;;
+}
+{ .mfb
+  (p7) mov   r40 = 49
+  nop.f 0
+  (p7) br.cond.sptk __libm_error_region ;;
+}
+// END DOUBLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
+GLOBAL_IEEE754_END(sqrt)
+libm_alias_double_other (__sqrt, sqrt)
+libm_alias_double_narrow (__sqrt, sqrt)
+
+// Stack operations when calling error support.
+//       (1)               (2)                          (3) (call)              (4)
+//   sp   -> +          psp -> +                     psp -> +                   sp -> +
+//           |                 |                            |                         |
+//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
+//           |                 |                            |                         |
+//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
+//           |                 |                            |                         |
+//           |                 | <- GR_X               X1 ->|                         |
+//           |                 |                            |                         |
+//  sp-64 -> +          sp ->  +                     sp ->  +                         +
+//    save ar.pfs          save b0                                               restore gp
+//    save gp                                                                    restore ar.pfs
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+
+//
+// This branch includes all those special values that are not negative,
+// with the result equal to frcpa(x)
+//
+
+.prologue
+// We are distinguishing between over(under)flow and letting
+// __libm_error_support set ERANGE or do anything else needed.
+
+// (1)
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                          // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                      // Save gp
+};;
+
+
+// (2)
+{ .mmi
+        stfd [GR_Parameter_Y] = f0,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp            // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                     // Save b0
+};;
+
+.body
+// (3)
+{ .mib
+        stfd [GR_Parameter_X] = f15                    // STORE Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y   // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = f8                     // STORE Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#          // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+
+// (4)
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_sqrtf.S
@@ -0,0 +1,260 @@
+.file "sqrtf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+// History:
+//
+// 02/02/00 Initial version
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+//*********************************************************************
+//
+// Function:   Combined sqrtf(x), where
+//                         _
+//             sqrtf(x) = |x, for single precision x values
+//
+//********************************************************************
+//
+// Accuracy:       Correctly Rounded
+//
+//********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8  (Input and Return Value)
+//                              f7 -f14
+//
+//    General Purpose Registers:
+//      r32-r36 (Locals)
+//      r37-r40 (Used to pass arguments to error handling routine)
+//
+//    Predicate Registers:      p6, p7, p8
+//
+//********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    All faults and exceptions should be raised correctly.
+//    sqrtf(QNaN) = QNaN
+//    sqrtf(SNaN) = QNaN
+//    sqrtf(+/-0) = +/-0
+//    sqrtf(negative) = QNaN and error handling is called
+//
+//********************************************************************
+//
+// Implementation:
+//
+//  Modified Newton-Raphson Algorithm
+//
+//********************************************************************
+
+
+GR_SAVE_B0                    = r34
+GR_SAVE_PFS                   = r33
+GR_SAVE_GP                    = r35
+
+GR_Parameter_X                = r37
+GR_Parameter_Y                = r38
+GR_Parameter_RESULT           = r39
+GR_Parameter_TAG              = r40
+
+FR_X             = f13
+FR_Y             = f0
+FR_RESULT        = f8
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(sqrtf)
+{ .mlx
+  // BEGIN SINGLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
+  alloc r32= ar.pfs,0,5,4,0
+  // exponent of +1/2 in r2
+  movl r2 = 0x0fffe
+} { .mfi
+  // +1/2 in f12
+  nop.m 0
+  frsqrta.s0 f7,p6=f8
+  nop.i 0;;
+} { .mfi
+  setf.exp f12 = r2
+  // Step (1)
+  // y0 = 1/sqrt(a) in f7
+  fclass.m.unc p7,p8 = f8,0x3A
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Make a copy of x just in case
+  mov f13 = f8
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (2)
+  // H0 = 1/2 * y0 in f9
+  (p6) fma.s1 f9=f12,f7,f0
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (3)
+  // S0 = a * y0 in f7
+  (p6) fma.s1 f7=f8,f7,f0
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (4)
+  // d = 1/2 - S0 * H0 in f10
+  (p6) fnma.s1 f10=f7,f9,f12
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (0'')
+  // 3/2 = 1 + 1/2 in f12
+  (p6) fma.s1 f12=f12,f1,f1
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (5)
+  // e = 1 + 3/2 * d in f12
+  (p6) fma.s1 f12=f12,f10,f1
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (6)
+  // T0 = d * S0 in f11
+  (p6) fma.s1 f11=f10,f7,f0
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (7)
+  // G0 = d * H0 in f10
+  (p6) fma.s1 f10=f10,f9,f0
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (8)
+  // S1 = S0 + e * T0 in f7
+  (p6) fma.s.s1 f7=f12,f11,f7
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (9)
+  // H1 = H0 + e * G0 in f12
+  (p6) fma.s1 f12=f12,f10,f9
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (10)
+  // d1 = a - S1 * S1 in f9
+  (p6) fnma.s1 f9=f7,f7,f8
+  nop.i 0;;
+} { .mfb
+  nop.m 0
+  // Step (11)
+  // S = S1 + d1 * H1 in f7
+  (p6) fma.s.s0 f8=f9,f12,f7
+  (p6) br.ret.sptk   b0 ;;
+// END SINGLE PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
+} { .mfb
+  nop.m 0
+       mov   f8 = f7
+  (p8) br.ret.sptk b0 ;;
+}
+//
+// This branch includes all those special values that are not negative,
+// with the result equal to frcpa(x)
+//
+GLOBAL_IEEE754_END(sqrtf)
+libm_alias_float_other (__sqrt, sqrt)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mii
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        mov   GR_Parameter_TAG = 50
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#   // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_sqrtf128.c
@@ -0,0 +1 @@
+#include <sysdeps/x86/fpu/e_sqrtf128.c>
--- /dev/null
+++ a/sysdeps/ia64/fpu/e_sqrtl.S
@@ -0,0 +1,275 @@
+.file "sqrtl.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//********************************************************************
+//
+// History:
+// 02/02/00 (hand-optimized)
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+//********************************************************************
+//
+// Function:   Combined sqrtl(x), where
+//                         _
+//             sqrtl(x) = |x, for double-extended precision x values
+//
+//********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8  (Input and Return Value)
+//                              f7 -f14
+//
+//    General Purpose Registers:
+//      r32-r36 (Locals)
+//      r37-r40 (Used to pass arguments to error handling routine)
+//
+//    Predicate Registers:      p6, p7, p8
+//
+//********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    All faults and exceptions should be raised correctly.
+//    sqrtl(QNaN) = QNaN
+//    sqrtl(SNaN) = QNaN
+//    sqrtl(+/-0) = +/-0
+//    sqrtl(negative) = QNaN and error handling is called
+//
+//********************************************************************
+//
+// Implementation:
+//
+//  Modified Newton-Raphson Algorithm
+//
+//********************************************************************
+
+GR_SAVE_PFS         = r33
+GR_SAVE_B0          = r34
+GR_SAVE_GP          = r35
+GR_Parameter_X      = r37
+GR_Parameter_Y      = r38
+GR_Parameter_RESULT = r39
+GR_Parameter_TAG    = r40
+
+FR_X                = f15
+FR_Y                = f0
+FR_RESULT           = f8
+
+.section .text
+GLOBAL_IEEE754_ENTRY(sqrtl)
+{ .mlx
+alloc r32= ar.pfs,0,5,4,0
+  // exponent of +1/2 in r2
+  movl r2 = 0x0fffe;;
+} { .mfi
+  // +1/2 in f10
+  setf.exp f12 = r2
+  // Step (1)
+  // y0 = 1/sqrt(a) in f7
+  frsqrta.s0 f7,p6=f8
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (2)
+  // H0 = +1/2 * y0 in f9
+  (p6) fma.s1 f9=f12,f7,f0
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (3)
+  // S0 = a * y0 in f7
+  (p6) fma.s1 f7=f8,f7,f0
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Make copy input x
+  mov f13=f8
+  nop.i 0
+} { .mfi
+  nop.m 0
+  fclass.m.unc p7,p8 = f8,0x3A
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (4)
+  // d0 = 1/2 - S0 * H0 in f10
+  (p6) fnma.s1 f10=f7,f9,f12
+  nop.i 0;;
+}
+{ .mfi
+  nop.m 0
+       mov f15=f8
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (5)
+  // H1 = H0 + d0 * H0 in f9
+  (p6) fma.s1 f9=f10,f9,f9
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (6)
+  // S1 = S0 + d0 * S0 in f7
+  (p6) fma.s1 f7=f10,f7,f7
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (7)
+  // d1 = 1/2 - S1 * H1 in f10
+  (p6) fnma.s1 f10=f7,f9,f12
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (8)
+  // H2 = H1 + d1 * H1 in f9
+  (p6) fma.s1 f9=f10,f9,f9
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (9)
+  // S2 = S1 + d1 * S1 in f7
+  (p6) fma.s1 f7=f10,f7,f7
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (10)
+  // d2 = 1/2 - S2 * H2 in f10
+  (p6) fnma.s1 f10=f7,f9,f12
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (11)
+  // e2 = a - S2 * S2 in f12
+  (p6) fnma.s1 f12=f7,f7,f8
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (12)
+  // S3 = S2 + d2 * S2 in f7
+  (p6) fma.s1 f7=f12,f9,f7
+  nop.i 0
+} { .mfi
+  nop.m 0
+  // Step (13)
+  // H3 = H2 + d2 * H2 in f9
+  (p6) fma.s1 f9=f10,f9,f9
+  nop.i 0;;
+} { .mfi
+  nop.m 0
+  // Step (14)
+  // e3 = a - S3 * S3 in f12
+  (p6) fnma.s1 f12=f7,f7,f8
+  nop.i 0;;
+} { .mfb
+  nop.m 0
+  // Step (15)
+  // S = S3 + e3 * H3 in f7
+  (p6) fma.s0 f8=f12,f9,f7
+  (p6) br.ret.sptk b0 ;;
+}
+{ .mfb
+       mov GR_Parameter_TAG    = 48
+       mov   f8 = f7
+  (p8) br.ret.sptk b0 ;;
+}
+//
+// This branch includes all those special values that are not negative,
+// with the result equal to frcpa(x)
+//
+
+
+// END DOUBLE EXTENDED PRECISION MINIMUM LATENCY SQUARE ROOT ALGORITHM
+GLOBAL_IEEE754_END(sqrtl)
+libm_alias_ldouble_other (__sqrt, sqrt)
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfe [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfe [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfe [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#  // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region#)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/fclrexcpt.c
@@ -0,0 +1,37 @@
+/* Clear given exceptions in current floating-point environment.
+   Copyright (C) 1997-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+feclearexcept (int excepts)
+{
+  fenv_t fpsr;
+
+  /* Get the current state.  */
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (fpsr));
+
+  /* Clear the relevant bits.  */
+  fpsr &= ~(((fenv_t) ((excepts & FE_ALL_EXCEPT) << 13)));
+  /* Put the new state in effect.  */
+  __asm__ __volatile__ ("mov.m ar.fpsr=%0" :: "r" (fpsr) : "memory");
+
+  /* success */
+  return 0;
+}
+libm_hidden_def (feclearexcept)
--- /dev/null
+++ a/sysdeps/ia64/fpu/fedisblxcpt.c
@@ -0,0 +1,35 @@
+/* Disable floating-point exceptions.
+   Copyright (C) 2000-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+fedisableexcept (int excepts)
+{
+  fenv_t old_fpsr;
+  fenv_t new_fpsr;
+
+  /* Get the current fpsr.  */
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (old_fpsr));
+
+  new_fpsr = old_fpsr | ((fenv_t) excepts & FE_ALL_EXCEPT);
+
+  __asm__ __volatile__ ("mov.m ar.fpsr=%0" :: "r" (new_fpsr) : "memory");
+
+  return (old_fpsr ^ FE_ALL_EXCEPT) & FE_ALL_EXCEPT;
+}
--- /dev/null
+++ a/sysdeps/ia64/fpu/feenablxcpt.c
@@ -0,0 +1,35 @@
+/* Enable floating-point exceptions.
+   Copyright (C) 2000-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+feenableexcept (int excepts)
+{
+  fenv_t old_fpsr;
+  fenv_t new_fpsr;
+
+  /* Get the current fpsr.  */
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (old_fpsr));
+
+  new_fpsr = old_fpsr & ~((fenv_t) excepts & FE_ALL_EXCEPT);
+
+  __asm__ __volatile__ ("mov.m ar.fpsr=%0" :: "r" (new_fpsr) : "memory");
+
+  return (old_fpsr ^ FE_ALL_EXCEPT) & FE_ALL_EXCEPT;
+}
--- /dev/null
+++ a/sysdeps/ia64/fpu/fegetenv.c
@@ -0,0 +1,30 @@
+/* Store current floating-point environment.
+   Copyright (C) 1997-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+__fegetenv (fenv_t *envp)
+{
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (*envp));
+
+  return 0;
+}
+libm_hidden_def (__fegetenv)
+weak_alias (__fegetenv, fegetenv)
+libm_hidden_weak (fegetenv)
--- /dev/null
+++ a/sysdeps/ia64/fpu/fegetexcept.c
@@ -0,0 +1,29 @@
+/* Get enabled floating-point exceptions.
+   Copyright (C) 2000-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+fegetexcept (void)
+{
+  fenv_t fpsr;
+
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (fpsr));
+
+  return (fpsr ^ FE_ALL_EXCEPT) & FE_ALL_EXCEPT;
+}
--- /dev/null
+++ a/sysdeps/ia64/fpu/fegetmode.c
@@ -0,0 +1,26 @@
+/* Store current floating-point control modes.  IA64 version.
+   Copyright (C) 2016-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+fegetmode (femode_t *modep)
+{
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (*modep));
+  return 0;
+}
--- /dev/null
+++ a/sysdeps/ia64/fpu/fegetround.c
@@ -0,0 +1,28 @@
+/* Return current rounding direction.
+   Copyright (C) 1999-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <get-rounding-mode.h>
+
+int
+__fegetround (void)
+{
+  return get_rounding_mode ();
+}
+libm_hidden_def (__fegetround)
+weak_alias (__fegetround, fegetround)
+libm_hidden_weak (fegetround)
--- /dev/null
+++ a/sysdeps/ia64/fpu/feholdexcpt.c
@@ -0,0 +1,42 @@
+/* Store current floating-point environment and clear exceptions.
+   Copyright (C) 1997-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+__feholdexcept (fenv_t *envp)
+{
+  fenv_t fpsr;
+  /* Save the current state.  */
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (fpsr));
+  *envp = fpsr;
+
+  /* Set the trap disable bits.  */
+  fpsr |= FE_ALL_EXCEPT;
+
+  /* And clear the exception bits.  */
+  fpsr &= ~(fenv_t) (FE_ALL_EXCEPT << 13);
+
+  __asm__ __volatile__ ("mov.m ar.fpsr=%0" :: "r" (fpsr));
+
+  /* Success.  */
+  return 0;
+}
+libm_hidden_def (__feholdexcept)
+weak_alias (__feholdexcept, feholdexcept)
+libm_hidden_weak (feholdexcept)
--- /dev/null
+++ a/sysdeps/ia64/fpu/fesetenv.c
@@ -0,0 +1,42 @@
+/* Install given floating-point environment.
+   Copyright (C) 1997-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+__fesetenv (const fenv_t *envp)
+{
+  fenv_t env;
+
+  /*
+     This stinks!
+     Magic encoding of default values: bit 62+63 set (which will never
+     happen for a user-space address) means it's not indirect.
+  */
+  if (((fenv_t) envp >> 62) == 0x03)
+    env = (fenv_t) envp & 0x3fffffffffffffff;
+  else
+    env = *envp;
+
+  __asm__ __volatile__ ("mov.m ar.fpsr=%0;;" :: "r" (env));
+
+  return 0;
+}
+libm_hidden_def (__fesetenv)
+weak_alias (__fesetenv, fesetenv)
+libm_hidden_weak (fesetenv)
--- /dev/null
+++ a/sysdeps/ia64/fpu/fesetexcept.c
@@ -0,0 +1,31 @@
+/* Set given exception flags.  IA64 version.
+   Copyright (C) 2016-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+fesetexcept (int excepts)
+{
+  fenv_t fpsr;
+
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (fpsr));
+  fpsr |= ((excepts & FE_ALL_EXCEPT) << 13);
+  __asm__ __volatile__ ("mov.m ar.fpsr=%0" :: "r" (fpsr) : "memory");
+
+  return 0;
+}
--- /dev/null
+++ a/sysdeps/ia64/fpu/fesetmode.c
@@ -0,0 +1,42 @@
+/* Install given floating-point control modes.  IA64 version.
+   Copyright (C) 2016-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+#define FPSR_STATUS 0x1f80UL
+#define FPSR_STATUS_ALL ((FPSR_STATUS << 6) | (FPSR_STATUS << 19) \
+			 | (FPSR_STATUS << 32) | (FPSR_STATUS << 45))
+
+int
+fesetmode (const femode_t *modep)
+{
+  femode_t mode;
+
+  /* As in fesetenv.  */
+  if (((fenv_t) modep >> 62) == 0x03)
+    mode = (femode_t) modep & 0x3fffffffffffffffUL;
+  else
+    mode = *modep;
+
+  femode_t fpsr;
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (fpsr));
+  fpsr = (fpsr & FPSR_STATUS_ALL) | (mode & ~FPSR_STATUS_ALL);
+  __asm__ __volatile__ ("mov.m ar.fpsr=%0;;" :: "r" (fpsr));
+
+  return 0;
+}
--- /dev/null
+++ a/sysdeps/ia64/fpu/fesetround.c
@@ -0,0 +1,42 @@
+/* Set current rounding direction.
+   Copyright (C) 1999-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+__fesetround (int round)
+{
+  fenv_t fpsr;
+
+  if (round & ~3)
+    return 1;
+
+  /* Get the current state.  */
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (fpsr));
+
+  /* Set the relevant bits.  */
+  fpsr = (fpsr & ~(3UL << 10)) | ((fenv_t) round << 10);
+
+  /* Put the new state in effect.  */
+  __asm__ __volatile__ ("mov.m ar.fpsr=%0" :: "r" (fpsr) : "memory");
+
+  return 0;
+}
+libm_hidden_def (__fesetround)
+weak_alias (__fesetround, fesetround)
+libm_hidden_weak (fesetround)
--- /dev/null
+++ a/sysdeps/ia64/fpu/feupdateenv.c
@@ -0,0 +1,41 @@
+/* Install given floating-point environment and raise exceptions.
+   Copyright (C) 1997-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+__feupdateenv (const fenv_t *envp)
+{
+  fenv_t fpsr;
+
+
+  /* Get the current exception state.  */
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (fpsr));
+
+  /* Install new environment.  */
+  __fesetenv (envp);
+
+  /* Raise the saved exceptions.  */
+  __feraiseexcept ((int) (fpsr >> 13) & FE_ALL_EXCEPT);
+
+  /* Success.  */
+  return 0;
+}
+libm_hidden_def (__feupdateenv)
+weak_alias (__feupdateenv, feupdateenv)
+libm_hidden_weak (feupdateenv)
--- /dev/null
+++ a/sysdeps/ia64/fpu/fgetexcptflg.c
@@ -0,0 +1,33 @@
+/* Store current representation for exceptions.
+   Copyright (C) 1997-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+fegetexceptflag (fexcept_t *flagp, int excepts)
+{
+  fenv_t fpsr;
+
+  /* Get the current exceptions.  */
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (fpsr));
+
+  *flagp = (fexcept_t) ((fpsr >> 13) & excepts & FE_ALL_EXCEPT);
+
+  /* Success.  */
+  return 0;
+}
--- /dev/null
+++ a/sysdeps/ia64/fpu/fraiseexcpt.c
@@ -0,0 +1,79 @@
+/* Raise given exceptions.
+   Copyright (C) 1997-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+#include <float.h>
+#include <math.h>
+#include <signal.h>
+#include <unistd.h>
+
+int
+__feraiseexcept (int excepts)
+{
+  double tmp;
+  double dummy;
+
+  /* Raise exceptions represented by EXPECTS.  But we must raise only
+     one signal at a time.  It is important the if the overflow/underflow
+     exception and the inexact exception are given at the same time,
+     the overflow/underflow exception precedes the inexact exception.  */
+
+  /* We do these bits in assembly to be certain GCC doesn't optimize
+     away something important.  */
+
+  /* First: invalid exception.  */
+  if (FE_INVALID & excepts)
+    {
+      /* One example of an invalid operation is 0 * Infinity.  */
+      tmp = 0;
+      __asm__ __volatile__ ("frcpa.s0 %0,p1=f0,f0" : "=f" (tmp) : : "p1" );
+    }
+
+  /* Next: division by zero.  */
+  if (FE_DIVBYZERO & excepts)
+    __asm__ __volatile__ ("frcpa.s0 %0,p1=f1,f0" : "=f" (tmp) : : "p1" );
+
+  /* Next: overflow.  */
+  if (FE_OVERFLOW & excepts)
+    {
+      dummy = DBL_MAX;
+
+      __asm__ __volatile__ ("fadd.d.s0 %0=%1,%1" : "=f" (dummy) : "0" (dummy));
+    }
+
+  /* Next: underflow.  */
+  if (FE_UNDERFLOW & excepts)
+    {
+      dummy = DBL_MIN;
+
+      __asm__ __volatile__ ("fnma.d.s0 %0=%1,%1,f0" : "=f" (tmp) : "f" (dummy));
+  }
+
+  /* Last: inexact.  */
+  if (FE_INEXACT & excepts)
+    {
+      dummy = DBL_MAX;
+      __asm__ __volatile__ ("fsub.d.s0 %0=%1,f1" : "=f" (dummy) : "0" (dummy));
+    }
+
+  /* Success.  */
+  return 0;
+}
+libm_hidden_def (__feraiseexcept)
+weak_alias (__feraiseexcept, feraiseexcept)
+libm_hidden_weak (feraiseexcept)
--- /dev/null
+++ a/sysdeps/ia64/fpu/fsetexcptflg.c
@@ -0,0 +1,39 @@
+/* Set floating-point environment exception handling.
+   Copyright (C) 1997-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+fesetexceptflag (const fexcept_t *flagp, int excepts)
+{
+  fenv_t fpsr;
+
+  /* Get the current exception state.  */
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (fpsr));
+
+  fpsr &= ~(((fenv_t) excepts & FE_ALL_EXCEPT) << 13);
+
+  /* Set all the bits that were called for.  */
+  fpsr |= ((*flagp & excepts & FE_ALL_EXCEPT) << 13);
+
+  /* And store it back.  */
+  __asm__ __volatile__ ("mov.m ar.fpsr=%0" :: "r" (fpsr) : "memory");
+
+  /* Success.  */
+  return 0;
+}
--- /dev/null
+++ a/sysdeps/ia64/fpu/ftestexcept.c
@@ -0,0 +1,31 @@
+/* Test exception in current environment.
+   Copyright (C) 1997-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <fenv.h>
+
+int
+fetestexcept (int excepts)
+{
+  fenv_t fpsr;
+
+  /* Get current exceptions.  */
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (fpsr));
+
+  return (fpsr >> 13) & excepts & FE_ALL_EXCEPT;
+}
+libm_hidden_def (fetestexcept)
--- /dev/null
+++ a/sysdeps/ia64/fpu/gen_import_file_list
@@ -0,0 +1,90 @@
+#!/bin/sh
+
+libm_dir=$1
+
+import() {
+	# $1 = name
+	# $2 = source file-name
+	# $3 = destination file-name
+	echo "$1 $libm_dir/$2 $3"
+}
+
+import_c() {
+	# $1 = name
+	# $2 = source file-name
+	# $3 = destination file-name
+	echo "$1 $libm_dir/$2 $3"
+}
+
+dummy_files="
+libm_cpu_defs.h
+libm_error_codes.h
+libm_support.h
+libm_error.c
+"
+
+for f in $dummy_files
+do
+  import_c DUMMY $f $f
+done
+
+import_c scalblnf scalblnf.c s_scalblnf.c
+
+for f in acos acosh asin atanh cosh exp2 exp10 fmod log2 pow remainder \
+	 scalb sinh sqrt; do
+ for t in "" f l; do
+  import $f$t $f$t.s e_$f$t.S
+ done
+done
+
+for f in atan2 exp; do
+ for t in "" f; do
+  import $f$t $f$t.s e_$f$t.S
+ done
+done
+import "atan" atan.s s_atan.S
+import "atanf" atanf.s s_atanf.S
+import "atan(2)?l" atanl.s s_atanl.S
+import "exp(m1)?l" expl_m1.s s_expm1l.S
+
+for t in "" f l; do
+  import "log(10)?$t" log$t.s e_log$t.S
+  import tgamma$t tgamma$t.s w_tgamma$t.S
+  import "(hypot|cabs)$t" hypot$t.s e_hypot$t.S
+done
+
+for f in asinh cbrt ceil erf erfc fabs floor \
+	 ilogb log1p logb modf nearbyint nextafter nexttoward \
+	 rint round significand fdim fma fmax tanh trunc; do
+ for t in "" f l; do
+  import $f$t $f$t.s s_$f$t.S
+ done
+done
+
+for t in "" f l; do
+  import "(tan|cot)$t" tancot$t.s s_tan$t.S
+done
+
+for t in "" f l; do
+  import "(sin|cos)$t" sincos$t.s s_cos$t.S
+  import_c frexp$t frexp$t.c s_frexp$t.c
+  import_c ldexp$t ldexp$t.c s_ldexp$t.c
+  import_c scalbn$t scalbn$t.c s_scalbn$t.c
+done
+
+import expm1 exp_m1.s s_expm1.S
+import expm1f expf_m1.s s_expm1f.S
+
+for f in frexp frexpf frexpl reduce; do
+  import __libm_$f libm_$f.s libm_$f.S
+done
+
+for t in "" f l; do
+  import __libm_ldexp$t libm_ldexp$t.s s_libm_ldexp$t.S
+  import "(__libm_)?(sincos|cis)$t" libm_sincos$t.s libm_sincos$t.S
+  import __libm_lgamma$t libm_lgamma$t.s libm_lgamma$t.S
+  import __libm_scalbn$t libm_scalbn$t.s s_libm_scalbn$t.S
+done
+import __libm_scalblnf libm_scalblnf.s libm_scalblnf.S
+import "__libm_(sin|cos|sincos)_large" libm_sincos_large.s \
+	libm_sincos_large.S
--- /dev/null
+++ a/sysdeps/ia64/fpu/get-rounding-mode.h
@@ -0,0 +1,36 @@
+/* Return current rounding direction within libc.  IA64 version.
+   Copyright (C) 1999-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef IA64_GET_ROUNDING_MODE_H
+#define IA64_GET_ROUNDING_MODE_H	1
+
+#include <fenv.h>
+
+/* Return the floating-point rounding mode.  */
+
+static inline int
+get_rounding_mode (void)
+{
+  fenv_t fpsr;
+
+  __asm__ __volatile__ ("mov.m %0=ar.fpsr" : "=r" (fpsr));
+
+  return (fpsr >> 10) & 3;
+}
+
+#endif /* get-rounding-mode.h */
--- /dev/null
+++ a/sysdeps/ia64/fpu/import_check
@@ -0,0 +1,81 @@
+#!/bin/sh
+
+objdir="$1"
+
+num_errors=0
+
+check_syms() {
+    global_count=0
+    entry_count=0
+    while read value type name; do
+	if [ $value = "U" ]; then
+	    name=$type
+	    # undefined symbols must start with double-underscore
+	    if [ $(expr $name : '\(..\)') != "__" ]; then
+		echo -e "$(basename $file):\tError: undefined reference $name doesn't start with \"__\"."
+		num_errors=$(($num_errors + 1))
+	    fi
+	    continue
+	fi
+
+	case "$type" in
+	    W)
+		entry_count=$(($entry_count + 1))
+		;;
+	    *)
+		entry_count=$(($entry_count + 1))
+		if [ "$(expr $name : '\(..\)')" != "__" ]; then
+		    global_count=$(($global_count + 1))
+		fi
+		;;
+	esac
+    done
+    if [ $entry_count -gt 1 -a $global_count -gt 0 ]; then
+	echo -e "$(basename $file):\tError: detected $global_count strong " \
+	    "global and $entry_count entry-points."
+	num_errors=$(($num_errors + 1))
+    fi
+}
+
+check_file() {
+    file=$1
+    size=$(readelf -S $file | \
+	(sz=0; while read line; do
+		if echo $line | grep -F -q " .rodata"; then
+		    read sz rest
+		    break
+		fi
+	    done;
+	    printf "%d" 0x$sz))
+
+    summands=$(readelf -s $file | grep -F " OBJECT " | tr -s ' ' |
+	cut -f4 -d' ' | sed 's,$,+,')0
+    sum=$(($summands))
+    if [ $sum != $size ]; then
+	echo -e "$(basename $file):\tError: sum of objects=$sum bytes, .rodata size=$size bytes"
+	num_errors=$(($num_errors + 1))
+    fi
+
+    tmp=$(tempfile -p syms)
+    nm -g $file > $tmp
+    check_syms < $tmp
+}
+
+do_checks() {
+    echo "Note: 1 error expected in w_tgammal.o due to 64-byte alignment-padding."
+    while read func_pattern src_file dst_file; do
+	if [ "$(expr $dst_file : '.*\(S\)$')" = "S" ]; then
+	    objfile=$(expr $dst_file : '\(.*\)[.]S$')
+	    check_file $objdir/$objfile.o
+	fi
+    done
+}
+
+do_checks < import_file_list
+
+if [ $num_errors -gt 0 ]; then
+    echo "FAILURE: Detected $num_errors error(s)."
+    exit 1
+fi
+echo SUCCESS
+exit 0
--- /dev/null
+++ a/sysdeps/ia64/fpu/import_diffs
@@ -0,0 +1,7 @@
+#!/bin/sh
+do_diffs() {
+    while read func_pattern src_file dst_file; do
+	diff -up $src_file $dst_file
+    done
+}
+do_diffs < import_file_list
--- /dev/null
+++ a/sysdeps/ia64/fpu/import_file.awk
@@ -0,0 +1,150 @@
+BEGIN {
+	getline;
+	while (!match($0, "^/[/*] static char cvs_id")) {
+		print;
+		getline;
+	}
+	getline;
+	while (!match($0, "^// WARRANTY DISCLAIMER")) {
+		print;
+		if (!getline) {
+			break;
+		}
+	}
+	if (getline)
+	{
+		printf								      \
+"// Redistribution and use in source and binary forms, with or without\n"     \
+"// modification, are permitted provided that the following conditions are\n" \
+"// met:\n"								      \
+"//\n"									      \
+"// * Redistributions of source code must retain the above copyright\n"	      \
+"// notice, this list of conditions and the following disclaimer.\n"	      \
+"//\n"									      \
+"// * Redistributions in binary form must reproduce the above copyright\n"    \
+"// notice, this list of conditions and the following disclaimer in the\n"    \
+"// documentation and/or other materials provided with the distribution.\n"   \
+"//\n"									      \
+"// * The name of Intel Corporation may not be used to endorse or promote\n"  \
+"// products derived from this software without specific prior written\n"     \
+"// permission.\n\n";
+		if (LICENSE_ONLY == "y") {
+			do {
+				print;
+			} while (getline);
+		}
+	}
+}
+
+/^[.]data/ {
+	print "RODATA";
+	next;
+}
+/^([a-zA-Z_0-9]*_(tb[l0-9]|Tt|[tT]able|data|low|coeffs|constants|CONSTANTS|reduction|Stirling)(_?([1-9cdimpqstPQT]+|tail))?|(Constants|Poly|coeff)_.+|(double_sin_?cos|double_cis)[fl]?_.+):/ {
+	table_name=substr($1,1,length($1)-1);
+	printf "LOCAL_OBJECT_START(%s)\n", table_name;
+	getline;
+	while (!match($0, "^[ \t]*data")) {
+		print;
+		getline;
+	}
+	while (match($0, "(//|^[ \t]*data)")) {
+		print;
+		getline;
+	}
+	printf "LOCAL_OBJECT_END(%s)\n\n", table_name;
+	next;
+}
+/^[.]proc[ \t]+__libm_(error_region|callout)/ {
+	printf "LOCAL_LIBM_ENTRY(%s)\n", $2;
+	getline;
+	next;
+}
+/^[.]endp[ \t]+__libm_(error_region|callout)/ {
+	printf "LOCAL_LIBM_END(%s)\n", $2;
+	next;
+}
+/^[.]global/ {
+	split($2, part, "#");
+	name=part[1];
+	if (match(name, "^"FUNC"$")) {
+		next;
+	}
+}
+/^[.]proc/ {
+	split($2, part, "#");
+	name=part[1];
+	if (match(name, "^"FUNC"$")) {
+		local_funcs=("^("			\
+			     "cis|cisf|cisl"		\
+			     "|cabs|cabsf|cabsl"	\
+			     "|cot|cotf|cotl"		\
+			     ")$");
+		ieee754_funcs=("^("					  \
+			       "atan2|atan2f|atan2l|atanl"		  \
+			       "|cos|cosf|cosl"				  \
+			       "|cosh|coshf|coshl"			  \
+			       "|exp|expf|expl"				  \
+			       "|exp10|exp10f|exp10l"			  \
+			       "|expm1|expm1f|expm1l"			  \
+			       "|fmod|fmodf|fmodl"			  \
+			       "|hypot|hypotf|hypotl"			  \
+			       "|fabs|fabsf|fabsl"			  \
+			       "|floor|floorf|floorl"			  \
+			       "|log1p|log1pf|log1pl"			  \
+			       "|log|log10|log10f|log10l|log2l|logf|logl" \
+			       "|remainder|remainderf|remainderl|"	  \
+			       "|rint|rintf|rintl|"			  \
+			       "|scalb|scalbf|scalbl"			  \
+			       "|sin|sinf|sinl"				  \
+			       "|sincos|sincosf|sincosl"		  \
+			       "|sinh|sinhf|sinhl"			  \
+			       "|sqrt|sqrtf|sqrtl"			  \
+			       "|tan|tanf|tanl"				  \
+			       ")$");
+		if (match(name, ieee754_funcs)) {
+			type="GLOBAL_IEEE754";
+		} else if (match (name, local_funcs)) {
+			type="LOCAL_LIBM";
+		} else {
+			type="GLOBAL_LIBM";
+		}
+		printf "%s_ENTRY(%s)\n", type, name;
+		getline;
+		while (!match($0, "^"name"#?:")) {
+			getline;
+		}
+		getline;
+		while (!match($0, "^.endp")) {
+			print
+			getline;
+		}
+		printf "%s_END(%s)\n", type, name;
+		if (match(name, "^exp10[fl]?$")) {
+			t=substr(name,6)
+			printf "weak_alias (exp10%s, pow10%s)\n", t, t
+		}
+		next;
+	}
+}
+/^[a-zA-Z_]+:/ {
+	split($1, part, ":");
+	name=part[1];
+	if (match(name, "^"FUNC"$")) {
+		printf "GLOBAL_LIBM_ENTRY(%s)\n", name;
+		getline;
+		while (!match($0, "^"name"#?:")) {
+			getline;
+		}
+		getline;
+		while (!match($0, "^.endp")) {
+			print
+			getline;
+		}
+		getline;
+		printf "GLOBAL_LIBM_END(%s)\n", name;
+		next;
+	}
+}
+
+{ print }
--- /dev/null
+++ a/sysdeps/ia64/fpu/import_intel_libm
@@ -0,0 +1,106 @@
+#!/bin/sh
+
+# Notes:
+
+#  We don't import copysign finite, fpclassify, isinf, isnan, and signbit
+#  since our own versions are nicer and just as correct and fast (except
+#  perhaps that they don't handle non-finite arguments well?).
+#
+#  Also, leave out cabs for now since it doesn't seem overridable in
+#  glibc.
+
+libm_dir=$1
+
+import_s() {
+	# $1 = name
+	# $2 = source file-name
+	# $3 = destination file-name
+	echo "Importing $1 from $2 -> $3"
+	rm -f $3
+	awk -f import_file.awk FUNC=$1 $2 > $3
+}
+
+import_c() {
+	# $1 = name
+	# $2 = source file-name
+	# $3 = destination file-name
+	echo "Importing $1 from $2 -> $3"
+	rm -f $3
+	awk -f import_file.awk LICENSE_ONLY=y $2 > $3
+}
+
+do_imports() {
+    while read func_pattern src_file dst_file; do
+        case $src_file in
+	*.[ch])
+	    import_c "$func_pattern" "$src_file" "$dst_file"
+	    ;;
+	*)
+	    import_s "$func_pattern" "$src_file" "$dst_file"
+	    ;;
+	esac
+    done
+}
+
+./gen_import_file_list $libm_dir > import_file_list
+
+do_imports < import_file_list
+
+emptyfiles="
+e_gamma_r.c
+e_gammaf_r.c
+e_gammal_r.c
+s_sincos.c
+s_sincosf.c
+s_sincosl.c
+t_exp.c
+w_acosh.c
+w_acoshf.c
+w_acoshl.c
+w_atanh.c
+w_atanhf.c
+w_atanhl.c
+w_exp10.c
+w_exp10f.c
+w_exp10l.c
+w_exp2.c
+w_exp2f.c
+w_exp2l.c
+w_expl.c
+w_lgamma_r.c
+w_lgammaf_r.c
+w_lgammal_r.c
+w_log2.c
+w_log2f.c
+w_log2l.c
+w_sinh.c
+w_sinhf.c
+w_sinhl.c
+"
+for f in $emptyfiles
+do
+  rm -f $f
+  echo "/* Not needed. */" > $f
+done
+
+removedfiles="
+libm_atan2_reg.S
+s_ldexp.S
+s_ldexpf.S
+s_ldexpl.S
+s_scalbn.S
+s_scalbnf.S
+s_scalbnl.S
+"
+
+rm -f $removedfiles
+
+for f in lgammaf_r.c lgammal_r.c lgamma_r.c
+do
+  import_c $f $libm_dir/$f e_$f
+done
+
+for f in lgamma.c lgammaf.c lgammal.c
+do
+  import_c $f $libm_dir/$f w_$f
+done
--- /dev/null
+++ a/sysdeps/ia64/fpu/lgamma-compat.h
@@ -0,0 +1,42 @@
+/* ABI compatibility for lgamma functions.  ia64 version.
+   Copyright (C) 2015-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef IA64_LGAMMA_COMPAT_H
+#define IA64_LGAMMA_COMPAT_H 1
+
+#include <math/lgamma-compat.h>
+
+#undef LGFUNC
+#if USE_AS_COMPAT
+# define LGFUNC(FUNC) __ ## FUNC ## _compat
+#else
+# define LGFUNC(FUNC) __ieee754_ ## FUNC
+#endif
+
+#undef CALL_LGAMMA
+#define CALL_LGAMMA(TYPE, FUNC, ARG)				\
+  ({								\
+    TYPE lgamma_tmp;						\
+    extern int __signgam, signgam;				\
+    lgamma_tmp = FUNC ((ARG), &__signgam, sizeof (__signgam));	\
+    if (USE_AS_COMPAT)						\
+      signgam = __signgam;					\
+    lgamma_tmp;							\
+  })
+
+#endif /* lgamma-compat.h.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/libc_libm_error.c
@@ -0,0 +1,14 @@
+/* Error handling in libm-style for libc.  */
+
+#include <errno.h>
+
+#include "libm_support.h"
+
+
+void
+__libm_error_support (void *arg1, void *arg2, void *retval,
+		      error_types input_tag)
+{
+  __set_errno (ERANGE);
+}
+libc_hidden_def (__libm_error_support)
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm-symbols.h
@@ -0,0 +1,65 @@
+#ifndef _ISOMAC
+# include <sysdep.h>
+# undef ret	/* get rid of the stupid "ret" macro; it breaks br.ret */
+
+# include <libm-alias-float.h>
+# include <libm-alias-double.h>
+# include <libm-alias-ldouble.h>
+# include <math-narrow-alias.h>
+
+/* Support for compatible assembler handling.  */
+
+# define ASM_SIZE_DIRECTIVE(name) .size name,.-name
+
+# define LOCAL_LIBM_ENTRY(name)			\
+	.proc name;				\
+ name:
+
+# define LOCAL_LIBM_END(name)			\
+	.endp name;				\
+ ASM_SIZE_DIRECTIVE(name)
+
+
+# define RODATA		.rodata
+# define LOCAL_OBJECT_START(name)		\
+   name:;					\
+   .type name, @object
+# define LOCAL_OBJECT_END(name)			\
+   ASM_SIZE_DIRECTIVE(name)
+
+# define GLOBAL_LIBM_ENTRY(name)		\
+	LOCAL_LIBM_ENTRY(name);			\
+	.global name
+# define GLOBAL_LIBM_END(name)		LOCAL_LIBM_END(name)
+
+# define INTERNAL_LIBM_ENTRY(name)		\
+	GLOBAL_LIBM_ENTRY(__libm_##name);	\
+	.global __libm_##name
+# define INTERNAL_LIBM_END(name)	GLOBAL_LIBM_END(__libm_##name)
+
+# define WEAK_LIBM_ENTRY(name)			\
+	.align 32;				\
+	LOCAL_LIBM_ENTRY(__##name);		\
+	.global __##name;			\
+ __##name:
+# define WEAK_LIBM_END(name)			\
+ weak_alias (__##name, name);			\
+ .hidden __##name;				\
+	LOCAL_LIBM_END(__##name);		\
+ ASM_SIZE_DIRECTIVE(__##name);			\
+ .type __##name, @function
+
+# define GLOBAL_IEEE754_ENTRY(name)		\
+	WEAK_LIBM_ENTRY(name);			\
+	.global __ieee754_##name;		\
+	.hidden __ieee754_##name;		\
+ __ieee754_##name:
+# define GLOBAL_IEEE754_END(name)			\
+	WEAK_LIBM_END(name);				\
+ ASM_SIZE_DIRECTIVE(__ieee754_##name);			\
+ .type __ieee754_##name, @function
+
+# if defined ASSEMBLER && IS_IN (libc)
+#  define __libm_error_support	HIDDEN_JUMPTARGET(__libm_error_support)
+# endif
+#endif
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm-test-ulps
@@ -0,0 +1,1491 @@
+# Begin of automatic generation
+
+# Maximal error of functions:
+Function: "acos":
+double: 1
+float128: 1
+
+Function: "acos_downward":
+double: 1
+float: 1
+float128: 1
+
+Function: "acos_towardzero":
+double: 1
+float: 1
+float128: 1
+
+Function: "acos_upward":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "acosh":
+double: 1
+float128: 4
+ldouble: 1
+
+Function: "acosh_downward":
+float128: 3
+
+Function: "acosh_towardzero":
+float128: 2
+
+Function: "acosh_upward":
+float128: 3
+
+Function: "asin":
+float128: 1
+
+Function: "asin_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "asin_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "asin_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "asinh":
+double: 1
+float128: 4
+
+Function: "asinh_downward":
+float128: 4
+
+Function: "asinh_towardzero":
+float128: 2
+
+Function: "asinh_upward":
+float128: 4
+
+Function: "atan":
+float128: 1
+
+Function: "atan2":
+float128: 2
+
+Function: "atan2_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "atan2_towardzero":
+float: 1
+float128: 3
+ldouble: 1
+
+Function: "atan2_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "atan_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "atan_towardzero":
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "atan_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "atanh":
+float128: 4
+
+Function: "atanh_downward":
+float: 1
+float128: 4
+
+Function: "atanh_towardzero":
+float: 1
+float128: 2
+
+Function: "atanh_upward":
+float: 1
+float128: 4
+
+Function: "cabs":
+float128: 1
+
+Function: "cabs_downward":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "cabs_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "cabs_upward":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "cacos":
+double: 1
+float: 2
+float128: 2
+ldouble: 1
+
+Function: Imaginary part of "cacos":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cacos_downward":
+double: 1
+float: 1
+float128: 3
+ldouble: 2
+
+Function: Imaginary part of "cacos_downward":
+double: 5
+float: 6
+float128: 6
+ldouble: 5
+
+Function: Real part of "cacos_towardzero":
+double: 1
+float: 1
+float128: 3
+ldouble: 2
+
+Function: Imaginary part of "cacos_towardzero":
+double: 4
+float: 5
+float128: 5
+ldouble: 4
+
+Function: Real part of "cacos_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 2
+
+Function: Imaginary part of "cacos_upward":
+double: 5
+float: 5
+float128: 7
+ldouble: 5
+
+Function: Real part of "cacosh":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "cacosh":
+double: 1
+float: 2
+float128: 2
+ldouble: 1
+
+Function: Real part of "cacosh_downward":
+double: 4
+float: 5
+float128: 5
+ldouble: 4
+
+Function: Imaginary part of "cacosh_downward":
+double: 2
+float: 2
+float128: 4
+ldouble: 3
+
+Function: Real part of "cacosh_towardzero":
+double: 4
+float: 5
+float128: 5
+ldouble: 4
+
+Function: Imaginary part of "cacosh_towardzero":
+double: 1
+float: 1
+float128: 3
+ldouble: 2
+
+Function: Real part of "cacosh_upward":
+double: 4
+float: 3
+float128: 6
+ldouble: 4
+
+Function: Imaginary part of "cacosh_upward":
+double: 3
+float: 2
+float128: 4
+ldouble: 3
+
+Function: "carg":
+float128: 2
+
+Function: "carg_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "carg_towardzero":
+float: 1
+float128: 3
+ldouble: 1
+
+Function: "carg_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: Real part of "casin":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: Imaginary part of "casin":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "casin_downward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "casin_downward":
+double: 5
+float: 6
+float128: 6
+ldouble: 5
+
+Function: Real part of "casin_towardzero":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "casin_towardzero":
+double: 4
+float: 5
+float128: 5
+ldouble: 4
+
+Function: Real part of "casin_upward":
+double: 2
+float: 1
+float128: 3
+ldouble: 2
+
+Function: Imaginary part of "casin_upward":
+double: 5
+float: 5
+float128: 7
+ldouble: 5
+
+Function: Real part of "casinh":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "casinh":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: Real part of "casinh_downward":
+double: 5
+float: 6
+float128: 6
+ldouble: 5
+
+Function: Imaginary part of "casinh_downward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "casinh_towardzero":
+double: 4
+float: 5
+float128: 5
+ldouble: 4
+
+Function: Imaginary part of "casinh_towardzero":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "casinh_upward":
+double: 5
+float: 5
+float128: 7
+ldouble: 5
+
+Function: Imaginary part of "casinh_upward":
+double: 2
+float: 1
+float128: 3
+ldouble: 2
+
+Function: Real part of "catan":
+double: 1
+float128: 1
+
+Function: Imaginary part of "catan":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "catan_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: Imaginary part of "catan_downward":
+double: 2
+float: 1
+float128: 2
+ldouble: 2
+
+Function: Real part of "catan_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: Imaginary part of "catan_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: Real part of "catan_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: Imaginary part of "catan_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "catanh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "catanh":
+double: 1
+float128: 1
+
+Function: Real part of "catanh_downward":
+double: 2
+float: 1
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "catanh_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: Real part of "catanh_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "catanh_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: Real part of "catanh_upward":
+double: 4
+float: 4
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "catanh_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "cbrt":
+float128: 1
+
+Function: "cbrt_downward":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "cbrt_towardzero":
+float: 1
+float128: 1
+
+Function: "cbrt_upward":
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "ccos":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "ccos":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "ccos_downward":
+double: 3
+float: 1
+float128: 2
+ldouble: 3
+
+Function: Imaginary part of "ccos_downward":
+double: 3
+float: 3
+float128: 2
+ldouble: 3
+
+Function: Real part of "ccos_towardzero":
+double: 3
+float: 1
+float128: 2
+ldouble: 3
+
+Function: Imaginary part of "ccos_towardzero":
+double: 3
+float: 3
+float128: 2
+ldouble: 3
+
+Function: Real part of "ccos_upward":
+double: 1
+float: 2
+float128: 3
+ldouble: 2
+
+Function: Imaginary part of "ccos_upward":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "ccosh":
+double: 1
+float: 1
+float128: 1
+
+Function: Imaginary part of "ccosh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "ccosh_downward":
+double: 3
+float: 2
+float128: 2
+ldouble: 3
+
+Function: Imaginary part of "ccosh_downward":
+double: 3
+float: 3
+float128: 2
+ldouble: 3
+
+Function: Real part of "ccosh_towardzero":
+double: 3
+float: 2
+float128: 2
+ldouble: 3
+
+Function: Imaginary part of "ccosh_towardzero":
+double: 3
+float: 3
+float128: 2
+ldouble: 3
+
+Function: Real part of "ccosh_upward":
+double: 1
+float: 2
+float128: 3
+ldouble: 2
+
+Function: Imaginary part of "ccosh_upward":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "cexp":
+double: 2
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "cexp":
+double: 1
+float: 2
+float128: 1
+ldouble: 1
+
+Function: Real part of "cexp_downward":
+double: 4
+float: 2
+float128: 2
+ldouble: 3
+
+Function: Imaginary part of "cexp_downward":
+double: 3
+float: 3
+float128: 2
+ldouble: 3
+
+Function: Real part of "cexp_towardzero":
+double: 4
+float: 2
+float128: 2
+ldouble: 3
+
+Function: Imaginary part of "cexp_towardzero":
+double: 3
+float: 3
+float128: 2
+ldouble: 3
+
+Function: Real part of "cexp_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 2
+
+Function: Imaginary part of "cexp_upward":
+double: 3
+float: 2
+float128: 3
+ldouble: 2
+
+Function: Real part of "clog":
+double: 2
+float: 3
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "clog":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "clog10":
+double: 3
+float: 4
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "clog10":
+double: 2
+float: 2
+float128: 2
+ldouble: 1
+
+Function: Real part of "clog10_downward":
+double: 4
+float: 4
+float128: 3
+ldouble: 4
+
+Function: Imaginary part of "clog10_downward":
+double: 2
+float: 2
+float128: 3
+ldouble: 2
+
+Function: Real part of "clog10_towardzero":
+double: 5
+float: 5
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "clog10_towardzero":
+double: 2
+float: 2
+float128: 3
+ldouble: 2
+
+Function: Real part of "clog10_upward":
+double: 4
+float: 5
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "clog10_upward":
+double: 2
+float: 2
+float128: 3
+ldouble: 2
+
+Function: Real part of "clog_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "clog_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: Real part of "clog_towardzero":
+double: 3
+float: 4
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "clog_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: Real part of "clog_upward":
+double: 2
+float: 3
+float128: 4
+ldouble: 3
+
+Function: Imaginary part of "clog_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "cos":
+double: 1
+float: 1
+float128: 2
+
+Function: "cos_downward":
+double: 1
+float: 1
+float128: 3
+ldouble: 1
+
+Function: "cos_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "cos_upward":
+double: 1
+float128: 2
+ldouble: 1
+
+Function: "cosh":
+float128: 2
+
+Function: "cosh_downward":
+float128: 3
+
+Function: "cosh_towardzero":
+float128: 3
+
+Function: "cosh_upward":
+float128: 3
+
+Function: Real part of "cpow":
+double: 2
+float: 5
+float128: 4
+ldouble: 3
+
+Function: Imaginary part of "cpow":
+float: 2
+float128: 1
+ldouble: 4
+
+Function: Real part of "cpow_downward":
+double: 5
+float: 8
+float128: 6
+ldouble: 7
+
+Function: Imaginary part of "cpow_downward":
+double: 2
+float: 2
+float128: 2
+ldouble: 1
+
+Function: Real part of "cpow_towardzero":
+double: 5
+float: 8
+float128: 6
+ldouble: 7
+
+Function: Imaginary part of "cpow_towardzero":
+double: 2
+float: 2
+float128: 2
+ldouble: 1
+
+Function: Real part of "cpow_upward":
+double: 4
+float: 1
+float128: 3
+ldouble: 2
+
+Function: Imaginary part of "cpow_upward":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "csin":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "csin":
+float: 1
+float128: 1
+
+Function: Real part of "csin_downward":
+double: 3
+float: 3
+float128: 2
+ldouble: 3
+
+Function: Imaginary part of "csin_downward":
+double: 3
+float: 1
+float128: 2
+ldouble: 3
+
+Function: Real part of "csin_towardzero":
+double: 3
+float: 3
+float128: 2
+ldouble: 3
+
+Function: Imaginary part of "csin_towardzero":
+double: 3
+float: 1
+float128: 2
+ldouble: 3
+
+Function: Real part of "csin_upward":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "csin_upward":
+double: 1
+float: 2
+float128: 3
+ldouble: 1
+
+Function: Real part of "csinh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Imaginary part of "csinh":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: Real part of "csinh_downward":
+double: 3
+float: 1
+float128: 2
+ldouble: 3
+
+Function: Imaginary part of "csinh_downward":
+double: 3
+float: 3
+float128: 2
+ldouble: 3
+
+Function: Real part of "csinh_towardzero":
+double: 3
+float: 1
+float128: 2
+ldouble: 3
+
+Function: Imaginary part of "csinh_towardzero":
+double: 3
+float: 3
+float128: 2
+ldouble: 3
+
+Function: Real part of "csinh_upward":
+double: 1
+float: 2
+float128: 3
+ldouble: 1
+
+Function: Imaginary part of "csinh_upward":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "csqrt":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Imaginary part of "csqrt":
+double: 2
+float: 2
+float128: 2
+ldouble: 2
+
+Function: Real part of "csqrt_downward":
+double: 4
+float: 4
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "csqrt_downward":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "csqrt_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Imaginary part of "csqrt_towardzero":
+double: 3
+float: 3
+float128: 3
+ldouble: 3
+
+Function: Real part of "csqrt_upward":
+double: 4
+float: 4
+float128: 4
+ldouble: 4
+
+Function: Imaginary part of "csqrt_upward":
+double: 3
+float: 2
+float128: 3
+ldouble: 3
+
+Function: Real part of "ctan":
+double: 1
+float: 1
+float128: 3
+ldouble: 2
+
+Function: Imaginary part of "ctan":
+double: 2
+float: 1
+float128: 3
+ldouble: 2
+
+Function: Real part of "ctan_downward":
+double: 4
+float: 4
+float128: 4
+ldouble: 2
+
+Function: Imaginary part of "ctan_downward":
+double: 3
+float: 2
+float128: 5
+ldouble: 2
+
+Function: Real part of "ctan_towardzero":
+double: 2
+float: 2
+float128: 4
+ldouble: 2
+
+Function: Imaginary part of "ctan_towardzero":
+double: 3
+float: 2
+float128: 5
+ldouble: 4
+
+Function: Real part of "ctan_upward":
+double: 2
+float: 3
+float128: 5
+ldouble: 5
+
+Function: Imaginary part of "ctan_upward":
+double: 6
+float: 2
+float128: 5
+ldouble: 7
+
+Function: Real part of "ctanh":
+double: 2
+float: 1
+float128: 3
+ldouble: 1
+
+Function: Imaginary part of "ctanh":
+double: 2
+float: 1
+float128: 3
+ldouble: 2
+
+Function: Real part of "ctanh_downward":
+double: 3
+float: 2
+float128: 5
+ldouble: 1
+
+Function: Imaginary part of "ctanh_downward":
+double: 4
+float: 4
+float128: 4
+ldouble: 2
+
+Function: Real part of "ctanh_towardzero":
+double: 3
+float: 2
+float128: 5
+ldouble: 4
+
+Function: Imaginary part of "ctanh_towardzero":
+double: 2
+float: 1
+float128: 3
+ldouble: 1
+
+Function: Real part of "ctanh_upward":
+double: 6
+float: 2
+float128: 5
+ldouble: 7
+
+Function: Imaginary part of "ctanh_upward":
+double: 2
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "erf":
+float128: 1
+
+Function: "erf_downward":
+float128: 2
+
+Function: "erf_towardzero":
+float128: 1
+
+Function: "erf_upward":
+float128: 2
+
+Function: "erfc":
+float128: 4
+
+Function: "erfc_downward":
+double: 1
+float128: 5
+
+Function: "erfc_towardzero":
+double: 1
+float128: 4
+
+Function: "erfc_upward":
+double: 1
+float128: 5
+
+Function: "exp":
+float: 1
+float128: 1
+
+Function: "exp10":
+float: 1
+float128: 2
+
+Function: "exp10_downward":
+float: 1
+float128: 3
+
+Function: "exp10_towardzero":
+float: 1
+float128: 3
+
+Function: "exp10_upward":
+float: 1
+float128: 3
+
+Function: "exp2":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "exp2_downward":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "exp2_towardzero":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "exp2_upward":
+double: 1
+float128: 2
+ldouble: 1
+
+Function: "expm1":
+double: 1
+float128: 2
+ldouble: 1
+
+Function: "expm1_downward":
+float128: 2
+ldouble: 1
+
+Function: "expm1_towardzero":
+float128: 4
+
+Function: "expm1_upward":
+float128: 3
+
+Function: "gamma":
+float: 1
+
+Function: "gamma_downward":
+double: 1
+float: 1
+
+Function: "gamma_towardzero":
+double: 1
+float: 1
+
+Function: "gamma_upward":
+double: 1
+float: 1
+
+Function: "hypot":
+float128: 1
+
+Function: "hypot_downward":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "hypot_towardzero":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "hypot_upward":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "j0":
+double: 3
+float: 9
+float128: 2
+ldouble: 8
+
+Function: "j0_downward":
+double: 9
+float: 9
+float128: 9
+ldouble: 4
+
+Function: "j0_towardzero":
+double: 5
+float: 9
+float128: 9
+ldouble: 9
+
+Function: "j0_upward":
+double: 4
+float: 9
+float128: 7
+ldouble: 5
+
+Function: "j1":
+double: 4
+float: 9
+float128: 4
+ldouble: 6
+
+Function: "j1_downward":
+double: 7
+float: 8
+float128: 4
+ldouble: 4
+
+Function: "j1_towardzero":
+double: 3
+float: 8
+float128: 4
+ldouble: 4
+
+Function: "j1_upward":
+double: 6
+float: 9
+float128: 3
+ldouble: 5
+
+Function: "jn":
+double: 4
+float: 4
+float128: 7
+ldouble: 4
+
+Function: "jn_downward":
+double: 4
+float: 5
+float128: 8
+ldouble: 4
+
+Function: "jn_towardzero":
+double: 4
+float: 5
+float128: 8
+ldouble: 5
+
+Function: "jn_upward":
+double: 5
+float: 4
+float128: 7
+ldouble: 5
+
+Function: "lgamma":
+float: 1
+float128: 5
+
+Function: "lgamma_downward":
+double: 1
+float: 1
+float128: 8
+
+Function: "lgamma_towardzero":
+double: 1
+float: 1
+float128: 5
+
+Function: "lgamma_upward":
+double: 1
+float: 1
+float128: 8
+
+Function: "log":
+float128: 1
+
+Function: "log10":
+float128: 2
+
+Function: "log10_downward":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "log10_towardzero":
+double: 1
+float128: 1
+ldouble: 1
+
+Function: "log10_upward":
+double: 1
+float: 1
+float128: 1
+ldouble: 1
+
+Function: "log1p":
+float128: 3
+
+Function: "log1p_downward":
+double: 1
+float128: 3
+
+Function: "log1p_towardzero":
+double: 1
+float128: 3
+
+Function: "log1p_upward":
+double: 1
+float128: 2
+
+Function: "log2":
+float128: 3
+
+Function: "log2_downward":
+float128: 3
+
+Function: "log2_towardzero":
+float128: 1
+
+Function: "log2_upward":
+float128: 1
+
+Function: "log_downward":
+double: 1
+float128: 1
+
+Function: "log_towardzero":
+double: 1
+float128: 2
+
+Function: "log_upward":
+double: 1
+float128: 1
+
+Function: "pow":
+float128: 2
+
+Function: "pow_downward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "pow_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "pow_upward":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "sin":
+double: 1
+float128: 2
+
+Function: "sin_downward":
+double: 1
+float: 1
+float128: 3
+ldouble: 1
+
+Function: "sin_towardzero":
+double: 1
+float: 1
+float128: 2
+ldouble: 1
+
+Function: "sin_upward":
+double: 1
+float: 1
+float128: 3
+ldouble: 1
+
+Function: "sincos":
+double: 1
+float128: 1
+
+Function: "sincos_downward":
+double: 1
+float: 1
+float128: 3
+
+Function: "sincos_towardzero":
+double: 1
+float: 1
+float128: 2
+
+Function: "sincos_upward":
+double: 1
+float: 1
+float128: 3
+
+Function: "sinh":
+float128: 2
+
+Function: "sinh_downward":
+float128: 3
+
+Function: "sinh_towardzero":
+float128: 3
+
+Function: "sinh_upward":
+float128: 4
+
+Function: "tan":
+float128: 1
+ldouble: 1
+
+Function: "tan_downward":
+float128: 1
+ldouble: 1
+
+Function: "tan_towardzero":
+float128: 1
+ldouble: 1
+
+Function: "tan_upward":
+float128: 1
+ldouble: 1
+
+Function: "tanh":
+float128: 2
+
+Function: "tanh_downward":
+float128: 4
+
+Function: "tanh_towardzero":
+float128: 3
+
+Function: "tanh_upward":
+float128: 3
+
+Function: "tgamma":
+float128: 4
+ldouble: 1
+
+Function: "tgamma_downward":
+double: 1
+float: 1
+float128: 5
+ldouble: 1
+
+Function: "tgamma_towardzero":
+double: 1
+float: 1
+float128: 5
+ldouble: 1
+
+Function: "tgamma_upward":
+double: 1
+float: 1
+float128: 4
+ldouble: 1
+
+Function: "y0":
+double: 2
+float: 8
+float128: 3
+ldouble: 1
+
+Function: "y0_downward":
+double: 4
+float: 8
+float128: 7
+ldouble: 4
+
+Function: "y0_towardzero":
+double: 3
+float: 8
+float128: 3
+ldouble: 7
+
+Function: "y0_upward":
+double: 4
+float: 8
+float128: 4
+ldouble: 7
+
+Function: "y1":
+double: 3
+float: 9
+float128: 5
+ldouble: 5
+
+Function: "y1_downward":
+double: 9
+float: 8
+float128: 5
+ldouble: 3
+
+Function: "y1_towardzero":
+double: 3
+float: 9
+float128: 2
+ldouble: 3
+
+Function: "y1_upward":
+double: 6
+float: 9
+float128: 5
+ldouble: 7
+
+Function: "yn":
+double: 3
+float: 3
+float128: 5
+ldouble: 3
+
+Function: "yn_downward":
+double: 4
+float: 4
+float128: 5
+ldouble: 4
+
+Function: "yn_towardzero":
+double: 3
+float: 3
+float128: 5
+ldouble: 5
+
+Function: "yn_upward":
+double: 4
+float: 5
+float128: 5
+ldouble: 3
+
+# end of automatic generation
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm-test-ulps-name
@@ -0,0 +1 @@
+IA64
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_cpu_defs.h
@@ -0,0 +1,155 @@
+/* file: libm_cpu_defs.h */
+
+
+// Copyright (c) 2000 - 2004, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+
+#ifndef __LIBM_CPU_DEFS__H_INCLUDED__
+#define __LIBM_CPU_DEFS__H_INCLUDED__
+
+void __libm_sincos_pi4(double,double*,double*,int);
+void __libm_y0y1(double , double *, double *);
+void __libm_j0j1(double , double *, double *);
+double __libm_j0(double);
+double __libm_j1(double);
+double __libm_jn(int,double);
+double __libm_y0(double);
+double __libm_y1(double);
+double __libm_yn(int,double);
+
+double __libm_copysign (double, double);
+float __libm_copysignf (float, float);
+long double __libm_copysignl (long double, long double);
+
+extern double sqrt(double);
+extern double fabs(double);
+extern double log(double);
+extern double log1p(double);
+extern double sqrt(double);
+extern double sin(double);
+extern double exp(double);
+extern double modf(double, double *);
+extern double asinh(double);
+extern double acosh(double);
+extern double atanh(double);
+extern double tanh(double);
+extern double erf(double);
+extern double erfc(double);
+extern double j0(double);
+extern double j1(double);
+extern double jn(int, double);
+extern double y0(double);
+extern double y1(double);
+extern double yn(int, double);
+
+extern float  fabsf(float);
+extern float  asinhf(float);
+extern float  acoshf(float);
+extern float  atanhf(float);
+extern float  tanhf(float);
+extern float  erff(float);
+extern float  erfcf(float);
+extern float  j0f(float);
+extern float  j1f(float);
+extern float  jnf(int, float);
+extern float  y0f(float);
+extern float  y1f(float);
+extern float  ynf(int, float);
+
+extern long double log1pl(long double);
+extern long double logl(long double);
+extern long double sqrtl(long double);
+extern long double expl(long double);
+extern long double fabsl(long double);
+
+#if !(defined(SIZE_LONG_INT_32) || defined(SIZE_LONG_INT_64))
+#error long int size not established; define SIZE_LONG_INT_32 or SIZE_LONG_INT_64
+#endif
+
+#if (defined(SIZE_LONG_INT_32) && defined(SIZE_LONG_INT_64))
+#error multiple long int size definitions; define SIZE_LONG_INT_32 or SIZE_LONG_INT_64
+#endif
+
+#if !(defined(SIZE_LONG_LONG_INT_32) || defined(SIZE_LONG_LONG_INT_64))
+#error long long int size not established; define SIZE_LONG_LONG_INT_32 or SIZE_LONG_LONG_INT_64
+#endif
+
+#if (defined(SIZE_LONG_LONG_INT_32) && defined(SIZE_LONG_LONG_INT_64))
+#error multiple long long int size definitions; define SIZE_LONG_LONG_INT_32 or SIZE_LONG_LONG_INT_64
+#endif
+
+#define HI_SIGNIFICAND_LESS(X, HI) ((X)->hi_significand < 0x ## HI)
+#define f64abs(x) ((x) < 0.0 ? -(x) : (x))
+
+#define FP80_DECLARE()
+#define FP80_SET()
+#define FP80_RESET()
+
+#ifdef _LIBC
+# include <math.h>
+#else
+
+static const unsigned INF[] = {
+    DOUBLE_HEX(7ff00000, 00000000),
+    DOUBLE_HEX(fff00000, 00000000)
+};
+
+static const double _zeroo = 0.0;
+static const double _bigg = 1.0e300;
+static const double _ponee = 1.0;
+static const double _nonee = -1.0;
+
+#define INVALID    (_zeroo * *((double*)&INF[0]))
+#define PINF       *((double*)&INF[0])
+#define NINF       -PINF
+#define PINF_DZ    (_ponee/_zeroo)
+#define X_TLOSS    1.41484755040568800000e+16
+#endif
+
+/* Set these appropriately to make thread Safe */
+#define ERRNO_RANGE  errno = ERANGE
+#define ERRNO_DOMAIN errno = EDOM
+
+#ifndef _LIBC
+#if defined(__ICC) || defined(__ICL) || defined(__ECC) || defined(__ECL)
+# pragma warning( disable : 68 )	/* #68: integer conversion resulted in a change of sign */
+# pragma warning( disable : 186 )	/* #186: pointless comparison of unsigned integer with zero */
+# pragma warning( disable : 1572 )	/* #1572: floating-point equality and inequality comparisons are unreliable */
+#endif
+#endif
+
+#endif    /*__LIBM_CPU_DEFS__H_INCLUDED__*/
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_error.c
@@ -0,0 +1,4301 @@
+/* file: libm_error.c */
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+//  2/02/00: Initial version
+//  3/22/00: Updated to support flexible and dynamic error handling.
+//  8/16/00: Changed all matherr function-calls to use the pmatherr
+//           function-pointers.
+// 10/03/00: Corrected a scalb type.
+// 11/28/00: Changed INPUT_XL to INPUT_XD for scalb_underflow case.
+// 12/07/00: Added code to make scalbn error support equivalent to ldexp.
+//  2/07/01: Added __declspec(align(16)) to long double constants to correct
+//           alignment problem.
+//  4/23/01: Added code for remquo
+//  6/07/01: Added code for fdim, lrint, lround, llrint, llround
+//           Deleted code for remquo
+//  8/15/01: Added code for scalbln, nexttoward
+// 12/10/01: Added code for erfc
+// 12/27/01: Added code for degree argument functions
+// 01/02/02: Added code for tand, cotd
+// 01/15/02: Corrected SVID/XOPEN code for log1p, pow, and acosh
+// 01/25/02: Corrected ISOC for lgamma and gamma to return EDOM for neg ints
+// 01/28/02: Corrected SVID/XOPEN stderr message for log2
+// 05/20/02: Added code for cot
+// 07/01/02: Added code for sinhcosh
+// 10/04/02: Underflow detection in ISOC path redefined to
+//           be zero rather than tiny and inexact
+// 12/06/02: Added code for annuity and compound
+// 01/30/03: Corrected test for underflow in ISOC path to not set denormal
+// 04/10/03: Corrected ISOC branch for gamma/lgamma to return ERANGE for neg ints.
+//           Added code for tgamma
+// 04/11/03: Corrected POSIX/SVID/XOPEN branches for gamma/lgamma
+//           to return EDOM for neg ints.
+// 09/08/03: Corrected XOPEN/SVID result for pow overflow with neg x, pos y.
+// 10/14/03: Added ILP32 ifdef
+// 12/12/03: Corrected XOPEN/SVID results for powf_zero_to_negative,
+//           powl_neg_to_non_integer, atan2f_zero, atan2df_zero,
+//           acoshf_lt_one, acosh_lt_one.
+// 12/07/04: Cast name strings as char *.
+// 12/08/04: Corrected POSIX behavior for atan2_zero, acos_gt_one, asin_gt_one,
+//           log_negative, log10_negative, log1p_negative, and log2_negative.
+//           Added SVID and XOPEN case log2l_zero.
+// 12/13/04: Corrected POSIX behavior for exp2_overflow, exp2_underflow,
+//           exp10_overflow, exp10_underflow.  Added ISOC to set errno for
+//           exp10_underflow.
+// 12/14/04: Corrected POSIX behavior for nextafter_overflow,
+//           nextafter_underflow, nexttoward_overflow, nexttoward_underflow.
+//           Added ISOC to set errno for nextafter and nexttoward underflow.
+// 12/15/04: Corrected POSIX behavior for exp, exp2, and exp10 underflow.
+// 03/31/05: Added missing ALIGNIT statement to 6 float constants.
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "libm_support.h"
+#include <math-svid-compat.h>
+
+#ifdef _LIBC
+# define pmatherr matherr
+# define pmatherrf matherrf
+# define pmatherrl matherrl
+# if LIBM_SVID_COMPAT
+compat_symbol_reference (libm, matherrf, matherrf, GLIBC_2_2_3);
+compat_symbol_reference (libm, matherrl, matherrl, GLIBC_2_2_3);
+# else
+#  define matherrf(EXC) ((void) (EXC), 0)
+#  define matherrl(EXC) ((void) (EXC), 0)
+# endif
+#else
+_LIB_VERSION_TYPE
+#if defined( __POSIX__ )
+_LIB_VERSIONIMF = _POSIX_;
+#elif defined( __XOPEN__ )
+_LIB_VERSIONIMF = _XOPEN_;
+#elif defined( __SVID__ )
+_LIB_VERSIONIMF = _SVID_;
+#elif defined( __IEEE__ )
+_LIB_VERSIONIMF = _IEEE_;
+#else
+_LIB_VERSIONIMF = _ISOC_;
+#endif
+
+/************************************************************/
+/* matherrX function pointers and setusermatherrX functions */
+/************************************************************/
+int (*pmatherrf)(struct exceptionf*) = MATHERR_F;
+int (*pmatherr)(struct EXC_DECL_D*) = MATHERR_D;
+int (*pmatherrl)(struct exceptionl*) = matherrl;
+
+void __libm_setusermatherrf( int(*user_merrf)(struct exceptionf*) )
+{   pmatherrf = ( (user_merrf==NULL)? (MATHERR_F) : (user_merrf) ); }
+
+void __libm_setusermatherr( int(*user_merr)(struct EXC_DECL_D*) )
+{   pmatherr = ( (user_merr==NULL)? (MATHERR_D) : (user_merr) );    }
+
+void __libm_setusermatherrl( int(*user_merrl)(struct exceptionl*) )
+{   pmatherrl = ( (user_merrl==NULL)? (matherrl) : (user_merrl) );  }
+
+#endif /* !_LIBC */
+
+/***********************************************/
+/* error-handling function, libm_error_support */
+/***********************************************/
+void __libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
+{
+
+# ifdef __cplusplus
+struct __exception exc;
+# else
+struct exception  exc;
+# endif
+
+struct exceptionf excf;
+struct exceptionl excl;
+
+# ifdef __GNUC__
+#define ALIGNIT __attribute__ ((__aligned__ (16)))
+# elif defined opensource
+#define ALIGNIT
+# else
+#define ALIGNIT __declspec(align(16))
+# endif
+
+# ifdef SIZE_LONG_INT_64
+#define __INT_64__ signed long
+# else
+# if ILP32
+#define __INT_64__ signed long long
+# else
+#define __INT_64__ __int64
+# endif
+# endif
+
+
+#define _DECL_NUM(type, prefix, var, bytes...)	\
+  ALIGNIT static const union {			\
+    const char _bytes[sizeof (type)];		\
+    const type num;				\
+  } prefix ## var = {				\
+    ._bytes = bytes,				\
+  }
+
+#define DECL_FLOAT(var, bytes...) \
+  _DECL_NUM (float, float_, var, ##bytes)
+
+DECL_FLOAT(inf,      {0x00,0x00,0x80,0x7F});
+DECL_FLOAT(huge,     {0xFF,0xFF,0x7F,0x7F});
+DECL_FLOAT(zero,     {0x00,0x00,0x00,0x00});
+DECL_FLOAT(neg_inf,  {0x00,0x00,0x80,0xFF});
+DECL_FLOAT(neg_huge, {0xFF,0xFF,0x7F,0xFF});
+DECL_FLOAT(neg_zero, {0x00,0x00,0x00,0x80});
+
+#define DECL_DOUBLE(var, bytes...) \
+  _DECL_NUM (double, double_, var, ##bytes)
+
+DECL_DOUBLE(inf,      {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x7F});
+#ifndef _LIBC
+DECL_DOUBLE(huge,     {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0x7F});
+#endif
+DECL_DOUBLE(zero,     {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00});
+DECL_DOUBLE(neg_inf,  {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFF});
+#ifndef _LIBC
+DECL_DOUBLE(neg_huge, {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xFF});
+#endif
+DECL_DOUBLE(neg_zero, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80});
+
+#define DECL_LONG_DOUBLE(var, bytes...) \
+  _DECL_NUM (long double, long_double_, var, ##bytes)
+
+DECL_LONG_DOUBLE(inf,      {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00});
+#ifndef _LIBC
+DECL_LONG_DOUBLE(huge,     {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x7F,0x00,0x00,0x00,0x00,0x00,0x00});
+#endif
+DECL_LONG_DOUBLE(zero,     {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00});
+DECL_LONG_DOUBLE(neg_inf,  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00});
+#ifndef _LIBC
+DECL_LONG_DOUBLE(neg_huge, {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0x00,0x00,0x00,0x00,0x00,0x00});
+#endif
+DECL_LONG_DOUBLE(neg_zero, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00});
+
+
+#define RETVAL_HUGE_VALL *(long double *)retval =  long_double_inf.num
+#define RETVAL_NEG_HUGE_VALL *(long double *)retval = long_double_neg_inf.num
+#define RETVAL_HUGEL *(long double *)retval = (long double)float_huge.num
+#define RETVAL_NEG_HUGEL *(long double *)retval = (long double)float_neg_huge.num
+
+#define RETVAL_HUGE_VALD *(double *)retval = double_inf.num
+#define RETVAL_NEG_HUGE_VALD *(double *)retval = double_neg_inf.num
+#define RETVAL_HUGED *(double *)retval = (double)float_huge.num
+#define RETVAL_NEG_HUGED *(double *)retval = (double)float_neg_huge.num
+
+#define RETVAL_HUGE_VALF *(float *)retval =  float_inf.num
+#define RETVAL_NEG_HUGE_VALF *(float *)retval = float_neg_inf.num
+#define RETVAL_HUGEF *(float *)retval = float_huge.num
+#define RETVAL_NEG_HUGEF *(float *)retval = float_neg_huge.num
+
+#define ZEROL_VALUE long_double_zero.num
+#define ZEROD_VALUE double_zero.num
+#define ZEROF_VALUE float_zero.num
+
+#define RETVAL_ZEROL *(long double *)retval = long_double_zero.num
+#define RETVAL_ZEROD *(double *)retval = double_zero.num
+#define RETVAL_ZEROF *(float *)retval = float_zero.num
+
+#define RETVAL_NEG_ZEROL *(long double *)retval = long_double_neg_zero.num
+#define RETVAL_NEG_ZEROD *(double *)retval = double_neg_zero.num
+#define RETVAL_NEG_ZEROF *(float *)retval = float_neg_zero.num
+
+#define RETVAL_ONEL *(long double *)retval = (long double) 1.0
+#define RETVAL_ONED *(double *)retval = 1.0
+#define RETVAL_ONEF *(float *)retval = 1.0f
+
+#define NOT_MATHERRL excl.arg1=*(long double *)arg1;excl.arg2=*(long double *)arg2;excl.retval=*(long double *)retval;if(!pmatherrl(&excl))
+#define NOT_MATHERRD exc.arg1=*(double *)arg1;exc.arg2=*(double *)arg2;exc.retval=*(double *)retval;if(!pmatherr(&exc))
+#define NOT_MATHERRF excf.arg1=*(float *)arg1;excf.arg2=*(float *)arg2;excf.retval=*(float *)retval;if(!pmatherrf(&excf))
+
+#define ifSVID if(_LIB_VERSIONIMF==_SVID_)
+
+#define NAMEL excl.name
+#define NAMED exc.name
+#define NAMEF excf.name
+
+//
+// These should work OK for MS because they are ints -
+// leading underbars are not necessary.
+//
+
+#define DOMAIN          1
+#define SING            2
+#define OVERFLOW        3
+#define UNDERFLOW       4
+#define TLOSS           5
+#define PLOSS           6
+
+#define SINGL excl.type = SING
+#define DOMAINL excl.type = DOMAIN
+#define OVERFLOWL excl.type = OVERFLOW
+#define UNDERFLOWL excl.type = UNDERFLOW
+#define TLOSSL excl.type = TLOSS
+#define SINGD exc.type = SING
+#define DOMAIND exc.type = DOMAIN
+#define OVERFLOWD exc.type = OVERFLOW
+#define UNDERFLOWD exc.type = UNDERFLOW
+#define TLOSSD exc.type = TLOSS
+#define SINGF excf.type = SING
+#define DOMAINF excf.type = DOMAIN
+#define OVERFLOWF excf.type = OVERFLOW
+#define UNDERFLOWF excf.type = UNDERFLOW
+#define TLOSSF excf.type = TLOSS
+
+#define INPUT_XL (excl.arg1=*(long double*)arg1)
+#define INPUT_XD (exc.arg1=*(double*)arg1)
+#define INPUT_XF (excf.arg1=*(float*)arg1)
+#define INPUT_YL (excl.arg2=*(long double*)arg2)
+#define INPUT_YD (exc.arg2=*(double*)arg2)
+#define INPUT_YF (excf.arg2=*(float*)arg2)
+#define INPUT_RESL (*(long double *)retval)
+#define INPUT_RESD (*(double *)retval)
+#define INPUT_RESF (*(float *)retval)
+#define INPUT_RESI64 (*(__INT_64__ *)retval)
+
+#define WRITEL_LOG_ZERO fputs("logl: SING error\n",stderr)
+#define WRITED_LOG_ZERO fputs("log: SING error\n",stderr)
+#define WRITEF_LOG_ZERO fputs("logf: SING error\n",stderr)
+#define WRITEL_LOG_NEGATIVE fputs("logl: DOMAIN error\n",stderr)
+#define WRITED_LOG_NEGATIVE fputs("log: DOMAIN error\n",stderr)
+#define WRITEF_LOG_NEGATIVE fputs("logf: DOMAIN error\n",stderr)
+#define WRITEL_Y0_ZERO fputs("y0l: DOMAIN error\n",stderr)
+#define WRITED_Y0_ZERO fputs("y0: DOMAIN error\n",stderr)
+#define WRITEF_Y0_ZERO fputs("y0f: DOMAIN error\n",stderr)
+#define WRITEL_Y0_NEGATIVE fputs("y0l: DOMAIN error\n",stderr)
+#define WRITED_Y0_NEGATIVE fputs("y0: DOMAIN error\n",stderr)
+#define WRITEF_Y0_NEGATIVE fputs("y0f: DOMAIN error\n",stderr)
+#define WRITEL_Y1_ZERO fputs("y1l: DOMAIN error\n",stderr)
+#define WRITED_Y1_ZERO fputs("y1: DOMAIN error\n",stderr)
+#define WRITEF_Y1_ZERO fputs("y1f: DOMAIN error\n",stderr)
+#define WRITEL_Y1_NEGATIVE fputs("y1l: DOMAIN error\n",stderr)
+#define WRITED_Y1_NEGATIVE fputs("y1: DOMAIN error\n",stderr)
+#define WRITEF_Y1_NEGATIVE fputs("y1f: DOMAIN error\n",stderr)
+#define WRITEL_YN_ZERO fputs("ynl: DOMAIN error\n",stderr)
+#define WRITED_YN_ZERO fputs("yn: DOMAIN error\n",stderr)
+#define WRITEF_YN_ZERO fputs("ynf: DOMAIN error\n",stderr)
+#define WRITEL_YN_NEGATIVE fputs("ynl: DOMAIN error\n",stderr)
+#define WRITED_YN_NEGATIVE fputs("yn: DOMAIN error\n",stderr)
+#define WRITEF_YN_NEGATIVE fputs("ynf: DOMAIN error\n",stderr)
+#define WRITEL_LOG1P_ZERO fputs("log1pl: SING error\n",stderr)
+#define WRITED_LOG1P_ZERO fputs("log1p: SING error\n",stderr)
+#define WRITEF_LOG1P_ZERO fputs("log1pf: SING error\n",stderr)
+#define WRITEL_LOG1P_NEGATIVE fputs("log1pl: DOMAIN error\n",stderr)
+#define WRITED_LOG1P_NEGATIVE fputs("log1p: DOMAIN error\n",stderr)
+#define WRITEF_LOG1P_NEGATIVE fputs("log1pf: DOMAIN error\n",stderr)
+#define WRITEL_LOG10_ZERO fputs("log10l: SING error\n",stderr)
+#define WRITED_LOG10_ZERO fputs("log10: SING error\n",stderr)
+#define WRITEF_LOG10_ZERO fputs("log10f: SING error\n",stderr)
+#define WRITEL_LOG10_NEGATIVE fputs("log10l: DOMAIN error\n",stderr)
+#define WRITED_LOG10_NEGATIVE fputs("log10: DOMAIN error\n",stderr)
+#define WRITEF_LOG10_NEGATIVE fputs("log10f: DOMAIN error\n",stderr)
+#define WRITEL_LOG2_ZERO fputs("log2l: SING error\n",stderr)
+#define WRITED_LOG2_ZERO fputs("log2: SING error\n",stderr)
+#define WRITEF_LOG2_ZERO fputs("log2f: SING error\n",stderr)
+#define WRITEL_LOG2_NEGATIVE fputs("log2l: DOMAIN error\n",stderr)
+#define WRITED_LOG2_NEGATIVE fputs("log2: DOMAIN error\n",stderr)
+#define WRITEF_LOG2_NEGATIVE fputs("log2f: DOMAIN error\n",stderr)
+#define WRITEL_POW_ZERO_TO_ZERO fputs("powl(0,0): DOMAIN error\n",stderr)
+#define WRITED_POW_ZERO_TO_ZERO fputs("pow(0,0): DOMAIN error\n",stderr)
+#define WRITEF_POW_ZERO_TO_ZERO fputs("powf(0,0): DOMAIN error\n",stderr)
+#define WRITEL_POW_ZERO_TO_NEGATIVE fputs("powl(0,negative): DOMAIN error\n",stderr)
+#define WRITED_POW_ZERO_TO_NEGATIVE fputs("pow(0,negative): DOMAIN error\n",stderr)
+#define WRITEF_POW_ZERO_TO_NEGATIVE fputs("powf(0,negative): DOMAIN error\n",stderr)
+#define WRITEL_POW_NEG_TO_NON_INTEGER fputs("powl(negative,non-integer): DOMAIN error\n",stderr)
+#define WRITED_POW_NEG_TO_NON_INTEGER fputs("pow(negative,non-integer): DOMAIN error\n",stderr)
+#define WRITEF_POW_NEG_TO_NON_INTEGER fputs("powf(negative,non-integer): DOMAIN error\n",stderr)
+#define WRITEL_ATAN2_ZERO_BY_ZERO fputs("atan2l: DOMAIN error\n",stderr)
+#define WRITED_ATAN2_ZERO_BY_ZERO fputs("atan2: DOMAIN error\n",stderr)
+#define WRITEF_ATAN2_ZERO_BY_ZERO fputs("atan2f: DOMAIN error\n",stderr)
+#define WRITEL_SQRT fputs("sqrtl: DOMAIN error\n",stderr)
+#define WRITED_SQRT fputs("sqrt: DOMAIN error\n",stderr)
+#define WRITEF_SQRT fputs("sqrtf: DOMAIN error\n",stderr)
+#define WRITEL_FMOD fputs("fmodl: DOMAIN error\n",stderr)
+#define WRITED_FMOD fputs("fmod: DOMAIN error\n",stderr)
+#define WRITEF_FMOD fputs("fmodf: DOMAIN error\n",stderr)
+#define WRITEL_REM fputs("remainderl: DOMAIN error\n",stderr)
+#define WRITED_REM fputs("remainder: DOMAIN error\n",stderr)
+#define WRITEF_REM fputs("remainderf: DOMAIN error\n",stderr)
+#define WRITEL_ACOS fputs("acosl: DOMAIN error\n",stderr)
+#define WRITED_ACOS fputs("acos: DOMAIN error\n",stderr)
+#define WRITEF_ACOS fputs("acosf: DOMAIN error\n",stderr)
+#define WRITEL_ASIN fputs("asinl: DOMAIN error\n",stderr)
+#define WRITED_ASIN fputs("asin: DOMAIN error\n",stderr)
+#define WRITEF_ASIN fputs("asinf: DOMAIN error\n",stderr)
+#define WRITEL_ACOSH fputs("acoshl: DOMAIN error\n",stderr)
+#define WRITED_ACOSH fputs("acosh: DOMAIN error\n",stderr)
+#define WRITEF_ACOSH fputs("acoshf: DOMAIN error\n",stderr)
+#define WRITEL_ATANH_GT_ONE fputs("atanhl: DOMAIN error\n",stderr)
+#define WRITED_ATANH_GT_ONE fputs("atanh: DOMAIN error\n",stderr)
+#define WRITEF_ATANH_GT_ONE fputs("atanhf: DOMAIN error\n",stderr)
+#define WRITEL_ATANH_EQ_ONE fputs("atanhl: SING error\n",stderr)
+#define WRITED_ATANH_EQ_ONE fputs("atanh: SING error\n",stderr)
+#define WRITEF_ATANH_EQ_ONE fputs("atanhf: SING error\n",stderr)
+#define WRITEL_LGAMMA_NEGATIVE fputs("lgammal: SING error\n",stderr)
+#define WRITED_LGAMMA_NEGATIVE fputs("lgamma: SING error\n",stderr)
+#define WRITEF_LGAMMA_NEGATIVE fputs("lgammaf: SING error\n",stderr)
+#define WRITEL_GAMMA_NEGATIVE fputs("gammal: SING error\n",stderr)
+#define WRITED_GAMMA_NEGATIVE fputs("gamma: SING error\n",stderr)
+#define WRITEF_GAMMA_NEGATIVE fputs("gammaf: SING error\n",stderr)
+#define WRITEL_TGAMMA_NEGATIVE fputs("tgammal: SING error\n",stderr)
+#define WRITED_TGAMMA_NEGATIVE fputs("tgamma: SING error\n",stderr)
+#define WRITEF_TGAMMA_NEGATIVE fputs("tgammaf: SING error\n",stderr)
+#define WRITEL_J0_TLOSS  fputs("j0l: TLOSS error\n",stderr)
+#define WRITEL_Y0_TLOSS  fputs("y0l: TLOSS error\n",stderr)
+#define WRITEL_J1_TLOSS  fputs("j1l: TLOSS error\n",stderr)
+#define WRITEL_Y1_TLOSS  fputs("y1l: TLOSS error\n",stderr)
+#define WRITEL_JN_TLOSS  fputs("jnl: TLOSS error\n",stderr)
+#define WRITEL_YN_TLOSS  fputs("ynl: TLOSS error\n",stderr)
+#define WRITED_J0_TLOSS  fputs("j0: TLOSS error\n",stderr)
+#define WRITED_Y0_TLOSS  fputs("y0: TLOSS error\n",stderr)
+#define WRITED_J1_TLOSS  fputs("j1: TLOSS error\n",stderr)
+#define WRITED_Y1_TLOSS  fputs("y1: TLOSS error\n",stderr)
+#define WRITED_JN_TLOSS  fputs("jn: TLOSS error\n",stderr)
+#define WRITED_YN_TLOSS  fputs("yn: TLOSS error\n",stderr)
+#define WRITEF_J0_TLOSS  fputs("j0f: TLOSS error\n",stderr)
+#define WRITEF_Y0_TLOSS  fputs("y0f: TLOSS error\n",stderr)
+#define WRITEF_J1_TLOSS  fputs("j1f: TLOSS error\n",stderr)
+#define WRITEF_Y1_TLOSS  fputs("y1f: TLOSS error\n",stderr)
+#define WRITEF_JN_TLOSS  fputs("jnf: TLOSS error\n",stderr)
+#define WRITEF_YN_TLOSS  fputs("ynf: TLOSS error\n",stderr)
+#define WRITEL_ACOSD fputs("acosdl: DOMAIN error\n",stderr)
+#define WRITED_ACOSD fputs("acosd: DOMAIN error\n",stderr)
+#define WRITEF_ACOSD fputs("acosdf: DOMAIN error\n",stderr)
+#define WRITEL_ASIND fputs("asindl: DOMAIN error\n",stderr)
+#define WRITED_ASIND fputs("asind: DOMAIN error\n",stderr)
+#define WRITEF_ASIND fputs("asindf: DOMAIN error\n",stderr)
+#define WRITEL_ATAN2D_ZERO_BY_ZERO fputs("atan2dl: DOMAIN error\n",stderr)
+#define WRITED_ATAN2D_ZERO_BY_ZERO fputs("atan2d: DOMAIN error\n",stderr)
+#define WRITEF_ATAN2D_ZERO_BY_ZERO fputs("atan2df: DOMAIN error\n",stderr)
+
+
+/***********************/
+/* IEEE Path           */
+/***********************/
+if(_LIB_VERSIONIMF==_IEEE_) return;
+
+/***********************/
+/* C9X Path           */
+/***********************/
+else if(_LIB_VERSIONIMF==_ISOC_)
+{
+  switch(input_tag)
+  {
+    case logl_zero:
+    case log_zero:
+    case logf_zero:
+    case log10l_zero:
+    case log10_zero:
+    case log10f_zero:
+    case log2l_zero:
+    case log2_zero:
+    case log2f_zero:
+    case log1pl_zero:
+    case log1p_zero:
+    case log1pf_zero:
+    case powl_overflow:
+    case pow_overflow:
+    case powf_overflow:
+    case expl_overflow:
+    case exp_overflow:
+    case expf_overflow:
+    case exp2l_overflow:
+    case exp2_overflow:
+    case exp2f_overflow:
+    case exp10l_overflow:
+    case exp10_overflow:
+    case exp10f_overflow:
+    case expm1l_overflow:
+    case expm1_overflow:
+    case expm1f_overflow:
+    case hypotl_overflow:
+    case hypot_overflow:
+    case hypotf_overflow:
+    case sinhl_overflow:
+    case sinh_overflow:
+    case sinhf_overflow:
+    case atanhl_eq_one:
+    case atanh_eq_one:
+    case atanhf_eq_one:
+    case scalbl_overflow:
+    case scalb_overflow:
+    case scalbf_overflow:
+    case coshl_overflow:
+    case cosh_overflow:
+    case coshf_overflow:
+    case nextafterl_overflow:
+    case nextafter_overflow:
+    case nextafterf_overflow:
+    case nextafterl_underflow:
+    case nextafter_underflow:
+    case nextafterf_underflow:
+    case nexttowardl_overflow:
+    case nexttoward_overflow:
+    case nexttowardf_overflow:
+    case nexttowardl_underflow:
+    case nexttoward_underflow:
+    case nexttowardf_underflow:
+    case scalbnl_overflow:
+    case scalbn_overflow:
+    case scalbnf_overflow:
+    case scalblnl_overflow:
+    case scalbln_overflow:
+    case scalblnf_overflow:
+    case ldexpl_overflow:
+    case ldexp_overflow:
+    case ldexpf_overflow:
+    case lgammal_overflow:
+    case lgamma_overflow:
+    case lgammaf_overflow:
+    case gammal_overflow:
+    case gamma_overflow:
+    case gammaf_overflow:
+    case lgammal_negative:
+    case lgamma_negative:
+    case lgammaf_negative:
+    case gammal_negative:
+    case gamma_negative:
+    case gammaf_negative:
+    case ilogbl_zero:
+    case ilogb_zero:
+    case ilogbf_zero:
+    case fdiml_overflow:
+    case fdim_overflow:
+    case fdimf_overflow:
+    case llrintl_large:
+    case llrint_large:
+    case llrintf_large:
+    case llroundl_large:
+    case llround_large:
+    case llroundf_large:
+    case lrintl_large:
+    case lrint_large:
+    case lrintf_large:
+    case lroundl_large:
+    case lround_large:
+    case lroundf_large:
+    case tandl_overflow:
+    case tand_overflow:
+    case tandf_overflow:
+    case cotdl_overflow:
+    case cotd_overflow:
+    case cotdf_overflow:
+    case cotl_overflow:
+    case cot_overflow:
+    case cotf_overflow:
+    case sinhcoshl_overflow:
+    case sinhcosh_overflow:
+    case sinhcoshf_overflow:
+    case annuityl_overflow:
+    case annuity_overflow:
+    case annuityf_overflow:
+    case compoundl_overflow:
+    case compound_overflow:
+    case compoundf_overflow:
+    case tgammal_overflow:
+    case tgamma_overflow:
+    case tgammaf_overflow:
+    {
+         ERRNO_RANGE; break;
+    }
+    case powl_underflow:
+    case expl_underflow:
+    case exp10l_underflow:
+    case exp2l_underflow:
+    case scalbl_underflow:
+    case scalbnl_underflow:
+    case scalblnl_underflow:
+    case ldexpl_underflow:
+    case erfcl_underflow:
+    case annuityl_underflow:
+    case compoundl_underflow:
+    {
+       /* Test for zero by testing 64 significand bits for zero. An integer
+          test is needed so denormal flag is not set by a floating-point test */
+       if ( INPUT_RESI64 == 0 ) ERRNO_RANGE;
+       break;
+    }
+    case pow_underflow:
+    case exp_underflow:
+    case exp10_underflow:
+    case exp2_underflow:
+    case scalb_underflow:
+    case scalbn_underflow:
+    case scalbln_underflow:
+    case ldexp_underflow:
+    case erfc_underflow:
+    case annuity_underflow:
+    case compound_underflow:
+    {
+       /* Test for zero by testing exp and significand bits for zero. An integer
+          test is needed so denormal flag is not set by a floating-point test */
+       if ( (INPUT_RESI64 << 1) == 0 ) ERRNO_RANGE;
+       break;
+    }
+    case powf_underflow:
+    case expf_underflow:
+    case exp10f_underflow:
+    case exp2f_underflow:
+    case scalbf_underflow:
+    case scalbnf_underflow:
+    case scalblnf_underflow:
+    case ldexpf_underflow:
+    case erfcf_underflow:
+    case annuityf_underflow:
+    case compoundf_underflow:
+    {
+       /* Test for zero by testing exp and significand bits for zero. An integer
+          test is needed so denormal flag is not set by a floating-point test */
+       if ( (INPUT_RESI64 << 33) == 0 ) ERRNO_RANGE;
+       break;
+    }
+    case logl_negative:
+    case log_negative:
+    case logf_negative:
+    case log10l_negative:
+    case log10_negative:
+    case log10f_negative:
+    case log2l_negative:
+    case log2_negative:
+    case log2f_negative:
+    case log1pl_negative:
+    case log1p_negative:
+    case log1pf_negative:
+    case sqrtl_negative:
+    case sqrt_negative:
+    case sqrtf_negative:
+    case atan2l_zero:
+    case atan2_zero:
+    case atan2f_zero:
+    case powl_zero_to_negative:
+    case powl_neg_to_non_integer:
+    case pow_zero_to_negative:
+    case pow_neg_to_non_integer:
+    case powf_zero_to_negative:
+    case powf_neg_to_non_integer:
+    case fmodl_by_zero:
+    case fmod_by_zero:
+    case fmodf_by_zero:
+    case atanhl_gt_one:
+    case atanh_gt_one:
+    case atanhf_gt_one:
+    case acosl_gt_one:
+    case acos_gt_one:
+    case acosf_gt_one:
+    case asinl_gt_one:
+    case asin_gt_one:
+    case asinf_gt_one:
+    case logbl_zero:
+    case logb_zero:
+    case logbf_zero:
+    case acoshl_lt_one:
+    case acosh_lt_one:
+    case acoshf_lt_one:
+    case y0l_zero:
+    case y0_zero:
+    case y0f_zero:
+    case y1l_zero:
+    case y1_zero:
+    case y1f_zero:
+    case ynl_zero:
+    case yn_zero:
+    case ynf_zero:
+    case y0l_negative:
+    case y0_negative:
+    case y0f_negative:
+    case y1l_negative:
+    case y1_negative:
+    case y1f_negative:
+    case ynl_negative:
+    case yn_negative:
+    case ynf_negative:
+    case acosdl_gt_one:
+    case acosd_gt_one:
+    case acosdf_gt_one:
+    case asindl_gt_one:
+    case asind_gt_one:
+    case asindf_gt_one:
+    case atan2dl_zero:
+    case atan2d_zero:
+    case atan2df_zero:
+    case annuityl_by_zero:
+    case annuity_by_zero:
+    case annuityf_by_zero:
+    case annuityl_less_m1:
+    case annuity_less_m1:
+    case annuityf_less_m1:
+    case compoundl_by_zero:
+    case compound_by_zero:
+    case compoundf_by_zero:
+    case compoundl_less_m1:
+    case compound_less_m1:
+    case compoundf_less_m1:
+    case tgammal_negative:
+    case tgamma_negative:
+    case tgammaf_negative:
+    {
+         ERRNO_DOMAIN; break;
+    }
+    default:
+      break;
+   }
+   return;
+}
+
+/***********************/
+/* _POSIX_ Path        */
+/***********************/
+
+else if(_LIB_VERSIONIMF==_POSIX_)
+{
+switch(input_tag)
+  {
+  case gammal_overflow:
+  case lgammal_overflow:
+  case tgammal_overflow:
+  {
+       RETVAL_HUGE_VALL; ERRNO_RANGE; break;
+  }
+  case gamma_overflow:
+  case lgamma_overflow:
+  case tgamma_overflow:
+  {
+       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
+  }
+  case gammaf_overflow:
+  case lgammaf_overflow:
+  case tgammaf_overflow:
+  {
+       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
+  }
+  case gammal_negative:
+  case gamma_negative:
+  case gammaf_negative:
+  case lgammal_negative:
+  case lgamma_negative:
+  case lgammaf_negative:
+  case tgammal_negative:
+  case tgamma_negative:
+  case tgammaf_negative:
+  {
+       ERRNO_DOMAIN; break;
+  }
+  case ldexpl_overflow:
+  case ldexpl_underflow:
+  case ldexp_overflow:
+  case ldexp_underflow:
+  case ldexpf_overflow:
+  case ldexpf_underflow:
+  case scalbnl_overflow:
+  case scalbnl_underflow:
+  case scalbn_overflow:
+  case scalbn_underflow:
+  case scalbnf_overflow:
+  case scalbnf_underflow:
+  case scalblnl_overflow:
+  case scalblnl_underflow:
+  case scalbln_overflow:
+  case scalbln_underflow:
+  case scalblnf_overflow:
+  case scalblnf_underflow:
+  case tandl_overflow:
+  case tand_overflow:
+  case tandf_overflow:
+  case cotdl_overflow:
+  case cotd_overflow:
+  case cotdf_overflow:
+  case cotl_overflow:
+  case cot_overflow:
+  case cotf_overflow:
+  case sinhcoshl_overflow:
+  case sinhcosh_overflow:
+  case sinhcoshf_overflow:
+  case nextafterl_overflow:
+  case nextafter_overflow:
+  case nextafterf_overflow:
+  case nextafterl_underflow:
+  case nextafter_underflow:
+  case nextafterf_underflow:
+  case nexttowardl_overflow:
+  case nexttoward_overflow:
+  case nexttowardf_overflow:
+  case nexttowardl_underflow:
+  case nexttoward_underflow:
+  case nexttowardf_underflow:
+  {
+       ERRNO_RANGE; break;
+  }
+  case atanhl_gt_one:
+  case atanhl_eq_one:
+    /* atanhl(|x| >= 1) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case atanh_gt_one:
+  case atanh_eq_one:
+    /* atanh(|x| >= 1) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case atanhf_gt_one:
+  case atanhf_eq_one:
+    /* atanhf(|x| >= 1) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case sqrtl_negative:
+    /* sqrtl(x < 0) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case sqrt_negative:
+    /* sqrt(x < 0) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case sqrtf_negative:
+    /* sqrtf(x < 0) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case y0l_zero:
+  case y1l_zero:
+  case ynl_zero:
+    /* y0l(0) */
+    /* y1l(0) */
+    /* ynl(0) */
+    {
+       RETVAL_NEG_HUGE_VALL; ERRNO_DOMAIN; break;
+    }
+  case y0_zero:
+  case y1_zero:
+  case yn_zero:
+    /* y0(0) */
+    /* y1(0) */
+    /* yn(0) */
+    {
+       RETVAL_NEG_HUGE_VALD; ERRNO_DOMAIN; break;
+    }
+  case y0f_zero:
+  case y1f_zero:
+  case ynf_zero:
+    /* y0f(0) */
+    /* y1f(0) */
+    /* ynf(0) */
+    {
+       RETVAL_NEG_HUGE_VALF; ERRNO_DOMAIN; break;
+    }
+  case y0l_negative:
+  case y1l_negative:
+  case ynl_negative:
+    /* y0l(x < 0) */
+    /* y1l(x < 0) */
+    /* ynl(x < 0) */
+    {
+#ifndef _LIBC
+       RETVAL_NEG_HUGE_VALL;
+#endif
+       ERRNO_DOMAIN; break;
+    }
+  case y0_negative:
+  case y1_negative:
+  case yn_negative:
+    /* y0(x < 0) */
+    /* y1(x < 0) */
+    /* yn(x < 0) */
+    {
+       RETVAL_NEG_HUGE_VALD; ERRNO_DOMAIN; break;
+    }
+  case y0f_negative:
+  case y1f_negative:
+  case ynf_negative:
+    /* y0f(x < 0) */
+    /* y1f(x < 0) */
+    /* ynf(x < 0) */
+    {
+       RETVAL_NEG_HUGE_VALF; ERRNO_DOMAIN; break;
+    }
+  case logl_zero:
+  case log1pl_zero:
+  case log10l_zero:
+  case log2l_zero:
+    /* logl(0) */
+    /* log1pl(-1) */
+    /* log10l(0) */
+    /* log2l(0) */
+    {
+       RETVAL_NEG_HUGE_VALL; ERRNO_RANGE; break;
+    }
+  case log_zero:
+  case log1p_zero:
+  case log10_zero:
+  case log2_zero:
+   /* log(0) */
+   /* log1p(-1) */
+   /* log10(0) */
+   /* log2(0) */
+    {
+       RETVAL_NEG_HUGE_VALD; ERRNO_RANGE; break;
+    }
+  case logf_zero:
+  case log1pf_zero:
+  case log10f_zero:
+  case log2f_zero:
+    /* logf(0) */
+    /* log1pf(-1) */
+    /* log10f(0) */
+    /* log2f(0) */
+    {
+       RETVAL_NEG_HUGE_VALF; ERRNO_RANGE; break;
+    }
+  case logl_negative:
+  case log1pl_negative:
+  case log10l_negative:
+  case log2l_negative:
+    /* logl(x < 0) */
+    /* log1pl(x < -1) */
+    /* log10l(x < 0) */
+    /* log2l(x < 0) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case log_negative:
+  case log1p_negative:
+  case log10_negative:
+  case log2_negative:
+    /* log(x < 0) */
+    /* log1p(x < -1) */
+    /* log10(x < 0) */
+    /* log2(x < 0) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case logf_negative:
+  case log1pf_negative:
+  case log10f_negative:
+  case log2f_negative:
+    /* logf(x < 0) */
+    /* log1pf(x < -1) */
+    /* log10f(x < 0) */
+    /* log2f(x < 0) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case expl_overflow:
+  case exp10l_overflow:
+  case exp2l_overflow:
+    /* expl overflow */
+    /* exp10l overflow */
+    /* exp2l overflow */
+    {
+       RETVAL_HUGE_VALL; ERRNO_RANGE; break;
+    }
+  case exp_overflow:
+  case exp10_overflow:
+  case exp2_overflow:
+    /* exp overflow */
+    /* exp10 overflow */
+    /* exp2 overflow */
+    {
+       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
+    }
+  case expf_overflow:
+  case exp10f_overflow:
+  case exp2f_overflow:
+    /* expf overflow */
+    {
+       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
+    }
+  case expl_underflow:
+  case exp10l_underflow:
+  case exp2l_underflow:
+    /* expl underflow */
+    /* exp10l underflow */
+    /* exp2l underflow */
+    {
+       ERRNO_RANGE; break;
+    }
+  case exp_underflow:
+  case exp10_underflow:
+  case exp2_underflow:
+    /* exp underflow */
+    /* exp10 underflow */
+    /* exp2 underflow */
+    {
+       ERRNO_RANGE; break;
+    }
+  case expf_underflow:
+  case exp10f_underflow:
+  case exp2f_underflow:
+    /* expf underflow */
+    /* exp10f underflow */
+    /* exp2f underflow */
+    {
+       ERRNO_RANGE; break;
+    }
+  case j0l_gt_loss:
+  case y0l_gt_loss:
+  case j1l_gt_loss:
+  case y1l_gt_loss:
+  case jnl_gt_loss:
+  case ynl_gt_loss:
+    /* jn and yn  doubl-extended> XLOSS */
+    {
+       RETVAL_ZEROL; ERRNO_RANGE; break;
+    }
+  case j0_gt_loss:
+  case y0_gt_loss:
+  case j1_gt_loss:
+  case y1_gt_loss:
+  case jn_gt_loss:
+  case yn_gt_loss:
+    /* jn and yn double > XLOSS */
+    {
+       RETVAL_ZEROD; ERRNO_RANGE; break;
+    }
+  case j0f_gt_loss:
+  case y0f_gt_loss:
+  case j1f_gt_loss:
+  case y1f_gt_loss:
+  case jnf_gt_loss:
+  case ynf_gt_loss:
+    /* j0n and y0n > XLOSS */
+    {
+       RETVAL_ZEROF; ERRNO_RANGE; break;
+    }
+  case powl_zero_to_zero:
+    /* powl 0**0 */
+    {
+       break;
+    }
+  case pow_zero_to_zero:
+    /* pow 0**0 */
+    {
+       break;
+    }
+  case powf_zero_to_zero:
+    /* powf 0**0 */
+    {
+       break;
+    }
+  case powl_overflow:
+  case annuityl_overflow:
+  case compoundl_overflow:
+    /* powl(x,y) overflow */
+    {
+       if (INPUT_RESL < ZEROL_VALUE /*0*/) RETVAL_NEG_HUGE_VALL;
+       else RETVAL_HUGE_VALL;
+       ERRNO_RANGE; break;
+    }
+  case pow_overflow:
+  case annuity_overflow:
+  case compound_overflow:
+    /* pow(x,y) overflow */
+    {
+       if (INPUT_RESD < ZEROD_VALUE /*0*/) RETVAL_NEG_HUGE_VALD;
+       else RETVAL_HUGE_VALD;
+       ERRNO_RANGE; break;
+    }
+  case powf_overflow:
+  case annuityf_overflow:
+  case compoundf_overflow:
+    /* powf(x,y) overflow */
+    {
+       if (INPUT_RESF < ZEROF_VALUE /*0*/) RETVAL_NEG_HUGE_VALF;
+       else RETVAL_HUGE_VALF;
+       ERRNO_RANGE; break;
+    }
+  case powl_underflow:
+  case annuityl_underflow:
+  case compoundl_underflow:
+    /* powl(x,y) underflow */
+    {
+       RETVAL_ZEROL; ERRNO_RANGE; break;
+    }
+  case pow_underflow:
+  case annuity_underflow:
+  case compound_underflow:
+    /* pow(x,y) underflow */
+    {
+       RETVAL_ZEROD; ERRNO_RANGE; break;
+    }
+  case powf_underflow:
+  case annuityf_underflow:
+  case compoundf_underflow:
+    /* powf(x,y) underflow */
+    {
+       RETVAL_ZEROF; ERRNO_RANGE; break;
+    }
+  case annuityl_by_zero:
+  case annuityl_less_m1:
+  case compoundl_by_zero:
+  case compoundl_less_m1:
+  case annuity_by_zero:
+  case annuity_less_m1:
+  case compound_by_zero:
+  case compound_less_m1:
+  case annuityf_by_zero:
+  case annuityf_less_m1:
+  case compoundf_by_zero:
+  case compoundf_less_m1:
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case powl_zero_to_negative:
+    /* 0**neg */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case pow_zero_to_negative:
+    /* 0**neg */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case  powf_zero_to_negative:
+    /* 0**neg */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case powl_neg_to_non_integer:
+    /* neg**non_integral */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case pow_neg_to_non_integer:
+    /* neg**non_integral */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case  powf_neg_to_non_integer:
+    /* neg**non-integral */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case  powl_nan_to_zero:
+    /* powl(NaN,0.0) */
+    /* Special Error */
+    {
+       break;
+    }
+  case  pow_nan_to_zero:
+    /* pow(NaN,0.0) */
+    {
+       break;
+    }
+  case  powf_nan_to_zero:
+    /* powf(NaN,0.0) */
+    {
+       break;
+    }
+  case atan2l_zero:
+  case atan2dl_zero:
+    /* atan2l(0,0) */
+    /* atan2dl(0,0) */
+    {
+       break;
+    }
+  case atan2_zero:
+  case atan2d_zero:
+    /* atan2(0,0) */
+    /* atan2d(0,0) */
+    {
+       break;
+    }
+  case atan2f_zero:
+  case atan2df_zero:
+    /* atan2f(0,0) */
+    /* atan2df(0,0) */
+    {
+       break;
+    }
+  case expm1l_overflow:
+    /* expm1 overflow */
+    {
+       ERRNO_RANGE; break;
+    }
+  case expm1_overflow:
+    /* expm1 overflow */
+    {
+       ERRNO_RANGE; break;
+    }
+  case expm1f_overflow:
+    /* expm1f overflow */
+    {
+       ERRNO_RANGE; break;
+    }
+  case expm1l_underflow:
+    /* expm1 underflow */
+    {
+       ERRNO_RANGE; break;
+    }
+  case expm1_underflow:
+    /* expm1 underflow */
+    {
+       ERRNO_RANGE; break;
+    }
+  case expm1f_underflow:
+    /* expm1f underflow */
+    {
+       ERRNO_RANGE; break;
+    }
+  case hypotl_overflow:
+    /* hypotl overflow */
+    {
+       RETVAL_HUGE_VALL; ERRNO_RANGE; break;
+    }
+  case hypot_overflow:
+    /* hypot overflow */
+    {
+       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
+    }
+  case hypotf_overflow:
+    /* hypotf overflow */
+    {
+       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
+    }
+  case scalbl_underflow:
+    /* scalbl underflow */
+    {
+       if (INPUT_XL < ZEROL_VALUE /*0*/) RETVAL_NEG_ZEROL;
+       else RETVAL_ZEROL;
+       ERRNO_RANGE; break;
+    }
+  case scalb_underflow:
+    /* scalb underflow */
+    {
+       if (INPUT_XD < ZEROD_VALUE /*0*/) RETVAL_NEG_ZEROD;
+       else RETVAL_ZEROD;
+       ERRNO_RANGE; break;
+    }
+  case scalbf_underflow:
+    /* scalbf underflow */
+    {
+       if (INPUT_XF < ZEROF_VALUE /*0*/) RETVAL_NEG_ZEROF;
+       else RETVAL_ZEROF;
+       ERRNO_RANGE; break;
+    }
+  case scalbl_overflow:
+    /* scalbl overflow */
+    {
+       if (INPUT_XL < ZEROL_VALUE /*0*/) RETVAL_NEG_HUGE_VALL;
+       else RETVAL_HUGE_VALL;
+       ERRNO_RANGE; break;
+    }
+  case scalb_overflow:
+    /* scalb overflow */
+    {
+       if (INPUT_XD < ZEROD_VALUE /*0*/) RETVAL_NEG_HUGE_VALD;
+       else RETVAL_HUGE_VALD;
+       ERRNO_RANGE; break;
+    }
+  case scalbf_overflow:
+    /* scalbf overflow */
+    {
+       if (INPUT_XF < ZEROF_VALUE /*0*/) RETVAL_NEG_HUGE_VALF;
+       else RETVAL_HUGE_VALF;
+       ERRNO_RANGE; break;
+    }
+  case acoshl_lt_one:
+    /* acoshl(x < 1) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case acosh_lt_one:
+    /* acosh(x < 1) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case acoshf_lt_one:
+    /* acoshf(x < 1) */
+    {
+        ERRNO_DOMAIN; break;
+    }
+  case acosl_gt_one:
+  case acosdl_gt_one:
+    /* acosl(x > 1) */
+    /* acosdl(x > 1) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case acos_gt_one:
+  case acosd_gt_one:
+    /* acos(x > 1) */
+    /* acosd(x > 1) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case acosf_gt_one:
+  case acosdf_gt_one:
+    /* acosf(x > 1) */
+    /* acosdf(x > 1) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case asinl_gt_one:
+  case asindl_gt_one:
+    /* asinl(x > 1) */
+    /* asindl(x > 1) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case asin_gt_one:
+  case asind_gt_one:
+    /* asin(x > 1) */
+    /* asind(x > 1) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case asinf_gt_one:
+  case asindf_gt_one:
+    /* asinf(x > 1) */
+    /* asindf(x > 1) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case remainderl_by_zero:
+  case fmodl_by_zero:
+    /* fmodl(x,0) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case remainder_by_zero:
+  case fmod_by_zero:
+    /* fmod(x,0) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case remainderf_by_zero:
+  case fmodf_by_zero:
+    /* fmodf(x,0) */
+    {
+       ERRNO_DOMAIN; break;
+    }
+  case coshl_overflow:
+    /* coshl overflows */
+    {
+       RETVAL_HUGE_VALL; ERRNO_RANGE; break;
+    }
+  case cosh_overflow:
+    /* cosh overflows */
+    {
+       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
+    }
+  case coshf_overflow:
+    /* coshf overflows */
+    {
+       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
+    }
+  case sinhl_overflow:
+    /* sinhl overflows */
+    {
+       if (INPUT_XL > ZEROL_VALUE /*0*/) RETVAL_HUGE_VALL;
+       else RETVAL_NEG_HUGE_VALL;
+       ERRNO_RANGE; break;
+    }
+  case sinh_overflow:
+    /* sinh overflows */
+    {
+       if (INPUT_XD > ZEROD_VALUE /*0*/) RETVAL_HUGE_VALD;
+       else RETVAL_NEG_HUGE_VALD;
+       ERRNO_RANGE; break;
+    }
+  case sinhf_overflow:
+    /* sinhf overflows */
+    {
+       if (INPUT_XF > ZEROF_VALUE /*0*/) RETVAL_HUGE_VALF;
+       else RETVAL_NEG_HUGE_VALF;
+       ERRNO_RANGE; break;
+    }
+  case logbl_zero:
+   /* logbl(0) */
+   {
+      ERRNO_DOMAIN; break;
+   }
+  case logb_zero:
+   /* logb(0) */
+   {
+      ERRNO_DOMAIN; break;
+   }
+  case logbf_zero:
+   /* logbf(0) */
+   {
+      ERRNO_DOMAIN; break;
+   }
+  case ilogbl_zero:
+   /* ilogbl(0) */
+   {
+      ERRNO_RANGE; break;
+   }
+  case ilogb_zero:
+   /* ilogb(0) */
+   {
+      ERRNO_RANGE; break;
+   }
+  case ilogbf_zero:
+   /* ilogbf(0) */
+   {
+      ERRNO_RANGE; break;
+   }
+  default:
+    break;
+}
+return;
+/* _POSIX_ */
+}
+
+/*******************************/
+/* __SVID__ and __XOPEN__ Path */
+/*******************************/
+else
+{
+  switch(input_tag)
+  {
+  case ldexpl_overflow:
+  case ldexpl_underflow:
+  case ldexp_overflow:
+  case ldexp_underflow:
+  case ldexpf_overflow:
+  case ldexpf_underflow:
+  case scalbnl_overflow:
+  case scalbnl_underflow:
+  case scalbn_overflow:
+  case scalbn_underflow:
+  case scalbnf_overflow:
+  case scalbnf_underflow:
+  case scalblnl_overflow:
+  case scalblnl_underflow:
+  case scalbln_overflow:
+  case scalbln_underflow:
+  case scalblnf_overflow:
+  case scalblnf_underflow:
+  case tandl_overflow:
+  case tand_overflow:
+  case tandf_overflow:
+  case cotdl_overflow:
+  case cotd_overflow:
+  case cotdf_overflow:
+  case cotl_overflow:
+  case cot_overflow:
+  case cotf_overflow:
+  case annuityl_overflow:
+  case annuityl_underflow:
+  case annuity_overflow:
+  case annuity_underflow:
+  case annuityf_overflow:
+  case annuityf_underflow:
+  case compoundl_overflow:
+  case compoundl_underflow:
+  case compound_overflow:
+  case compound_underflow:
+  case compoundf_overflow:
+  case compoundf_underflow:
+  {
+       ERRNO_RANGE; break;
+  }
+  case annuityl_by_zero:
+  case annuityl_less_m1:
+  case annuity_by_zero:
+  case annuity_less_m1:
+  case annuityf_by_zero:
+  case annuityf_less_m1:
+  case compoundl_by_zero:
+  case compoundl_less_m1:
+  case compound_by_zero:
+  case compound_less_m1:
+  case compoundf_by_zero:
+  case compoundf_less_m1:
+  {
+       ERRNO_DOMAIN; break;
+  }
+  case sqrtl_negative:
+    /* sqrtl(x < 0) */
+    {
+       DOMAINL; NAMEL = (char *) "sqrtl";
+       ifSVID
+       {
+          RETVAL_ZEROL;
+          NOT_MATHERRL
+          {
+            WRITEL_SQRT;
+            ERRNO_DOMAIN;
+          }
+       }
+       else
+       { /* NaN already computed */
+          NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case sqrt_negative:
+    /* sqrt(x < 0) */
+    {
+       DOMAIND; NAMED = (char *) "sqrt";
+       ifSVID
+       {
+
+         RETVAL_ZEROD;
+         NOT_MATHERRD
+         {
+           WRITED_SQRT;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       { /* NaN already computed */
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case sqrtf_negative:
+    /* sqrtf(x < 0) */
+    {
+       DOMAINF; NAMEF = (char *) "sqrtf";
+       ifSVID
+       {
+         RETVAL_ZEROF;
+         NOT_MATHERRF
+         {
+           WRITEF_SQRT;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case logl_zero:
+    /* logl(0) */
+    {
+       SINGL; NAMEL = (char *) "logl";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_LOG_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case log_zero:
+    /* log(0) */
+    {
+       SINGD; NAMED = (char *) "log";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_LOG_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case logf_zero:
+    /* logf(0) */
+    {
+       SINGF; NAMEF = (char *) "logf";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+            WRITEF_LOG_ZERO;
+            ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+
+  case logl_negative:
+    /* logl(x < 0) */
+    {
+       DOMAINL; NAMEL = (char *) "logl";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_LOG_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case log_negative:
+    /* log(x < 0) */
+    {
+       DOMAIND; NAMED = (char *) "log";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_LOG_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case logf_negative:
+    /* logf(x < 0) */
+    {
+       DOMAINF; NAMEF = (char *) "logf";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+           WRITEF_LOG_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF{ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case log1pl_zero:
+    /* log1pl(-1) */
+    {
+       SINGL; NAMEL = (char *) "log1pl";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_LOG1P_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case log1p_zero:
+    /* log1p(-1) */
+    {
+       SINGD; NAMED = (char *) "log1p";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_LOG1P_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case log1pf_zero:
+    /* log1pf(-1) */
+    {
+       SINGF; NAMEF = (char *) "log1pf";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+           WRITEF_LOG1P_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+ case log1pl_negative:
+   /* log1pl(x < -1) */
+   {
+      DOMAINL; NAMEL = (char *) "log1pl";
+      ifSVID
+      {
+        RETVAL_NEG_HUGEL;
+        NOT_MATHERRL
+        {
+          WRITEL_LOG1P_NEGATIVE;
+          ERRNO_DOMAIN;
+        }
+      }
+      else
+      {
+        RETVAL_NEG_HUGE_VALL;
+        NOT_MATHERRL {ERRNO_DOMAIN;}
+      }
+      *(long double *)retval = excl.retval;
+      break;
+   }
+ case log1p_negative:
+   /* log1p(x < -1) */
+   {
+      DOMAIND; NAMED = (char *) "log1p";
+      ifSVID
+      {
+        RETVAL_NEG_HUGED;
+        NOT_MATHERRD
+        {
+          WRITED_LOG1P_NEGATIVE;
+          ERRNO_DOMAIN;
+        }
+      }
+      else
+      {
+        RETVAL_NEG_HUGE_VALD;
+        NOT_MATHERRD {ERRNO_DOMAIN;}
+      }
+      *(double *)retval = exc.retval;
+      break;
+   }
+ case log1pf_negative:
+   /* log1pf(x < -1) */
+   {
+      DOMAINF; NAMEF = (char *) "log1pf";
+      ifSVID
+      {
+        RETVAL_NEG_HUGEF;
+        NOT_MATHERRF
+        {
+          WRITEF_LOG1P_NEGATIVE;
+          ERRNO_DOMAIN;
+        }
+      }
+      else
+      {
+        RETVAL_NEG_HUGE_VALF;
+        NOT_MATHERRF {ERRNO_DOMAIN;}
+      }
+      *(float *)retval = excf.retval;
+      break;
+   }
+  case log10l_zero:
+    /* log10l(0) */
+    {
+       SINGL; NAMEL = (char *) "log10l";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+            WRITEL_LOG10_ZERO;
+            ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case log10_zero:
+    /* log10(0) */
+    {
+       SINGD; NAMED = (char *) "log10";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_LOG10_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case log10f_zero:
+    /* log10f(0) */
+    {
+       SINGF; NAMEF = (char *) "log10f";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+          WRITEF_LOG10_ZERO;
+          ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case log10l_negative:
+    /* log10l(x < 0) */
+    {
+       DOMAINL; NAMEL = (char *) "log10l";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_LOG10_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case log10_negative:
+    /* log10(x < 0) */
+    {
+       DOMAIND; NAMED = (char *) "log10";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_LOG10_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case log10f_negative:
+    /* log10f(x < 0) */
+    {
+       DOMAINF; NAMEF = (char *) "log10f";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+           WRITEF_LOG10_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case log2l_zero:
+    /* log2l(0) */
+    {
+       SINGL; NAMEL = (char *) "log2l";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_LOG2_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case log2_zero:
+    /* log2(0) */
+    {
+       SINGD; NAMED = (char *) "log2";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_LOG2_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case log2f_zero:
+    /* log2f(0) */
+    {
+       SINGF; NAMEF = (char *) "log2f";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+          WRITEF_LOG2_ZERO;
+          ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case log2l_negative:
+    /* log2l(x < 0) */
+    {
+       DOMAINL; NAMEL = (char *) "log2l";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_LOG2_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case log2_negative:
+    /* log2(x < 0) */
+    {
+       DOMAIND; NAMED = (char *) "log2";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_LOG2_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case log2f_negative:
+    /* log2f(x < 0) */
+    {
+       DOMAINF; NAMEF = (char *) "log2f";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+           WRITEF_LOG2_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case expl_overflow:
+    /* expl overflow */
+    {
+       OVERFLOWL; NAMEL = (char *) "expl";
+       ifSVID
+       {
+         RETVAL_HUGEL;
+       }
+       else
+       {
+       RETVAL_HUGE_VALL;
+       }
+       NOT_MATHERRL {ERRNO_RANGE;}
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case exp_overflow:
+    /* exp overflow */
+    {
+       OVERFLOWD; NAMED = (char *) "exp";
+       ifSVID
+       {
+         RETVAL_HUGED;
+       }
+       else
+       {
+         RETVAL_HUGE_VALD;
+       }
+       NOT_MATHERRD {ERRNO_RANGE;}
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case expf_overflow:
+    /* expf overflow */
+    {
+       OVERFLOWF; NAMEF = (char *) "expf";
+       ifSVID
+       {
+         RETVAL_HUGEF;
+       }
+       else
+       {
+         RETVAL_HUGE_VALF;
+       }
+       NOT_MATHERRF {ERRNO_RANGE;}
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case expl_underflow:
+    /* expl underflow */
+    {
+       UNDERFLOWL; NAMEL = (char *) "expl"; RETVAL_ZEROL;
+       NOT_MATHERRL {ERRNO_RANGE;}
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case exp_underflow:
+    /* exp underflow */
+    {
+       UNDERFLOWD; NAMED = (char *) "exp"; RETVAL_ZEROD;
+       NOT_MATHERRD {ERRNO_RANGE;}
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case expf_underflow:
+    /* expf underflow */
+    {
+       UNDERFLOWF; NAMEF = (char *) "expf"; RETVAL_ZEROF;
+       NOT_MATHERRF {ERRNO_RANGE;}
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case powl_zero_to_zero:
+    /* powl 0**0 */
+    {
+       DOMAINL; NAMEL = (char *) "powl";
+       ifSVID
+       {
+         RETVAL_ZEROL;
+         NOT_MATHERRL
+         {
+            WRITEL_POW_ZERO_TO_ZERO;
+            ERRNO_DOMAIN;
+         }
+         *(long double *)retval = excl.retval;
+       }
+       else RETVAL_ONEL;
+       break;
+    }
+  case pow_zero_to_zero:
+    /* pow 0**0 */
+    {
+       DOMAIND; NAMED = (char *) "pow";
+       ifSVID
+       {
+         RETVAL_ZEROD;
+         NOT_MATHERRD
+         {
+            WRITED_POW_ZERO_TO_ZERO;
+            ERRNO_DOMAIN;
+         }
+         *(double *)retval = exc.retval;
+       }
+       else RETVAL_ONED;
+       break;
+    }
+  case powf_zero_to_zero:
+    /* powf 0**0 */
+    {
+       DOMAINF; NAMEF = (char *) "powf";
+       ifSVID
+       {
+         RETVAL_ZEROF;
+         NOT_MATHERRF
+         {
+          WRITEF_POW_ZERO_TO_ZERO;
+          ERRNO_DOMAIN;
+         }
+         *(float *)retval = excf.retval;
+       }
+       else RETVAL_ONEF;
+       break;
+    }
+  case powl_overflow:
+    /* powl(x,y) overflow */
+    {
+       OVERFLOWL; NAMEL = (char *) "powl";
+       ifSVID
+       {
+         if (INPUT_RESL < ZEROL_VALUE /*0*/) RETVAL_NEG_HUGEL;
+         else RETVAL_HUGEL;
+       }
+       else
+       {
+         if (INPUT_RESL < ZEROL_VALUE /*0*/) RETVAL_NEG_HUGE_VALL;
+         else RETVAL_HUGE_VALL;
+       }
+       NOT_MATHERRL {ERRNO_RANGE;}
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case pow_overflow:
+    /* pow(x,y) overflow */
+    {
+       OVERFLOWD; NAMED = (char *) "pow";
+       ifSVID
+       {
+         if (INPUT_RESD < ZEROD_VALUE /*0*/) RETVAL_NEG_HUGED;
+         else RETVAL_HUGED;
+       }
+       else
+       {
+         if (INPUT_RESD < ZEROD_VALUE /*0*/) RETVAL_NEG_HUGE_VALD;
+         else RETVAL_HUGE_VALD;
+       }
+       NOT_MATHERRD {ERRNO_RANGE;}
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case powf_overflow:
+    /* powf(x,y) overflow */
+    {
+       OVERFLOWF; NAMEF = (char *) "powf";
+       ifSVID
+       {
+         if (INPUT_RESF < ZEROF_VALUE /*0*/) RETVAL_NEG_HUGEF;
+         else RETVAL_HUGEF;
+       }
+       else
+       {
+         if (INPUT_RESF < ZEROF_VALUE /*0*/) RETVAL_NEG_HUGE_VALF;
+         else RETVAL_HUGE_VALF;
+       }
+       NOT_MATHERRF {ERRNO_RANGE;}
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case powl_underflow:
+    /* powl(x,y) underflow */
+    {
+       UNDERFLOWL; NAMEL = (char *) "powl"; RETVAL_ZEROL;
+       NOT_MATHERRL {ERRNO_RANGE;}
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case pow_underflow:
+    /* pow(x,y) underflow */
+    {
+       UNDERFLOWD; NAMED = (char *) "pow"; RETVAL_ZEROD;
+       NOT_MATHERRD {ERRNO_RANGE;}
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case powf_underflow:
+    /* powf(x,y) underflow */
+    {
+       UNDERFLOWF; NAMEF = (char *) "powf"; RETVAL_ZEROF;
+       NOT_MATHERRF {ERRNO_RANGE;}
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case powl_zero_to_negative:
+    /* 0 to neg */
+    {
+       DOMAINL; NAMEL = (char *) "powl";
+       ifSVID
+       {
+         RETVAL_ZEROL;
+         NOT_MATHERRL
+         {
+           WRITEL_POW_ZERO_TO_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case pow_zero_to_negative:
+    /* 0**neg */
+    {
+       DOMAIND; NAMED = (char *) "pow";
+       ifSVID
+       {
+         RETVAL_ZEROD;
+         NOT_MATHERRD
+         {
+           WRITED_POW_ZERO_TO_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case powf_zero_to_negative:
+    /* 0**neg */
+    {
+       DOMAINF; NAMEF = (char *) "powf";
+       ifSVID
+       {
+         RETVAL_ZEROF;
+         NOT_MATHERRF
+         {
+            WRITEF_POW_ZERO_TO_NEGATIVE;
+            ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case powl_neg_to_non_integer:
+    /* neg**non_integral */
+    {
+       DOMAINL; NAMEL = (char *) "powl";
+       ifSVID
+       {
+         RETVAL_ZEROL;
+         NOT_MATHERRL
+         {
+           WRITEL_POW_NEG_TO_NON_INTEGER;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case pow_neg_to_non_integer:
+    /* neg**non_integral */
+    {
+       DOMAIND; NAMED = (char *) "pow";
+       ifSVID
+       {
+         RETVAL_ZEROD;
+         NOT_MATHERRD
+         {
+            WRITED_POW_NEG_TO_NON_INTEGER;
+            ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case powf_neg_to_non_integer:
+    /* neg**non-integral */
+    {
+       DOMAINF; NAMEF = (char *) "powf";
+       ifSVID
+       {
+         RETVAL_ZEROF;
+         NOT_MATHERRF
+         {
+            WRITEF_POW_NEG_TO_NON_INTEGER;
+            ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case powl_nan_to_zero:
+    /* pow(NaN,0.0) */
+    /* Special Error */
+    {
+       DOMAINL; NAMEL = (char *) "powl";
+       *(long double *)retval = *(long double *)arg1;
+       NOT_MATHERRL {ERRNO_DOMAIN;}
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case pow_nan_to_zero:
+    /* pow(NaN,0.0) */
+    /* Special Error */
+    {
+       DOMAIND; NAMED = (char *) "pow";
+       *(double *)retval = *(double *)arg1;
+       NOT_MATHERRD {ERRNO_DOMAIN;}
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case powf_nan_to_zero:
+    /* powf(NaN,0.0) */
+    /* Special Error */
+    {
+       DOMAINF; NAMEF = (char *) "powf";
+       *(float *)retval = *(float *)arg1;
+       NOT_MATHERRF {ERRNO_DOMAIN;}
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case atan2l_zero:
+    /* atan2l(0.0,0.0) */
+    {
+       DOMAINL; NAMEL = (char *) "atan2l";
+       RETVAL_ZEROL;
+       NOT_MATHERRL
+       {
+         ifSVID
+         {
+            WRITEL_ATAN2_ZERO_BY_ZERO;
+         }
+         ERRNO_DOMAIN;
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case atan2_zero:
+    /* atan2(0.0,0.0) */
+    {
+       DOMAIND; NAMED = (char *) "atan2";
+       RETVAL_ZEROD;
+       NOT_MATHERRD
+       {
+         ifSVID
+         {
+            WRITED_ATAN2_ZERO_BY_ZERO;
+         }
+         ERRNO_DOMAIN;
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case atan2f_zero:
+    /* atan2f(0.0,0.0) */
+    {
+       DOMAINF; NAMEF = (char *) "atan2f";
+       RETVAL_ZEROF;
+       NOT_MATHERRF
+       {
+         ifSVID
+         {
+            WRITEF_ATAN2_ZERO_BY_ZERO;
+         }
+         ERRNO_DOMAIN;
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case atan2dl_zero:
+    /* atan2dl(0.0,0.0) */
+    {
+       DOMAINL; NAMEL = (char *) "atan2dl";
+       RETVAL_ZEROL;
+       NOT_MATHERRL
+       {
+         ifSVID
+         {
+            WRITEL_ATAN2D_ZERO_BY_ZERO;
+         }
+         ERRNO_DOMAIN;
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case atan2d_zero:
+    /* atan2d(0.0,0.0) */
+    {
+       DOMAIND; NAMED = (char *) "atan2d";
+       RETVAL_ZEROD;
+       NOT_MATHERRD
+       {
+         ifSVID
+         {
+            WRITED_ATAN2D_ZERO_BY_ZERO;
+         }
+         ERRNO_DOMAIN;
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case atan2df_zero:
+    /* atan2df(0.0,0.0) */
+    {
+       DOMAINF; NAMEF = (char *) "atan2df";
+       RETVAL_ZEROF;
+       NOT_MATHERRF
+       {
+         ifSVID
+         {
+            WRITEF_ATAN2D_ZERO_BY_ZERO;
+         }
+         ERRNO_DOMAIN;
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case expm1_overflow:
+    /* expm1(finite) overflow */
+    /* Overflow is the only documented */
+    /* special value. */
+    {
+      ERRNO_RANGE;
+      break;
+    }
+  case expm1f_overflow:
+    /* expm1f(finite) overflow */
+    {
+      ERRNO_RANGE;
+      break;
+    }
+  case expm1_underflow:
+    /* expm1(finite) underflow */
+    /* Underflow is not documented */
+    /* special value. */
+    {
+      ERRNO_RANGE;
+      break;
+    }
+  case expm1f_underflow:
+    /* expm1f(finite) underflow */
+    {
+      ERRNO_RANGE;
+      break;
+    }
+  case scalbl_underflow:
+    /* scalbl underflow */
+    {
+       UNDERFLOWL; NAMEL = (char *) "scalbl";
+       if (INPUT_XL < ZEROL_VALUE /*0.0L*/) RETVAL_NEG_ZEROL;
+       else  RETVAL_ZEROL;
+       NOT_MATHERRL {ERRNO_RANGE;}
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case scalb_underflow:
+    /* scalb underflow */
+    {
+       UNDERFLOWD; NAMED = (char *) "scalb";
+       if (INPUT_XD < ZEROD_VALUE /*0.0*/) RETVAL_NEG_ZEROD;
+       else  RETVAL_ZEROD;
+       NOT_MATHERRD {ERRNO_RANGE;}
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case scalbf_underflow:
+    /* scalbf underflow */
+    {
+       UNDERFLOWF; NAMEF = (char *) "scalbf";
+       if (INPUT_XF < ZEROF_VALUE /*0.0*/) RETVAL_NEG_ZEROF;
+       else  RETVAL_ZEROF;
+       NOT_MATHERRF {ERRNO_RANGE;}
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case scalbl_overflow:
+    /* scalbl overflow */
+    {
+       OVERFLOWL; NAMEL = (char *) "scalbl";
+       if (INPUT_XL < ZEROL_VALUE /*0*/) RETVAL_NEG_HUGE_VALL;
+       else RETVAL_HUGE_VALL;
+       NOT_MATHERRL {ERRNO_RANGE;}
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case scalb_overflow:
+    /* scalb overflow */
+    {
+       OVERFLOWD; NAMED = (char *) "scalb";
+       if (INPUT_XD < ZEROD_VALUE /*0*/) RETVAL_NEG_HUGE_VALD;
+       else RETVAL_HUGE_VALD;
+       NOT_MATHERRD {ERRNO_RANGE;}
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case scalbf_overflow:
+    /* scalbf overflow */
+    {
+       OVERFLOWF; NAMEF = (char *) "scalbf";
+       if (INPUT_XF < ZEROF_VALUE /*0*/) RETVAL_NEG_HUGE_VALF;
+       else RETVAL_HUGE_VALF;
+       NOT_MATHERRF {ERRNO_RANGE;}
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case hypotl_overflow:
+    /* hypotl overflow */
+    {
+       OVERFLOWL; NAMEL = (char *) "hypotl";
+       ifSVID
+       {
+         RETVAL_HUGEL;
+       }
+       else
+       {
+         RETVAL_HUGE_VALL;
+       }
+       NOT_MATHERRL {ERRNO_RANGE;}
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case hypot_overflow:
+    /* hypot overflow */
+    {
+       OVERFLOWD; NAMED = (char *) "hypot";
+       ifSVID
+       {
+         RETVAL_HUGED;
+       }
+       else
+       {
+         RETVAL_HUGE_VALD;
+       }
+       NOT_MATHERRD {ERRNO_RANGE;}
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case hypotf_overflow:
+    /* hypotf overflow */
+    {
+       OVERFLOWF; NAMEF = (char *) "hypotf";
+       ifSVID
+       {
+         RETVAL_HUGEF;
+       }
+       else
+       {
+         RETVAL_HUGE_VALF;
+       }
+       NOT_MATHERRF {ERRNO_RANGE;}
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case acosl_gt_one:
+    /* acosl(x > 1) */
+    {
+       DOMAINL; NAMEL = (char *) "acosl";
+       RETVAL_ZEROL;
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+           WRITEL_ACOS;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case acos_gt_one:
+    /* acos(x > 1) */
+    {
+       DOMAIND; NAMED = (char *) "acos";
+       RETVAL_ZEROD;
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+           WRITED_ACOS;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case acosf_gt_one:
+    /* acosf(x > 1) */
+    {
+       DOMAINF; NAMEF = (char *) "acosf";
+       RETVAL_ZEROF;
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+           WRITEF_ACOS;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case asinl_gt_one:
+    /* asinl(x > 1) */
+    {
+       DOMAINL; NAMEL = (char *) "asinl";
+       RETVAL_ZEROL;
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+           WRITEL_ASIN;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case asin_gt_one:
+    /* asin(x > 1) */
+    {
+       DOMAIND; NAMED = (char *) "asin";
+       RETVAL_ZEROD;
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+           WRITED_ASIN;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case asinf_gt_one:
+    /* asinf(x > 1) */
+    {
+       DOMAINF; NAMEF = (char *) "asinf";
+       RETVAL_ZEROF;
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+            WRITEF_ASIN;
+            ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case acosdl_gt_one:
+    /* acosdl(x > 1) */
+    {
+       DOMAINL; NAMEL = (char *) "acosdl";
+       RETVAL_ZEROL;
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+           WRITEL_ACOSD;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case acosd_gt_one:
+    /* acosd(x > 1) */
+    {
+       DOMAIND; NAMED = (char *) "acosd";
+       RETVAL_ZEROD;
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+           WRITED_ACOSD;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case acosdf_gt_one:
+    /* acosdf(x > 1) */
+    {
+       DOMAINF; NAMEF = (char *) "acosdf";
+       RETVAL_ZEROF;
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+           WRITEF_ACOSD;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case asindl_gt_one:
+    /* asindl(x > 1) */
+    {
+       DOMAINL; NAMEL = (char *) "asindl";
+       RETVAL_ZEROL;
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+           WRITEL_ASIND;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case asind_gt_one:
+    /* asind(x > 1) */
+    {
+       DOMAIND; NAMED = (char *) "asind";
+       RETVAL_ZEROD;
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+           WRITED_ASIND;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case asindf_gt_one:
+    /* asindf(x > 1) */
+    {
+       DOMAINF; NAMEF = (char *) "asindf";
+       RETVAL_ZEROF;
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+            WRITEF_ASIND;
+            ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+ case coshl_overflow:
+   /* coshl overflow */
+   {
+      OVERFLOWL; NAMEL = (char *) "coshl";
+      ifSVID
+      {
+        RETVAL_HUGEL;
+      }
+      else
+      {
+        RETVAL_HUGE_VALL;
+      }
+      NOT_MATHERRL {ERRNO_RANGE;}
+      *(long double *)retval = excl.retval;
+      break;
+   }
+ case cosh_overflow:
+   /* cosh overflow */
+   {
+      OVERFLOWD; NAMED = (char *) "cosh";
+      ifSVID
+      {
+        RETVAL_HUGED;
+      }
+      else
+      {
+        RETVAL_HUGE_VALD;
+      }
+      NOT_MATHERRD {ERRNO_RANGE;}
+      *(double *)retval = exc.retval;
+      break;
+   }
+ case coshf_overflow:
+   /* coshf overflow */
+   {
+      OVERFLOWF; NAMEF = (char *) "coshf";
+      ifSVID
+      {
+        RETVAL_HUGEF;
+      }
+      else
+      {
+        RETVAL_HUGE_VALF;
+      }
+      NOT_MATHERRF {ERRNO_RANGE;}
+      *(float *)retval = excf.retval;
+      break;
+   }
+ case sinhl_overflow:
+   /* sinhl overflow */
+   {
+      OVERFLOWL; NAMEL = (char *) "sinhl";
+      ifSVID
+      {
+        if (INPUT_XL > ZEROL_VALUE /*0.0*/) RETVAL_HUGEL;
+        else RETVAL_NEG_HUGEL;
+      }
+      else
+      {
+        if (INPUT_XL > ZEROL_VALUE /*0.0*/) RETVAL_HUGE_VALL;
+        else RETVAL_NEG_HUGE_VALL;
+      }
+      NOT_MATHERRL {ERRNO_RANGE;}
+      *(long double *)retval = excl.retval;
+      break;
+   }
+ case sinh_overflow:
+   /* sinh overflow */
+   {
+      OVERFLOWD; NAMED = (char *) "sinh";
+      ifSVID
+      {
+        if (INPUT_XD > ZEROD_VALUE /*0.0*/) RETVAL_HUGED;
+        else RETVAL_NEG_HUGED;
+      }
+      else
+      {
+        if (INPUT_XD > ZEROD_VALUE /*0.0*/) RETVAL_HUGE_VALD;
+        else RETVAL_NEG_HUGE_VALD;
+      }
+      NOT_MATHERRD {ERRNO_RANGE;}
+      *(double *)retval = exc.retval;
+      break;
+   }
+ case sinhf_overflow:
+   /* sinhf overflow */
+   {
+      OVERFLOWF; NAMEF = (char *) "sinhf";
+      ifSVID
+      {
+        if (INPUT_XF > ZEROF_VALUE /*0.0*/) RETVAL_HUGEF;
+        else RETVAL_NEG_HUGEF;
+      }
+      else
+      {
+        if (INPUT_XF > ZEROF_VALUE /*0.0*/) RETVAL_HUGE_VALF;
+        else RETVAL_NEG_HUGE_VALF;
+      }
+      NOT_MATHERRF {ERRNO_RANGE;}
+      *(float *)retval = excf.retval;
+      break;
+   }
+  case acoshl_lt_one:
+    /* acoshl(x < 1) */
+    {
+       DOMAINL; NAMEL = (char *) "acoshl";
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+           WRITEL_ACOSH;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+           NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case acosh_lt_one:
+    /* acosh(x < 1) */
+    {
+       DOMAIND; NAMED = (char *) "acosh";
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+          WRITED_ACOSH;
+          ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+          NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case acoshf_lt_one:
+    /* acoshf(x < 1) */
+    {
+       DOMAINF; NAMEF = (char *) "acoshf";
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+           WRITEF_ACOSH;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case atanhl_gt_one:
+    /* atanhl(|x| > 1) */
+    {
+       DOMAINL; NAMEL = (char *) "atanhl";
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+           WRITEL_ATANH_GT_ONE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       break;
+    }
+  case atanh_gt_one:
+    /* atanh(|x| > 1) */
+    {
+       DOMAIND; NAMED = (char *) "atanh";
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+           WRITED_ATANH_GT_ONE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       break;
+    }
+  case atanhf_gt_one:
+    /* atanhf(|x| > 1) */
+    {
+       DOMAINF; NAMEF = (char *) "atanhf";
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+           WRITEF_ATANH_GT_ONE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       break;
+    }
+  case atanhl_eq_one:
+    /* atanhl(|x| == 1) */
+    {
+       SINGL; NAMEL = (char *) "atanhl";
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+           WRITEL_ATANH_EQ_ONE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       break;
+    }
+  case atanh_eq_one:
+    /* atanh(|x| == 1) */
+    {
+       SINGD; NAMED = (char *) "atanh";
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+           WRITED_ATANH_EQ_ONE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+       NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       break;
+    }
+  case atanhf_eq_one:
+    /* atanhf(|x| == 1) */
+    {
+       SINGF; NAMEF = (char *) "atanhf";
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+           WRITEF_ATANH_EQ_ONE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       break;
+    }
+  case gammal_overflow:
+    /* gammal overflow */
+    {
+       OVERFLOWL; NAMEL = (char *) "gammal";
+       ifSVID
+       {
+         RETVAL_HUGEL;
+       }
+       else
+       {
+         RETVAL_HUGE_VALL;
+       }
+       NOT_MATHERRL {ERRNO_RANGE;}
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case gamma_overflow:
+    /* gamma overflow */
+    {
+       OVERFLOWD; NAMED = (char *) "gamma";
+       ifSVID
+       {
+         RETVAL_HUGED;
+       }
+         else
+       {
+         RETVAL_HUGE_VALD;
+       }
+       NOT_MATHERRD {ERRNO_RANGE;}
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case gammaf_overflow:
+    /* gammaf overflow */
+    {
+       OVERFLOWF; NAMEF = (char *) "gammaf";
+       ifSVID
+       {
+         RETVAL_HUGEF;
+       }
+       else
+       {
+         RETVAL_HUGE_VALF;
+       }
+       NOT_MATHERRF {ERRNO_RANGE;}
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case gammal_negative:
+    /* gammal -int or 0 */
+    {
+       SINGL; NAMEL = (char *) "gammal";
+       ifSVID
+       {
+         RETVAL_HUGEL;
+         NOT_MATHERRL
+         {
+            WRITEL_GAMMA_NEGATIVE;
+            ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case gamma_negative:
+    /* gamma -int or 0 */
+    {
+       SINGD; NAMED = (char *) "gamma";
+       ifSVID
+       {
+         RETVAL_HUGED;
+         NOT_MATHERRD
+         {
+            WRITED_GAMMA_NEGATIVE;
+            ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case gammaf_negative:
+    /* gammaf -int or 0 */
+    {
+       SINGF; NAMEF = (char *) "gammaf";
+       ifSVID
+       {
+         RETVAL_HUGEF;
+         NOT_MATHERRF
+         {
+            WRITEF_GAMMA_NEGATIVE;
+            ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case lgammal_overflow:
+    /* lgammal overflow */
+    {
+       OVERFLOWL; NAMEL = (char *) "lgammal";
+       ifSVID
+       {
+         RETVAL_HUGEL;
+       }
+       else
+       {
+         RETVAL_HUGE_VALL;
+       }
+       NOT_MATHERRL {ERRNO_RANGE;}
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case lgamma_overflow:
+    /* lgamma overflow */
+    {
+       OVERFLOWD; NAMED = (char *) "lgamma";
+       ifSVID
+       {
+         RETVAL_HUGED;
+       }
+       else
+       {
+         RETVAL_HUGE_VALD;
+       }
+       NOT_MATHERRD {ERRNO_RANGE;}
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case lgammaf_overflow:
+    /* lgammaf overflow */
+    {
+       OVERFLOWF; NAMEF = (char *) "lgammaf";
+       ifSVID
+       {
+         RETVAL_HUGEF;
+       }
+       else
+       {
+         RETVAL_HUGE_VALF;
+       }
+       NOT_MATHERRF {ERRNO_RANGE;}
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case lgammal_negative:
+    /* lgammal -int or 0 */
+    {
+       SINGL; NAMEL = (char *) "lgammal";
+       ifSVID
+       {
+         RETVAL_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_LGAMMA_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case lgamma_negative:
+    /* lgamma -int or 0 */
+    {
+       SINGD; NAMED = (char *) "lgamma";
+       ifSVID
+       {
+         RETVAL_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_LGAMMA_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case lgammaf_negative:
+    /* lgammaf -int or 0 */
+    {
+       SINGF; NAMEF = (char *) "lgammaf";
+       ifSVID
+       {
+         RETVAL_HUGEF;
+         NOT_MATHERRF
+         {
+           WRITEF_LGAMMA_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case tgammal_overflow:
+    /* tgammal overflow */
+    {
+       OVERFLOWL; NAMEL = (char *) "tgammal";
+       ifSVID
+       {
+         RETVAL_HUGEL;
+       }
+       else
+       {
+         RETVAL_HUGE_VALL;
+       }
+       NOT_MATHERRL {ERRNO_RANGE;}
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case tgamma_overflow:
+    /* tgamma overflow */
+    {
+       OVERFLOWD; NAMED = (char *) "tgamma";
+       ifSVID
+       {
+         RETVAL_HUGED;
+       }
+       else
+       {
+         RETVAL_HUGE_VALD;
+       }
+       NOT_MATHERRD {ERRNO_RANGE;}
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case tgammaf_overflow:
+    /* tgammaf overflow */
+    {
+       OVERFLOWF; NAMEF = (char *) "tgammaf";
+       ifSVID
+       {
+         RETVAL_HUGEF;
+       }
+       else
+       {
+         RETVAL_HUGE_VALF;
+       }
+       NOT_MATHERRF {ERRNO_RANGE;}
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case tgammal_negative:
+    /* tgammal -int or 0 */
+    {
+       SINGL; NAMEL = (char *) "tgammal";
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+           WRITEL_TGAMMA_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case tgamma_negative:
+    /* tgamma -int or 0 */
+    {
+       SINGD; NAMED = (char *) "tgamma";
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+           WRITED_TGAMMA_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case tgammaf_negative:
+    /* tgammaf -int or 0 */
+    {
+       SINGF; NAMEF = (char *) "tgammaf";
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+           WRITEF_TGAMMA_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case j0l_gt_loss:
+    /* j0l > loss */
+    {
+       TLOSSL; NAMEL = (char *) "j0l";
+       RETVAL_ZEROL;
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+            WRITEL_J0_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_RANGE;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case j0_gt_loss:
+    /* j0 > loss */
+    {
+       TLOSSD; NAMED = (char *) "j0";
+       RETVAL_ZEROD;
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+            WRITED_J0_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_RANGE;}
+       }
+       *(double*)retval = exc.retval;
+       break;
+    }
+  case j0f_gt_loss:
+    /* j0f > loss */
+    {
+       TLOSSF; NAMEF = (char *) "j0f";
+       RETVAL_ZEROF;
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+            WRITEF_J0_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_RANGE;}
+       }
+       *(float*)retval = excf.retval;
+       break;
+    }
+  case j1l_gt_loss:
+    /* j1l > loss */
+    {
+       TLOSSL; NAMEL = (char *) "j1l";
+       RETVAL_ZEROL;
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+            WRITEL_J1_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_RANGE;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case j1_gt_loss:
+    /* j1 > loss */
+    {
+       TLOSSD; NAMED = (char *) "j1";
+       RETVAL_ZEROD;
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+            WRITED_J1_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_RANGE;}
+       }
+       *(double*)retval = exc.retval;
+       break;
+    }
+  case j1f_gt_loss:
+    /* j1f > loss */
+    {
+       TLOSSF; NAMEF = (char *) "j1f";
+       RETVAL_ZEROF;
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+            WRITEF_J1_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_RANGE;}
+       }
+       *(float*)retval = excf.retval;
+       break;
+    }
+  case jnl_gt_loss:
+    /* jnl > loss */
+    {
+       TLOSSL; NAMEL = (char *) "jnl";
+       RETVAL_ZEROL;
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+            WRITEL_JN_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_RANGE;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case jn_gt_loss:
+    /* jn > loss */
+    {
+       TLOSSD; NAMED = (char *) "jn";
+       RETVAL_ZEROD;
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+            WRITED_JN_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_RANGE;}
+       }
+       *(double*)retval = exc.retval;
+       break;
+    }
+  case jnf_gt_loss:
+    /* jnf > loss */
+    {
+       TLOSSF; NAMEF = (char *) "jnf";
+       RETVAL_ZEROF;
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+            WRITEF_JN_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_RANGE;}
+       }
+       *(float*)retval = excf.retval;
+       break;
+    }
+  case y0l_gt_loss:
+    /* y0l > loss */
+    {
+       TLOSSL; NAMEL = (char *) "y0l";
+       RETVAL_ZEROL;
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+            WRITEL_Y0_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_RANGE;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case y0_gt_loss:
+    /* y0 > loss */
+    {
+       TLOSSD; NAMED = (char *) "y0";
+       RETVAL_ZEROD;
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+            WRITED_Y0_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_RANGE;}
+       }
+       *(double*)retval = exc.retval;
+       break;
+    }
+  case y0f_gt_loss:
+    /* y0f > loss */
+    {
+       TLOSSF; NAMEF = (char *) "y0f";
+       RETVAL_ZEROF;
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+            WRITEF_Y0_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_RANGE;}
+       }
+       *(float*)retval = excf.retval;
+       break;
+    }
+  case y0l_zero:
+    /* y0l(0) */
+    {
+       DOMAINL; NAMEL = (char *) "y0l";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_Y0_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case y0_zero:
+    /* y0(0) */
+    {
+       DOMAIND; NAMED = (char *) "y0";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_Y0_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case y0f_zero:
+    /* y0f(0) */
+    {
+       DOMAINF; NAMEF = (char *) "y0f";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+           WRITEF_Y0_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case y1l_gt_loss:
+    /* y1l > loss */
+    {
+       TLOSSL; NAMEL = (char *) "y1l";
+       RETVAL_ZEROL;
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+            WRITEL_Y1_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_RANGE;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case y1_gt_loss:
+    /* y1 > loss */
+    {
+       TLOSSD; NAMED = (char *) "y1";
+       RETVAL_ZEROD;
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+            WRITED_Y1_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_RANGE;}
+       }
+       *(double*)retval = exc.retval;
+       break;
+    }
+  case y1f_gt_loss:
+    /* y1f > loss */
+    {
+       TLOSSF; NAMEF = (char *) "y1f";
+       RETVAL_ZEROF;
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+            WRITEF_Y1_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_RANGE;}
+       }
+       *(float*)retval = excf.retval;
+       break;
+    }
+  case y1l_zero:
+    /* y1l(0) */
+    {
+       DOMAINL; NAMEL = (char *) "y1l";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_Y1_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case y1_zero:
+    /* y1(0) */
+    {
+       DOMAIND; NAMED = (char *) "y1";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_Y1_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case y1f_zero:
+    /* y1f(0) */
+    {
+       DOMAINF; NAMEF = (char *) "y1f";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+           WRITEF_Y1_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case ynl_gt_loss:
+    /* ynl > loss */
+    {
+       TLOSSL; NAMEL = (char *) "ynl";
+       RETVAL_ZEROL;
+       ifSVID
+       {
+         NOT_MATHERRL
+         {
+            WRITEL_YN_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRL {ERRNO_RANGE;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case yn_gt_loss:
+    /* yn > loss */
+    {
+       TLOSSD; NAMED = (char *) "yn";
+       RETVAL_ZEROD;
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+            WRITED_YN_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRD {ERRNO_RANGE;}
+       }
+       *(double*)retval = exc.retval;
+       break;
+    }
+  case ynf_gt_loss:
+    /* ynf > loss */
+    {
+       TLOSSF; NAMEF = (char *) "ynf";
+       RETVAL_ZEROF;
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+            WRITEF_YN_TLOSS;
+            ERRNO_RANGE;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_RANGE;}
+       }
+       *(float*)retval = excf.retval;
+       break;
+    }
+  case ynl_zero:
+    /* ynl(0) */
+    {
+       DOMAINL; NAMEL = (char *) "ynl";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_YN_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case yn_zero:
+    /* yn(0) */
+    {
+       DOMAIND; NAMED = (char *) "yn";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_YN_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case ynf_zero:
+    /* ynf(0) */
+    {
+       DOMAINF; NAMEF = (char *) "ynf";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+           WRITEF_YN_ZERO;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case y0l_negative:
+    /* y0l(x<0) */
+    {
+       DOMAINL; NAMEL = (char *) "y0l";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_Y0_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case y0_negative:
+    /* y0(x<0) */
+    {
+       DOMAIND; NAMED = (char *) "y0";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_Y0_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case y0f_negative:
+    /* y0f(x<0) */
+    {
+       DOMAINF; NAMEF = (char *) "y0f";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+           WRITEF_Y0_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case y1l_negative:
+    /* y1l(x<0) */
+    {
+       DOMAINL; NAMEL = (char *) "y1l";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+           WRITEL_Y1_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case y1_negative:
+    /* y1(x<0) */
+    {
+       DOMAIND; NAMED = (char *) "y1";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_Y1_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case y1f_negative:
+    /* y1f(x<0) */
+    {
+       DOMAINF; NAMEF = (char *) "y1f";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+           WRITEF_Y1_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case ynl_negative:
+    /* ynl(x<0) */
+    {
+       DOMAINL; NAMEL = (char *) "ynl";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEL;
+         NOT_MATHERRL
+         {
+          WRITEL_YN_NEGATIVE;
+          ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALL;
+         NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case yn_negative:
+    /* yn(x<0) */
+    {
+       DOMAIND; NAMED = (char *) "yn";
+       ifSVID
+       {
+         RETVAL_NEG_HUGED;
+         NOT_MATHERRD
+         {
+           WRITED_YN_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALD;
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case ynf_negative:
+    /* ynf(x<0) */
+    {
+       DOMAINF; NAMEF = (char *) "ynf";
+       ifSVID
+       {
+         RETVAL_NEG_HUGEF;
+         NOT_MATHERRF
+         {
+           WRITEF_YN_NEGATIVE;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         RETVAL_NEG_HUGE_VALF;
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case fmodl_by_zero:
+    /* fmodl(x,0) */
+    {
+       DOMAINL; NAMEL = (char *) "fmodl";
+       ifSVID
+       {
+            *(long double *)retval = *(long double *)arg1;
+            NOT_MATHERRL
+            {
+              WRITEL_FMOD;
+              ERRNO_DOMAIN;
+            }
+       }
+       else
+       { /* NaN already computed */
+            NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case fmod_by_zero:
+    /* fmod(x,0) */
+    {
+       DOMAIND; NAMED = (char *) "fmod";
+       ifSVID
+       {
+         *(double *)retval = *(double *)arg1;
+         NOT_MATHERRD
+         {
+           WRITED_FMOD;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       { /* NaN already computed */
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case fmodf_by_zero:
+    /* fmodf(x,0) */
+    {
+       DOMAINF; NAMEF = (char *) "fmodf";
+       ifSVID
+       {
+         *(float *)retval = *(float *)arg1;
+         NOT_MATHERRF
+         {
+           WRITEF_FMOD;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  case remainderl_by_zero:
+    /* remainderl(x,0) */
+    {
+       DOMAINL; NAMEL = (char *) "remainderl";
+       ifSVID
+       {
+          NOT_MATHERRL
+          {
+            WRITEL_REM;
+            ERRNO_DOMAIN;
+          }
+       }
+       else
+       { /* NaN already computed */
+            NOT_MATHERRL {ERRNO_DOMAIN;}
+       }
+       *(long double *)retval = excl.retval;
+       break;
+    }
+  case remainder_by_zero:
+    /* remainder(x,0) */
+    {
+       DOMAIND; NAMED = (char *) "remainder";
+       ifSVID
+       {
+         NOT_MATHERRD
+         {
+           WRITED_REM;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       { /* NaN already computed */
+         NOT_MATHERRD {ERRNO_DOMAIN;}
+       }
+       *(double *)retval = exc.retval;
+       break;
+    }
+  case remainderf_by_zero:
+    /* remainderf(x,0) */
+    {
+       DOMAINF; NAMEF = (char *) "remainderf";
+       ifSVID
+       {
+         NOT_MATHERRF
+         {
+           WRITEF_REM;
+           ERRNO_DOMAIN;
+         }
+       }
+       else
+       {
+         NOT_MATHERRF {ERRNO_DOMAIN;}
+       }
+       *(float *)retval = excf.retval;
+       break;
+    }
+  default:
+    /* We don't want to abort () since SVID doesn't cover all math
+       library functions.  */
+    break;
+   }
+   return;
+   }
+}
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_error_codes.h
@@ -0,0 +1,210 @@
+/* file: libm_error_codes.h */
+
+
+/*
+// Copyright (c) 2000 - 2004, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+
+// Abstract:
+// ========================================================================
+// This file contains the interface to the Intel exception dispatcher.
+//
+//
+// History:
+// ========================================================================
+// 12/15/2004 Initial version - extracted from libm_support.h
+//
+*/
+
+#if !defined(__LIBM_ERROR_CODES_H__)
+#define __LIBM_ERROR_CODES_H__
+
+typedef enum
+{
+  logl_zero=0,   logl_negative,                  /*  0,  1 */
+  log_zero,      log_negative,                   /*  2,  3 */
+  logf_zero,     logf_negative,                  /*  4,  5 */
+  log10l_zero,   log10l_negative,                /*  6,  7 */
+  log10_zero,    log10_negative,                 /*  8,  9 */
+  log10f_zero,   log10f_negative,                /* 10, 11 */
+  expl_overflow, expl_underflow,                 /* 12, 13 */
+  exp_overflow,  exp_underflow,                  /* 14, 15 */
+  expf_overflow, expf_underflow,                 /* 16, 17 */
+  powl_overflow, powl_underflow,                 /* 18, 19 */
+  powl_zero_to_zero,                             /* 20     */
+  powl_zero_to_negative,                         /* 21     */
+  powl_neg_to_non_integer,                       /* 22     */
+  powl_nan_to_zero,                              /* 23     */
+  pow_overflow,  pow_underflow,                  /* 24, 25 */
+  pow_zero_to_zero,                              /* 26     */
+  pow_zero_to_negative,                          /* 27     */
+  pow_neg_to_non_integer,                        /* 28     */
+  pow_nan_to_zero,                               /* 29     */
+  powf_overflow, powf_underflow,                 /* 30, 31 */
+  powf_zero_to_zero,                             /* 32     */
+  powf_zero_to_negative,                         /* 33     */
+  powf_neg_to_non_integer,                       /* 34     */
+  powf_nan_to_zero,                              /* 35     */
+  atan2l_zero,                                   /* 36     */
+  atan2_zero,                                    /* 37     */
+  atan2f_zero,                                   /* 38     */
+  expm1l_overflow,                               /* 39     */
+  expm1l_underflow,                              /* 40     */
+  expm1_overflow,                                /* 41     */
+  expm1_underflow,                               /* 42     */
+  expm1f_overflow,                               /* 43     */
+  expm1f_underflow,                              /* 44     */
+  hypotl_overflow,                               /* 45     */
+  hypot_overflow,                                /* 46     */
+  hypotf_overflow,                               /* 47     */
+  sqrtl_negative,                                /* 48     */
+  sqrt_negative,                                 /* 49     */
+  sqrtf_negative,                                /* 50     */
+  scalbl_overflow, scalbl_underflow,             /* 51, 52  */
+  scalb_overflow,  scalb_underflow,              /* 53, 54  */
+  scalbf_overflow, scalbf_underflow,             /* 55, 56  */
+  acosl_gt_one, acos_gt_one, acosf_gt_one,       /* 57, 58, 59 */
+  asinl_gt_one, asin_gt_one, asinf_gt_one,       /* 60, 61, 62 */
+  coshl_overflow, cosh_overflow, coshf_overflow, /* 63, 64, 65 */
+  y0l_zero, y0l_negative,y0l_gt_loss,            /* 66, 67, 68 */
+  y0_zero, y0_negative,y0_gt_loss,               /* 69, 70, 71 */
+  y0f_zero, y0f_negative,y0f_gt_loss,            /* 72, 73, 74 */
+  y1l_zero, y1l_negative,y1l_gt_loss,            /* 75, 76, 77 */
+  y1_zero, y1_negative,y1_gt_loss,               /* 78, 79, 80 */
+  y1f_zero, y1f_negative,y1f_gt_loss,            /* 81, 82, 83 */
+  ynl_zero, ynl_negative,ynl_gt_loss,            /* 84, 85, 86 */
+  yn_zero, yn_negative,yn_gt_loss,               /* 87, 88, 89 */
+  ynf_zero, ynf_negative,ynf_gt_loss,            /* 90, 91, 92 */
+  j0l_gt_loss,                                   /* 93 */
+  j0_gt_loss,                                    /* 94 */
+  j0f_gt_loss,                                   /* 95 */
+  j1l_gt_loss,                                   /* 96 */
+  j1_gt_loss,                                    /* 97 */
+  j1f_gt_loss,                                   /* 98 */
+  jnl_gt_loss,                                   /* 99 */
+  jn_gt_loss,                                    /* 100 */
+  jnf_gt_loss,                                   /* 101 */
+  lgammal_overflow, lgammal_negative,lgammal_reserve, /* 102, 103, 104 */
+  lgamma_overflow, lgamma_negative,lgamma_reserve,    /* 105, 106, 107 */
+  lgammaf_overflow, lgammaf_negative, lgammaf_reserve,/* 108, 109, 110 */
+  gammal_overflow,gammal_negative, gammal_reserve,    /* 111, 112, 113 */
+  gamma_overflow, gamma_negative, gamma_reserve,      /* 114, 115, 116 */
+  gammaf_overflow,gammaf_negative,gammaf_reserve,     /* 117, 118, 119 */
+  fmodl_by_zero,                                 /* 120 */
+  fmod_by_zero,                                  /* 121 */
+  fmodf_by_zero,                                 /* 122 */
+  remainderl_by_zero,                            /* 123 */
+  remainder_by_zero,                             /* 124 */
+  remainderf_by_zero,                            /* 125 */
+  sinhl_overflow, sinh_overflow, sinhf_overflow, /* 126, 127, 128 */
+  atanhl_gt_one, atanhl_eq_one,                  /* 129, 130 */
+  atanh_gt_one, atanh_eq_one,                    /* 131, 132 */
+  atanhf_gt_one, atanhf_eq_one,                  /* 133, 134 */
+  acoshl_lt_one,                                 /* 135 */
+  acosh_lt_one,                                  /* 136 */
+  acoshf_lt_one,                                 /* 137 */
+  log1pl_zero,   log1pl_negative,                /* 138, 139 */
+  log1p_zero,    log1p_negative,                 /* 140, 141 */
+  log1pf_zero,   log1pf_negative,                /* 142, 143 */
+  ldexpl_overflow,   ldexpl_underflow,           /* 144, 145 */
+  ldexp_overflow,    ldexp_underflow,            /* 146, 147 */
+  ldexpf_overflow,   ldexpf_underflow,           /* 148, 149 */
+  logbl_zero,   logb_zero, logbf_zero,           /* 150, 151, 152 */
+  nextafterl_overflow,   nextafter_overflow,
+  nextafterf_overflow,                           /* 153, 154, 155 */
+  ilogbl_zero,  ilogb_zero, ilogbf_zero,         /* 156, 157, 158 */
+  exp2l_overflow, exp2l_underflow,               /* 159, 160 */
+  exp2_overflow,  exp2_underflow,                /* 161, 162 */
+  exp2f_overflow, exp2f_underflow,               /* 163, 164 */
+  exp10l_overflow, exp10_overflow,
+  exp10f_overflow,                               /* 165, 166, 167 */
+  log2l_zero,    log2l_negative,                 /* 168, 169 */
+  log2_zero,     log2_negative,                  /* 170, 171 */
+  log2f_zero,    log2f_negative,                 /* 172, 173 */
+  scalbnl_overflow, scalbnl_underflow,           /* 174, 175 */
+  scalbn_overflow,  scalbn_underflow,            /* 176, 177 */
+  scalbnf_overflow, scalbnf_underflow,           /* 178, 179 */
+  remquol_by_zero,                               /* 180 */
+  remquo_by_zero,                                /* 181 */
+  remquof_by_zero,                               /* 182 */
+  lrintl_large, lrint_large, lrintf_large,       /* 183, 184, 185 */
+  llrintl_large, llrint_large, llrintf_large,    /* 186, 187, 188 */
+  lroundl_large, lround_large, lroundf_large,    /* 189, 190, 191 */
+  llroundl_large, llround_large, llroundf_large, /* 192, 193, 194 */
+  fdiml_overflow, fdim_overflow, fdimf_overflow, /* 195, 196, 197 */
+  nexttowardl_overflow,   nexttoward_overflow,
+  nexttowardf_overflow,                          /* 198, 199, 200 */
+  scalblnl_overflow, scalblnl_underflow,         /* 201, 202 */
+  scalbln_overflow,  scalbln_underflow,          /* 203, 204 */
+  scalblnf_overflow, scalblnf_underflow,         /* 205, 206 */
+  erfcl_underflow, erfc_underflow, erfcf_underflow, /* 207, 208, 209 */
+  acosdl_gt_one, acosd_gt_one, acosdf_gt_one,    /* 210, 211, 212 */
+  asindl_gt_one, asind_gt_one, asindf_gt_one,    /* 213, 214, 215 */
+  atan2dl_zero, atan2d_zero, atan2df_zero,       /* 216, 217, 218 */
+  tandl_overflow, tand_overflow, tandf_overflow, /* 219, 220, 221 */
+  cotdl_overflow, cotd_overflow, cotdf_overflow, /* 222, 223, 224 */
+  cotl_overflow, cot_overflow, cotf_overflow,    /* 225, 226, 227 */
+  sinhcoshl_overflow, sinhcosh_overflow, sinhcoshf_overflow, /* 228, 229, 230 */
+  annuityl_by_zero, annuity_by_zero, annuityf_by_zero, /* 231, 232, 233 */
+  annuityl_less_m1, annuity_less_m1, annuityf_less_m1, /* 234, 235, 236 */
+  annuityl_overflow, annuity_overflow, annuityf_overflow, /* 237, 238, 239 */
+  annuityl_underflow, annuity_underflow, annuityf_underflow, /* 240, 241, 242 */
+  compoundl_by_zero, compound_by_zero, compoundf_by_zero, /* 243, 244, 245 */
+  compoundl_less_m1, compound_less_m1, compoundf_less_m1, /* 246, 247, 248 */
+  compoundl_overflow, compound_overflow, compoundf_overflow, /* 249, 250, 251 */
+  compoundl_underflow, compound_underflow, compoundf_underflow, /* 252, 253, 254 */
+  tgammal_overflow, tgammal_negative, tgammal_reserve, /* 255, 256, 257 */
+  tgamma_overflow, tgamma_negative, tgamma_reserve, /* 258, 259, 260 */
+  tgammaf_overflow, tgammaf_negative, tgammaf_reserve, /* 261, 262, 263 */
+  exp10l_underflow, exp10_underflow, exp10f_underflow, /* 264, 265, 266 */
+  nextafterl_underflow, nextafter_underflow,
+  nextafterf_underflow,                                /* 267, 268, 269 */
+  nexttowardl_underflow, nexttoward_underflow,
+  nexttowardf_underflow                                /* 270, 271, 272 */
+} error_types;
+
+#define LIBM_ERROR __libm_error_support
+
+extern void LIBM_ERROR(void*,void*,void*,error_types);
+#ifdef _LIBC
+libc_hidden_proto(LIBM_ERROR)
+#endif
+
+#define LIBM_ERROR1(x,r,e)	LIBM_ERROR(&(x), (void *)0, &(r), e)
+#define LIBM_ERROR2(x,y,r,e)	LIBM_ERROR(&(x), &(y), &(r), e)
+
+#endif // !defined(__LIBM_ERROR_CODES_H__)
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_frexp.S
@@ -0,0 +1,208 @@
+.file "libm_frexp.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 03/20/00 Improved speed
+// 06/01/00 Fixed bug when x a double-extended denormal
+// 12/08/00 Corrected label on .endp
+// 01/23/02 Added handling for int 32 or 64 bits
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+// API
+//==============================================================
+// double __libm_frexp(double x, int* y, int int_type)
+// input  floating point f8, pointer to y (r33), int int_type (r34)
+// output floating point f8, returns the fraction of x, 0.5 <= fraction < 1.0
+// output int* y, returns the true exponent of x
+//
+// int_type = 0 if int is 32 bits
+// int_type = 1 if int is 64 bits
+//
+// int* y is returned as a 32 bit integer if int_type = 0
+// int* y is returned as a 64 bit integer if int_type = 1
+//
+// Overview of operation
+//==============================================================
+// break a floating point x number into fraction and an exponent
+// The fraction is returned as a double
+// The exponent is returned as an integer pointed to by y
+//    This is a true (not a biased exponent) but 0fffe is subtracted
+//    as a bias instead of 0xffff. This is because the fraction returned
+//    is between 0.5 and 1.0, not the expected IEEE range.
+//
+// The fraction is 0.5 <= fraction < 1.0
+//
+// Registers used
+//==============================================================
+//
+// general registers:
+// r14  exponent bias for x negative
+// r15  exponent bias for x positive
+// r16  signexp of x
+// r17  exponent mask
+// r18  exponent of x
+// r19  exponent result
+// r20  signexp of 2^64
+// r32  on input contains the 64-bit IEEE double that is in f8
+// r33  on input pointer to 32-bit or 64-bit integer for exponent
+// r34  on input contains 0 if output int is 32 bits, else output int is 64 bits
+//
+// predicate registers:
+// p6   set if x is Nan, zero, or infinity
+// p7   set if x negative
+// p8   set if x positive
+// p9   set if x double-extended denormal
+// p10  set if int_type = 0, 32-bit integer
+// p11  set if int_type = 1, 64-bit integer
+//
+// floating-point registers:
+// f8  input, output
+// f9  normalized x
+// f10 signexp for significand result for x positive
+// f11 signexp for significand result for x negative
+// f12 2^64
+
+.section .text
+GLOBAL_LIBM_ENTRY(__libm_frexp)
+
+// Set signexp for significand result for x>0
+// If x is a NaN, zero, or infinity, return it.
+// Put 0 in the int pointer.
+// x NAN, ZERO, INFINITY?
+// Set signexp for significand result for x<0
+{ .mfi
+        mov         r15 = 0x0fffe
+        fclass.m    p6,p7 = f8, 0xe7
+        mov         r14 = 0x2fffe
+}
+// Form signexp of 2^64 in case x double-extended denormal
+// Save the normalized value of input in f9
+// The normalization also sets fault flags and takes faults if necessary
+{ .mfi
+        mov         r20 = 0x1003f
+        fnorm.s0    f9 = f8
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x>0 to FP reg
+// Form 2^64 in case x double-extended denormal
+{ .mmi
+        setf.exp    f10 = r15
+        setf.exp    f12 = r20
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x<0 to FP reg
+// p7 if x<0, else p8
+// If x=0,nan,inf, set p10 if output int to be 32 bits, or set p11 if 64 bits
+{ .mfi
+        setf.exp    f11 = r14
+(p7)    fcmp.lt.s0  p7,p8 = f8,f0
+(p6)    cmp.eq.unc  p10,p11 = r34, r0 ;;
+}
+
+// If x NAN, ZERO, INFINITY, set *y=0 and exit
+{ .mmb
+(p10)   st4         [r33] = r0      // Store *y=0 as 32-bit integer
+(p11)   st8         [r33] = r0      // Store *y=0 as 64-bit integer
+(p6)    br.ret.spnt b0 ;;
+}
+
+// Form exponent mask
+// Test for fnorm(x) denormal, means x double-extended denormal
+{ .mfi
+        mov         r17 = 0x1ffff
+        fclass.m    p9,p0 = f9, 0x0b
+        nop.i 999 ;;
+}
+
+// If x double-extended denormal add 64 to exponent bias for scaling
+// If x double-extended denormal multiply x * 2^64 which is normal
+// Set p10 if output int to be 32 bits, or set p11 if 64 bits
+{ .mfi
+(p9)    add         r15 = 64, r15
+(p9)    fmpy.s0     f9 = f9, f12
+        cmp.eq      p10,p11 = r34, r0 ;;
+}
+
+// true exponent stored to int pointer
+// the bias is treated as 0xfffe instead of
+// normal 0xffff because we want the significand
+// to be in the range <=0.5 sig < 1.0
+// Store the value of the exponent at the pointer in r33
+
+// If x>0 form significand result
+{ .mfi
+        nop.m 999
+(p8)    fmerge.se   f8 = f10,f9
+        nop.i 999  ;;
+}
+
+// Get signexp of normalized x
+// If x<0 form significand result
+{ .mfi
+        getf.exp    r16 = f9
+(p7)    fmerge.se   f8 = f11,f9
+        nop.i 999  ;;
+}
+
+// Get exp of normalized x
+// Subtract off bias to get true exponent of x
+{ .mmi
+        and         r18 = r17,r16 ;;
+        sub         r19 = r18,r15
+        nop.i 999  ;;
+}
+
+// Store int *y as a 32-bit integer
+// Make the value a double
+{ .mfi
+(p10)   st4         [r33] = r19        // Store *y as 32-bit integer
+        fnorm.d.s0  f8 = f8
+        nop.i 999
+}
+{ .mfb
+(p11)   st8         [r33] = r19        // Store *y as 64-bit integer
+        nop.f 999
+        br.ret.sptk b0 ;;
+}
+
+GLOBAL_LIBM_END(__libm_frexp)
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_frexp4.S
@@ -0,0 +1,197 @@
+.file "libm_frexp_4.s"
+
+// Copyright (C) 2000, 2001, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://developer.intel.com/opensource.
+//
+// History
+//==============================================================
+// 2/02/00: Initial version
+// 3/20/00: Improved speed
+// 6/01/00: Fixed bug when x a double-extended denormal
+// 12/08/00 Corrected label on .endp
+//
+// API
+//==============================================================
+// double frexp(double x, int* y)
+// double __libm_frexp_4(double x, int* y)
+//   where int* y is a 32-bit integer
+//
+// Overview of operation
+//==============================================================
+// break a floating point x number into fraction and an exponent
+// The fraction is returned as a double
+// The exponent is returned as an integer pointed to by y
+//    This is a true (not a biased exponent) but 0fffe is subtracted
+//    as a bias instead of 0xffff. This is because the fraction returned
+//    is between 0.5 and 1.0, not the expected IEEE range.
+//
+// The fraction is 0.5 <= fraction < 1.0
+//
+// Registers used
+//==============================================================
+//
+// general registers:
+// r14  exponent bias for x negative
+// r15  exponent bias for x positive
+// r16  signexp of x
+// r17  exponent mask
+// r18  exponent of x
+// r19  exponent result
+// r20  signexp of 2^64
+// r32  on input contains the 64-bit IEEE double that is in f8
+// r33  on input pointer to 32-bit integer for exponent
+//
+// predicate registers:
+// p6   set if x is Nan, zero, or infinity
+// p7   set if x negative
+// p8   set if x positive
+// p9   set if x double-extended denormal
+//
+// floating-point registers:
+// f8  input, output
+// f9  normalized x
+// f10 signexp for significand result for x positive
+// f11 signexp for significand result for x negative
+// f12 2^64
+
+#include "libm_support.h"
+
+.align 32
+.global __libm_frexp_4#
+
+.section .text
+.proc  __libm_frexp_4#
+.align 32
+
+__libm_frexp_4:
+
+// Set signexp for significand result for x>0
+// If x is a NaN, zero, or infinity, return it.
+// Put 0 in the int pointer.
+// x NAN, ZERO, INFINITY?
+// Set signexp for significand result for x<0
+{ .mfi
+(p0)    mov         r15 = 0x0fffe
+(p0)    fclass.m.unc p6,p0 = f8, 0xe7
+(p0)    mov         r14 = 0x2fffe
+}
+// Form signexp of 2^64 in case x double-extended denormal
+// Save the normalized value of input in f9
+// The normalization also sets fault flags and takes faults if necessary
+{ .mfi
+(p0)    mov         r20 = 0x1003f
+(p0)    fnorm       f9 = f8
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x>0 to FP reg
+// Form 2^64 in case x double-extended denormal
+{ .mmi
+(p0)    setf.exp    f10 = r15
+(p0)    setf.exp    f12 = r20
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x<0 to FP reg
+// If x NAN, ZERO, INFINITY, set *y=0 as a 32-bit integer, and exit
+{ .mmb
+(p0)    setf.exp    f11 = r14
+(p6)    st4         [r33] = r0
+(p6)    br.ret.spnt b0 ;;
+}
+
+// Form exponent mask
+// p7 if x<0, else p8
+{ .mfi
+(p0)    mov         r17 = 0x1ffff
+(p0)    fcmp.lt.unc p7,p8 = f8,f0
+        nop.i 999 ;;
+}
+
+// Test for fnorm(x) denormal, means x double-extended denormal
+{ .mfi
+        nop.m 999
+(p0)    fclass.m.unc p9,p0 = f9, 0x0b
+        nop.i 999 ;;
+}
+
+// If x double-extended denormal add 64 to exponent bias for scaling
+// If x double-extended denormal multiply x * 2^64 which is normal
+{ .mfi
+(p9)    add         r15 = 64, r15
+(p9)    fmpy        f9 = f9, f12
+        nop.i 999 ;;
+}
+
+// true exponent stored to int pointer
+// the bias is treated as 0xfffe instead of
+// normal 0xffff because we want the significand
+// to be in the range <=0.5 sig < 1.0
+// Store the value of the exponent at the pointer in r33
+
+// If x>0 form significand result
+{ .mfi
+        nop.m 999
+(p8)    fmerge.se   f8 = f10,f9
+        nop.i 999  ;;
+}
+
+// Get signexp of normalized x
+// If x<0 form significand result
+{ .mfi
+(p0)    getf.exp    r16 = f9
+(p7)    fmerge.se   f8 = f11,f9
+        nop.i 999  ;;
+}
+
+// Get exp of normalized x
+// Subtract off bias to get true exponent of x
+{ .mmi
+(p0)    and         r18 = r17,r16 ;;
+(p0)    sub         r19 = r18,r15
+        nop.i 999  ;;
+}
+
+// Store int y as a 32-bit integer
+// Make the value a double
+{ .mfb
+(p0)    st4         [r33] = r19
+(p0)    fnorm.d     f8 = f8
+(p0)    br.ret.sptk b0 ;;
+}
+
+.endp __libm_frexp_4
+ASM_SIZE_DIRECTIVE(__libm_frexp_4)
+strong_alias(__libm_frexp_4, _GI___libm_frexp_4)
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_frexp4f.S
@@ -0,0 +1,197 @@
+.file "libm_frexp_4f.s"
+
+// Copyright (C) 2000, 2001, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://developer.intel.com/opensource.
+//
+// History
+//==============================================================
+// 2/02/00: Initial version
+// 3/20/00: Improved speed
+// 6/01/00: Fixed bug when x a double-extended denormal
+// 12/08/00 Corrected label on .endp
+//
+// API
+//==============================================================
+// float frexp(float x, int* y)
+// float __libm_frexp_4f(float x, int* y)
+//   where int* y is a 32-bit integer
+//
+// Overview of operation
+//==============================================================
+// break a floating point x number into fraction and an exponent
+// The fraction is returned as a float
+// The exponent is returned as an integer pointed to by y
+//    This is a true (not a biased exponent) but 0fffe is subtracted
+//    as a bias instead of 0xffff. This is because the fraction returned
+//    is between 0.5 and 1.0, not the expected IEEE range.
+//
+// The fraction is 0.5 <= fraction < 1.0
+//
+// Registers used
+//==============================================================
+
+// general registers:
+// r14  exponent bias for x negative
+// r15  exponent bias for x positive
+// r16  signexp of x
+// r17  exponent mask
+// r18  exponent of x
+// r19  exponent result
+// r20  signexp of 2^64
+// r32  on input contains the 32-bit IEEE float that is in f8
+// r33  on input pointer to 32-bit integer for exponent
+
+// predicate registers:
+// p6   set if x is Nan, zero, or infinity
+// p7   set if x negative
+// p8   set if x positive
+// p9   set if x double-extended denormal
+
+// floating-point registers:
+// f8  input, output
+// f9  normalized x
+// f10 signexp for significand result for x positive
+// f11 signexp for significand result for x negative
+// f12 2^64
+
+#include "libm_support.h"
+
+.align 32
+.global __libm_frexp_4f#
+
+.section .text
+.proc  __libm_frexp_4f#
+.align 32
+
+__libm_frexp_4f:
+
+// Set signexp for significand result for x>0
+// If x is a NaN, zero, or infinity, return it.
+// Put 0 in the int pointer.
+// x NAN, ZERO, INFINITY?
+// Set signexp for significand result for x<0
+{ .mfi
+(p0)    mov         r15 = 0x0fffe
+(p0)    fclass.m.unc p6,p0 = f8, 0xe7
+(p0)    mov         r14 = 0x2fffe
+}
+// Form signexp of 2^64 in case x double-extended denormal
+// Save the normalized value of input in f9
+// The normalization also sets fault flags and takes faults if necessary
+{ .mfi
+(p0)    mov         r20 = 0x1003f
+(p0)    fnorm       f9 = f8
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x>0 to FP reg
+// Form 2^64 in case x double-extended denormal
+{ .mmi
+(p0)    setf.exp    f10 = r15
+(p0)    setf.exp    f12 = r20
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x<0 to FP reg
+// If x NAN, ZERO, INFINITY, set *y=0 as a 32-bit integer, and exit
+{ .mmb
+(p0)    setf.exp    f11 = r14
+(p6)    st4         [r33] = r0
+(p6)    br.ret.spnt b0 ;;
+}
+
+// Form exponent mask
+// p7 if x<0, else p8
+{ .mfi
+(p0)    mov         r17 = 0x1ffff
+(p0)    fcmp.lt.unc p7,p8 = f8,f0
+        nop.i 999 ;;
+}
+
+// Test for fnorm(x) denormal, means x double-extended denormal
+{ .mfi
+        nop.m 999
+(p0)    fclass.m.unc p9,p0 = f9, 0x0b
+        nop.i 999 ;;
+}
+
+// If x double-extended denormal add 64 to exponent bias for scaling
+// If x double-extended denormal multiply x * 2^64 which is normal
+{ .mfi
+(p9)    add         r15 = 64, r15
+(p9)    fmpy        f9 = f9, f12
+        nop.i 999 ;;
+}
+
+// true exponent stored to int pointer
+// the bias is treated as 0xfffe instead of
+// normal 0xffff because we want the significand
+// to be in the range <=0.5 sig < 1.0
+// Store the value of the exponent at the pointer in r33
+
+// If x>0 form significand result
+{ .mfi
+        nop.m 999
+(p8)    fmerge.se   f8 = f10,f9
+        nop.i 999  ;;
+}
+
+// Get signexp of normalized x
+// If x<0 form significand result
+{ .mfi
+(p0)    getf.exp    r16 = f9
+(p7)    fmerge.se   f8 = f11,f9
+        nop.i 999  ;;
+}
+
+// Get exp of normalized x
+// Subtract off bias to get true exponent of x
+{ .mmi
+(p0)    and         r18 = r17,r16 ;;
+(p0)    sub         r19 = r18,r15
+        nop.i 999  ;;
+}
+
+// Store int y as a 32-bit integer
+// Make the value a float
+{ .mfb
+(p0)    st4         [r33] = r19
+(p0)    fnorm.s     f8 = f8
+(p0)    br.ret.sptk b0 ;;
+}
+
+.endp __libm_frexp_4f
+ASM_SIZE_DIRECTIVE(__libm_frexp_4f)
+strong_alias(__libm_frexp_4f, _GI___libm_frexp_4f)
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_frexp4l.S
@@ -0,0 +1,196 @@
+.file "libm_frexp_4l.s"
+
+// Copyright (C) 2000, 2001, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://developer.intel.com/opensource.
+//
+// History
+//==============================================================
+// 3/20/00: Initial version
+// 6/01/00: Fixed bug when x a double-extended denormal
+// 12/08/00 Corrected label on .endp
+//
+// API
+//==============================================================
+// long double frexpl(long double x, int* y)
+// long double __libm_frexp_4l(long double x, int* y)
+//   where int* y is a 32-bit integer
+//
+// Overview of operation
+//==============================================================
+// break a floating point x number into fraction and an exponent
+// The fraction is returned as a long double
+// The exponent is returned as an integer pointed to by y
+//    This is a true (not a biased exponent) but 0fffe is subtracted
+//    as a bias instead of 0xffff. This is because the fraction returned
+//    is between 0.5 and 1.0, not the expected IEEE range.
+//
+// The fraction is 0.5 <= fraction < 1.0
+//
+// Registers used
+//==============================================================
+//
+// general registers:
+// r14  exponent bias for x negative
+// r15  exponent bias for x positive
+// r16  signexp of x
+// r17  exponent mask
+// r18  exponent of x
+// r19  exponent result
+// r20  signexp of 2^64
+// r32-33  on input contains the 80-bit IEEE long double that is in f8
+// r34  on input pointer to 32-bit integer for exponent
+//
+// predicate registers:
+// p6   set if x is Nan, zero, or infinity
+// p7   set if x negative
+// p8   set if x positive
+// p9   set if x double-extended denormal
+//
+// floating-point registers:
+// f8  input, output
+// f9  normalized x
+// f10 signexp for significand result for x positive
+// f11 signexp for significand result for x negative
+// f12 2^64
+
+#include "libm_support.h"
+
+.align 32
+.global __libm_frexp_4l#
+
+.section .text
+.proc  __libm_frexp_4l#
+.align 32
+
+__libm_frexp_4l:
+
+// Set signexp for significand result for x>0
+// If x is a NaN, zero, or infinity, return it.
+// Put 0 in the int pointer.
+// x NAN, ZERO, INFINITY?
+// Set signexp for significand result for x<0
+{ .mfi
+(p0)    mov         r15 = 0x0fffe
+(p0)    fclass.m.unc p6,p0 = f8, 0xe7
+(p0)    mov         r14 = 0x2fffe
+}
+// Form signexp of 2^64 in case x double-extended denormal
+// Save the normalized value of input in f9
+// The normalization also sets fault flags and takes faults if necessary
+{ .mfi
+(p0)    mov         r20 = 0x1003f
+(p0)    fnorm       f9 = f8
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x>0 to FP reg
+// Form 2^64 in case x double-extended denormal
+{ .mmi
+(p0)    setf.exp    f10 = r15
+(p0)    setf.exp    f12 = r20
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x<0 to FP reg
+// If x NAN, ZERO, INFINITY, set *y=0 as a 32-bit integer, and exit
+{ .mmb
+(p0)    setf.exp    f11 = r14
+(p6)    st4         [r34] = r0
+(p6)    br.ret.spnt b0 ;;
+}
+
+// Form exponent mask
+// p7 if x<0, else p8
+{ .mfi
+(p0)    mov         r17 = 0x1ffff
+(p0)    fcmp.lt.unc p7,p8 = f8,f0
+        nop.i 999 ;;
+}
+
+// Test for fnorm(x) denormal, means x double-extended denormal
+{ .mfi
+        nop.m 999
+(p0)    fclass.m.unc p9,p0 = f9, 0x0b
+        nop.i 999 ;;
+}
+
+// If x double-extended denormal add 64 to exponent bias for scaling
+// If x double-extended denormal multiply x * 2^64 which is normal
+{ .mfi
+(p9)    add         r15 = 64, r15
+(p9)    fmpy        f9 = f9, f12
+        nop.i 999 ;;
+}
+
+// true exponent stored to int pointer
+// the bias is treated as 0xfffe instead of
+// normal 0xffff because we want the significand
+// to be in the range <=0.5 sig < 1.0
+// Store the value of the exponent at the pointer in r34
+
+// If x>0 form significand result
+{ .mfi
+        nop.m 999
+(p8)    fmerge.se   f8 = f10,f9
+        nop.i 999  ;;
+}
+
+// Get signexp of normalized x
+// If x<0 form significand result
+{ .mfi
+(p0)    getf.exp    r16 = f9
+(p7)    fmerge.se   f8 = f11,f9
+        nop.i 999  ;;
+}
+
+// Get exp of normalized x
+// Subtract off bias to get true exponent of x
+{ .mmi
+(p0)    and         r18 = r17,r16 ;;
+(p0)    sub         r19 = r18,r15
+        nop.i 999  ;;
+}
+
+// Store int y as a 32-bit integer
+// Make the value a long double
+{ .mfb
+(p0)    st4         [r34] = r19
+(p0)    fnorm       f8 = f8
+(p0)    br.ret.sptk b0 ;;
+}
+
+.endp __libm_frexp_4l
+ASM_SIZE_DIRECTIVE(__libm_frexp_4l)
+strong_alias(__libm_frexp_4l, _GI___libm_frexp_4l)
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_frexpf.S
@@ -0,0 +1,208 @@
+.file "libm_frexpf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 03/20/00 Improved speed
+// 06/01/00 Fixed bug when x a double-extended denormal
+// 12/08/00 Corrected label on .endp
+// 01/23/02 Added handling for int 32 or 64 bits
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+// API
+//==============================================================
+// float __libm_frexpf(float x, int* y, int int_type)
+// input  floating point f8, pointer to y (r33), int int_type (r34)
+// output floating point f8, returns the fraction of x, 0.5 <= fraction < 1.0
+// output int* y, returns the true exponent of x
+//
+// int_type = 0 if int is 32 bits
+// int_type = 1 if int is 64 bits
+//
+// int* y is returned as a 32 bit integer if int_type = 0
+// int* y is returned as a 64 bit integer if int_type = 1
+//
+// Overview of operation
+//==============================================================
+// break a floating point x number into fraction and an exponent
+// The fraction is returned as a float
+// The exponent is returned as an integer pointed to by y
+//    This is a true (not a biased exponent) but 0fffe is subtracted
+//    as a bias instead of 0xffff. This is because the fraction returned
+//    is between 0.5 and 1.0, not the expected IEEE range.
+//
+// The fraction is 0.5 <= fraction < 1.0
+//
+// Registers used
+//==============================================================
+//
+// general registers:
+// r14  exponent bias for x negative
+// r15  exponent bias for x positive
+// r16  signexp of x
+// r17  exponent mask
+// r18  exponent of x
+// r19  exponent result
+// r20  signexp of 2^64
+// r32  on input contains the 32-bit IEEE float that is in f8
+// r33  on input pointer to 32-bit or 64-bit integer for exponent
+// r34  on input contains 0 if output int is 32 bits, else output int is 64 bits
+//
+// predicate registers:
+// p6   set if x is Nan, zero, or infinity
+// p7   set if x negative
+// p8   set if x positive
+// p9   set if x double-extended denormal
+// p10  set if int_type = 0, 32-bit integer
+// p11  set if int_type = 1, 64-bit integer
+//
+// floating-point registers:
+// f8  input, output
+// f9  normalized x
+// f10 signexp for significand result for x positive
+// f11 signexp for significand result for x negative
+// f12 2^64
+
+.section .text
+GLOBAL_LIBM_ENTRY(__libm_frexpf)
+
+// Set signexp for significand result for x>0
+// If x is a NaN, zero, or infinity, return it.
+// Put 0 in the int pointer.
+// x NAN, ZERO, INFINITY?
+// Set signexp for significand result for x<0
+{ .mfi
+        mov         r15 = 0x0fffe
+        fclass.m    p6,p7 = f8, 0xe7
+        mov         r14 = 0x2fffe
+}
+// Form signexp of 2^64 in case x double-extended denormal
+// Save the normalized value of input in f9
+// The normalization also sets fault flags and takes faults if necessary
+{ .mfi
+        mov         r20 = 0x1003f
+        fnorm.s0    f9 = f8
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x>0 to FP reg
+// Form 2^64 in case x double-extended denormal
+{ .mmi
+        setf.exp    f10 = r15
+        setf.exp    f12 = r20
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x<0 to FP reg
+// p7 if x<0, else p8
+// If x=0,nan,inf, set p10 if output int to be 32 bits, or set p11 if 64 bits
+{ .mfi
+        setf.exp    f11 = r14
+(p7)    fcmp.lt.s0  p7,p8 = f8,f0
+(p6)    cmp.eq.unc  p10,p11 = r34, r0 ;;
+}
+
+// If x NAN, ZERO, INFINITY, set *y=0 and exit
+{ .mmb
+(p10)   st4         [r33] = r0      // Store *y=0 as 32-bit integer
+(p11)   st8         [r33] = r0      // Store *y=0 as 64-bit integer
+(p6)    br.ret.spnt b0 ;;
+}
+
+// Form exponent mask
+// Test for fnorm(x) denormal, means x double-extended denormal
+{ .mfi
+        mov         r17 = 0x1ffff
+        fclass.m    p9,p0 = f9, 0x0b
+        nop.i 999 ;;
+}
+
+// If x double-extended denormal add 64 to exponent bias for scaling
+// If x double-extended denormal multiply x * 2^64 which is normal
+// Set p10 if output int to be 32 bits, or set p11 if 64 bits
+{ .mfi
+(p9)    add         r15 = 64, r15
+(p9)    fmpy.s0     f9 = f9, f12
+        cmp.eq      p10,p11 = r34, r0 ;;
+}
+
+// true exponent stored to int pointer
+// the bias is treated as 0xfffe instead of
+// normal 0xffff because we want the significand
+// to be in the range <=0.5 sig < 1.0
+// Store the value of the exponent at the pointer in r33
+
+// If x>0 form significand result
+{ .mfi
+        nop.m 999
+(p8)    fmerge.se   f8 = f10,f9
+        nop.i 999  ;;
+}
+
+// Get signexp of normalized x
+// If x<0 form significand result
+{ .mfi
+        getf.exp    r16 = f9
+(p7)    fmerge.se   f8 = f11,f9
+        nop.i 999  ;;
+}
+
+// Get exp of normalized x
+// Subtract off bias to get true exponent of x
+{ .mmi
+        and         r18 = r17,r16 ;;
+        sub         r19 = r18,r15
+        nop.i 999  ;;
+}
+
+// Store int *y as a 32-bit integer
+// Make the value a float
+{ .mfi
+(p10)   st4         [r33] = r19        // Store *y as 32-bit integer
+        fnorm.s.s0  f8 = f8
+        nop.i 999
+}
+{ .mfb
+(p11)   st8         [r33] = r19        // Store *y as 64-bit integer
+        nop.f 999
+        br.ret.sptk b0 ;;
+}
+
+GLOBAL_LIBM_END(__libm_frexpf)
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_frexpl.S
@@ -0,0 +1,208 @@
+.file "libm_frexpl.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 03/20/00 Improved speed
+// 06/01/00 Fixed bug when x a double-extended denormal
+// 12/08/00 Corrected label on .endp
+// 01/23/02 Added handling for int 32 or 64 bits
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+//
+// API
+//==============================================================
+// long double __libm_frexpl(long double x, int* y, int int_type)
+// input  floating point f8, pointer to y (r34), int int_type (r35)
+// output floating point f8, returns the fraction of x, 0.5 <= fraction < 1.0
+// output int* y, returns the true exponent of x
+//
+// int_type = 0 if int is 32 bits
+// int_type = 1 if int is 64 bits
+//
+// int* y is returned as a 32 bit integer if int_type = 0
+// int* y is returned as a 64 bit integer if int_type = 1
+//
+// Overview of operation
+//==============================================================
+// break a floating point x number into fraction and an exponent
+// The fraction is returned as a long double
+// The exponent is returned as an integer pointed to by y
+//    This is a true (not a biased exponent) but 0fffe is subtracted
+//    as a bias instead of 0xffff. This is because the fraction returned
+//    is between 0.5 and 1.0, not the expected IEEE range.
+//
+// The fraction is 0.5 <= fraction < 1.0
+//
+// Registers used
+//==============================================================
+//
+// general registers:
+// r14  exponent bias for x negative
+// r15  exponent bias for x positive
+// r16  signexp of x
+// r17  exponent mask
+// r18  exponent of x
+// r19  exponent result
+// r20  signexp of 2^64
+// r32-33  on input contains the 80-bit IEEE long double that is in f8
+// r34  on input pointer to 32-bit or 64-bit integer for exponent
+// r35  on input contains 0 if output int is 32 bits, else output int is 64 bits
+//
+// predicate registers:
+// p6   set if x is Nan, zero, or infinity
+// p7   set if x negative
+// p8   set if x positive
+// p9   set if x double-extended denormal
+// p10  set if int_type = 0, 32-bit integer
+// p11  set if int_type = 1, 64-bit integer
+//
+// floating-point registers:
+// f8  input, output
+// f9  normalized x
+// f10 signexp for significand result for x positive
+// f11 signexp for significand result for x negative
+// f12 2^64
+
+.section .text
+GLOBAL_LIBM_ENTRY(__libm_frexpl)
+
+// Set signexp for significand result for x>0
+// If x is a NaN, zero, or infinity, return it.
+// Put 0 in the int pointer.
+// x NAN, ZERO, INFINITY?
+// Set signexp for significand result for x<0
+{ .mfi
+        mov         r15 = 0x0fffe
+        fclass.m    p6,p7 = f8, 0xe7
+        mov         r14 = 0x2fffe
+}
+// Form signexp of 2^64 in case x double-extended denormal
+// Save the normalized value of input in f9
+// The normalization also sets fault flags and takes faults if necessary
+{ .mfi
+        mov         r20 = 0x1003f
+        fnorm.s0    f9 = f8
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x>0 to FP reg
+// Form 2^64 in case x double-extended denormal
+{ .mmi
+        setf.exp    f10 = r15
+        setf.exp    f12 = r20
+        nop.i 999 ;;
+}
+
+// Move signexp for significand result for x<0 to FP reg
+// p7 if x<0, else p8
+// If x=0,nan,inf, set p10 if output int to be 32 bits, or set p11 if 64 bits
+{ .mfi
+        setf.exp    f11 = r14
+(p7)    fcmp.lt.s0  p7,p8 = f8,f0
+(p6)    cmp.eq.unc  p10,p11 = r35, r0 ;;
+}
+
+// If x NAN, ZERO, INFINITY, set *y=0 and exit
+{ .mmb
+(p10)   st4         [r34] = r0      // Store *y=0 as 32-bit integer
+(p11)   st8         [r34] = r0      // Store *y=0 as 64-bit integer
+(p6)    br.ret.spnt b0 ;;
+}
+
+// Form exponent mask
+// Test for fnorm(x) denormal, means x double-extended denormal
+{ .mfi
+        mov         r17 = 0x1ffff
+        fclass.m    p9,p0 = f9, 0x0b
+        nop.i 999 ;;
+}
+
+// If x double-extended denormal add 64 to exponent bias for scaling
+// If x double-extended denormal multiply x * 2^64 which is normal
+// Set p10 if output int to be 32 bits, or set p11 if 64 bits
+{ .mfi
+(p9)    add         r15 = 64, r15
+(p9)    fmpy.s0     f9 = f9, f12
+        cmp.eq      p10,p11 = r35, r0 ;;
+}
+
+// true exponent stored to int pointer
+// the bias is treated as 0xfffe instead of
+// normal 0xffff because we want the significand
+// to be in the range <=0.5 sig < 1.0
+// Store the value of the exponent at the pointer in r34
+
+// If x>0 form significand result
+{ .mfi
+        nop.m 999
+(p8)    fmerge.se   f8 = f10,f9
+        nop.i 999  ;;
+}
+
+// Get signexp of normalized x
+// If x<0 form significand result
+{ .mfi
+        getf.exp    r16 = f9
+(p7)    fmerge.se   f8 = f11,f9
+        nop.i 999  ;;
+}
+
+// Get exp of normalized x
+// Subtract off bias to get true exponent of x
+{ .mmi
+        and         r18 = r17,r16 ;;
+        sub         r19 = r18,r15
+        nop.i 999  ;;
+}
+
+// Store int *y as a 32-bit integer
+// Make the value a long double
+{ .mfi
+(p10)   st4         [r34] = r19        // Store *y as 32-bit integer
+        fnorm.s0    f8 = f8
+        nop.i 999
+}
+{ .mfb
+(p11)   st8         [r34] = r19        // Store *y as 64-bit integer
+        nop.f 999
+        br.ret.sptk b0 ;;
+}
+
+GLOBAL_LIBM_END(__libm_frexpl)
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_lgamma.S
@@ -0,0 +1,3622 @@
+.file "libm_lgamma.s"
+
+
+// Copyright (c) 2002 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,INCLUDING,BUT NOT
+// LIMITED TO,THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT,INDIRECT,INCIDENTAL,SPECIAL,
+// EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING,BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,DATA,OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY,WHETHER IN CONTRACT,STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE,EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code,and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 01/10/02  Initial version
+// 01/25/02  Corrected error tag numbers
+// 02/04/02  Added support of SIGN(GAMMA(x)) calculation
+// 05/20/02  Cleaned up namespace and sf0 syntax
+// 09/15/02  Fixed bug on the branch lgamma_negrecursion
+// 10/21/02  Now it returns SIGN(GAMMA(x))=-1 for negative zero
+// 02/10/03  Reordered header: .section, .global, .proc, .align
+// 07/22/03  Reformatted some data tables
+// 03/31/05  Reformatted delimiters between data tables
+//
+//*********************************************************************
+//
+//*********************************************************************
+//
+// Function: __libm_lgamma(double x, int* signgam, int szsigngam)
+// computes the principle value of the logarithm of the GAMMA function
+// of x. Signum of GAMMA(x) is stored to memory starting at the address
+// specified by the signgam.
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f6-f15
+//                              f32-f122
+//
+//    General Purpose Registers:
+//      r8-r11
+//      r14-r31
+//      r32-r36
+//      r37-r40 (Used to pass arguments to error handling routine)
+//
+//    Predicate Registers:      p6-p15
+//
+//*********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    __libm_lgamma(+inf) = +inf
+//    __libm_lgamma(-inf) = QNaN
+//    __libm_lgamma(+/-0) = +inf
+//    __libm_lgamma(x<0, x - integer) = +inf
+//    __libm_lgamma(SNaN) = QNaN
+//    __libm_lgamma(QNaN) = QNaN
+//
+//*********************************************************************
+//
+// Overview
+//
+// The method consists of three cases.
+//
+// If      512 <= x < OVERFLOW_BOUNDARY   use case lgamma_pstirling;
+// else if 1 < x < 512                    use case lgamma_regular;
+// else if -17 < x < 1                    use case lgamma_negrecursion;
+// else if -512 <  x < -17                use case lgamma_negpoly;
+// else if x < -512                       use case lgamma_negstirling;
+// else if x is close to negative
+//         roots of ln(GAMMA(x))          use case lgamma_negroots;
+//
+//
+// Case 512 <= x < OVERFLOW_BOUNDARY
+// ---------------------------------
+//   Here we use algorithm based on the Stirling formula:
+//   ln(GAMMA(x)) = ln(sqrt(2*Pi)) + (x-0.5)ln(x) - x + (W2 + W4/x^2)/x
+//
+// Case 1 < x < 512
+// ----------------
+//   To calculate GAMMA(x) on this interval we use polynomial approximation
+//   on following intervals [0.875; 1.25), [1.25; 1.75), [1.75, 2.25),
+//   [2.25; 4), [2^i; 2^(i+1)), i=2..8
+//
+//   Following variants of approximation and argument reduction are used:
+//    1. [0.875; 1.25)
+//       ln(GAMMA(x)) ~ (x-1.0)*P17(x-1.0)
+//
+//    2. [1.25; 1.75)
+//       ln(GAMMA(x)) ~ (x-LocalMinimun)*P17(x-LocalMinimun)
+//
+//    3. [1.75, 2.25)
+//       ln(GAMMA(x)) ~ (x-2.0)*P17(x-2.0)
+//
+//    4. [2.25; 4)
+//       ln(GAMMA(x)) ~ P22(x)
+//
+//    5. [2^i; 2^(i+1)), i=2..8
+//       ln(GAMMA(x)) ~ P22((x-2^i)/2^i)
+//
+// Case -17 < x < 1
+// ----------------
+//   Here we use the recursive formula:
+//   ln(GAMMA(x)) = ln(GAMMA(x+1)) - ln(x)
+//
+//   Using this formula we reduce argument to base interval [1.0; 2.0]
+//
+// Case -512 <  x < -17
+// --------------------
+//   Here we use the formula:
+//   ln(GAMMA(-x)) = ln(Pi/(x*GAMMA(x)*sin(Pi*x))) =
+//   = -ln(x) - ln((GAMMA(x)) - ln(sin(Pi*r)/(Pi*r)) - ln(|r|)
+//   where r = x - rounded_to_nearest(x), i.e |r| <= 0.5 and
+//   ln(sin(Pi*r)/(Pi*r)) is approximated by 14-degree polynomial of r^2
+//
+//
+// Case x < -512
+// -------------
+//   Here we use algorithm based on the Stirling formula:
+//   ln(GAMMA(-x)) = -ln(sqrt(2*Pi)) + (-x-0.5)ln(x) + x - (W2 + W4/x^2)/x -
+//   - ln(sin(Pi*r)/(Pi*r)) - ln(|r|)
+//   where r = x - rounded_to_nearest(x).
+//
+// Neighbourhoods of negative roots
+// --------------------------------
+//   Here we use polynomial approximation
+//   ln(GAMMA(x-x0)) = ln(GAMMA(x0)) + (x-x0)*P14(x-x0),
+//   where x0 is a root of ln(GAMMA(x)) rounded to nearest double
+//   precision number.
+//
+
+//*********************************************************************
+
+FR_X                   = f10
+FR_Y                   = f1 // __libm_lgamma is single argument function
+FR_RESULT              = f8
+
+FR_B11                 = f6
+FR_B10                 = f7
+
+FR_int_N               = f9
+FR_N                   = f10
+FR_P5                  = f11
+FR_P4                  = f12
+FR_P3                  = f13
+FR_P2                  = f14
+FR_NormX               = f15
+
+FR_Ln2                 = f32
+FR_C01                 = f33
+FR_A17                 = f33
+FR_C00                 = f34
+FR_Xp2                 = f34
+FR_A00                 = f34
+FR_A16                 = f34
+FR_C11                 = f35
+FR_A15                 = f35
+FR_C10                 = f36
+FR_Xp3                 = f36
+FR_A14                 = f36
+FR_B1                  = f36
+FR_C21                 = f37
+FR_A13                 = f37
+FR_PR01                = f37
+FR_C20                 = f38
+FR_Xp6                 = f38
+FR_A12                 = f38
+FR_C31                 = f39
+FR_Xp7                 = f39
+FR_B0                  = f39
+FR_A11                 = f39
+FR_C30                 = f40
+FR_Xp8                 = f40
+FR_A10                 = f40
+FR_PR00                = f40
+FR_C41                 = f41
+FR_Xp9                 = f41
+FR_A9                  = f41
+FR_PR11                = f41
+FR_C40                 = f42
+FR_A8                  = f42
+FR_C51                 = f43
+FR_Xp11                = f43
+FR_A7                  = f43
+FR_C50                 = f44
+FR_C                   = f44
+FR_Xp12                = f44
+FR_A6                  = f44
+FR_Xm2                 = f45
+FR_Xp13                = f45
+FR_A5                  = f45
+FR_PR10                = f45
+FR_C61                 = f46
+FR_Xp14                = f46
+FR_A4                  = f46
+FR_PR21                = f46
+FR_C60                 = f47
+FR_Xp15                = f47
+FR_A3                  = f47
+FR_PR20                = f47
+FR_C71                 = f48
+FR_Xp16                = f48
+FR_A2                  = f48
+FR_PR31                = f48
+FR_C70                 = f49
+FR_Xp17                = f49
+FR_A1                  = f49
+FR_PR30                = f49
+FR_C81                 = f50
+FR_B17                 = f50
+FR_A0                  = f50
+FR_C80                 = f51
+FR_B16                 = f51
+FR_C91                 = f52
+FR_B15                 = f52
+FR_C90                 = f53
+FR_B14                 = f53
+FR_CA1                 = f54
+FR_B13                 = f54
+FR_CA0                 = f55
+FR_B12                 = f55
+FR_CN                  = f56
+FR_Qlo                 = f56
+FR_PRN                 = f56
+FR_B7                  = f57
+FR_B6                  = f58
+FR_Qhi                 = f59
+FR_x                   = f60
+FR_x2                  = f61
+FR_TpNxLn2             = f62
+FR_W2                  = f63
+FR_x4                  = f64
+FR_r4                  = f64
+FR_x8                  = f65
+FR_r8                  = f65
+FR_r05                 = f66
+FR_Xm05                = f66
+FR_B5                  = f66
+FR_LnSqrt2Pi           = f67
+FR_B4                  = f67
+FR_InvX                = f68
+FR_B3                  = f68
+FR_InvX2               = f69
+FR_B2                  = f69
+FR_W4                  = f70
+FR_OvfBound            = f71
+FR_05                  = f72
+FR_LocalMin            = f73
+FR_tmp                 = f73
+FR_LnX                 = f74
+FR_Xf                  = f75
+FR_InvXf               = f76
+FR_rf                  = f77
+FR_rf2                 = f78
+FR_P54f                = f79
+FR_P32f                = f80
+FR_rf3                 = f81
+FR_P10f                = f82
+FR_TpNxLn2f            = f83
+FR_Nf                  = f84
+FR_LnXf                = f85
+FR_int_Nf              = f86
+FR_Tf                  = f87
+FR_Xf2                 = f88
+FR_Xp10                = f89
+FR_w3                  = f90
+FR_S28                 = f90
+FR_w2                  = f91
+FR_S26                 = f91
+FR_w6                  = f92
+FR_S24                 = f92
+FR_w4                  = f93
+FR_S22                 = f93
+FR_w                   = f94
+FR_S20                 = f94
+FR_Q8                  = f95
+FR_S18                 = f95
+FR_Q7                  = f96
+FR_S16                 = f96
+FR_Q4                  = f97
+FR_S14                 = f97
+FR_Q3                  = f98
+FR_S12                 = f98
+FR_Q6                  = f99
+FR_S10                 = f99
+FR_Q5                  = f100
+FR_S8                  = f100
+FR_Q2                  = f101
+FR_S6                  = f101
+FR_Root                = f101
+FR_S4                  = f102
+FR_Q1                  = f102
+FR_S2                  = f103
+FR_Xp1                 = f104
+FR_Xf4                 = f105
+FR_Xf8                 = f106
+FR_Xfr                 = f107
+FR_Xf6                 = f108
+FR_Ntrunc              = f109
+FR_B9                  = f110
+FR_2                   = f110
+FR_B8                  = f111
+FR_3                   = f111
+FR_5                   = f112
+FR_Xp4                 = f113
+FR_Xp5                 = f114
+FR_P54                 = f115
+FR_P32                 = f116
+FR_P10                 = f117
+FR_r                   = f118
+FR_r2                  = f119
+FR_r3                  = f120
+FR_T                   = f121
+FR_int_Ntrunc          = f122
+
+//===================================
+
+GR_TAG                 = r8
+GR_ExpMask             = r8
+GR_ExpBias             = r9
+GR_ad_Roots            = r9
+GR_Expf                = r10
+GR_Arg                 = r10
+GR_SignExp             = r11
+GR_ArgXfr              = r11
+
+GR_Exp                 = r14
+GR_Arg125              = r14
+GR_RootInd             = r14
+GR_ArgAsIs             = r15
+GR_Arg175              = r15
+GR_Sig                 = r16
+GR_Ind                 = r17
+GR_ad_Dx               = r17
+GR_ad_1                = r18
+GR_SignExp_w           = r19
+GR_2_25                = r19
+GR_Arg025              = r19
+GR_Arg15               = r19
+GR_Arg17               = r19
+GR_Exp_w               = r19//21
+GR_ad_2                = r20
+GR_2xDx                = r21
+GR_SignOfGamma         = r21
+GR_fff9                = r22
+GR_Offs                = r22
+GR_ad_Co7              = r23
+GR_Arg075              = r23
+GR_Arg0875             = r23
+GR_ad_T                = r24
+GR_ad_Root             = r24
+GR_Ind                 = r24
+GR_ad_Co               = r25
+GR_ad_Ce               = r26
+GR_ad_Ce7              = r27
+GR_Arg05               = r27
+GR_Offs7               = r28
+GR_ArgXfrAsIs          = r28
+GR_ExpOf2              = r29
+GR_ad_LnT              = r29
+GR_Dx                  = r29
+GR_ExpOf256            = r30
+GR_0x30033             = r30
+GR_Root                = r30
+GR_PseudoRoot          = r30
+GR_ad_Data             = r31
+GR_ad_SignGam          = r31
+
+
+GR_SAVE_B0             = r33
+GR_SAVE_PFS            = r34
+GR_SAVE_GP             = r35
+GR_SAVE_SP             = r36
+
+GR_Parameter_X         = r37
+GR_Parameter_Y         = r38
+GR_Parameter_RESULT    = r39
+GR_Parameter_TAG       = r40
+
+
+
+// Data tables
+//==============================================================
+
+RODATA
+.align 16
+LOCAL_OBJECT_START(lgamma_data)
+// polynomial approximation of ln(GAMMA(x)), 2.25 <= x < 512
+// [2.25; 4)
+data8 0xF888E8D7892718A2,0xC001 // C01
+data8 0xF62F273BA12A4639,0x3FFD // C11
+data8 0xA93AC50A37EC8D38,0xBFFC // C21
+data8 0xB4CC43D2C161E057,0xBFFF // C31
+data8 0xC6AC672F0C1392C7,0xC000 // C41
+data8 0xA292B9AE3276942E,0xC001 // C51
+data8 0xE554E4CCCA6C7B7B,0xC001 // C61
+data8 0x92F0F55FBC87F860,0xC002 // C71
+data8 0xAF60D0112843F6C1,0xC002 // C81
+data8 0xC5956500FA3D92E7,0xC002 // C91
+data8 0xD3B22CCBD8587750,0xC002 // CA1
+data8 0xD888B6CF34159B54,0x4001 // C00
+data8 0xBCB79C8329FD9F44,0x3FFE // C10
+data8 0xCB8896FAD69C455D,0x4000 // C20
+data8 0xE510A424639EBF5E,0x4001 // C30
+data8 0xC65ED41B097486B3,0x4002 // C40
+// [4; 8)
+data8 0x9F1F3C822D03080E,0xC001 // C01
+data8 0x941CACFA9C0FA8A6,0xC001 // C11
+data8 0xFE34336391D99CB7,0xC000 // C21
+data8 0xC40BAEAA165F81A1,0xC000 // C31
+data8 0xFE3AE166E9B4DE8F,0xBFFF // C41
+data8 0xD744F91AF7DAF873,0xBFFE // C51
+data8 0x87871851E9C32D02,0x3FFD // C61
+data8 0x9C93C03C502E808F,0x3FFF // C71
+data8 0xF78BED07501D6A8E,0x3FFF // C81
+data8 0x92FE41BA8BEADF70,0x4000 // C91
+data8 0xA021878E1903A2C6,0x3FFF // CA1
+data8 0xC85EFAC379FAFEE2,0x4001 // C00
+data8 0xC10D7AAB7CEC7FF2,0x4001 // C10
+data8 0xB3537BDF603E454C,0x4001 // C20
+data8 0xA0D44E3D5BBE44C4,0x4001 // C30
+data8 0x8B9C229B6241E7B3,0x4001 // C40
+// [8; 16)
+data8 0xD16AB33AEC220DF6,0x3FFF // C01
+data8 0x987483646E150BCD,0x4000 // C11
+data8 0x80C10A24C863999B,0x4000 // C21
+data8 0xA39A8EB6F8AACE75,0x3FFF // C31
+data8 0x93E04A1379BEC764,0x3FFD // C41
+data8 0xD9F59C4BD3A69BD1,0xBFFE // C51
+data8 0x82094EC891179B1A,0xC000 // C61
+data8 0xC90CFE3A24F70659,0xC000 // C71
+data8 0x827984EA7C155184,0xC001 // C81
+data8 0x981BFDF79D1E0D80,0xC001 // C91
+data8 0xA37209A8B97D230D,0xC001 // CA1
+data8 0xAA1989737D6BA66D,0x3FFE // C00
+data8 0xDBC013A351630AF8,0x3FFF // C10
+data8 0x8B8D47698299389D,0x4000 // C20
+data8 0xACCDD1315DE06EB0,0x4000 // C30
+data8 0xD3414A5AC81BBB2D,0x4000 // C40
+// [16; 32)
+data8 0xECB2B0BE75C5F995,0x3FFF // C01
+data8 0x9DD28BD6DBC96500,0x4000 // C11
+data8 0x8521431B99C6244F,0x4000 // C21
+data8 0xA95F92612B8413C3,0x3FFF // C31
+data8 0x9C76E643B22D9544,0x3FFD // C41
+data8 0xDD90EA99417C8038,0xBFFE // C51
+data8 0x84EA6B6D32E5F906,0xC000 // C61
+data8 0xCDBFE499E05AA622,0xC000 // C71
+data8 0x8594A7DE35427100,0xC001 // C81
+data8 0x9BC1CB2C10DC702F,0xC001 // C91
+data8 0xA7602268762666B0,0xC001 // CA1
+data8 0xDA082BCC6BDB8F7B,0x3FFE // C00
+data8 0xEEBFE1C99322B85E,0x3FFF // C10
+data8 0x96FED4C785361946,0x4000 // C20
+data8 0xB9E3A7207C16B2FE,0x4000 // C30
+data8 0xE1E8170CED48E2C7,0x4000 // C40
+// [32; 64)
+data8 0xFD481EB9AEDD53E7,0x3FFF // C01
+data8 0xA216FB66AC8C53E1,0x4000 // C11
+data8 0x885FF935787553BA,0x4000 // C21
+data8 0xAD471CD89A313327,0x3FFF // C31
+data8 0x9FF13FBA139D21E0,0x3FFD // C41
+data8 0xE25E1663A6EE0266,0xBFFE // C51
+data8 0x87BE51DD5D262FA2,0xC000 // C61
+data8 0xD211A9D4CCE55696,0xC000 // C71
+data8 0x885BEFC29FDED3C9,0xC001 // C81
+data8 0x9EFA48E6367A67F6,0xC001 // C91
+data8 0xAAD3978FC0791297,0xC001 // CA1
+data8 0xF96D210DF37A0AEA,0x3FFE // C00
+data8 0xFE11DC6783917C82,0x3FFF // C10
+data8 0x9FFCD928291B7DDE,0x4000 // C20
+data8 0xC4518F4A80E09AE1,0x4000 // C30
+data8 0xEDDFE9E0FD297C63,0x4000 // C40
+// [64; 128)
+data8 0x840E2E62609B0AD3,0x4000 // C01
+data8 0xA5275A0DD0D3DDF8,0x4000 // C11
+data8 0x8AADC6ABFC441731,0x4000 // C21
+data8 0xB041C6696BE90E50,0x3FFF // C31
+data8 0xA4A8C9153F4B037E,0x3FFD // C41
+data8 0xE3C6A461A7B86736,0xBFFE // C51
+data8 0x89047681C6DE7673,0xC000 // C61
+data8 0xD42DF77A480092DF,0xC000 // C71
+data8 0x89C25D17F086FB20,0xC001 // C81
+data8 0xA09F907D02E34EC7,0xC001 // C91
+data8 0xAC998A9CB79805B7,0xC001 // CA1
+data8 0x875CC9B69AE964CC,0x3FFF // C00
+data8 0x847836BA85DD4C12,0x4000 // C10
+data8 0xA5F3CB2B32E74936,0x4000 // C20
+data8 0xCAE2197C96CB5A0F,0x4000 // C30
+data8 0xF50F7EB60DE5CD09,0x4000 // C40
+// [128; 256)
+data8 0x87D9065DD1876926,0x4000 // C01
+data8 0xA781C28FDAD7CC25,0x4000 // C11
+data8 0x8C6A4FCE35A7EC8D,0x4000 // C21
+data8 0xB27BA081728354F9,0x3FFF // C31
+data8 0xA82FEA7124B0EB2B,0x3FFD // C41
+data8 0xE4C996E42ECBF77A,0xBFFE // C51
+data8 0x89F1A92C84FA538F,0xC000 // C61
+data8 0xD5B6CFF7DB7F6070,0xC000 // C71
+data8 0x8AC6B561FAE38B66,0xC001 // C81
+data8 0xA1D1505C438D8F46,0xC001 // C91
+data8 0xADE2DC1C924FEC81,0xC001 // CA1
+data8 0x8EF6CC62A7E0EB5A,0x3FFF // C00
+data8 0x88A2FFC0ABCB00C0,0x4000 // C10
+data8 0xAA6EA8FCB75B065B,0x4000 // C20
+data8 0xCFC4B82B3D5C9363,0x4000 // C30
+data8 0xFA60FD85DE861771,0x4000 // C40
+// [256; 512)
+data8 0x8AAA7CE4ED5C1EFD,0x4000 // C01
+data8 0xA9679234FB56F1E1,0x4000 // C11
+data8 0x8DCE02287789D841,0x4000 // C21
+data8 0xB44328EF30A8DE7E,0x3FFF // C31
+data8 0xAB0DC564BFA1AB12,0x3FFD // C41
+data8 0xE5882B16FCF2D3CB,0xBFFE // C51
+data8 0x8AA7F48993006A86,0xC000 // C61
+data8 0xD6E63752D192750D,0xC000 // C71
+data8 0x8B90080B17853295,0xC001 // C81
+data8 0xA2BDD4253128D1AB,0xC001 // C91
+data8 0xAEE1A042F96B8121,0xC001 // CA1
+data8 0x94A9C37A42E43BA7,0x3FFF // C00
+data8 0x8BFA54E703878F5A,0x4000 // C10
+data8 0xADFA426DDF14647B,0x4000 // C20
+data8 0xD39C7F7B3958EAF0,0x4000 // C30
+data8 0xFE8C3987853C01E3,0x4000 // C40
+//
+// [2.25; 4)
+data8 0x943AF77763601441,0x4003 // C50
+data8 0xC8A93F9ECB06E891,0x4003 // C60
+data8 0xFC2E5A4AD33DE19D,0x4003 // C70
+data8 0x9526B75B38670119,0x4004 // C80
+data8 0xA7675879D68B587E,0x4004 // C90
+data8 0xB31DFA672D7FB8C0,0x4004 // CA0
+data8 0x83A27775D86F9A81,0xBFD7 // CN
+// [4; 8)
+data8 0xEB8049BA5E79ADA3,0x4000 // C50
+data8 0xC20C95EA99037228,0x4000 // C60
+data8 0x9D4A8C864053CEB8,0x4000 // C70
+data8 0xFC7716544AB0C5C9,0x3FFF // C80
+data8 0xC7EB985259EABA5F,0x3FFF // C90
+data8 0xC042FB3B4C95096D,0x3FFD // CA0
+data8 0xCC2A7F930856177B,0x3FEE // CN
+// [8; 16)
+data8 0xFE1903679D078C7A,0x4000 // C50
+data8 0x957C221AB90171F1,0x4001 // C60
+data8 0xAB2C53B2A78F4031,0x4001 // C70
+data8 0xBE080AE6063AE387,0x4001 // C80
+data8 0xCC019A0311605CB9,0x4001 // C90
+data8 0xD3739D85A12C8ADF,0x4001 // CA0
+data8 0x81FA4D2B7BD7A82D,0x3FEF // CN
+// [16; 32)
+data8 0x871F69E2DD221F02,0x4001 // C50
+data8 0x9E3EF2D477442A9C,0x4001 // C60
+data8 0xB48733582B3C82C5,0x4001 // C70
+data8 0xC7DB9B3C25854A2A,0x4001 // C80
+data8 0xD628B87975BE898F,0x4001 // C90
+data8 0xDDC569C321FF119C,0x4001 // CA0
+data8 0xB27B65560DF7ADA7,0x3FEF // CN
+// [32; 64)
+data8 0x8DE4127349719B22,0x4001 // C50
+data8 0xA5C30A7760F5FBB2,0x4001 // C60
+data8 0xBCB4096055AA2A4E,0x4001 // C70
+data8 0xD08F5F2FB4E7B899,0x4001 // C80
+data8 0xDF39ED39DC91F9CF,0x4001 // C90
+data8 0xE7063E45322F072E,0x4001 // CA0
+data8 0x85A9E11DDDDE67C8,0x3FF0 // CN
+// [64; 128)
+data8 0x91CA191EB80E8893,0x4001 // C50
+data8 0xA9F1D5A55397334A,0x4001 // C60
+data8 0xC1222710295094E3,0x4001 // C70
+data8 0xD52FFABBA6CBE5C6,0x4001 // C80
+data8 0xE3FD9D5282052E1D,0x4001 // C90
+data8 0xEBDBE47BB662F3EF,0x4001 // CA0
+data8 0xEF889F489D88FD31,0x3FF0 // CN
+// [128; 256)
+data8 0x94AA029C2286F8D2,0x4001 // C50
+data8 0xAD0549E55A72389F,0x4001 // C60
+data8 0xC4628899DAF94BA4,0x4001 // C70
+data8 0xD89432A4161C72CB,0x4001 // C80
+data8 0xE77ABA75E9C38F3A,0x4001 // C90
+data8 0xEF65BFFFF71347FF,0x4001 // CA0
+data8 0xE2627460064D918D,0x3FF1 // CN
+// [256; 512)
+data8 0x96E9890D722C2FC1,0x4001 // C50
+data8 0xAF6C2236F6A1CEC4,0x4001 // C60
+data8 0xC6EBB8C9F987D20D,0x4001 // C70
+data8 0xDB38CEFD5EF328CC,0x4001 // C80
+data8 0xEA3265DC66C9A0B4,0x4001 // C90
+data8 0xF2272D6B368C70B1,0x4001 // CA0
+data8 0xDBFF93ECEBCEF1F3,0x3FF2 // CN
+//
+data8 0x3FDD8B618D5AF8FE // point of local minimum on [1;2]
+data8 0x3FE0000000000000 // 0.5
+data8 0xBFC5555DA7212371 // P5
+data8 0x3FC999A19EEF5826 // P4
+data8 0xb17217f7d1cf79ac,0x3ffe // ln(2)
+data8 0xEB3F8E4325F5A535,0x3FFE // ln(sqrt(4*arcsin(1)))
+//
+data8 0xBFCFFFFFFFFEF009 // P3
+data8 0x3FD555555554ECB2 // P2
+data8 0xBF66C16C16C16C17 // W4=B4/12=-1/360
+data8 0x7F5754D9278B51A8 // overflow boundary (first inf result)
+data8 0xAAAAAAAAAAAAAAAB,0x3FFB // W2=B2/2=1/12
+//
+data8 0x3FBC756AC654273B // Q8
+data8 0xBFC001A42489AB4D // Q7
+data8 0x3FC99999999A169B // Q4
+data8 0xBFD00000000019AC // Q3
+data8 0x3FC2492479AA0DF8 // Q6
+data8 0xBFC5555544986F52 // Q5
+data8 0x3FD5555555555555 // Q2
+data8 0xBFE0000000000000 // Q1, P1 = -0.5
+//
+data8 0x80200aaeac44ef38,0x3ff6 // ln(1/frcpa(1+  0/2^-8))
+data8 0xc09090a2c35aa070,0x3ff7 // ln(1/frcpa(1+  1/2^-8))
+data8 0xa0c94fcb41977c75,0x3ff8 // ln(1/frcpa(1+  2/2^-8))
+data8 0xe18b9c263af83301,0x3ff8 // ln(1/frcpa(1+  3/2^-8))
+data8 0x8d35c8d6399c30ea,0x3ff9 // ln(1/frcpa(1+  4/2^-8))
+data8 0xadd4d2ecd601cbb8,0x3ff9 // ln(1/frcpa(1+  5/2^-8))
+data8 0xce95403a192f9f01,0x3ff9 // ln(1/frcpa(1+  6/2^-8))
+data8 0xeb59392cbcc01096,0x3ff9 // ln(1/frcpa(1+  7/2^-8))
+data8 0x862c7d0cefd54c5d,0x3ffa // ln(1/frcpa(1+  8/2^-8))
+data8 0x94aa63c65e70d499,0x3ffa // ln(1/frcpa(1+  9/2^-8))
+data8 0xa54a696d4b62b382,0x3ffa // ln(1/frcpa(1+ 10/2^-8))
+data8 0xb3e4a796a5dac208,0x3ffa // ln(1/frcpa(1+ 11/2^-8))
+data8 0xc28c45b1878340a9,0x3ffa // ln(1/frcpa(1+ 12/2^-8))
+data8 0xd35c55f39d7a6235,0x3ffa // ln(1/frcpa(1+ 13/2^-8))
+data8 0xe220f037b954f1f5,0x3ffa // ln(1/frcpa(1+ 14/2^-8))
+data8 0xf0f3389b036834f3,0x3ffa // ln(1/frcpa(1+ 15/2^-8))
+data8 0xffd3488d5c980465,0x3ffa // ln(1/frcpa(1+ 16/2^-8))
+data8 0x87609ce2ed300490,0x3ffb // ln(1/frcpa(1+ 17/2^-8))
+data8 0x8ede9321e8c85927,0x3ffb // ln(1/frcpa(1+ 18/2^-8))
+data8 0x96639427f2f8e2f4,0x3ffb // ln(1/frcpa(1+ 19/2^-8))
+data8 0x9defad3e8f73217b,0x3ffb // ln(1/frcpa(1+ 20/2^-8))
+data8 0xa582ebd50097029c,0x3ffb // ln(1/frcpa(1+ 21/2^-8))
+data8 0xac06dbe75ab80fee,0x3ffb // ln(1/frcpa(1+ 22/2^-8))
+data8 0xb3a78449b2d3ccca,0x3ffb // ln(1/frcpa(1+ 23/2^-8))
+data8 0xbb4f79635ab46bb2,0x3ffb // ln(1/frcpa(1+ 24/2^-8))
+data8 0xc2fec93a83523f3f,0x3ffb // ln(1/frcpa(1+ 25/2^-8))
+data8 0xc99af2eaca4c4571,0x3ffb // ln(1/frcpa(1+ 26/2^-8))
+data8 0xd1581106472fa653,0x3ffb // ln(1/frcpa(1+ 27/2^-8))
+data8 0xd8002560d4355f2e,0x3ffb // ln(1/frcpa(1+ 28/2^-8))
+data8 0xdfcb43b4fe508632,0x3ffb // ln(1/frcpa(1+ 29/2^-8))
+data8 0xe67f6dff709d4119,0x3ffb // ln(1/frcpa(1+ 30/2^-8))
+data8 0xed393b1c22351280,0x3ffb // ln(1/frcpa(1+ 31/2^-8))
+data8 0xf5192bff087bcc35,0x3ffb // ln(1/frcpa(1+ 32/2^-8))
+data8 0xfbdf4ff6dfef2fa3,0x3ffb // ln(1/frcpa(1+ 33/2^-8))
+data8 0x81559a97f92f9cc7,0x3ffc // ln(1/frcpa(1+ 34/2^-8))
+data8 0x84be72bce90266e8,0x3ffc // ln(1/frcpa(1+ 35/2^-8))
+data8 0x88bc74113f23def2,0x3ffc // ln(1/frcpa(1+ 36/2^-8))
+data8 0x8c2ba3edf6799d11,0x3ffc // ln(1/frcpa(1+ 37/2^-8))
+data8 0x8f9dc92f92ea08b1,0x3ffc // ln(1/frcpa(1+ 38/2^-8))
+data8 0x9312e8f36efab5a7,0x3ffc // ln(1/frcpa(1+ 39/2^-8))
+data8 0x968b08643409ceb6,0x3ffc // ln(1/frcpa(1+ 40/2^-8))
+data8 0x9a062cba08a1708c,0x3ffc // ln(1/frcpa(1+ 41/2^-8))
+data8 0x9d845b3abf95485c,0x3ffc // ln(1/frcpa(1+ 42/2^-8))
+data8 0xa06fd841bc001bb4,0x3ffc // ln(1/frcpa(1+ 43/2^-8))
+data8 0xa3f3a74652fbe0db,0x3ffc // ln(1/frcpa(1+ 44/2^-8))
+data8 0xa77a8fb2336f20f5,0x3ffc // ln(1/frcpa(1+ 45/2^-8))
+data8 0xab0497015d28b0a0,0x3ffc // ln(1/frcpa(1+ 46/2^-8))
+data8 0xae91c2be6ba6a615,0x3ffc // ln(1/frcpa(1+ 47/2^-8))
+data8 0xb189d1b99aebb20b,0x3ffc // ln(1/frcpa(1+ 48/2^-8))
+data8 0xb51cced5de9c1b2c,0x3ffc // ln(1/frcpa(1+ 49/2^-8))
+data8 0xb819bee9e720d42f,0x3ffc // ln(1/frcpa(1+ 50/2^-8))
+data8 0xbbb2a0947b093a5d,0x3ffc // ln(1/frcpa(1+ 51/2^-8))
+data8 0xbf4ec1505811684a,0x3ffc // ln(1/frcpa(1+ 52/2^-8))
+data8 0xc2535bacfa8975ff,0x3ffc // ln(1/frcpa(1+ 53/2^-8))
+data8 0xc55a3eafad187eb8,0x3ffc // ln(1/frcpa(1+ 54/2^-8))
+data8 0xc8ff2484b2c0da74,0x3ffc // ln(1/frcpa(1+ 55/2^-8))
+data8 0xcc0b1a008d53ab76,0x3ffc // ln(1/frcpa(1+ 56/2^-8))
+data8 0xcfb6203844b3209b,0x3ffc // ln(1/frcpa(1+ 57/2^-8))
+data8 0xd2c73949a47a19f5,0x3ffc // ln(1/frcpa(1+ 58/2^-8))
+data8 0xd5daae18b49d6695,0x3ffc // ln(1/frcpa(1+ 59/2^-8))
+data8 0xd8f08248cf7e8019,0x3ffc // ln(1/frcpa(1+ 60/2^-8))
+data8 0xdca7749f1b3e540e,0x3ffc // ln(1/frcpa(1+ 61/2^-8))
+data8 0xdfc28e033aaaf7c7,0x3ffc // ln(1/frcpa(1+ 62/2^-8))
+data8 0xe2e012a5f91d2f55,0x3ffc // ln(1/frcpa(1+ 63/2^-8))
+data8 0xe600064ed9e292a8,0x3ffc // ln(1/frcpa(1+ 64/2^-8))
+data8 0xe9226cce42b39f60,0x3ffc // ln(1/frcpa(1+ 65/2^-8))
+data8 0xec4749fd97a28360,0x3ffc // ln(1/frcpa(1+ 66/2^-8))
+data8 0xef6ea1bf57780495,0x3ffc // ln(1/frcpa(1+ 67/2^-8))
+data8 0xf29877ff38809091,0x3ffc // ln(1/frcpa(1+ 68/2^-8))
+data8 0xf5c4d0b245cb89be,0x3ffc // ln(1/frcpa(1+ 69/2^-8))
+data8 0xf8f3afd6fcdef3aa,0x3ffc // ln(1/frcpa(1+ 70/2^-8))
+data8 0xfc2519756be1abc7,0x3ffc // ln(1/frcpa(1+ 71/2^-8))
+data8 0xff59119f503e6832,0x3ffc // ln(1/frcpa(1+ 72/2^-8))
+data8 0x8147ce381ae0e146,0x3ffd // ln(1/frcpa(1+ 73/2^-8))
+data8 0x82e45f06cb1ad0f2,0x3ffd // ln(1/frcpa(1+ 74/2^-8))
+data8 0x842f5c7c573cbaa2,0x3ffd // ln(1/frcpa(1+ 75/2^-8))
+data8 0x85ce471968c8893a,0x3ffd // ln(1/frcpa(1+ 76/2^-8))
+data8 0x876e8305bc04066d,0x3ffd // ln(1/frcpa(1+ 77/2^-8))
+data8 0x891012678031fbb3,0x3ffd // ln(1/frcpa(1+ 78/2^-8))
+data8 0x8a5f1493d766a05f,0x3ffd // ln(1/frcpa(1+ 79/2^-8))
+data8 0x8c030c778c56fa00,0x3ffd // ln(1/frcpa(1+ 80/2^-8))
+data8 0x8da85df17e31d9ae,0x3ffd // ln(1/frcpa(1+ 81/2^-8))
+data8 0x8efa663e7921687e,0x3ffd // ln(1/frcpa(1+ 82/2^-8))
+data8 0x90a22b6875c6a1f8,0x3ffd // ln(1/frcpa(1+ 83/2^-8))
+data8 0x91f62cc8f5d24837,0x3ffd // ln(1/frcpa(1+ 84/2^-8))
+data8 0x93a06cfc3857d980,0x3ffd // ln(1/frcpa(1+ 85/2^-8))
+data8 0x94f66d5e6fd01ced,0x3ffd // ln(1/frcpa(1+ 86/2^-8))
+data8 0x96a330156e6772f2,0x3ffd // ln(1/frcpa(1+ 87/2^-8))
+data8 0x97fb3582754ea25b,0x3ffd // ln(1/frcpa(1+ 88/2^-8))
+data8 0x99aa8259aad1bbf2,0x3ffd // ln(1/frcpa(1+ 89/2^-8))
+data8 0x9b0492f6227ae4a8,0x3ffd // ln(1/frcpa(1+ 90/2^-8))
+data8 0x9c5f8e199bf3a7a5,0x3ffd // ln(1/frcpa(1+ 91/2^-8))
+data8 0x9e1293b9998c1daa,0x3ffd // ln(1/frcpa(1+ 92/2^-8))
+data8 0x9f6fa31e0b41f308,0x3ffd // ln(1/frcpa(1+ 93/2^-8))
+data8 0xa0cda11eaf46390e,0x3ffd // ln(1/frcpa(1+ 94/2^-8))
+data8 0xa22c8f029cfa45aa,0x3ffd // ln(1/frcpa(1+ 95/2^-8))
+data8 0xa3e48badb7856b34,0x3ffd // ln(1/frcpa(1+ 96/2^-8))
+data8 0xa5459a0aa95849f9,0x3ffd // ln(1/frcpa(1+ 97/2^-8))
+data8 0xa6a79c84480cfebd,0x3ffd // ln(1/frcpa(1+ 98/2^-8))
+data8 0xa80a946d0fcb3eb2,0x3ffd // ln(1/frcpa(1+ 99/2^-8))
+data8 0xa96e831a3ea7b314,0x3ffd // ln(1/frcpa(1+100/2^-8))
+data8 0xaad369e3dc544e3b,0x3ffd // ln(1/frcpa(1+101/2^-8))
+data8 0xac92e9588952c815,0x3ffd // ln(1/frcpa(1+102/2^-8))
+data8 0xadfa035aa1ed8fdc,0x3ffd // ln(1/frcpa(1+103/2^-8))
+data8 0xaf6219eae1ad6e34,0x3ffd // ln(1/frcpa(1+104/2^-8))
+data8 0xb0cb2e6d8160f753,0x3ffd // ln(1/frcpa(1+105/2^-8))
+data8 0xb2354249ad950f72,0x3ffd // ln(1/frcpa(1+106/2^-8))
+data8 0xb3a056e98ef4a3b4,0x3ffd // ln(1/frcpa(1+107/2^-8))
+data8 0xb50c6dba52c6292a,0x3ffd // ln(1/frcpa(1+108/2^-8))
+data8 0xb679882c33876165,0x3ffd // ln(1/frcpa(1+109/2^-8))
+data8 0xb78c07429785cedc,0x3ffd // ln(1/frcpa(1+110/2^-8))
+data8 0xb8faeb8dc4a77d24,0x3ffd // ln(1/frcpa(1+111/2^-8))
+data8 0xba6ad77eb36ae0d6,0x3ffd // ln(1/frcpa(1+112/2^-8))
+data8 0xbbdbcc915e9bee50,0x3ffd // ln(1/frcpa(1+113/2^-8))
+data8 0xbd4dcc44f8cf12ef,0x3ffd // ln(1/frcpa(1+114/2^-8))
+data8 0xbec0d81bf5b531fa,0x3ffd // ln(1/frcpa(1+115/2^-8))
+data8 0xc034f19c139186f4,0x3ffd // ln(1/frcpa(1+116/2^-8))
+data8 0xc14cb69f7c5e55ab,0x3ffd // ln(1/frcpa(1+117/2^-8))
+data8 0xc2c2abbb6e5fd56f,0x3ffd // ln(1/frcpa(1+118/2^-8))
+data8 0xc439b2c193e6771e,0x3ffd // ln(1/frcpa(1+119/2^-8))
+data8 0xc553acb9d5c67733,0x3ffd // ln(1/frcpa(1+120/2^-8))
+data8 0xc6cc96e441272441,0x3ffd // ln(1/frcpa(1+121/2^-8))
+data8 0xc8469753eca88c30,0x3ffd // ln(1/frcpa(1+122/2^-8))
+data8 0xc962cf3ce072b05c,0x3ffd // ln(1/frcpa(1+123/2^-8))
+data8 0xcadeba8771f694aa,0x3ffd // ln(1/frcpa(1+124/2^-8))
+data8 0xcc5bc08d1f72da94,0x3ffd // ln(1/frcpa(1+125/2^-8))
+data8 0xcd7a3f99ea035c29,0x3ffd // ln(1/frcpa(1+126/2^-8))
+data8 0xcef93860c8a53c35,0x3ffd // ln(1/frcpa(1+127/2^-8))
+data8 0xd0192f68a7ed23df,0x3ffd // ln(1/frcpa(1+128/2^-8))
+data8 0xd19a201127d3c645,0x3ffd // ln(1/frcpa(1+129/2^-8))
+data8 0xd2bb92f4061c172c,0x3ffd // ln(1/frcpa(1+130/2^-8))
+data8 0xd43e80b2ee8cc8fc,0x3ffd // ln(1/frcpa(1+131/2^-8))
+data8 0xd56173601fc4ade4,0x3ffd // ln(1/frcpa(1+132/2^-8))
+data8 0xd6e6637efb54086f,0x3ffd // ln(1/frcpa(1+133/2^-8))
+data8 0xd80ad9f58f3c8193,0x3ffd // ln(1/frcpa(1+134/2^-8))
+data8 0xd991d1d31aca41f8,0x3ffd // ln(1/frcpa(1+135/2^-8))
+data8 0xdab7d02231484a93,0x3ffd // ln(1/frcpa(1+136/2^-8))
+data8 0xdc40d532cde49a54,0x3ffd // ln(1/frcpa(1+137/2^-8))
+data8 0xdd685f79ed8b265e,0x3ffd // ln(1/frcpa(1+138/2^-8))
+data8 0xde9094bbc0e17b1d,0x3ffd // ln(1/frcpa(1+139/2^-8))
+data8 0xe01c91b78440c425,0x3ffd // ln(1/frcpa(1+140/2^-8))
+data8 0xe14658f26997e729,0x3ffd // ln(1/frcpa(1+141/2^-8))
+data8 0xe270cdc2391e0d23,0x3ffd // ln(1/frcpa(1+142/2^-8))
+data8 0xe3ffce3a2aa64922,0x3ffd // ln(1/frcpa(1+143/2^-8))
+data8 0xe52bdb274ed82887,0x3ffd // ln(1/frcpa(1+144/2^-8))
+data8 0xe6589852e75d7df6,0x3ffd // ln(1/frcpa(1+145/2^-8))
+data8 0xe786068c79937a7d,0x3ffd // ln(1/frcpa(1+146/2^-8))
+data8 0xe91903adad100911,0x3ffd // ln(1/frcpa(1+147/2^-8))
+data8 0xea481236f7d35bb0,0x3ffd // ln(1/frcpa(1+148/2^-8))
+data8 0xeb77d48c692e6b14,0x3ffd // ln(1/frcpa(1+149/2^-8))
+data8 0xeca84b83d7297b87,0x3ffd // ln(1/frcpa(1+150/2^-8))
+data8 0xedd977f4962aa158,0x3ffd // ln(1/frcpa(1+151/2^-8))
+data8 0xef7179a22f257754,0x3ffd // ln(1/frcpa(1+152/2^-8))
+data8 0xf0a450d139366ca7,0x3ffd // ln(1/frcpa(1+153/2^-8))
+data8 0xf1d7e0524ff9ffdb,0x3ffd // ln(1/frcpa(1+154/2^-8))
+data8 0xf30c29036a8b6cae,0x3ffd // ln(1/frcpa(1+155/2^-8))
+data8 0xf4412bc411ea8d92,0x3ffd // ln(1/frcpa(1+156/2^-8))
+data8 0xf576e97564c8619d,0x3ffd // ln(1/frcpa(1+157/2^-8))
+data8 0xf6ad62fa1b5f172f,0x3ffd // ln(1/frcpa(1+158/2^-8))
+data8 0xf7e499368b55c542,0x3ffd // ln(1/frcpa(1+159/2^-8))
+data8 0xf91c8d10abaffe22,0x3ffd // ln(1/frcpa(1+160/2^-8))
+data8 0xfa553f7018c966f3,0x3ffd // ln(1/frcpa(1+161/2^-8))
+data8 0xfb8eb13e185d802c,0x3ffd // ln(1/frcpa(1+162/2^-8))
+data8 0xfcc8e3659d9bcbed,0x3ffd // ln(1/frcpa(1+163/2^-8))
+data8 0xfe03d6d34d487fd2,0x3ffd // ln(1/frcpa(1+164/2^-8))
+data8 0xff3f8c7581e9f0ae,0x3ffd // ln(1/frcpa(1+165/2^-8))
+data8 0x803e029e280173ae,0x3ffe // ln(1/frcpa(1+166/2^-8))
+data8 0x80dca10cc52d0757,0x3ffe // ln(1/frcpa(1+167/2^-8))
+data8 0x817ba200632755a1,0x3ffe // ln(1/frcpa(1+168/2^-8))
+data8 0x821b05f3b01d6774,0x3ffe // ln(1/frcpa(1+169/2^-8))
+data8 0x82bacd623ff19d06,0x3ffe // ln(1/frcpa(1+170/2^-8))
+data8 0x835af8c88e7a8f47,0x3ffe // ln(1/frcpa(1+171/2^-8))
+data8 0x83c5f8299e2b4091,0x3ffe // ln(1/frcpa(1+172/2^-8))
+data8 0x8466cb43f3d87300,0x3ffe // ln(1/frcpa(1+173/2^-8))
+data8 0x850803a67c80ca4b,0x3ffe // ln(1/frcpa(1+174/2^-8))
+data8 0x85a9a1d11a23b461,0x3ffe // ln(1/frcpa(1+175/2^-8))
+data8 0x864ba644a18e6e05,0x3ffe // ln(1/frcpa(1+176/2^-8))
+data8 0x86ee1182dcc432f7,0x3ffe // ln(1/frcpa(1+177/2^-8))
+data8 0x875a925d7e48c316,0x3ffe // ln(1/frcpa(1+178/2^-8))
+data8 0x87fdaa109d23aef7,0x3ffe // ln(1/frcpa(1+179/2^-8))
+data8 0x88a129ed4becfaf2,0x3ffe // ln(1/frcpa(1+180/2^-8))
+data8 0x89451278ecd7f9cf,0x3ffe // ln(1/frcpa(1+181/2^-8))
+data8 0x89b29295f8432617,0x3ffe // ln(1/frcpa(1+182/2^-8))
+data8 0x8a572ac5a5496882,0x3ffe // ln(1/frcpa(1+183/2^-8))
+data8 0x8afc2d0ce3b2dadf,0x3ffe // ln(1/frcpa(1+184/2^-8))
+data8 0x8b6a69c608cfd3af,0x3ffe // ln(1/frcpa(1+185/2^-8))
+data8 0x8c101e106e899a83,0x3ffe // ln(1/frcpa(1+186/2^-8))
+data8 0x8cb63de258f9d626,0x3ffe // ln(1/frcpa(1+187/2^-8))
+data8 0x8d2539c5bd19e2b1,0x3ffe // ln(1/frcpa(1+188/2^-8))
+data8 0x8dcc0e064b29e6f1,0x3ffe // ln(1/frcpa(1+189/2^-8))
+data8 0x8e734f45d88357ae,0x3ffe // ln(1/frcpa(1+190/2^-8))
+data8 0x8ee30cef034a20db,0x3ffe // ln(1/frcpa(1+191/2^-8))
+data8 0x8f8b0515686d1d06,0x3ffe // ln(1/frcpa(1+192/2^-8))
+data8 0x90336bba039bf32f,0x3ffe // ln(1/frcpa(1+193/2^-8))
+data8 0x90a3edd23d1c9d58,0x3ffe // ln(1/frcpa(1+194/2^-8))
+data8 0x914d0de2f5d61b32,0x3ffe // ln(1/frcpa(1+195/2^-8))
+data8 0x91be0c20d28173b5,0x3ffe // ln(1/frcpa(1+196/2^-8))
+data8 0x9267e737c06cd34a,0x3ffe // ln(1/frcpa(1+197/2^-8))
+data8 0x92d962ae6abb1237,0x3ffe // ln(1/frcpa(1+198/2^-8))
+data8 0x9383fa6afbe2074c,0x3ffe // ln(1/frcpa(1+199/2^-8))
+data8 0x942f0421651c1c4e,0x3ffe // ln(1/frcpa(1+200/2^-8))
+data8 0x94a14a3845bb985e,0x3ffe // ln(1/frcpa(1+201/2^-8))
+data8 0x954d133857f861e7,0x3ffe // ln(1/frcpa(1+202/2^-8))
+data8 0x95bfd96468e604c4,0x3ffe // ln(1/frcpa(1+203/2^-8))
+data8 0x9632d31cafafa858,0x3ffe // ln(1/frcpa(1+204/2^-8))
+data8 0x96dfaabd86fa1647,0x3ffe // ln(1/frcpa(1+205/2^-8))
+data8 0x9753261fcbb2a594,0x3ffe // ln(1/frcpa(1+206/2^-8))
+data8 0x9800c11b426b996d,0x3ffe // ln(1/frcpa(1+207/2^-8))
+data8 0x9874bf4d45ae663c,0x3ffe // ln(1/frcpa(1+208/2^-8))
+data8 0x99231f5ee9a74f79,0x3ffe // ln(1/frcpa(1+209/2^-8))
+data8 0x9997a18a56bcad28,0x3ffe // ln(1/frcpa(1+210/2^-8))
+data8 0x9a46c873a3267e79,0x3ffe // ln(1/frcpa(1+211/2^-8))
+data8 0x9abbcfc621eb6cb6,0x3ffe // ln(1/frcpa(1+212/2^-8))
+data8 0x9b310cb0d354c990,0x3ffe // ln(1/frcpa(1+213/2^-8))
+data8 0x9be14cf9e1b3515c,0x3ffe // ln(1/frcpa(1+214/2^-8))
+data8 0x9c5710b8cbb73a43,0x3ffe // ln(1/frcpa(1+215/2^-8))
+data8 0x9ccd0abd301f399c,0x3ffe // ln(1/frcpa(1+216/2^-8))
+data8 0x9d7e67f3bdce8888,0x3ffe // ln(1/frcpa(1+217/2^-8))
+data8 0x9df4ea81a99daa01,0x3ffe // ln(1/frcpa(1+218/2^-8))
+data8 0x9e6ba405a54514ba,0x3ffe // ln(1/frcpa(1+219/2^-8))
+data8 0x9f1e21c8c7bb62b3,0x3ffe // ln(1/frcpa(1+220/2^-8))
+data8 0x9f956593f6b6355c,0x3ffe // ln(1/frcpa(1+221/2^-8))
+data8 0xa00ce1092e5498c3,0x3ffe // ln(1/frcpa(1+222/2^-8))
+data8 0xa0c08309c4b912c1,0x3ffe // ln(1/frcpa(1+223/2^-8))
+data8 0xa1388a8c6faa2afa,0x3ffe // ln(1/frcpa(1+224/2^-8))
+data8 0xa1b0ca7095b5f985,0x3ffe // ln(1/frcpa(1+225/2^-8))
+data8 0xa22942eb47534a00,0x3ffe // ln(1/frcpa(1+226/2^-8))
+data8 0xa2de62326449d0a3,0x3ffe // ln(1/frcpa(1+227/2^-8))
+data8 0xa357690f88bfe345,0x3ffe // ln(1/frcpa(1+228/2^-8))
+data8 0xa3d0a93f45169a4b,0x3ffe // ln(1/frcpa(1+229/2^-8))
+data8 0xa44a22f7ffe65f30,0x3ffe // ln(1/frcpa(1+230/2^-8))
+data8 0xa500c5e5b4c1aa36,0x3ffe // ln(1/frcpa(1+231/2^-8))
+data8 0xa57ad064eb2ebbc2,0x3ffe // ln(1/frcpa(1+232/2^-8))
+data8 0xa5f5152dedf4384e,0x3ffe // ln(1/frcpa(1+233/2^-8))
+data8 0xa66f9478856233ec,0x3ffe // ln(1/frcpa(1+234/2^-8))
+data8 0xa6ea4e7cca02c32e,0x3ffe // ln(1/frcpa(1+235/2^-8))
+data8 0xa765437325341ccf,0x3ffe // ln(1/frcpa(1+236/2^-8))
+data8 0xa81e21e6c75b4020,0x3ffe // ln(1/frcpa(1+237/2^-8))
+data8 0xa899ab333fe2b9ca,0x3ffe // ln(1/frcpa(1+238/2^-8))
+data8 0xa9157039c51ebe71,0x3ffe // ln(1/frcpa(1+239/2^-8))
+data8 0xa991713433c2b999,0x3ffe // ln(1/frcpa(1+240/2^-8))
+data8 0xaa0dae5cbcc048b3,0x3ffe // ln(1/frcpa(1+241/2^-8))
+data8 0xaa8a27ede5eb13ad,0x3ffe // ln(1/frcpa(1+242/2^-8))
+data8 0xab06de228a9e3499,0x3ffe // ln(1/frcpa(1+243/2^-8))
+data8 0xab83d135dc633301,0x3ffe // ln(1/frcpa(1+244/2^-8))
+data8 0xac3fb076adc7fe7a,0x3ffe // ln(1/frcpa(1+245/2^-8))
+data8 0xacbd3cbbe47988f1,0x3ffe // ln(1/frcpa(1+246/2^-8))
+data8 0xad3b06b1a5dc57c3,0x3ffe // ln(1/frcpa(1+247/2^-8))
+data8 0xadb90e94af887717,0x3ffe // ln(1/frcpa(1+248/2^-8))
+data8 0xae3754a218f7c816,0x3ffe // ln(1/frcpa(1+249/2^-8))
+data8 0xaeb5d9175437afa2,0x3ffe // ln(1/frcpa(1+250/2^-8))
+data8 0xaf349c322e9c7cee,0x3ffe // ln(1/frcpa(1+251/2^-8))
+data8 0xafb39e30d1768d1c,0x3ffe // ln(1/frcpa(1+252/2^-8))
+data8 0xb032df51c2c93116,0x3ffe // ln(1/frcpa(1+253/2^-8))
+data8 0xb0b25fd3e6035ad9,0x3ffe // ln(1/frcpa(1+254/2^-8))
+data8 0xb1321ff67cba178c,0x3ffe // ln(1/frcpa(1+255/2^-8))
+//
+data8 0xC7DC2985D3B44557,0x3FCA // A00
+//
+// polynomial approximation of ln(GAMMA(x)), 1 <= x < 2.25
+// [0.875,1.25)
+data8 0xBF9A04F7E40C8498,0x3FAB79D8D9380F03 // C17,C16
+data8 0xBFB3B63609CA0CBD,0x3FB5564EA1675539 // C13,C12
+data8 0xBFBC806766F48C41,0x3FC010B36CDA773A // C9,C8
+data8 0xD45CE0BD54BE3D67,0xBFFC // C5
+data8 0xCD26AADF559676D0,0xBFFD // C3
+data8 0x93C467E37DB0C7A7,0xBFFE // C1
+data8 0xBFB10C251723B123,0x3FB2669DAD69A12D // C15,C14
+data8 0xBFB748A3CFCE4717,0x3FB9A01DEE29966A // C11,C10
+data8 0xBFC2703A1D85497E,0x3FC5B40CB0FD353C // C7,C6
+data8 0x8A8991563ECBBA5D,0x3FFD // C4
+data8 0xD28D3312983E9844,0x3FFE // C2
+data8 0,0                       // C0
+// [1.25,1.75)
+data8 0xBF12680486396DE6,0x3F23C51FC332CD9D // C17,C16
+data8 0xBF422633DA3A1496,0x3F4CC70680768857 // C13,C12
+data8 0xBF6E2F1A1F804B5D,0x3F78FCE02A032428 // C9,C8
+data8 0x864D46FA895985C1,0xBFFA // C5
+data8 0x97213C6E35E12043,0xBFFC // C3
+data8 0x8A8A42A401D979B7,0x3FC7 // C1
+data8 0xBF2E098A8A2332A8,0x3F370E61B73B205C // C15,C14
+data8 0xBF56F9849D3BC6CC,0x3F6283126F58D7F4 // C11,C10
+data8 0xBF851F9F9516A98F,0x3F9266E797A1433F // C7,C6
+data8 0x845A14A6A81B0638,0x3FFB // C4
+data8 0xF7B95E4771C55C99,0x3FFD // C2
+data8 0xF8CDCDE61C520E0F,0xBFFB // C0
+// [1.75,2.25)
+data8 0xBEA01D7AFA5D8F52,0x3EB1010986E60253 // C17,C16
+data8 0xBEE3CBEDB4C918AA,0x3EF580F6D9D0F72D // C13,C12
+data8 0xBF2D3FD4C7F68563,0x3F40B36AF884AE9A // C9,C8
+data8 0xF2027E10C7B051EC,0xBFF7 // C5
+data8 0x89F000D2ABB03401,0xBFFB // C3
+data8 0xD8773039049E70B6,0x3FFD // C1
+data8 0xBEC112CD07CFC31A,0x3ED2528A428D30E1 // C15,C14
+data8 0xBF078DE5618D8C9F,0x3F1A127AD811A53D // C11,C10
+data8 0xBF538AC5C2BF540D,0x3F67ADD6EADB5718 // C7,C6
+data8 0xA8991563EC243383,0x3FF9 // C4
+data8 0xA51A6625307D3230,0x3FFD // C2
+data8 0,0                       // C0
+//
+// polynomial approximation of ln(sin(Pi*x)/(Pi*x)), 9 <= x <= 0.5
+data8 0xBFDC1BF0931AE591,0x3FD36D6D6CE263D7 //S28,S26
+data8 0xBFBD516F4FD9FB18,0xBFBBE1703F315086 //S20,S18
+data8 0xAAB5A3CCEFCD3628,0xBFFC //S12
+data8 0x80859B5C318E19A5,0xBFFD //S8
+data8 0x8A8991563EC7EB33,0xBFFE //S4
+data8 0xBFD23AB9E6CC88AC,0xBF9957F5146FC7AF //S24,S22
+data8 0xBFC007B324E23040,0xBFC248DEC29CAC4A //S16,S14
+data8 0xCD00EFF2F8F86899,0xBFFC //S10
+data8 0xADA06587FACD668B,0xBFFD //S6
+data8 0xD28D3312983E98A0,0xBFFF //S2
+//
+data8 0x8090F777D7942F73,0x4001 // PR01
+data8 0xE5B521193CF61E63,0x4000 // PR11
+data8 0xC02C000000001939 // (-15;-14)
+data8 0x0000000000000233 // (-15;-14)
+data8 0xC02A000000016124 // (-14;-13)
+data8 0x0000000000002BFB // (-14;-13)
+data8 0xC02800000011EED9 // (-13;-12)
+data8 0x0000000000025CBB // (-13;-12)
+data8 0xC026000000D7322A // (-12;-11)
+data8 0x00000000001E1095 // (-12;-11)
+data8 0xC0240000093F2777 // (-11;-10)
+data8 0x00000000013DD3DC // (-11;-10)
+data8 0xC02200005C7768FB // (-10;-9)
+data8 0x000000000C9539B9 // (-10;-9)
+data8 0xC02000034028B3F9 // (-9;-8)
+data8 0x000000007570C565 // (-9;-8)
+data8 0xC01C0033FDEDFE1F // (-8;-7)
+data8 0x00000007357E670E // (-8;-7)
+data8 0xC018016B25897C8D // (-7;-6)
+data8 0x000000346DC5D639 // (-7;-6)
+data8 0xC014086A57F0B6D9 // (-6;-5)
+data8 0x0000010624DD2F1B // (-6;-5)
+data8 0xC010284E78599581 // (-5;-4)
+data8 0x0000051EB851EB85 // (-5;-4)
+data8 0xC009260DBC9E59AF // (-4;-3)
+data8 0x000028F5C28F5C29 // (-4;-3)
+data8 0xC003A7FC9600F86C // (-3;-2)
+data8 0x0000666666666666 // (-3;-2)
+data8 0xCC15879606130890,0x4000 // PR21
+data8 0xB42FE3281465E1CC,0x4000 // PR31
+//
+data8 0x828185F0B95C9916,0x4001 // PR00
+//
+data8 0xD4D3C819E4E5654B,0x4000 // PR10
+data8 0xA82FBBA4FCC75298,0x4000 // PR20
+data8 0xC02DFFFFFFFFFE52 // (-15;-14)
+data8 0x000000000000001C // (-15;-14)
+data8 0xC02BFFFFFFFFE6C7 // (-14;-13)
+data8 0x00000000000001A6 // (-14;-13)
+data8 0xC029FFFFFFFE9EDC // (-13;-12)
+data8 0x0000000000002BFB // (-13;-12)
+data8 0xC027FFFFFFEE1127 // (-12;-11)
+data8 0x000000000001EEC8 // (-12;-11)
+data8 0xC025FFFFFF28CDD4 // (-11;-10)
+data8 0x00000000001E1095 // (-11;-10)
+data8 0xC023FFFFF6C0D7C0 // (-10;-9)
+data8 0x000000000101B2B3 // (-10;-9)
+data8 0xC021FFFFA3884BD0 // (-9;-8)
+data8 0x000000000D6BF94D // (-9;-8)
+data8 0xC01FFFF97F8159CF // (-8;-7)
+data8 0x00000000C9539B89 // (-8;-7)
+data8 0xC01BFFCBF76B86F0 // (-7;-6)
+data8 0x00000007357E670E // (-7;-6)
+data8 0xC017FE92F591F40D // (-6;-5)
+data8 0x000000346DC5D639 // (-6;-5)
+data8 0xC013F7577A6EEAFD // (-5;-4)
+data8 0x00000147AE147AE1 // (-5;-4)
+data8 0xC00FA471547C2FE5 // (-4;-3)
+data8 0x00000C49BA5E353F // (-4;-3)
+data8 0xC005FB410A1BD901 // (-3;-2)
+data8 0x000053F7CED91687 // (-3;-2)
+data8 0x80151BB918A293AA,0x4000 // PR30
+data8 0xB3C9F8F47422A314,0x400B // PRN
+//
+// right negative roots
+//(-3;-2)
+data8 0x40BFCF8B90BE7F6B,0x40B237623345EFC3 // A15,A14
+data8 0x407A92EFB03B281E,0x40728700C7819759 // A11,A10
+data8 0x403809F04EF4D0F2,0x4038D32F682D9593 // A7,A6
+data8 0xB4A5302C53C2F2D8,0x3FFF // A3
+data8 0xC1FF4B357A9B0383,0x3FFF // A1
+data8 0x409C46632EB4B2D3,0x4091A72AFA2148F5 // A13,A12
+data8 0x4059297AC79A88DB,0x40548EAA7BE7FA6B // A9,A8
+data8 0x4017339FE04B227F,0x4021718D7CA09E02 // A5,A4
+data8 0x9B775D8017AAE668,0x4001 // A2
+data8 0x8191DB68FF4366A1,0x3FC9 // A0
+//(-4;-3)
+data8 0x425260910D35307B,0x422668F5BE7983BB // A15,A14
+data8 0x41A4454DBE4BEE43,0x41799CA93F6EA817 // A11,A10
+data8 0x40FBB97AA1400F31,0x40D293C3F7ADAB15 // A7,A6
+data8 0xE089B8926AE4517B,0x4005 // A3
+data8 0xF90532F97D630C69,0x4001 // A1
+data8 0x41F9F0CF98C5F2EA,0x41D026336C6BF394 // A13,A12
+data8 0x415057F61156D5B8,0x41251EA3055CB754 // A9,A8
+data8 0x40A99A6337D9FC2B,0x408267203D776151 // A5,A4
+data8 0xCEA694BB8A8827A9,0x4003 // A2
+data8 0xF4B02F1D73D30EED,0x3FCD // A0
+//(-5;-4)
+data8 0x4412365489340979,0x43C86441BAFDEE39 // A15,A14
+data8 0x42ED68FCB19352DD,0x42A45FCE3905CD6F // A11,A10
+data8 0x41CD14FE49FD4FCA,0x41855E3DBFA89744 // A7,A6
+data8 0xAACD88D954E0EC16,0x400B // A3
+data8 0xD652E7A490B0DCDF,0x4003 // A1
+data8 0x437F52608E0E752A,0x433560E0633E33D5 // A13,A12
+data8 0x425C83998976DE3D,0x421433DCCD3B473B // A9,A8
+data8 0x4140261EB5732106,0x40F96D18E21AE6CC // A5,A4
+data8 0xA220AE6C09FA8A0E,0x4007 // A2
+data8 0xCC1682D17A2B5A58,0xBFCF // A0
+//(-6;-5)
+data8 0x4630E41D6386CF5A,0x45C2E7992C628C8C // A15,A14
+data8 0x447AABEC714F913A,0x440EDCAB45339F3A // A11,A10
+data8 0x42C9A8D00C97E3CE,0x425F7D8D5BEAB44D // A7,A6
+data8 0x929EC2B1FB95BB5B,0x4012 // A3
+data8 0xF6B970414D717D38,0x4005 // A1
+data8 0x45545E578976F6A2,0x44E738288DD52686 // A13,A12
+data8 0x43A20921FEC49492,0x433557FD7C6A41B3 // A9,A8
+data8 0x41F3E01773761DB4,0x418A225DF2DA6C47 // A5,A4
+data8 0xE7661976117F9312,0x400B // A2
+data8 0xC33C13FEE07494DE,0x3FCF // A0
+//(-7;-6)
+data8 0x4898F1E6133305AD,0x4802C5306FE4A850 // A15,A14
+data8 0x463FD37946B44094,0x45A8D489B784C2DD // A11,A10
+data8 0x43E9500995815F06,0x4354F21E2FEE6DF5 // A7,A6
+data8 0xEF281D1E1BBE10BD,0x4019 // A3
+data8 0xB4EF24F1D78C2029,0x4008 // A1
+data8 0x476AB1D5930011E5,0x46D4867E77BFB622 // A13,A12
+data8 0x45139151ECDEF7C5,0x447F3A2BC6BF466F // A9,A8
+data8 0x42C1D3D50713FA40,0x422F9C7B52556A1B // A5,A4
+data8 0xFE711A4267CEA83A,0x4010 // A2
+data8 0xD11E91B3FF8F4B94,0xBFD2 // A0
+//(-8;-7)
+data8 0x4B39E57569811B6E,0x4A7656073EB1FA21 // A15,A14
+data8 0x482C9B24A516B0BB,0x47698FF55139C62B // A11,A10
+data8 0x452393E2BC8E8D04,0x44628E1C710DA478 // A7,A6
+data8 0x9F2A95AF1B7A773F,0x4022 // A3
+data8 0x9DA03D51C303C918,0x400B // A1
+data8 0x49B24C241A3D5BCB,0x48F01CB936ECDA67 // A13,A12
+data8 0x46A712B3425C6797,0x45E5164114BD6DA1 // A9,A8
+data8 0x43A216A356069D01,0x42E25E42A45E2108 // A5,A4
+data8 0xC1F42ED57BBC2529,0x4016 // A2
+data8 0xB1C7B615A7DCA8A9,0xBFD7 // A0
+//(-9;-8)
+data8 0x4E09D478E5EE857D,0x4D1647782106E9AB // A15,A14
+data8 0x4A3C7F4D51927548,0x49497954796D743A // A11,A10
+data8 0x467387BD6AF0CBDF,0x4582843E134111D2 // A7,A6
+data8 0x9F003C6DE9666513,0x402B // A3
+data8 0x9D8447F6BF99950A,0x400E // A1
+data8 0x4C22364D238C61A9,0x4B300B18050AB940 // A13,A12
+data8 0x4857004D64215772,0x4765074E448C3C9A // A9,A8
+data8 0x44920E9EA07BF624,0x43A257BEC94BBF48 // A5,A4
+data8 0xC1D1C49AC5B2A4B4,0x401C // A2
+data8 0x9A749AF9F2D2E688,0x3FDB // A0
+//(-10;-9)
+data8 0x5102C7C43EA26C83,0x4FDCD174DEB0426B // A15,A14
+data8 0x4C6A036195CD5BAD,0x4B44ABB52B65628A // A11,A10
+data8 0x47D6439374B98FED,0x46B2C3903EF44D7D // A7,A6
+data8 0xE25BAF73AB8A7DB3,0x4034 // A3
+data8 0xB130901CA6D81B61,0x4011 // A1
+data8 0x4EB50BB0726AE206,0x4D907A96E6D2B6E2 // A13,A12
+data8 0x4A20975D78EAF01A,0x48FAF79C9C3E7908 // A9,A8
+data8 0x459044144129A247,0x446D6043FA3150A3 // A5,A4
+data8 0xF547997E083D9BA7,0x4022 // A2
+data8 0x977AF525A6ECA1BC,0x3FDC // A0
+//(-11;-10)
+data8 0x5420A5D5E90C6D73,0x52C4710A503DC67A // A15,A14
+data8 0x4EB2ED07BA88D2A8,0x4D581001ED9A5ECE // A11,A10
+data8 0x494A8A28E9E3DFEF,0x47F1E4E1E476793E // A7,A6
+data8 0xDD0C97E12D4A3378,0x403E // A3
+data8 0xDD7C12D5182FD543,0x4014 // A1
+data8 0x5167ED536877A072,0x500DF9AF21DDC0B6 // A13,A12
+data8 0x4BFEE6F04BC34FF8,0x4AA4175CEF736A5E // A9,A8
+data8 0x4698D1B4388FEC78,0x4541EDE7607A600D // A5,A4
+data8 0xBF9F645F282AC552,0x4029 // A2
+data8 0xAE1BBE4D3CDACCF4,0x3FE1 // A0
+//(-12;-11)
+data8 0x575F0EEF5FB7D4C0,0x55CBB7302B211A7C // A15,A14
+data8 0x5113A4F1825C7CB2,0x4F822A0D46E0605A // A11,A10
+data8 0x4ACED38FC8BE069A,0x493E3B56D2649F18 // A7,A6
+data8 0x8FA8FF5DF8B72D5E,0x4049 // A3
+data8 0x9845417E8598D642,0x4018 // A1
+data8 0x5437780541C3F2D3,0x52A56279B563C1B2 // A13,A12
+data8 0x4DF0F71A48C50188,0x4C600B358988DEBF // A9,A8
+data8 0x47AE7EE95BDA3DE9,0x46200599DC16B18F // A5,A4
+data8 0xB5249F914932E55D,0x4030 // A2
+data8 0xEAE760CD2C086094,0x3FE5 // A0
+//(-13;-12)
+data8 0x5ABA5848651F6D18,0x58EF60D8A817650B // A15,A14
+data8 0x538A8CA86E13EFB1,0x51C05DBD4D01076D // A11,A10
+data8 0x4C607594C339D259,0x4A9585BD5BF932BB // A7,A6
+data8 0xF26D282C36EC3611,0x4053 // A3
+data8 0xE467DF4810EE7EEE,0x401B // A1
+data8 0x5721D9BA485E8CC3,0x5555AF2CCFB2104D // A13,A12
+data8 0x4FF4619A17B14EA6,0x4E29B2F29EB9F8C4 // A9,A8
+data8 0x48CCF27629D46E79,0x47044715F991A63D // A5,A4
+data8 0xCBC92FB9BDAA95A9,0x4037 // A2
+data8 0xFB743A426163665B,0xBFE6 // A0
+//(-14;-13)
+data8 0x5E3295B24B353EAA,0x5C2B447E29796F20 // A15,A14
+data8 0x5615A35CB5EAFAE5,0x54106AB089C95CAF // A11,A10
+data8 0x4DFEC7D93501900A,0x4BF8C4C685F01B83 // A7,A6
+data8 0x820899603D9A74D5,0x405F // A3
+data8 0xB9949919933821CB,0x401F // A1
+data8 0x5A23373DB9A995AC,0x581CBA0AF7F53009 // A13,A12
+data8 0x520929836BB304CD,0x500386409A7076DA // A9,A8
+data8 0x49F480173FEAF90B,0x47F1ACB14B810793 // A5,A4
+data8 0x86881B8674DBF205,0x403F // A2
+data8 0x8CF3CC35AA2C5F90,0x3FED // A0
+//(-15;-14)
+data8 0x61C37D53BE0029D6,0x5F80667CD9D68354 // A15,A14
+data8 0x58B3F01898E6605B,0x567149652116DB6A // A11,A10
+data8 0x4FA82FA4F5D35B00,0x4D663DB00832DF8F // A7,A6
+data8 0xAE426731C9B94996,0x406A // A3
+data8 0xA264C84BE3708F3F,0x4023 // A1
+data8 0x5D3B254BC1C806A8,0x5AF72E736048B553 // A13,A12
+data8 0x542E476505104BB0,0x51EAD96CDC4FB48F // A9,A8
+data8 0x4B25095F498DB134,0x48E4B9FDEBFE24AB // A5,A4
+data8 0xCE076A5A116C1D34,0x4046 // A2
+data8 0x940013871A15050B,0x3FF1 // A0
+//
+// left negative roots
+//(-3;-2)
+data8 0x41AEB7998DBE2B2C,0xC19053D8FAC05DF7 // A16,A15
+data8 0x4133197BF1ADEAF9,0xC1150728B9B82072 // A12,A11
+data8 0x40BDBA65E74F4526,0xC0A12239BEEF8F72 // A8,A7
+data8 0xFA8256664F99E2AA,0x4004 // A4
+data8 0x9933F9E132D2A5DB,0x4002 // A2
+data8 0x416FFB167B85F77C,0xC15166AE0ACCF87C // A14,A13
+data8 0x40F75815106322C0,0xC0DA2D23C59C348D // A10,A9
+data8 0x4084373F7CC42043,0xC0685884581F8C61 // A6,A5
+data8 0xA0C2D6186460FF9D,0xC003 // A3
+data8 0xF5096D48258CA0AD,0xBFFF // A1
+//(-4;-3)
+data8 0xC3E5BD233016D4B9,0x43A084DAD2D94AB1 // A15,A14
+data8 0xC2CCFFF5E5AED722,0x4286D143AC7D29A6 // A11,A10
+data8 0xC1B7DBBE0680D07B,0x4173E8F3ABB79CED // A7,A6
+data8 0xE929ACEA59799BAF,0xC00A // A3
+data8 0xA5CCECB362B21E1C,0xC003 // A1
+data8 0xC357EED873871B81,0x43128E0B873204FC // A13,A12
+data8 0xC242225FA76E8450,0x41FD2F76AE7386CE // A9,A8
+data8 0xC13116F7806D0C7A,0x40EE8F829F141025 // A5,A4
+data8 0xFBB6F57021B5B397,0x4006 // A2
+data8 0xEEE019B4C05AC269,0xBFCB // A0
+//(-5;-4)
+data8 0xC626A52FE8AAA100,0x45B9FD1F4DDFE31E // A15,A14
+data8 0xC473812A5675F08B,0x440738530AECC254 // A11,A10
+data8 0xC2C5068B3F94AC27,0x425A8C5C539A500B // A7,A6
+data8 0x869FBFF732F20C3A,0xC012 // A3
+data8 0xE91251F7CF25A655,0xC005 // A1
+data8 0xC54C18CB48E5DA0F,0x44E07BD36FF561DF // A13,A12
+data8 0xC39BEC120D2FEBEA,0x4330FFA5388435BE // A9,A8
+data8 0xC1F13D5D163B7FB5,0x418752A6F5AC0F39 // A5,A4
+data8 0xDA99E33C51D360F0,0x400B // A2
+data8 0x9F47A66A2F53D9B9,0x3FD1 // A0
+//(-6;-5)
+data8 0xC8970DAC16B6D59E,0x480170728306FD76 // A15,A14
+data8 0xC63E0E5030604CF3,0x45A7924D74D57C65 // A11,A10
+data8 0xC3E8684E41730FC6,0x43544D54EA2E5B9A // A7,A6
+data8 0xEB7404450C47C5F4,0xC019 // A3
+data8 0xB30FB521D2C19F8B,0xC008 // A1
+data8 0xC768F34D35DF6320,0x46D348B3BB2E68B8 // A13,A12
+data8 0xC512AC2FE5EA638E,0x447DF44BC7FC5E17 // A9,A8
+data8 0xC2C15EA6B0AAFEF9,0x422EF5D308DBC420 // A5,A4
+data8 0xFBCEE5BCA70FD3A3,0x4010 // A2
+data8 0x8589A7CFFE0A3E86,0xBFD5 // A0
+//(-7;-6)
+data8 0xCB3995A0CC961E5A,0x4A7615C6C7116ADD // A15,A14
+data8 0xC82C5AFE0BF9C427,0x47695BD2F367668B // A11,A10
+data8 0xC52377E70BA14CF5,0x4462775E859E4392 // A7,A6
+data8 0x9EC8ED6E4C3D4DBE,0xC022 // A3
+data8 0x9D5FBD2E75520E65,0xC00B // A1
+data8 0xC9B21BB881A4DDF8,0x48EFEAB06FBA0207 // A13,A12
+data8 0xC6A6E8550CBC188F,0x45E4F3D26238B099 // A9,A8
+data8 0xC3A20427DF1B110A,0x42E24F3D636F2E4E // A5,A4
+data8 0xC1A4D12A82280CFB,0x4016 // A2
+data8 0xEF46D8DCCA9E8197,0x3FD2 // A0
+//(-8;-7)
+data8 0xCE0946982B27DE5B,0x4D15DBC6664E2DD2 // A15,A14
+data8 0xCA3C769F6B3B2B93,0x49497251CD0C4363 // A11,A10
+data8 0xC67384066C47F489,0x458281393433AB28 // A7,A6
+data8 0x9EF3459926D0F14F,0xC02B // A3
+data8 0x9D7BB7F2600DFF0B,0xC00E // A1
+data8 0xCC22351326C939A7,0x4B3009431C4F1D3F // A13,A12
+data8 0xC856FAADDD48815D,0x476502BC3ECA040C // A9,A8
+data8 0xC4920C2A84173810,0x43A255C052525F99 // A5,A4
+data8 0xC1C73B6554011EFA,0x401C // A2
+data8 0x954612700ADF8317,0xBFD8 // A0
+//(-9;-8)
+data8 0xD102F5CC7B590D3A,0x4FDD0F1C30E4EB22 // A15,A14
+data8 0xCC6A02912B0DF650,0x4B44AB18E4FCC159 // A11,A10
+data8 0xC7D64314B4A2FAAB,0x46B2C334AE5E2D34 // A7,A6
+data8 0xE2598724F7E28E99,0xC034 // A3
+data8 0xB12F6FE2E195452C,0xC011 // A1
+data8 0xCEB507747AF9356A,0x4D907802C08BA48F // A13,A12
+data8 0xCA2096E3DC29516F,0x48FAF6ED046A1DB7 // A9,A8
+data8 0xC59043D21BA5EE56,0x446D5FE468B30450 // A5,A4
+data8 0xF5460A8196B59C83,0x4022 // A2
+data8 0xB108F35A8EDA92D5,0xBFDD // A0
+//(-10;-9)
+data8 0xD420430D91F8265B,0x52C406CAAAC9E0EE // A15,A14
+data8 0xCEB2ECDDDAA3DAD1,0x4D580FDA97F92E3A // A11,A10
+data8 0xC94A8A192341B5D4,0x47F1E4D8C690D07B // A7,A6
+data8 0xDD0C5F920C2F0D2B,0xC03E // A3
+data8 0xDD7BED3631657B48,0xC014 // A1
+data8 0xD167F410E64E90A4,0x500DFFED20F714A7 // A13,A12
+data8 0xCBFEE6D9043169E9,0x4AA4174F64B40AA7 // A9,A8
+data8 0xC698D1A9AF0AB9C2,0x4541EDE14987A887 // A5,A4
+data8 0xBF9F43D461B3DE6E,0x4029 // A2
+data8 0xF3891A50642FAF26,0x3FE1 // A0
+//(-11;-10)
+data8 0xD75F0EEAF769D42A,0x55CBB72C8869183A // A15,A14
+data8 0xD113A4EF80394F77,0x4F822A0B96B3ECA9 // A11,A10
+data8 0xCACED38DC75763CB,0x493E3B5522D2D028 // A7,A6
+data8 0x8FA8FB5C92533701,0xC049 // A3
+data8 0x98453EDB9339C24E,0xC018 // A1
+data8 0xD43778026CCD4B20,0x52A5627753273B9B // A13,A12
+data8 0xCDF0F718DD7E1214,0x4C600B34582911EB // A9,A8
+data8 0xC7AE7EE7F112362C,0x46200599439C264F // A5,A4
+data8 0xB5249C335342B5BC,0x4030 // A2
+data8 0x881550711D143475,0x3FE4 // A0
+//(-12;-11)
+data8 0xDAB9C724EEEE2BBB,0x58EEC971340EDDBA // A15,A14
+data8 0xD38A8C8AE63BD8BF,0x51C05DB21CEE00D3 // A11,A10
+data8 0xCC607594C311C12D,0x4A9585BD5BE6AB57 // A7,A6
+data8 0xF26D282C36EC0E66,0xC053 // A3
+data8 0xE467DF1FA674BFAE,0xC01B // A1
+data8 0xD721DE506999AA9C,0x5555B34F71B45132 // A13,A12
+data8 0xCFF4619A476BF76F,0x4E29B2F2BBE7A67E // A9,A8
+data8 0xC8CCF27629D48EDC,0x47044715F991AB46 // A5,A4
+data8 0xCBC92FB9BDAA928D,0x4037 // A2
+data8 0xCE27C4F01CF53284,0xBFE6 // A0
+//(-13;-12)
+data8 0xDE3295B24355C5A1,0x5C2B447E298B562D // A15,A14
+data8 0xD615A35CB5E92103,0x54106AB089C95E8C // A11,A10
+data8 0xCDFEC7D935019005,0x4BF8C4C685F01B83 // A7,A6
+data8 0x820899603D9A74D5,0xC05F // A3
+data8 0xB9949916F8DF4AC4,0xC01F // A1
+data8 0xDA23373DBA0B7548,0x581CBA0AF7F45C01 // A13,A12
+data8 0xD20929836BB30934,0x500386409A7076D6 // A9,A8
+data8 0xC9F480173FEAF90B,0x47F1ACB14B810793 // A5,A4
+data8 0x86881B8674DBF205,0x403F // A2
+data8 0x8CFAFA9A142C1FF0,0x3FED // A0
+//(-14;-13)
+data8 0xE1C33F356FA2C630,0x5F8038B8AA919DD7 // A15,A14
+data8 0xD8B3F0167E14982D,0x5671496400BAE0DB // A11,A10
+data8 0xCFA82FA4F5D25C3E,0x4D663DB008328C58 // A7,A6
+data8 0xAE426731C9B94980,0xC06A // A3
+data8 0xA264C84BB8A66F86,0xC023 // A1
+data8 0xDD3B26E34762ED1E,0x5AF72F76E3C1B793 // A13,A12
+data8 0xD42E476507E3D06E,0x51EAD96CDD881DFA // A9,A8
+data8 0xCB25095F498DB15F,0x48E4B9FDEBFE24B5 // A5,A4
+data8 0xCE076A5A116C1D32,0x4046 // A2
+data8 0x94001BF5A24966F5,0x3FF1 // A0
+//(-15;-14)
+data8 0xE56DB8B72D7156FF,0x62EAB0CDB22539BE // A15,A14
+data8 0xDB63D76B0D3457E7,0x58E254823D0AE4FF // A11,A10
+data8 0xD15F060BF548404A,0x4EDE65C20CD4E961 // A7,A6
+data8 0x900DA565ED76C19D,0xC076 // A3
+data8 0x9868C809852DA712,0xC027 // A1
+data8 0xE067CCDA0408AAF0,0x5DE5A79C5C5C54AF // A13,A12
+data8 0xD6611ADBF5958ED0,0x53E0294092BE9677 // A9,A8
+data8 0xCC5EA28D90EE8C5D,0x49E014930EF336EE // A5,A4
+data8 0xB57930DCE7A61AE8,0x404E // A2
+data8 0x976BEC1F30DF151C,0x3FF5 // A0
+LOCAL_OBJECT_END(lgamma_data)
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(__libm_lgamma)
+
+{ .mfi
+      getf.exp      GR_SignExp = f8
+      frcpa.s1      FR_C,p9 = f1,f8
+      mov           GR_ExpMask = 0x1ffff
+}
+{ .mfi
+      addl          GR_ad_Data = @ltoff(lgamma_data),gp
+      fcvt.fx.s1    FR_int_N = f8
+      mov           GR_2_25 = 0x4002 // 2.25
+};;
+{ .mfi
+      getf.d        GR_ArgAsIs = f8
+      fclass.m      p13,p0 = f8,0x1EF // is x NaTVal, NaN,
+                                      // +/-0, +/-INF or +/-deno?
+      mov           GR_ExpBias = 0xFFFF
+}
+{ .mfi
+      ld8           GR_ad_Data = [GR_ad_Data]
+      fcvt.fx.trunc.s1 FR_int_Ntrunc = f8
+      mov           GR_ExpOf256 = 0x10007
+};;
+{ .mfi
+      mov           GR_ExpOf2 = 0x10000
+      fcmp.lt.s1    p14,p15 = f8,f0 // p14 if x<0
+      dep.z         GR_Ind = GR_SignExp,8,4
+}
+{ .mfi
+      and           GR_Exp = GR_SignExp,GR_ExpMask
+      fma.s1        FR_2 = f1,f1,f1
+      cmp.lt        p10,p0 = GR_SignExp,GR_ExpBias
+};;
+{ .mfi
+      add           GR_ad_1 = 0xB80,GR_ad_Data
+      fnorm.s1      FR_NormX = f8
+      shr.u         GR_Arg = GR_ArgAsIs,48
+}
+{ .mib
+      add           GR_ad_Co = GR_Ind,GR_ad_Data
+      add           GR_ad_Ce = 0x10,GR_ad_Data
+      // jump if the input argument is NaTVal, NaN, +/-0, +/-INF or +/-deno
+(p13) br.cond.spnt  lgamma_spec
+};;
+lgamma_common:
+{ .mfi
+      ldfpd         FR_LocalMin,FR_05 = [GR_ad_1],16
+      fmerge.se     FR_x = f1,f8
+      add           GR_ad_2 = 0xBC0,GR_ad_Data
+}
+{ .mfb
+      add           GR_ad_Ce = GR_Ind,GR_ad_Ce
+      fms.s1        FR_w = f8,f1,f1 // x-1
+      // jump if the input argument is positive and  less than 1.0
+(p10) br.cond.spnt  lgamma_0_1
+};;
+{ .mfi
+      ldfe          FR_C01 = [GR_ad_Co],32
+      fnma.s1       FR_InvX = FR_C,f8,f1 // NR iteration #1
+(p15) cmp.lt.unc    p8,p0 = GR_ExpOf256,GR_SignExp
+}
+{ .mib
+      ldfe          FR_C11 = [GR_ad_Ce],32
+(p15) cmp.lt.unc    p11,p0 = GR_Arg,GR_2_25
+      // jump if the input argument isn't less than 512.0
+(p8)  br.cond.spnt  lgamma_pstirling
+};;
+{ .mfi
+      ldfe          FR_C21 = [GR_ad_Co],32
+(p14) fms.s1        FR_r = FR_C,f8,f1 // reduced arg for log(x)
+(p14) cmp.lt.unc    p0,p9 = GR_Exp,GR_ExpOf256
+}
+{ .mib
+      ldfe          FR_C31 = [GR_ad_Ce],32
+      add           GR_ad_Co7 = 0x12C0,GR_ad_2
+      // jump if the input argument is from range [1.0; 2.25)
+(p11) br.cond.spnt  lgamma_1_2
+};;
+{ .mfi
+      ldfe          FR_C41 = [GR_ad_Co],32
+      fcvt.xf       FR_N = FR_int_N
+      add           GR_ad_Ce7 = 0x1310,GR_ad_2
+}
+{ .mfb
+      ldfe          FR_C51 = [GR_ad_Ce],32
+(p14) fma.s1        FR_5 = FR_2,FR_2,f1
+      // jump if the input argument is less or equal to -512.0
+(p9)  br.cond.spnt  lgamma_negstirling
+};;
+{ .mfi
+      ldfe          FR_C61 = [GR_ad_Co],32
+(p14) fcvt.xf       FR_Ntrunc = FR_int_Ntrunc
+      shr           GR_Ind = GR_Ind,4
+}
+{ .mfi
+      ldfe          FR_C71 = [GR_ad_Ce],32
+(p14) fma.s1        FR_Xp1 = f1,f1,FR_NormX // x+1
+      cmp.eq        p6,p7 = GR_ExpOf2,GR_SignExp
+};;
+.pred.rel "mutex",p6,p7
+{ .mfi
+      ldfe          FR_C81 = [GR_ad_Co],32
+(p6)  fma.s1        FR_x = f0,f0,FR_NormX
+      shladd        GR_Offs7 = GR_Ind,2,GR_Ind // (ind*16)*5
+}
+{ .mfi
+      ldfe          FR_C91 = [GR_ad_Ce],32
+(p7)  fms.s1        FR_x = FR_x,f1,f1
+      add           GR_ad_Co7 = 0x800,GR_ad_Data
+};;
+{ .mfi
+      ldfe          FR_CA1 = [GR_ad_Co],32
+(p14) fma.s1        FR_3 = f1,f1,FR_2
+      shladd        GR_Offs7 = GR_Ind,1,GR_Offs7 // (ind*16)*7
+}
+{ .mfi
+      ldfe          FR_C00 = [GR_ad_Ce],32
+(p14) fma.s1        FR_Xp4 = FR_2,FR_2,FR_NormX
+      add           GR_ad_Ce7 = 0x810,GR_ad_Data
+};;
+{ .mfi
+      ldfe          FR_C10 = [GR_ad_Co],32
+(p6)  fms.s1        FR_Xm2 = FR_w,f1,f1
+      add           GR_ad_Co7 = GR_ad_Co7,GR_Offs7
+}
+{ .mfi
+      ldfe          FR_C20 = [GR_ad_Ce],32
+(p14) fma.s1        FR_r2 = FR_r,FR_r,f0 // log(x)
+      add           GR_ad_Ce7 = GR_ad_Ce7,GR_Offs7
+};;
+{ .mfi
+      ldfe          FR_C30 = [GR_ad_Co],32
+(p14) fms.s1        FR_Xf = FR_NormX,f1,FR_N  // xf = x - [x]
+(p14) mov           GR_Arg17 = 0xC031 // -17
+}
+{ .mfi
+      ldfe          FR_C40 = [GR_ad_Ce],32
+(p14) fma.s1        FR_Xp5 = FR_5,f1,FR_NormX
+(p14) sub           GR_Exp = GR_Exp,GR_ExpBias
+};;
+{ .mfi
+      ldfe          FR_C50 = [GR_ad_Co7],32
+(p14) fms.s1        FR_Xfr = FR_Xp1,f1,FR_Ntrunc // xfr = (x+1) - [x]
+(p14) cmp.lt.unc    p13,p0 = GR_Arg,GR_Arg17
+}
+{ .mfb
+      ldfe          FR_C60 = [GR_ad_Ce7],32
+(p14) fma.s1        FR_Xp10 = FR_5,FR_2,FR_NormX
+      // jump if the input argument is negative and great than -17.0
+(p13) br.cond.spnt  lgamma_negrecursion
+};;
+{ .mfi
+      ldfe          FR_C70 = [GR_ad_Co7],32
+      fma.s1        FR_C01 = FR_x,f1,FR_C01
+(p14) add           GR_ad_Ce = 0x1310,GR_ad_2
+}
+{ .mfi
+      ldfe          FR_C80 = [GR_ad_Ce7],32
+      fma.s1        FR_C11 = FR_x,f1,FR_C11
+(p14) add           GR_ad_Co = 0x12C0,GR_ad_2
+};;
+{ .mfi
+      ldfe          FR_C90 = [GR_ad_Co7],32
+      fma.s1        FR_C21 = FR_x,f1,FR_C21
+      nop.i         0
+}
+{ .mfi
+      ldfe          FR_CA0 = [GR_ad_Ce7],32
+      fma.s1        FR_C31 = FR_x,f1,FR_C31
+      nop.i         0
+};;
+{ .mfi
+      ldfe          FR_CN = [GR_ad_Co7],32
+      fma.s1        FR_C41 = FR_x,f1,FR_C41
+      nop.i         0
+}
+{ .mfi
+(p14) ldfpd         FR_P5,FR_P4 = [GR_ad_1],16
+      fma.s1        FR_C51 = FR_x,f1,FR_C51
+      nop.i         0
+};;
+{ .mfi
+(p14) ldfpd         FR_P3,FR_P2 = [GR_ad_2],16
+      fma.s1        FR_C61 = FR_x,f1,FR_C61
+      nop.i         0
+}
+{ .mfi
+(p14) ldfe          FR_Ln2 = [GR_ad_1]
+      fma.s1        FR_C71 = FR_x,f1,FR_C71
+      nop.i         0
+};;
+{ .mfi
+(p14) ldfpd         FR_S28,FR_S26 = [GR_ad_Co],16
+      fma.s1        FR_C81 = FR_x,f1,FR_C81
+      add           GR_ad_2 = 0x60,GR_ad_2
+}
+{ .mfi
+(p14) ldfpd         FR_S24,FR_S22 = [GR_ad_Ce],16
+      fma.s1        FR_C91 = FR_x,f1,FR_C91
+      nop.i         0
+};;
+{ .mfi
+(p14) ldfpd         FR_S20,FR_S18 = [GR_ad_Co],16
+      fma.s1        FR_CA1 = FR_x,f1,FR_CA1
+      nop.i         0
+}
+{ .mfi
+(p14) ldfpd         FR_S16,FR_S14 = [GR_ad_Ce],16
+      fma.s1        FR_C01 = FR_C01,FR_x,FR_C00
+      nop.i         0
+};;
+{ .mfi
+(p14) getf.exp      GR_SignExp = FR_Xf
+      fma.s1        FR_C11 = FR_C11,FR_x,FR_C10
+      nop.i         0
+}
+{ .mfi
+(p14) ldfe          FR_S12 = [GR_ad_Co],16
+      fma.s1        FR_C21 = FR_C21,FR_x,FR_C20
+      nop.i         0
+};;
+{ .mfi
+(p14) getf.sig      GR_Sig = FR_Xf
+(p14) frcpa.s1      FR_InvXf,p0 = f1,FR_Xf
+      nop.i         0
+}
+{ .mfi
+(p14) ldfe          FR_S10 = [GR_ad_Ce],16
+      fma.s1        FR_C41 = FR_C41,FR_x,FR_C40
+      nop.i         0
+};;
+{ .mfi
+(p14) ldfe          FR_S8 = [GR_ad_Co],16
+      fma.s1        FR_C51 = FR_C51,FR_x,FR_C50
+      nop.i         0
+}
+{ .mfi
+(p14) ldfe          FR_S6 = [GR_ad_Ce],16
+      fma.s1        FR_C61 = FR_C61,FR_x,FR_C60
+(p14) and           GR_Expf = GR_SignExp,GR_ExpMask
+};;
+{ .mfi
+(p14) sub           GR_Expf = GR_Expf,GR_ExpBias
+      fma.s1        FR_C71 = FR_C71,FR_x,FR_C70
+(p14) shl           GR_Ind = GR_Sig,1
+}
+{ .mfi
+(p14) ldfe          FR_S4 = [GR_ad_Co],16
+      fma.s1        FR_C81 = FR_C81,FR_x,FR_C80
+(p14) cmp.eq.unc    p8,p0 = 0,GR_Sig
+};;
+{ .mfi
+(p14) setf.sig      FR_int_Nf = GR_Expf
+      fma.s1        FR_C91 = FR_C91,FR_x,FR_C90
+(p14) shr.u         GR_Ind = GR_Ind,56
+}
+{ .mfb
+(p14) ldfe          FR_S2 = [GR_ad_Ce],16
+      fma.s1        FR_CA1 = FR_CA1,FR_x,FR_CA0
+      // jump if the input argument is integer number from range (-512.0;-17.0]
+(p8)  br.cond.spnt  lgamma_singularity
+};;
+{ .mfi
+(p14) getf.sig      GR_Sig = FR_int_Ntrunc
+      fma.s1        FR_C01 = FR_C01,FR_C11,f0
+      nop.i         0
+}
+{ .mfi
+(p14) shladd        GR_ad_T = GR_Ind,4,GR_ad_2
+      fma.s1        FR_C31 = FR_C31,FR_x,FR_C30
+      nop.i         0
+};;
+{ .mfi
+(p14) ldfe          FR_Tf = [GR_ad_T]
+(p14) fms.s1        FR_rf = FR_InvXf,FR_Xf,f1 // reduced arg for log({x})
+(p14) extr.u        GR_Ind = GR_ArgAsIs,44,8
+}
+{ .mfi
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+      fma.s1        FR_C21 = FR_C21,FR_C41,f0
+      mov           GR_SignOfGamma = 1
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C51 = FR_C51,FR_C61,f0
+(p14) tbit.z.unc    p8,p0 = GR_Sig,0
+}
+{ .mfi
+(p14) shladd        GR_ad_T = GR_Ind,4,GR_ad_2
+(p6)  fma.s1        FR_CN = FR_CN,FR_Xm2,f0
+      nop.i         0
+};;
+{ .mfi
+(p14) setf.sig      FR_int_N = GR_Exp
+      fma.s1        FR_C71 = FR_C71,FR_C81,f0
+(p8)  sub           GR_SignOfGamma = r0,GR_SignOfGamma
+}
+{ .mfi
+      nop.m         0
+(p14) fma.s1        FR_Xf2 = FR_Xf,FR_Xf,f0
+      nop.i         0
+};;
+{ .mfi
+(p14) ldfe          FR_T = [GR_ad_T]
+      fma.s1        FR_C91 = FR_C91,FR_CA1,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p14) fma.s1        FR_r2 = FR_r,FR_r,f0
+      nop.i         0
+};;
+.pred.rel "mutex",p9,p10
+{ .mfi
+      // store sign of gamma(x) as 32-bit int
+(p9)  st4           [r33] = GR_SignOfGamma
+      fma.s1        FR_C01 = FR_C01,FR_C31,f0
+      nop.i         0
+}
+{ .mfi
+      // store sign of gamma(x) as 64-bit int
+(p10) st8           [r33] = GR_SignOfGamma
+(p14) fma.s1        FR_P54 = FR_P5,FR_r,FR_P4
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p14) fma.s1        FR_P32 = FR_P3,FR_r,FR_P2
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p14) fma.s1        FR_P54f = FR_P5,FR_rf,FR_P4
+      // jump if the input argument is non-integer from range (-512.0;-17.0]
+(p14) br.cond.spnt  lgamma_negpoly
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C21 = FR_C21,FR_C51,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C71 = FR_C71,FR_C91,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_CN  = FR_C01,FR_CN,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C21 = FR_C21,FR_C71,f0
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+      fma.d.s0      f8 = FR_C21,FR_CN,f0
+      br.ret.sptk   b0 // exit for arguments from range [2.25; 512.0)
+};;
+// branch for calculating of ln(GAMMA(x)) for -512 < x < -17
+//---------------------------------------------------------------------
+.align 32
+lgamma_negpoly:
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Xf4 = FR_Xf2,FR_Xf2,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S28 = FR_S28,FR_Xf2,FR_S26
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S24 = FR_S24,FR_Xf2,FR_S22
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S20 = FR_S20,FR_Xf2,FR_S18
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S16 = FR_S16,FR_Xf2,FR_S14
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S12 = FR_S12,FR_Xf2,FR_S10
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S8 = FR_S8,FR_Xf2,FR_S6
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S4 = FR_S4,FR_Xf2,FR_S2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_rf2 = FR_rf,FR_rf,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P32f = FR_P3,FR_rf,FR_P2 // log(x)
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_r3 = FR_r2,FR_r,f0 // log(x)
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fcvt.xf       FR_Nf = FR_int_Nf // log({x})
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S28 = FR_S28,FR_Xf4,FR_S24
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Xf8 = FR_Xf4,FR_Xf4,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S20 = FR_S20,FR_Xf4,FR_S16
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C21 = FR_C21,FR_C51,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S12 = FR_S12,FR_Xf4,FR_S8
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C71 = FR_C71,FR_C91,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_P10 = FR_r2,FR_05,FR_r // log(x)
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P54 = FR_P54,FR_r2,FR_P32 // log(x)
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_P10f = FR_rf2,FR_05,FR_rf // log({x})
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fcvt.xf       FR_N = FR_int_N // log(x)
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_rf3 = FR_rf2,FR_rf,f0 // log({x})
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P54f = FR_P54f,FR_rf2,FR_P32f // log({x})
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S28 = FR_S28,FR_Xf8,FR_S20
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_TpNxLn2f = FR_Nf,FR_Ln2,FR_Tf // log({x})
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_CN  = FR_C01,FR_CN,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_C21 = FR_C21,FR_C71,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P54 = FR_P54,FR_r3,FR_P10 // log(x)
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_TpNxLn2 = FR_N,FR_Ln2,FR_T // log(x)
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P54f = FR_P54f,FR_rf3,FR_P10f // log({x})
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S28 = FR_S28,FR_Xf8,FR_S12
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_C21 = FR_C21,FR_CN,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_LnX = FR_TpNxLn2,f1,FR_P54 // log(x)
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_LnXf = FR_TpNxLn2f,f1,FR_P54f // log({x})
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S28 = FR_S28,FR_Xf4,FR_S4
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_LnX = FR_LnX,f1,FR_LnXf
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_S28 = FR_S28,FR_Xf2,FR_C21
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+      fms.d.s0      f8 = FR_S28,f1,FR_LnX
+      br.ret.sptk   b0
+};;
+// branch for calculating of ln(GAMMA(x)) for x >= 512
+//---------------------------------------------------------------------
+.align 32
+lgamma_pstirling:
+{ .mfi
+      ldfpd         FR_P5,FR_P4 = [GR_ad_1],16
+      nop.f         0
+      and           GR_Exp = GR_SignExp,GR_ExpMask
+}
+{ .mfi
+      ldfpd         FR_P3,FR_P2 = [GR_ad_2],16
+      fma.s1        FR_InvX = FR_C,FR_InvX,FR_C // NR iteration #1
+      mov           GR_ExpBias = 0xffff
+};;
+{ .mfi
+      ldfe          FR_Ln2 = [GR_ad_1],16
+      nop.f         0
+      sub           GR_Exp = GR_Exp,GR_ExpBias
+};;
+{ .mfi
+      ldfpd         FR_W4,FR_OvfBound = [GR_ad_2],16
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      setf.sig      FR_int_N = GR_Exp
+      fms.s1        FR_r = FR_C,f8,f1
+      nop.i         0
+};;
+{ .mmf
+      getf.sig      GR_Sig = FR_NormX
+      ldfe          FR_LnSqrt2Pi = [GR_ad_1],16
+      nop.f         0
+};;
+{ .mmf
+      ldfe          FR_W2 = [GR_ad_2],16
+      nop.m         0
+      fnma.s1       FR_InvX2 = FR_InvX,FR_NormX,f1 // NR iteration #2
+};;
+{ .mfi
+      add           GR_ad_2 = 0x40,GR_ad_2
+      nop.f         0
+      shl           GR_Ind = GR_Sig,1
+};;
+{ .mfi
+      mov           GR_SignOfGamma = 1
+      nop.f         0
+      shr.u         GR_Ind = GR_Ind,56
+};;
+{ .mfi
+      shladd        GR_ad_2 = GR_Ind,4,GR_ad_2
+      fma.s1        FR_r2 = FR_r,FR_r,f0
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+};;
+{ .mfi
+      ldfe          FR_T = [GR_ad_2]
+      fma.s1        FR_P54 = FR_P5,FR_r,FR_P4
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P32 = FR_P3,FR_r,FR_P2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fcmp.le.s1    p6,p0 = FR_OvfBound,FR_NormX
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_InvX2 = FR_InvX,FR_InvX2,FR_InvX // NR iteration #2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fcvt.xf       FR_N = FR_int_N
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+      nop.f         0
+      // jump if x is great than OVERFLOW_BOUNDARY
+(p6)  br.cond.spnt  lgamma_overflow
+};;
+.pred.rel "mutex",p9,p10
+{ .mfi
+      // store sign of gamma(x) as 32-bit int
+(p9)  st4           [r33] = GR_SignOfGamma
+      fma.s1        FR_r3 = FR_r2,FR_r,f0
+      nop.i         0
+}
+{ .mfi
+      // store sign of gamma(x) as 64-bit int
+(p10) st8           [r33] = GR_SignOfGamma
+      fnma.s1       FR_P10 = FR_r2,FR_05,FR_r
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P54 = FR_P54,FR_r2,FR_P32
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_InvX = FR_InvX2,FR_NormX,f1 // NR iteration #3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fms.s1        FR_Xm05 = FR_NormX,f1,FR_05 // (x-1/2)
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_TpNxLn2 = FR_N,FR_Ln2,FR_T
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P54 = FR_P54,FR_r3,FR_P10
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_InvX = FR_InvX2,FR_InvX,FR_InvX2 // NR iteration #3
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fms.s1        FR_LnSqrt2Pi = FR_LnSqrt2Pi,f1,FR_NormX // ln(sqrt(2*Pi))-x
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_LnX = FR_TpNxLn2,f1,FR_P54
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_InvX2 = FR_InvX,FR_InvX,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      // (x-1/2)*ln(x)+ln(sqrt(2*Pi))-x
+      fma.s1        FR_LnX = FR_LnX,FR_Xm05,FR_LnSqrt2Pi
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_W2 = FR_W4,FR_InvX2,FR_W2 // W2 + W4/x^2
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+      fma.d.s0      f8 = FR_InvX,FR_W2,FR_LnX
+      br.ret.sptk   b0
+};;
+// branch for calculating of ln(GAMMA(x)) for x < -512
+//---------------------------------------------------------------------
+.align 32
+lgamma_negstirling:
+{ .mfi
+      ldfpd         FR_P5,FR_P4 = [GR_ad_1],16
+      fms.s1        FR_Xf = FR_NormX,f1,FR_N  // xf = x - [x]
+      and           GR_Exp = GR_SignExp,GR_ExpMask
+}
+{ .mfi
+      ldfpd         FR_P3,FR_P2 = [GR_ad_2],16
+      fma.s1        FR_InvX = FR_C,FR_InvX,FR_C // NR iteration #1
+      mov           GR_0x30033 = 0x30033
+};;
+{ .mfi
+      ldfe          FR_Ln2 = [GR_ad_1],16
+      nop.f         0
+      extr.u        GR_Ind = GR_ArgAsIs,44,8
+}
+{ .mib
+      ldfd          FR_W4 = [GR_ad_2],16
+      // jump if x is less or equal to -2^52, i.e. x is big negative integer
+      cmp.leu.unc   p7,p0 = GR_0x30033,GR_SignExp
+(p7)  br.cond.spnt  lgamma_singularity
+};;
+{ .mfi
+      ldfpd         FR_S28,FR_S26 = [GR_ad_Co7],16
+      nop.f         0
+      add           GR_ad_LnT = 0x50,GR_ad_2
+}
+{ .mfi
+      ldfpd         FR_S24,FR_S22 = [GR_ad_Ce7],16
+      nop.f         0
+      mov           GR_ExpBias = 0xffff
+};;
+{ .mfi
+      ldfpd         FR_S20,FR_S18 = [GR_ad_Co7],16
+      nop.f         0
+      shladd        GR_ad_T = GR_Ind,4,GR_ad_LnT
+}
+{ .mfi
+      ldfpd         FR_S16,FR_S14 = [GR_ad_Ce7],16
+      nop.f         0
+      sub           GR_Exp = GR_Exp,GR_ExpBias
+};;
+{ .mfi
+      ldfe          FR_S12 = [GR_ad_Co7],16
+      nop.f         0
+      nop.i         0
+}
+{ .mfi
+      ldfe          FR_S10 = [GR_ad_Ce7],16
+      fms.s1        FR_r = FR_C,f8,f1
+      nop.i         0
+};;
+{ .mmf
+      ldfe          FR_S8 = [GR_ad_Co7],16
+      ldfe          FR_S6 = [GR_ad_Ce7],16
+      nop.f         0
+};;
+{ .mfi
+      ldfe          FR_S4 = [GR_ad_Co7],16
+      fma.s1        FR_Xf2 = FR_Xf,FR_Xf,f0
+      nop.i         0
+}
+{ .mfi
+      ldfe          FR_S2 = [GR_ad_Ce7],16
+      fnma.s1       FR_InvX2 = FR_InvX,FR_NormX,f1 // NR iteration #2
+      nop.i         0
+};;
+{ .mfi
+      setf.sig      FR_int_N = GR_Exp
+      frcpa.s1      FR_InvXf,p9 = f1,FR_Xf // 1/xf
+      nop.i         0
+}
+{ .mfi
+      ldfe          FR_LnSqrt2Pi = [GR_ad_1],16
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      getf.exp      GR_SignExp = FR_Xf
+      nop.f         0
+      nop.i         0
+}
+{ .mfi
+      ldfe          FR_W2 = [GR_ad_2],16
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      getf.sig      GR_Sig = FR_Xf
+      fma.s1        FR_P54 = FR_P5,FR_r,FR_P4
+      nop.i         0
+}
+{ .mfi
+      ldfe          FR_T = [GR_ad_T]
+      fma.s1        FR_P32 = FR_P3,FR_r,FR_P2
+      nop.i         0
+};;
+{ .mfi
+      and           GR_Exp = GR_SignExp,GR_ExpMask
+      fma.s1        FR_r2 = FR_r,FR_r,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fms.s1        FR_Xm05 = FR_NormX,f1,FR_05 // (x-1/2)
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_InvX2 = FR_InvX,FR_InvX2,FR_InvX // NR iteration #2
+      extr.u        GR_Ind = GR_Sig,55,8
+}
+{ .mfi
+      sub           GR_Exp = GR_Exp,GR_ExpBias
+      fma.s1        FR_Xf4 = FR_Xf2,FR_Xf2,f0
+      cmp.eq        p6,p0 = 0,GR_Sig
+};;
+{ .mfi
+      setf.sig      FR_int_Nf = GR_Exp
+      fma.s1        FR_S28 = FR_S28,FR_Xf2,FR_S26
+      shladd        GR_ad_T = GR_Ind,4,GR_ad_LnT
+}
+{ .mfb
+      nop.m         0
+      fma.s1        FR_S24 = FR_S24,FR_Xf2,FR_S22
+      // jump if the input argument is integer number from range (-512.0;-17.0]
+(p6)  br.cond.spnt  lgamma_singularity
+};;
+{ .mfi
+      getf.sig      GR_Sig = FR_int_Ntrunc
+      fma.s1        FR_S20 = FR_S20,FR_Xf2,FR_S18
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S16 = FR_S16,FR_Xf2,FR_S14
+      nop.i         0
+};;
+{ .mfi
+      ldfe          FR_Tf = [GR_ad_T]
+      fma.s1        FR_S12 = FR_S12,FR_Xf2,FR_S10
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S8 = FR_S8,FR_Xf2,FR_S6
+      mov           GR_SignOfGamma = 1
+};;
+{ .mfi
+      nop.m         0
+      fms.s1        FR_rf = FR_InvXf,FR_Xf,f1 // reduced arg rf
+      tbit.z        p8,p0 = GR_Sig,0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_r3 = FR_r2,FR_r,f0
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+};;
+{ .mfi
+      nop.m         0
+      fcvt.xf       FR_N = FR_int_N
+(p8)  sub           GR_SignOfGamma = r0,GR_SignOfGamma
+}
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_InvX = FR_InvX2,FR_NormX,f1 // NR iteration #3
+      nop.i         0
+};;
+.pred.rel "mutex",p9,p10
+{ .mfi
+      // store sign of gamma(x) as 32-bit int
+(p9)  st4           [r33] = GR_SignOfGamma
+      fma.s1        FR_P54 = FR_P54,FR_r2,FR_P32
+      nop.i         0
+}
+{ .mfi
+      // store sign of gamma(x) as 64-bit int
+(p10) st8           [r33] = GR_SignOfGamma
+      fnma.s1       FR_P10 = FR_r2,FR_05,FR_r
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Xf8 = FR_Xf4,FR_Xf4,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S28 = FR_S28,FR_Xf4,FR_S24
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S20 = FR_S20,FR_Xf4,FR_S16
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S12 = FR_S12,FR_Xf4,FR_S8
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_rf2 = FR_rf,FR_rf,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P54f = FR_P5,FR_rf,FR_P4
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P32f = FR_P3,FR_rf,FR_P2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_InvX = FR_InvX2,FR_InvX,FR_InvX2 // NR iteration #3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fcvt.xf       FR_Nf = FR_int_Nf
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_LnSqrt2Pi = FR_NormX,f1,FR_LnSqrt2Pi // x+ln(sqrt(2*Pi))
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P54 = FR_P54,FR_r3,FR_P10
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S28 = FR_S28,FR_Xf8,FR_S20
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_rf3 = FR_rf2,FR_rf,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_P10f = FR_rf2,FR_05,FR_rf
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_TpNxLn2 = FR_N,FR_Ln2,FR_T
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P54f = FR_P54f,FR_rf2,FR_P32f
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_InvX2 = FR_InvX,FR_InvX,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S28 = FR_S28,FR_Xf8,FR_S12
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S4 = FR_S4,FR_Xf2,FR_S2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P54f = FR_P54f,FR_rf3,FR_P10f
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_TpNxLn2f = FR_Nf,FR_Ln2,FR_Tf
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_LnX = FR_TpNxLn2,f1,FR_P54
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_W2 = FR_W4,FR_InvX2,FR_W2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S28 = FR_S28,FR_Xf4,FR_S4
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_LnXf = FR_TpNxLn2f,f1,FR_P54f
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fms.s1        FR_LnX = FR_LnX,FR_Xm05,FR_LnSqrt2Pi
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_LnX = FR_InvX,FR_W2,FR_LnX
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_LnX = FR_S28,FR_Xf2,FR_LnX
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+      fms.d.s0      f8 = FR_LnX,f1,FR_LnXf
+      br.ret.sptk   b0
+};;
+// branch for calculating of ln(GAMMA(x)) for 0 <= x < 1
+//---------------------------------------------------------------------
+.align 32
+lgamma_0_1:
+{ .mfi
+      ldfpd         FR_P5,FR_P4 = [GR_ad_1],16
+      fms.s1        FR_x = FR_NormX,f1,f0 // x
+      mov           GR_Arg025 = 0x3FD0
+}
+{ .mfi
+      ldfpd         FR_P3,FR_P2 = [GR_ad_2],16
+      nop.f         0
+      add           GR_ad_Co = 0x1C40,GR_ad_Data
+};;
+{ .mfi
+      ldfe          FR_Ln2 = [GR_ad_1],0x50
+      nop.f         0
+      // p6 if arg < 0.25
+      cmp.lt        p6,p9 = GR_Arg,GR_Arg025
+}
+{ .mfi
+      add           GR_ad_2 = 0x40,GR_ad_2
+      nop.f         0
+      mov           GR_Arg075 = 0x3FE8
+};;
+{ .mfi
+      ldfpd         FR_Q8,FR_Q7 = [GR_ad_1],16
+      fma.s1        FR_w2 = FR_w,FR_w,f0
+      // p7 if 0.25 <= arg < 0.75
+      // p8 if 0.75 <= arg < 1.0
+(p9)  cmp.lt.unc    p7,p8 = GR_Arg,GR_Arg075
+}
+{ .mfi
+      mov           GR_Arg0875 = 0x3FEC
+      nop.f         0
+      sub           GR_Exp = GR_Exp,GR_ExpBias
+};;
+{ .mfi
+      ldfpd         FR_Q6,FR_Q5 = [GR_ad_2],16
+      nop.f         0
+(p8)  cmp.lt        p9,p0 = GR_Arg,GR_Arg0875
+}
+{ .mfi
+      ldfpd         FR_Q4,FR_Q3 = [GR_ad_1],16
+      nop.f         0
+      add           GR_ad_Ce = 0x60,GR_ad_Co
+};;
+.pred.rel "mutex",p7,p8
+{ .mfi
+      ldfd          FR_Q2 = [GR_ad_2],16
+      fms.s1        FR_r = FR_C,f8,f1
+(p7)  mov           GR_Offs = 0xC0
+}
+{ .mfi
+      setf.sig      FR_int_N = GR_Exp
+      nop.f         0
+(p8)  mov           GR_Offs = 0x180
+};;
+.pred.rel "mutex",p6,p7
+{ .mfi
+(p9)  add           GR_ad_Co = GR_Offs,GR_ad_Co
+(p8)  fms.s1        FR_x = FR_NormX,f1,f1 // x-1
+      nop.i         0
+}
+{ .mfi
+(p9)  add           GR_ad_Ce = GR_Offs,GR_ad_Ce
+(p7)  fms.s1        FR_x = FR_NormX,f1,FR_LocalMin // x-LocalMin
+      cmp.lt        p10,p0 = GR_Arg,GR_Arg0875
+};;
+lgamma_common_0_2:
+{ .mfi
+      ldfpd         FR_A17,FR_A16 = [GR_ad_Co],16
+      nop.f         0
+      nop.i         0
+}
+{ .mfi
+      ldfpd         FR_A15,FR_A14 = [GR_ad_Ce],16
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      ldfpd         FR_A13,FR_A12 = [GR_ad_Co],16
+      nop.f         0
+(p10) extr.u        GR_Ind = GR_ArgAsIs,44,8
+}
+{ .mfi
+      ldfpd         FR_A11,FR_A10 = [GR_ad_Ce],16
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      ldfpd         FR_A9,FR_A8 = [GR_ad_Co],16
+(p10) fnma.s1       FR_Q1 = FR_05,FR_w2,FR_w
+      nop.i         0
+}
+{ .mfi
+      ldfpd         FR_A7,FR_A6 = [GR_ad_Ce],16
+(p10) fma.s1        FR_w3 = FR_w2,FR_w,f0
+      nop.i         0
+};;
+{ .mfi
+(p10) getf.exp      GR_SignExp_w = FR_w
+(p10) fma.s1        FR_w4 = FR_w2,FR_w2,f0
+      nop.i         0
+}
+{ .mfi
+(p10) shladd        GR_ad_2 = GR_Ind,4,GR_ad_2
+(p10) fma.s1        FR_r2 = FR_r,FR_r,f0
+      nop.i         0
+};;
+{ .mfi
+(p10) ldfe          FR_T = [GR_ad_2]
+(p10) fma.s1        FR_P54 = FR_P5,FR_r,FR_P4
+      nop.i         0
+}
+{ .mfi
+      ldfe          FR_A5 = [GR_ad_Co],16
+(p10) fma.s1        FR_P32 = FR_P3,FR_r,FR_P2
+      nop.i         0
+};;
+{ .mfi
+      ldfe          FR_A4 = [GR_ad_Ce],16
+      fma.s1        FR_x2 = FR_x,FR_x,f0
+(p10) and           GR_Exp_w = GR_ExpMask, GR_SignExp_w
+}
+{ .mfi
+      ldfe          FR_A3 = [GR_ad_Co],16
+      nop.f         0
+(p10) mov           GR_fff9 = 0xfff9
+};;
+//    p13 <== large w __libm_lgamma
+//    p14 <== small w __libm_lgamma
+{ .mfi
+      ldfe          FR_A2 = [GR_ad_Ce],16
+(p10) fma.s1        FR_Q8 = FR_Q8,FR_w,FR_Q7
+(p10) cmp.ge.unc    p13,p14 = GR_Exp_w,GR_fff9
+}
+{ .mfi
+      ldfe          FR_A1 = [GR_ad_Co],16
+(p10) fma.s1        FR_Q6 = FR_Q6,FR_w,FR_Q5
+      nop.i         0
+};;
+{ .mfi
+      ldfe          FR_A0 = [GR_ad_Ce],16
+(p10) fma.s1        FR_Q4 = FR_Q4,FR_w,FR_Q3
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p10) fma.s1        FR_Q2 = FR_Q2,FR_w3,FR_Q1
+      nop.i         0
+};;
+{ .mfi
+      // set p11 if signgum is 32-bit int
+      // set p12 if signgum is 64-bit int
+      cmp.eq        p12,p11 = 8,r34
+(p10) fma.s1        FR_r3 = FR_r2,FR_r,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p10) fnma.s1       FR_P10 = FR_r2,FR_05,FR_r
+      mov           GR_SignOfGamma = 1
+};;
+.pred.rel "mutex",p11,p12
+{ .mfi
+      // store sign of gamma(x) as 32-bit int
+(p11) st4           [r33] = GR_SignOfGamma
+      fma.s1        FR_A17 = FR_A17,FR_x,FR_A16
+      nop.i         0
+}
+{ .mfi
+      // store sign of gamma(x) as 64-bit int
+(p12) st8           [r33] = GR_SignOfGamma
+      fma.s1        FR_A15 = FR_A15,FR_x,FR_A14
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p10) fcvt.xf       FR_N = FR_int_N
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p10) fma.s1        FR_P54 = FR_P54,FR_r2,FR_P32
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A13 = FR_A13,FR_x,FR_A12
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A11 = FR_A11,FR_x,FR_A10
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A9 = FR_A9,FR_x,FR_A8
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A7 = FR_A7,FR_x,FR_A6
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p10) fma.s1        FR_Qlo = FR_Q8,FR_w2,FR_Q6
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p10) fma.s1        FR_w6 = FR_w3,FR_w3,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p10) fma.s1        FR_Qhi = FR_Q4,FR_w4,FR_Q2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A5 = FR_A5,FR_x,FR_A4
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p10) fma.s1        FR_TpNxLn2 = FR_N,FR_Ln2,FR_T
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A3 = FR_A3,FR_x,FR_A2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p10) fma.s1        FR_P54 = FR_P54,FR_r3,FR_P10
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A1 = FR_A1,FR_x,FR_A0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A17 = FR_A17,FR_x2,FR_A15
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A13 = FR_A13,FR_x2,FR_A11
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A9 = FR_A9,FR_x2,FR_A7
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x4 = FR_x2,FR_x2,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p14) fma.s1        FR_LnX = FR_Qlo,FR_w6,FR_Qhi
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A5 = FR_A5,FR_x2,FR_A3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_LnX = FR_TpNxLn2,f1,FR_P54
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A17 = FR_A17,FR_x4,FR_A13
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x8 = FR_x4,FR_x4,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A9 = FR_A9,FR_x4,FR_A5
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A17 = FR_A17,FR_x8,FR_A9
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p10) fms.s1        FR_A1 = FR_A1,f1,FR_LnX
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+      fma.d.s0      f8 = FR_A17,FR_x2,FR_A1
+      br.ret.sptk   b0
+};;
+// branch for calculating of ln(GAMMA(x)) for 1.0 <= x < 2.25
+//---------------------------------------------------------------------
+.align 32
+lgamma_1_2:
+{ .mfi
+      add           GR_ad_Co = 0x10B0,GR_ad_1
+      fcmp.eq.s1    p12,p0 = f1,FR_w
+      mov           GR_Arg125 = 0x3FF4
+}
+{ .mfi
+      add           GR_ad_Ce = 0x1110,GR_ad_1
+      nop.f         0
+      mov           GR_Arg175 = 0x3FFC
+};;
+{ .mfi
+      mov           GR_SignOfGamma = 1
+      fcmp.eq.s1    p13,p0 = f1,FR_NormX
+      cmp.lt        p6,p9 = GR_Arg,GR_Arg125 // 1.0 <= x < 1.25
+}
+{ .mfi
+      // set p10 if signgum is 32-bit int
+      // set p11 if signgum is 64-bit int
+      cmp.eq        p11,p10 = 8,r34
+      nop.f         0
+      cmp.ge        p8,p0 = GR_Arg,GR_Arg175 // x >= 1.75
+};;
+.pred.rel "mutex",p10,p11
+{ .mfi
+      // store sign of gamma(x) as 32-bit int
+(p10) st4           [r33] = GR_SignOfGamma
+(p12) fma.d.s0      f8 = f0,f0,f0
+(p9)  cmp.lt.unc    p7,p0 = GR_Arg,GR_Arg175 // 1.25 <= x < 1.75
+}
+{ .mib
+      // store sign of gamma(x) as 64-bit int
+(p11) st8           [r33] = GR_SignOfGamma
+      mov           GR_Offs = 0
+(p12) br.ret.spnt   b0 // fast exit for 2.0
+};;
+.pred.rel "mutex",p7,p8
+{ .mfi
+(p7)  mov           GR_Offs = 0xC0
+(p7)  fms.s1        FR_x = FR_w,f1,FR_LocalMin
+      nop.i         0
+}
+{ .mfb
+(p8)  mov           GR_Offs = 0x180
+(p13) fma.d.s0      f8 = f0,f0,f0
+(p13) br.ret.spnt   b0 // fast exit for 1.0
+};;
+.pred.rel "mutex",p6,p8
+{ .mfi
+      add           GR_ad_Co = GR_ad_Co,GR_Offs
+(p8)  fms.s1        FR_x = FR_w,f1,f1
+      cmp.eq        p0,p10 = r0,r0
+}
+{ .mfb
+      add           GR_ad_Ce = GR_ad_Ce,GR_Offs
+(p6)  fma.s1        FR_x = f0,f0,FR_w
+      br.cond.sptk  lgamma_common_0_2
+};;
+// branch for calculating of ln(GAMMA(x)) for -17 < x < 0
+//---------------------------------------------------------------------
+.align 32
+lgamma_negrecursion:
+{ .mfi
+      getf.d        GR_ArgXfrAsIs = FR_Xfr
+      fma.s1        FR_Xp2 = FR_2,f1,FR_NormX
+      mov           GR_Arg05 = 0x3FE
+}
+{ .mfi
+      add           GR_ad_Roots = 0x1390,GR_ad_1
+      fma.s1        FR_NormX = FR_NormX,FR_Xfr,f0
+      mov           GR_Arg075 = 0x3FE8
+};;
+{ .mfi
+      getf.sig      GR_Sig = FR_int_Ntrunc
+      fma.s1        FR_Xp3 = FR_2,f1,FR_Xp1
+      shl           GR_Arg05 = GR_Arg05,52
+}
+{ .mfi
+      mov           GR_Arg025 = 0x3FD0
+      fma.s1        FR_Xp6 = FR_5,f1,FR_Xp1
+      add           GR_ad_Co = 0x1C40,GR_ad_Data
+};;
+{ .mfi
+      add           GR_ad_Dx = 8,GR_ad_Roots
+      fma.s1        FR_Xp7 = FR_2,f1,FR_Xp5
+      shr.u         GR_ArgXfr = GR_ArgXfrAsIs,48
+}
+{ .mfi
+      add           GR_ad_Ce = 0x60,GR_ad_Co
+      fma.s1        FR_Xp8 = FR_3,f1,FR_Xp5
+      cmp.lt        p6,p0 = GR_ArgXfrAsIs,GR_Arg05
+};;
+{ .mfi
+      and           GR_RootInd = 0xF,GR_Sig
+      fma.s1        FR_Xp9 = FR_2,FR_2,FR_Xp5
+      // p10 if arg < 0.25
+      cmp.lt        p10,p14 = GR_ArgXfr,GR_Arg025
+}
+{ .mfi
+(p6)  add           GR_ad_Roots = 0x120,GR_ad_Roots
+      fma.s1        FR_Xp11 = f1,f1,FR_Xp10
+(p6)  add           GR_ad_Dx = 0x120,GR_ad_Dx
+};;
+{ .mfi
+      shladd        GR_ad_Root = GR_RootInd,4,GR_ad_Roots
+      fma.s1        FR_Xp12 = FR_2,f1,FR_Xp10
+      // p11 if 0.25 <= arg < 0.75
+      // p12 if 0.75 <= arg < 1.0
+(p14) cmp.lt.unc    p11,p12 = GR_ArgXfr,GR_Arg075
+}
+{ .mfi
+      shladd        GR_ad_Dx = GR_RootInd,4,GR_ad_Dx
+      fma.s1        FR_Xp13 = FR_3,f1,FR_Xp10
+      cmp.eq        p0,p13 = 0,GR_Sig
+};;
+{ .mfi
+      ld8           GR_Root = [GR_ad_Root]
+      fma.s1        FR_Xp14 = FR_2,FR_2,FR_Xp10
+(p12) mov           GR_Offs = 0x180
+}
+{ .mfi
+      ldfd          FR_Root = [GR_ad_Root]
+      fma.s1        FR_Xp15 = FR_5,f1,FR_Xp10
+      and           GR_Sig = 0xF,GR_Sig
+};;
+{ .mfi
+      ld8           GR_Dx = [GR_ad_Dx]
+      fma.s1        FR_Xp16 = FR_3,FR_2,FR_Xp10
+(p13) cmp.ge.unc    p6,p0 = 0xD,GR_Sig
+}
+{ .mfi
+(p11) mov           GR_Offs = 0xC0
+(p13) fma.s1        FR_NormX = FR_NormX,FR_Xp1,f0
+(p13) cmp.ge.unc    p7,p0 = 0xB,GR_Sig
+};;
+{ .mfi
+(p14) add           GR_ad_Co = GR_Offs,GR_ad_Co
+(p6)  fma.s1        FR_Xp2 = FR_Xp2,FR_Xp3,f0
+(p13) cmp.ge.unc    p8,p0 = 0x9,GR_Sig
+}
+{ .mfi
+(p14) add           GR_ad_Ce = GR_Offs,GR_ad_Ce
+(p7)  fma.s1        FR_Xp4 = FR_Xp4,FR_Xp5,f0
+(p13) cmp.ge.unc    p9,p0 = 0x7,GR_Sig
+};;
+{ .mfi
+      ldfpd         FR_B17,FR_B16 = [GR_ad_Co],16
+(p8)  fma.s1        FR_Xp6 = FR_Xp6,FR_Xp7,f0
+(p13) cmp.ge.unc    p6,p0 = 0x5,GR_Sig
+}
+{ .mfi
+      ldfpd         FR_B15,FR_B14 = [GR_ad_Ce],16
+(p9)  fma.s1        FR_Xp8 = FR_Xp8,FR_Xp9,f0
+(p13) cmp.ge.unc    p7,p0 = 0x3,GR_Sig
+};;
+{ .mfi
+      ldfpd         FR_B13,FR_B12 = [GR_ad_Co],16
+(p6)  fma.s1        FR_Xp10 = FR_Xp10,FR_Xp11,f0
+(p13) cmp.ge.unc    p8,p0 = 0x1,GR_Sig
+}
+{ .mfi
+      ldfpd         FR_B11,FR_B10 = [GR_ad_Ce],16
+(p7)  fma.s1        FR_Xp12 = FR_Xp12,FR_Xp13,f0
+(p13) cmp.eq.unc    p9,p0 = 0,GR_Sig
+};;
+{ .mfi
+      ldfpd         FR_B9,FR_B8 = [GR_ad_Co],16
+(p8)  fma.s1        FR_Xp14 = FR_Xp14,FR_Xp15,f0
+      mov           GR_Arg15 = 0xC02E // -15
+}
+{ .mfi
+      ldfpd         FR_B7,FR_B6 = [GR_ad_Ce],16
+      fcmp.eq.s1    p15,p0 = f0,FR_Xf
+(p13) cmp.ge.unc    p6,p0 = 0xC,GR_Sig
+};;
+{ .mfi
+      ldfe          FR_B5 = [GR_ad_Co],16
+(p9)  fma.s1        FR_NormX = FR_NormX,FR_Xp16,f0
+      sub           GR_Root = GR_ArgAsIs,GR_Root
+}
+{ .mfi
+      sub           GR_RootInd = 0xE,GR_RootInd
+(p11) fms.s1        FR_x = FR_Xfr,f1,FR_LocalMin // x-LocalMin
+(p13) cmp.ge.unc    p7,p0 = 0x8,GR_Sig
+};;
+.pred.rel "mutex",p10,p12
+{ .mfi
+      ldfe          FR_B4 = [GR_ad_Ce],16
+(p10) fms.s1        FR_x = FR_Xfr,f1,f0 // x
+      add           GR_Root = GR_Root,GR_Dx
+}
+{ .mfb
+      cmp.gtu       p14,p0 = 0xE,GR_RootInd
+(p12) fms.s1        FR_x = FR_Xfr,f1,f1 // x-1
+(p15) br.cond.spnt  lgamma_singularity
+};;
+{ .mfi
+      ldfe          FR_B3 = [GR_ad_Co],16
+(p6)  fma.s1        FR_Xp2 = FR_Xp2,FR_Xp4,f0
+(p14) cmp.lt.unc    p11,p0 = GR_Arg,GR_Arg15
+}
+{ .mfi
+      ldfe          FR_B2 = [GR_ad_Ce],16
+(p7)  fma.s1        FR_Xp6 = FR_Xp6,FR_Xp8,f0
+      add           GR_2xDx = GR_Dx,GR_Dx
+};;
+{ .mfi
+      ldfe          FR_B1 = [GR_ad_Co],16
+      fms.s1        FR_r = f8,f1,FR_Root
+(p13) cmp.ge.unc    p6,p0 = 0x4,GR_Sig
+}
+{ .mib
+      ldfe          FR_B0 = [GR_ad_Ce],16
+(p11) cmp.leu.unc   p10,p0 = GR_Root,GR_2xDx
+(p10) br.cond.spnt  lgamma_negroots
+};;
+{ .mfi
+      ldfpd         FR_P5,FR_P4 = [GR_ad_1],16
+(p6)  fma.s1        FR_Xp10 = FR_Xp10,FR_Xp12,f0
+      tbit.z        p14,p15 = GR_Sig,0
+}
+{ .mfi
+      ldfpd         FR_P3,FR_P2 = [GR_ad_2],16
+      fnma.d.s0     FR_T = f1,f1,f8 //      nop.f         0
+
+(p13) cmp.ge.unc    p7,p0 = 0x2,GR_Sig
+};;
+{ .mfi
+      ldfe          FR_Ln2 = [GR_ad_1],0x50
+(p7)  fma.s1        FR_NormX = FR_NormX,FR_Xp14,f0
+      mov           GR_PseudoRoot = 0xBFFBC
+}
+{ .mlx
+      add           GR_ad_2 = 0x40,GR_ad_2
+      movl          GR_2xDx = 0x00002346DC5D6389
+};;
+{ .mfi
+      ldfpd         FR_Q8,FR_Q7 = [GR_ad_1],16
+      fma.s1        FR_x2 = FR_x,FR_x,f0
+      shl           GR_PseudoRoot = GR_PseudoRoot,44
+}
+{ .mfi
+      ldfpd         FR_Q6,FR_Q5 = [GR_ad_2],16
+      fma.s1        FR_B17 = FR_B17,FR_x,FR_B16
+(p13) cmp.ge.unc    p6,p0 = 0xA,GR_Sig
+};;
+{ .mfi
+      ldfpd         FR_Q4,FR_Q3 = [GR_ad_1],16
+(p6)  fma.s1        FR_Xp2 = FR_Xp2,FR_Xp6,f0
+      sub           GR_PseudoRoot = GR_ArgAsIs,GR_PseudoRoot
+}
+{ .mfi
+      ldfpd         FR_Q2,FR_Q1 = [GR_ad_2],16
+      fma.s1        FR_B15 = FR_B15,FR_x,FR_B14
+(p13) cmp.ge.unc    p7,p0 = 0x6,GR_Sig
+};;
+{ .mfi
+      add           GR_ad_Co = 0x12F0,GR_ad_2
+      fma.s1        FR_B13 = FR_B13,FR_x,FR_B12
+      cmp.leu.unc   p10,p0 = GR_PseudoRoot,GR_2xDx
+}
+{ .mfi
+      add           GR_ad_Ce = 0x1300,GR_ad_2
+      fma.s1        FR_B11 = FR_B11,FR_x,FR_B10
+      mov           GR_ExpMask = 0x1ffff
+};;
+{ .mfi
+(p10) ldfe          FR_PR01 = [GR_ad_Co],0xF0
+      fma.s1        FR_B9 = FR_B9,FR_x,FR_B8
+      mov           GR_ExpBias = 0xFFFF
+}
+{ .mfb
+(p10) ldfe          FR_PR11 = [GR_ad_Ce],0xF0
+      fma.s1        FR_B7 = FR_B7,FR_x,FR_B6
+(p10) br.cond.spnt  lgamma_pseudoroot
+};;
+{ .mfi
+(p13) cmp.ge.unc    p6,p0 = 0xE,GR_Sig
+(p7)  fma.s1        FR_NormX = FR_NormX,FR_Xp10,f0
+      tbit.z.unc    p8,p0 = GR_Sig,0
+}
+{ .mfi
+      mov           GR_SignOfGamma = 1
+      fma.s1        FR_B5 = FR_B5,FR_x,FR_B4
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_B3 = FR_B3,FR_x,FR_B2
+(p8)  sub           GR_SignOfGamma = r0,GR_SignOfGamma
+}
+{ .mfi
+      nop.m         0
+(p14) fms.s1        FR_w = f0,f0,f1
+      nop.i         0
+};;
+.pred.rel "mutex",p9,p10
+{ .mfi
+      // store sign of gamma(x) as 32-bit int
+(p9)  st4           [r33] = GR_SignOfGamma
+      fma.s1        FR_B1 = FR_B1,FR_x,FR_B0
+      nop.i         0
+}
+{ .mfi
+      // store sign of gamma(x) as 64-bit int
+(p10) st8           [r33] = GR_SignOfGamma
+      fma.s1        FR_B17 = FR_B17,FR_x2,FR_B15
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_B13 = FR_B13,FR_x2,FR_B11
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_B9 = FR_B9,FR_x2,FR_B7
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x4 = FR_x2,FR_x2,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p6)  fma.s1        FR_NormX = FR_NormX,FR_Xp2,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_B5 = FR_B5,FR_x2,FR_B3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_B17 = FR_B17,FR_x4,FR_B13
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x8 = FR_x4,FR_x4,f0
+      nop.i         0
+};;
+.pred.rel "mutex",p14,p15
+{ .mfi
+      nop.m         0
+(p15) fms.s1        FR_w = FR_NormX,f1,f1
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p14) fnma.s1       FR_w = FR_NormX,f1,FR_w
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_B9 = FR_B9,FR_x4,FR_B5
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      frcpa.s1      FR_C,p0 = f1,FR_NormX
+      nop.i         0
+};;
+{ .mfi
+      getf.exp      GR_Exp = FR_NormX
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      getf.d        GR_ArgAsIs = FR_NormX
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_w2 = FR_w,FR_w,f0
+      nop.i         0
+}
+{ .mfi
+      and           GR_Exp = GR_Exp,GR_ExpMask
+      fma.s1        FR_Q8 = FR_Q8,FR_w,FR_Q7
+      nop.i         0
+};;
+{ .mfi
+      sub           GR_Exp = GR_Exp,GR_ExpBias
+      fma.s1        FR_B17 = FR_B17,FR_x8,FR_B9
+      extr.u        GR_Ind = GR_ArgAsIs,44,8
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Q6 = FR_Q6,FR_w,FR_Q5
+      nop.i         0
+};;
+{ .mfi
+      setf.sig      FR_int_N = GR_Exp
+      fms.s1        FR_r = FR_C,FR_NormX,f1
+      nop.i         0
+}
+{ .mfi
+      shladd        GR_ad_2 = GR_Ind,4,GR_ad_2
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      getf.exp      GR_SignExp_w = FR_w
+      fma.s1        FR_Q4 = FR_Q4,FR_w,FR_Q3
+      nop.i         0
+}
+{ .mfi
+      ldfe          FR_T = [GR_ad_2]
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      and           GR_Exp_w = GR_ExpMask, GR_SignExp_w
+      fnma.s1       FR_Q1 = FR_05,FR_w2,FR_w
+      mov           GR_fff9 = 0xfff9
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_w3 = FR_w2,FR_w,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_w4 = FR_w2,FR_w2,f0
+//    p13 <== large w __libm_lgamma
+//    p14 <== small w __libm_lgamma
+      cmp.ge        p13,p14 = GR_Exp_w,GR_fff9
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Qlo = FR_Q8,FR_w2,FR_Q6
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_r2 = FR_r,FR_r,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_B17 = FR_B17,FR_x2,FR_B1
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_P32 = FR_P3,FR_r,FR_P2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_P54 = FR_P5,FR_r,FR_P4
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p14) fma.s1        FR_Q2 = FR_Q2,FR_w3,FR_Q1
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p14) fma.s1        FR_w6 = FR_w3,FR_w3,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fcvt.xf       FR_N = FR_int_N
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_r3 = FR_r2,FR_r,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p13) fnma.s1       FR_P10 = FR_r2,FR_05,FR_r
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_P54 = FR_P54,FR_r2,FR_P32
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p14) fma.s1        FR_Qhi = FR_Q4,FR_w4,FR_Q2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p14) fnma.s1       FR_Qlo = FR_Qlo,FR_w6,FR_B17
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_TpNxLn2 = FR_N,FR_Ln2,FR_T
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_P54 = FR_P54,FR_r3,FR_P10
+      nop.i         0
+};;
+.pred.rel "mutex",p13,p14
+{ .mfi
+      nop.m         0
+(p14) fms.d.s0      f8 = FR_Qlo,f1,FR_Qhi
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_LnX = FR_TpNxLn2,f1,FR_P54
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+(p13) fms.d.s0      f8 = FR_B17,f1,FR_LnX
+      br.ret.sptk   b0
+};;
+// branch for calculating of ln(GAMMA(x)) near negative roots
+//---------------------------------------------------------------------
+.align 32
+lgamma_negroots:
+{ .mfi
+      shladd        GR_Offs = GR_RootInd,3,r0 //GR_RootInd*8
+      fma.s1        FR_r2 = FR_r,FR_r,f0
+      add           GR_ad_Co = 0x15C0,GR_ad_1//0x1590,GR_ad_1
+}
+{ .mfi
+      add           GR_ad_Ce = 0x1610,GR_ad_1//0x15E0,GR_ad_1
+      nop.f         0
+      cmp.lt        p6,p0 = GR_ArgXfrAsIs,GR_Arg05
+};;
+{ .mfi
+      add           GR_ad_Roots = 0x10A0,GR_ad_1
+      nop.f         0
+(p6)  add           GR_ad_Co = 0x820,GR_ad_Co
+}
+{ .mfi
+(p6)  add           GR_ad_Ce = 0x820,GR_ad_Ce
+      nop.f         0
+      shladd        GR_Offs = GR_RootInd,1,GR_Offs //GR_RootInd*10
+};;
+{ .mmi
+      shladd        GR_ad_Co = GR_Offs,4,GR_ad_Co
+      shladd        GR_ad_Ce = GR_Offs,4,GR_ad_Ce
+      cmp.eq        p8,p7 = r0,r0
+};;
+{ .mmi
+      ldfpd         FR_A15,FR_A14 = [GR_ad_Co],16
+      ldfpd         FR_A13,FR_A12 = [GR_ad_Ce],16
+      mov           GR_SignOfGamma = 1
+};;
+{ .mmi
+      ldfpd         FR_A11,FR_A10 = [GR_ad_Co],16
+      ldfpd         FR_A9,FR_A8   = [GR_ad_Ce],16
+(p6)  cmp.eq        p7,p8 = r0,GR_RootInd
+};;
+{ .mmi
+      ldfpd         FR_A7,FR_A6 = [GR_ad_Co],16
+      ldfpd         FR_A5,FR_A4 = [GR_ad_Ce],16
+      tbit.z        p11,p0 = GR_Sig,0
+};;
+{ .mmi
+      ldfe          FR_A3 = [GR_ad_Co],16
+      ldfe          FR_A2 = [GR_ad_Ce],16
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+};;
+{ .mmi
+      ldfe          FR_A1 = [GR_ad_Co],16
+      ldfe          FR_A0 = [GR_ad_Ce],16
+(p11) sub           GR_SignOfGamma = r0,GR_SignOfGamma
+};;
+{ .mfi
+      ldfe          FR_A00 = [GR_ad_Roots]
+      fma.s1        FR_r4 = FR_r2,FR_r2,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A15 = FR_A15,FR_r,FR_A14
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A13 = FR_A13,FR_r,FR_A12
+      nop.i         0
+};;
+.pred.rel "mutex",p9,p10
+{ .mfi
+      // store sign of gamma(x) as 32-bit int
+(p9)  st4           [r33] = GR_SignOfGamma
+      fma.s1        FR_A11 = FR_A11,FR_r,FR_A10
+      nop.i         0
+}
+{ .mfi
+      // store sign of gamma(x) as 64-bit int
+(p10) st8           [r33] = GR_SignOfGamma
+      fma.s1        FR_A9 = FR_A9,FR_r,FR_A8
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A7 = FR_A7,FR_r,FR_A6
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A5 = FR_A5,FR_r,FR_A4
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A3 = FR_A3,FR_r,FR_A2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_r8 = FR_r4,FR_r4,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A1 = FR_A1,FR_r,FR_A0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A15 = FR_A15,FR_r2,FR_A13
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A11 = FR_A11,FR_r2,FR_A9
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A7 = FR_A7,FR_r2,FR_A5
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A3 = FR_A3,FR_r2,FR_A1
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A15 = FR_A15,FR_r4,FR_A11
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A7 = FR_A7,FR_r4,FR_A3
+      nop.i         0
+};;
+.pred.rel "mutex",p7,p8
+{ .mfi
+      nop.m         0
+(p7)  fma.s1        FR_A1 = FR_A15,FR_r8,FR_A7
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p8)  fma.d.s0      f8 = FR_A15,FR_r8,FR_A7
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+(p7)  fma.d.s0      f8 = FR_A1,FR_r,FR_A00
+      br.ret.sptk   b0
+};;
+// branch for handling pseudo root on (-2;-1)
+//---------------------------------------------------------------------
+.align 32
+lgamma_pseudoroot:
+{ .mmi
+      ldfe          FR_PR21 = [GR_ad_Co],32
+      ldfe          FR_PR31 = [GR_ad_Ce],32
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+};;
+{ .mmi
+      ldfe          FR_PR00 = [GR_ad_Co],32
+      ldfe          FR_PR10 = [GR_ad_Ce],0xF0
+      mov           GR_SignOfGamma = 1
+};;
+{ .mmi
+      ldfe          FR_PR20 = [GR_ad_Co],0xF0
+      ldfe          FR_PR30 = [GR_ad_Ce]
+      tbit.z        p8,p0 = GR_Sig,0
+};;
+{ .mfi
+      ldfe          FR_PRN = [GR_ad_Co]
+      fma.s1        FR_PR01 = f8,f1,FR_PR01
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_PR11 = f8,f1,FR_PR11
+(p8)  sub           GR_SignOfGamma = r0,GR_SignOfGamma
+};;
+.pred.rel "mutex",p9,p10
+{ .mfi
+      // store sign of gamma(x) as 32-bit int
+(p9)  st4           [r33] = GR_SignOfGamma
+      fma.s1        FR_PR21 = f8,f1,FR_PR21
+      nop.i         0
+}
+{ .mfi
+      // store sign of gamma(x) as 64-bit int
+(p10) st8           [r33] = GR_SignOfGamma
+      fma.s1        FR_PR31 = f8,f1,FR_PR31
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_PR01 = f8,FR_PR01,FR_PR00
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_PR11 = f8,FR_PR11,FR_PR10
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_PR21 = f8,FR_PR21,FR_PR20
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_PR31 = f8,FR_PR31,FR_PR30
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_PR01 = FR_PR11,FR_PR01,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_PR21 = FR_PR31,FR_PR21,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_PR01 = FR_PR21,FR_PR01,f0
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+      fma.d.s0      f8 = FR_PR01,FR_PRN,f0
+      br.ret.sptk   b0
+};;
+// branch for handling +/-0, NaT, QNaN, +/-INF and denormalised numbers
+//---------------------------------------------------------------------
+.align 32
+lgamma_spec:
+{ .mfi
+      getf.exp      GR_SignExp = FR_NormX
+      fclass.m      p6,p0 = f8,0x21 // is arg +INF?
+      mov           GR_SignOfGamma = 1
+};;
+{ .mfi
+      getf.sig      GR_ArgAsIs = FR_NormX
+      fclass.m      p7,p0 = f8,0xB // is x deno?
+      // set p11 if signgum is 32-bit int
+      // set p12 if signgum is 64-bit int
+      cmp.eq        p12,p11 = 8,r34
+};;
+.pred.rel "mutex",p11,p12
+{ .mfi
+      // store sign of gamma(x) as 32-bit int
+(p11) st4           [r33] = GR_SignOfGamma
+      fclass.m      p8,p0 = f8,0x1C0 // is arg NaT or NaN?
+      dep.z         GR_Ind = GR_SignExp,8,4
+}
+{ .mib
+      // store sign of gamma(x) as 64-bit int
+(p12) st8           [r33] = GR_SignOfGamma
+      cmp.lt        p10,p0 = GR_SignExp,GR_ExpBias
+(p6)  br.ret.spnt   b0 // exit for +INF
+};;
+{ .mfi
+      and           GR_Exp = GR_SignExp,GR_ExpMask
+      fclass.m      p9,p0 = f8,0x22 // is arg -INF?
+      nop.i         0
+};;
+{ .mfi
+      add           GR_ad_Co = GR_Ind,GR_ad_Data
+(p7)  fma.s0        FR_tmp = f8,f8,f8
+      extr.u        GR_ArgAsIs = GR_ArgAsIs,11,52
+}
+{ .mfb
+      nop.m         0
+(p8)  fms.d.s0      f8 = f8,f1,f8
+(p8)  br.ret.spnt   b0 // exit for NaT and NaN
+};;
+{ .mib
+      nop.m         0
+      shr.u         GR_Arg = GR_ArgAsIs,48
+(p7)  br.cond.sptk  lgamma_common
+};;
+{ .mfb
+      nop.m         0
+(p9)  fmerge.s      f8 = f1,f8
+(p9)  br.ret.spnt   b0 // exit -INF
+};;
+// branch for handling negative integers and +/-0
+//---------------------------------------------------------------------
+.align 32
+lgamma_singularity:
+{ .mfi
+      mov           GR_ad_SignGam = r33
+      fclass.m      p6,p0 = f8, 0x6 // is x -0?
+      mov           GR_SignOfGamma = 1
+}
+{ .mfi
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+      fma.s1        FR_X = f0,f0,f8
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      frcpa.s0      f8,p0 = f1,f0
+      mov           GR_TAG = 106 // negative
+}
+{ .mib
+      nop.m         0
+(p6)  sub           GR_SignOfGamma = r0,GR_SignOfGamma
+      br.cond.sptk  lgamma_libm_err
+};;
+// overflow (x > OVERFLOV_BOUNDARY)
+//---------------------------------------------------------------------
+.align 32
+lgamma_overflow:
+{ .mfi
+      mov           GR_SignOfGamma = 1
+      nop.f         0
+      mov           r8 = 0x1FFFE
+};;
+{ .mfi
+      setf.exp      f9 = r8
+      fmerge.s      FR_X = f8,f8
+      mov           GR_TAG = 105 // overflow
+};;
+{ .mfi
+      mov           GR_ad_SignGam = r33
+      nop.f         0
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+}
+{ .mfi
+      nop.m         0
+      fma.d.s0      f8 = f9,f9,f0 // Set I,O and +INF result
+      nop.i         0
+};;
+//
+//---------------------------------------------------------------------
+.align 32
+lgamma_libm_err:
+{ .mmi
+      alloc         r32 = ar.pfs,1,4,4,0
+      mov           GR_Parameter_TAG = GR_TAG
+      nop.i         0
+};;
+.pred.rel "mutex",p9,p10
+{ .mmi
+      // store sign of gamma(x) as 32-bit int
+(p9)  st4           [GR_ad_SignGam] = GR_SignOfGamma
+      // store sign of gamma(x) as 64-bit int
+(p10) st8           [GR_ad_SignGam] = GR_SignOfGamma
+      nop.i         0
+};;
+GLOBAL_LIBM_END(__libm_lgamma)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov   GR_SAVE_PFS=ar.pfs                // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add   sp=-64,sp                         // Create new stack
+        nop.f 0
+        mov   GR_SAVE_GP=gp                     // Save gp
+};;
+{ .mmi
+        stfd [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfd [GR_Parameter_X] = FR_X                  // STORE Parameter 1
+                                                      // on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+        nop.b 0
+}
+{ .mib
+        stfd [GR_Parameter_Y] = FR_RESULT             // STORE Parameter 3
+                                                      // on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#         // Call error handling
+                                                      // function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_lgammaf.S
@@ -0,0 +1,2198 @@
+.file "libm_lgammaf.s"
+
+
+// Copyright (c) 2002 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,INCLUDING,BUT NOT
+// LIMITED TO,THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT,INDIRECT,INCIDENTAL,SPECIAL,
+// EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING,BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,DATA,OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY,WHETHER IN CONTRACT,STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE,EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code,and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 01/10/02  Initial version
+// 01/25/02  Corrected parameter store, load, and tag for __libm_error_support
+// 02/01/02  Added support of SIGN(GAMMA(x)) calculation
+// 05/20/02  Cleaned up namespace and sf0 syntax
+// 09/16/02  Improved accuracy on intervals reduced to [1;1.25]
+// 10/21/02  Now it returns SIGN(GAMMA(x))=-1 for negative zero
+// 02/10/03  Reordered header: .section, .global, .proc, .align
+// 07/22/03  Reformatted some data tables
+// 03/31/05  Reformatted delimiters between data tables
+//
+//*********************************************************************
+//
+//*********************************************************************
+//
+// Function: __libm_lgammaf(float x, int* signgam, int szsigngam)
+// computes the principle value of the logarithm of the GAMMA function
+// of x. Signum of GAMMA(x) is stored to memory starting at the address
+// specified by the signgam.
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f6-f15
+//                              f32-f97
+//
+//    General Purpose Registers:
+//      r8-r11
+//      r14-r30
+//      r32-r36
+//      r37-r40 (Used to pass arguments to error handling routine)
+//
+//    Predicate Registers:      p6-p15
+//
+//*********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    lgamma(+inf) = +inf
+//    lgamma(-inf) = +inf
+//    lgamma(+/-0) = +inf
+//    lgamma(x<0, x - integer) = +inf
+//    lgamma(SNaN) = QNaN
+//    lgamma(QNaN) = QNaN
+//
+//*********************************************************************
+//
+// Overview
+//
+// The method consists of three cases.
+//
+// If      2^13 <= x < OVERFLOW_BOUNDARY  use case lgammaf_pstirling;
+// else if 1 < x < 2^13                   use case lgammaf_regular;
+// else if -9 < x < 1                     use case lgammaf_negrecursion;
+// else if -2^13 <  x < -9                use case lgammaf_negpoly;
+// else if x < -2^13                      use case lgammaf_negstirling;
+// else if x is close to negative
+//         roots of ln(GAMMA(x))          use case lgammaf_negroots;
+//
+//
+// Case 2^13 <= x < OVERFLOW_BOUNDARY
+// ----------------------------------
+//   Here we use algorithm based on the Stirling formula:
+//     ln(GAMMA(x)) = ln(sqrt(2*Pi)) + (x-0.5)*ln(x) - x
+//
+// Case 1 < x < 2^13
+// -----------------
+//   To calculate ln(GAMMA(x)) for such arguments we use polynomial
+//   approximation on following intervals: [1.0; 1.25), [1.25; 1.5),
+//   [1.5, 1.75), [1.75; 2), [2; 4), [2^i; 2^(i+1)), i=1..8
+//
+//   Following variants of approximation and argument reduction are used:
+//    1. [1.0; 1.25)
+//       ln(GAMMA(x)) ~ (x-1.0)*P7(x)
+//
+//    2. [1.25; 1.5)
+//       ln(GAMMA(x)) ~ ln(GAMMA(x0))+(x-x0)*P8(x-x0),
+//       where x0 - point of local minimum on [1;2] rounded to nearest double
+//       precision number.
+//
+//    3. [1.5; 1.75)
+//       ln(GAMMA(x)) ~ P8(x)
+//
+//    4. [1.75; 2.0)
+//       ln(GAMMA(x)) ~ (x-2)*P7(x)
+//
+//    5. [2; 4)
+//       ln(GAMMA(x)) ~ (x-2)*P10(x)
+//
+//    6. [2^i; 2^(i+1)), i=2..8
+//       ln(GAMMA(x)) ~ P10((x-2^i)/2^i)
+//
+// Case -9 < x < 1
+// ---------------
+//   Here we use the recursive formula:
+//   ln(GAMMA(x)) = ln(GAMMA(x+1)) - ln(x)
+//
+//   Using this formula we reduce argument to base interval [1.0; 2.0]
+//
+// Case -2^13 < x < -9
+// --------------------
+//   Here we use the formula:
+//   ln(GAMMA(x)) = ln(Pi/(|x|*GAMMA(|x|)*sin(Pi*|x|))) =
+//   = -ln(|x|) - ln((GAMMA(|x|)) - ln(sin(Pi*r)/(Pi*r)) - ln(|r|)
+//   where r = x - rounded_to_nearest(x), i.e |r| <= 0.5 and
+//   ln(sin(Pi*r)/(Pi*r)) is approximated by 8-degree polynomial of r^2
+//
+// Case x < -2^13
+// --------------
+//   Here we use algorithm based on the Stirling formula:
+//   ln(GAMMA(x)) = -ln(sqrt(2*Pi)) + (|x|-0.5)ln(x) - |x| -
+//   - ln(sin(Pi*r)/(Pi*r)) - ln(|r|)
+//   where r = x - rounded_to_nearest(x).
+//
+// Neighbourhoods of negative roots
+// --------------------------------
+//   Here we use polynomial approximation
+//   ln(GAMMA(x-x0)) = ln(GAMMA(x0)) + (x-x0)*P14(x-x0),
+//   where x0 is a root of ln(GAMMA(x)) rounded to nearest double
+//   precision number.
+//
+//
+// Calculation of logarithm
+// ------------------------
+//   Consider  x = 2^N * xf so
+//   ln(x) = ln(frcpa(x)*x/frcpa(x))
+//         = ln(1/frcpa(x)) + ln(frcpa(x)*x)
+//
+//   frcpa(x) = 2^(-N) * frcpa(xf)
+//
+//   ln(1/frcpa(x)) = -ln(2^(-N)) - ln(frcpa(xf))
+//                  = N*ln(2) - ln(frcpa(xf))
+//                  = N*ln(2) + ln(1/frcpa(xf))
+//
+//   ln(x) = ln(1/frcpa(x)) + ln(frcpa(x)*x) =
+//         = N*ln(2) + ln(1/frcpa(xf)) + ln(frcpa(x)*x)
+//         = N*ln(2) + T + ln(frcpa(x)*x)
+//
+//   Let r = 1 - frcpa(x)*x, note that r is quite small by
+//   absolute value so
+//
+//   ln(x) = N*ln(2) + T + ln(1+r) ~ N*ln(2) + T + Series(r),
+//   where T - is precomputed tabular value,
+//   Series(r) = (P3*r + P2)*r^2 + (P1*r + 1)
+//
+//*********************************************************************
+
+GR_TAG                 = r8
+GR_ad_Data             = r8
+GR_ad_Co               = r9
+GR_ad_SignGam          = r10
+GR_ad_Ce               = r10
+GR_SignExp             = r11
+
+GR_ad_C650             = r14
+GR_ad_RootCo           = r14
+GR_ad_C0               = r15
+GR_Dx                  = r15
+GR_Ind                 = r16
+GR_Offs                = r17
+GR_IntNum              = r17
+GR_ExpBias             = r18
+GR_ExpMask             = r19
+GR_Ind4T               = r20
+GR_RootInd             = r20
+GR_Sig                 = r21
+GR_Exp                 = r22
+GR_PureExp             = r23
+GR_ad_C43              = r24
+GR_StirlBound          = r25
+GR_ad_T                = r25
+GR_IndX8               = r25
+GR_Neg2                = r25
+GR_2xDx                = r25
+GR_SingBound           = r26
+GR_IndX2               = r26
+GR_Neg4                = r26
+GR_ad_RootCe           = r26
+GR_Arg                 = r27
+GR_ExpOf2              = r28
+GR_fff7                = r28
+GR_Root                = r28
+GR_ReqBound            = r28
+GR_N                   = r29
+GR_ad_Root             = r30
+GR_ad_OvfBound         = r30
+GR_SignOfGamma         = r31
+
+GR_SAVE_B0             = r33
+GR_SAVE_PFS            = r34
+GR_SAVE_GP             = r35
+GR_SAVE_SP             = r36
+
+GR_Parameter_X         = r37
+GR_Parameter_Y         = r38
+GR_Parameter_RESULT    = r39
+GR_Parameter_TAG       = r40
+
+//*********************************************************************
+
+FR_X                   = f10
+FR_Y                   = f1 // lgammaf is single argument function
+FR_RESULT              = f8
+
+FR_x                   = f6
+FR_x2                  = f7
+
+FR_x3                  = f9
+FR_x4                  = f10
+FR_xm2                 = f11
+FR_w                   = f11
+FR_w2                  = f12
+FR_Q32                 = f13
+FR_Q10                 = f14
+FR_InvX                = f15
+
+FR_NormX               = f32
+
+FR_A0                  = f33
+FR_A1                  = f34
+FR_A2                  = f35
+FR_A3                  = f36
+FR_A4                  = f37
+FR_A5                  = f38
+FR_A6                  = f39
+FR_A7                  = f40
+FR_A8                  = f41
+FR_A9                  = f42
+FR_A10                 = f43
+
+FR_int_N               = f44
+FR_P3                  = f45
+FR_P2                  = f46
+FR_P1                  = f47
+FR_LocalMin            = f48
+FR_Ln2                 = f49
+FR_05                  = f50
+FR_LnSqrt2Pi           = f51
+FR_3                   = f52
+FR_r                   = f53
+FR_r2                  = f54
+FR_T                   = f55
+FR_N                   = f56
+FR_xm05                = f57
+FR_int_Ln              = f58
+FR_P32                 = f59
+FR_P10                 = f60
+
+FR_Xf                  = f61
+FR_InvXf               = f62
+FR_rf                  = f63
+FR_rf2                 = f64
+FR_Tf                  = f65
+FR_Nf                  = f66
+FR_xm05f               = f67
+FR_P32f                = f68
+FR_P10f                = f69
+FR_Lnf                 = f70
+FR_Xf2                 = f71
+FR_Xf4                 = f72
+FR_Xf8                 = f73
+FR_Ln                  = f74
+FR_xx                  = f75
+FR_Root                = f75
+FR_Req                 = f76
+FR_1pXf                = f77
+
+FR_S16                 = f78
+FR_R3                  = f78
+FR_S14                 = f79
+FR_R2                  = f79
+FR_S12                 = f80
+FR_R1                  = f80
+FR_S10                 = f81
+FR_R0                  = f81
+FR_S8                  = f82
+FR_rx                  = f82
+FR_S6                  = f83
+FR_rx2                 = f84
+FR_S4                  = f84
+FR_S2                  = f85
+
+FR_Xp1                 = f86
+FR_Xp2                 = f87
+FR_Xp3                 = f88
+FR_Xp4                 = f89
+FR_Xp5                 = f90
+FR_Xp6                 = f91
+FR_Xp7                 = f92
+FR_Xp8                 = f93
+FR_OverflowBound       = f93
+
+FR_2                   = f94
+FR_tmp                 = f95
+FR_int_Ntrunc          = f96
+FR_Ntrunc              = f97
+
+//*********************************************************************
+
+RODATA
+.align 32
+LOCAL_OBJECT_START(lgammaf_data)
+log_table_1:
+data8 0xbfd0001008f39d59 // P3
+data8 0x3fd5556073e0c45a // P2
+data8 0x3fe62e42fefa39ef // ln(2)
+data8 0x3fe0000000000000 // 0.5
+//
+data8 0x3F60040155D5889E //ln(1/frcpa(1+   0/256)
+data8 0x3F78121214586B54 //ln(1/frcpa(1+   1/256)
+data8 0x3F841929F96832F0 //ln(1/frcpa(1+   2/256)
+data8 0x3F8C317384C75F06 //ln(1/frcpa(1+   3/256)
+data8 0x3F91A6B91AC73386 //ln(1/frcpa(1+   4/256)
+data8 0x3F95BA9A5D9AC039 //ln(1/frcpa(1+   5/256)
+data8 0x3F99D2A8074325F4 //ln(1/frcpa(1+   6/256)
+data8 0x3F9D6B2725979802 //ln(1/frcpa(1+   7/256)
+data8 0x3FA0C58FA19DFAAA //ln(1/frcpa(1+   8/256)
+data8 0x3FA2954C78CBCE1B //ln(1/frcpa(1+   9/256)
+data8 0x3FA4A94D2DA96C56 //ln(1/frcpa(1+  10/256)
+data8 0x3FA67C94F2D4BB58 //ln(1/frcpa(1+  11/256)
+data8 0x3FA85188B630F068 //ln(1/frcpa(1+  12/256)
+data8 0x3FAA6B8ABE73AF4C //ln(1/frcpa(1+  13/256)
+data8 0x3FAC441E06F72A9E //ln(1/frcpa(1+  14/256)
+data8 0x3FAE1E6713606D07 //ln(1/frcpa(1+  15/256)
+data8 0x3FAFFA6911AB9301 //ln(1/frcpa(1+  16/256)
+data8 0x3FB0EC139C5DA601 //ln(1/frcpa(1+  17/256)
+data8 0x3FB1DBD2643D190B //ln(1/frcpa(1+  18/256)
+data8 0x3FB2CC7284FE5F1C //ln(1/frcpa(1+  19/256)
+data8 0x3FB3BDF5A7D1EE64 //ln(1/frcpa(1+  20/256)
+data8 0x3FB4B05D7AA012E0 //ln(1/frcpa(1+  21/256)
+data8 0x3FB580DB7CEB5702 //ln(1/frcpa(1+  22/256)
+data8 0x3FB674F089365A7A //ln(1/frcpa(1+  23/256)
+data8 0x3FB769EF2C6B568D //ln(1/frcpa(1+  24/256)
+data8 0x3FB85FD927506A48 //ln(1/frcpa(1+  25/256)
+data8 0x3FB9335E5D594989 //ln(1/frcpa(1+  26/256)
+data8 0x3FBA2B0220C8E5F5 //ln(1/frcpa(1+  27/256)
+data8 0x3FBB0004AC1A86AC //ln(1/frcpa(1+  28/256)
+data8 0x3FBBF968769FCA11 //ln(1/frcpa(1+  29/256)
+data8 0x3FBCCFEDBFEE13A8 //ln(1/frcpa(1+  30/256)
+data8 0x3FBDA727638446A2 //ln(1/frcpa(1+  31/256)
+data8 0x3FBEA3257FE10F7A //ln(1/frcpa(1+  32/256)
+data8 0x3FBF7BE9FEDBFDE6 //ln(1/frcpa(1+  33/256)
+data8 0x3FC02AB352FF25F4 //ln(1/frcpa(1+  34/256)
+data8 0x3FC097CE579D204D //ln(1/frcpa(1+  35/256)
+data8 0x3FC1178E8227E47C //ln(1/frcpa(1+  36/256)
+data8 0x3FC185747DBECF34 //ln(1/frcpa(1+  37/256)
+data8 0x3FC1F3B925F25D41 //ln(1/frcpa(1+  38/256)
+data8 0x3FC2625D1E6DDF57 //ln(1/frcpa(1+  39/256)
+data8 0x3FC2D1610C86813A //ln(1/frcpa(1+  40/256)
+data8 0x3FC340C59741142E //ln(1/frcpa(1+  41/256)
+data8 0x3FC3B08B6757F2A9 //ln(1/frcpa(1+  42/256)
+data8 0x3FC40DFB08378003 //ln(1/frcpa(1+  43/256)
+data8 0x3FC47E74E8CA5F7C //ln(1/frcpa(1+  44/256)
+data8 0x3FC4EF51F6466DE4 //ln(1/frcpa(1+  45/256)
+data8 0x3FC56092E02BA516 //ln(1/frcpa(1+  46/256)
+data8 0x3FC5D23857CD74D5 //ln(1/frcpa(1+  47/256)
+data8 0x3FC6313A37335D76 //ln(1/frcpa(1+  48/256)
+data8 0x3FC6A399DABBD383 //ln(1/frcpa(1+  49/256)
+data8 0x3FC70337DD3CE41B //ln(1/frcpa(1+  50/256)
+data8 0x3FC77654128F6127 //ln(1/frcpa(1+  51/256)
+data8 0x3FC7E9D82A0B022D //ln(1/frcpa(1+  52/256)
+data8 0x3FC84A6B759F512F //ln(1/frcpa(1+  53/256)
+data8 0x3FC8AB47D5F5A310 //ln(1/frcpa(1+  54/256)
+data8 0x3FC91FE49096581B //ln(1/frcpa(1+  55/256)
+data8 0x3FC981634011AA75 //ln(1/frcpa(1+  56/256)
+data8 0x3FC9F6C407089664 //ln(1/frcpa(1+  57/256)
+data8 0x3FCA58E729348F43 //ln(1/frcpa(1+  58/256)
+data8 0x3FCABB55C31693AD //ln(1/frcpa(1+  59/256)
+data8 0x3FCB1E104919EFD0 //ln(1/frcpa(1+  60/256)
+data8 0x3FCB94EE93E367CB //ln(1/frcpa(1+  61/256)
+data8 0x3FCBF851C067555F //ln(1/frcpa(1+  62/256)
+data8 0x3FCC5C0254BF23A6 //ln(1/frcpa(1+  63/256)
+data8 0x3FCCC000C9DB3C52 //ln(1/frcpa(1+  64/256)
+data8 0x3FCD244D99C85674 //ln(1/frcpa(1+  65/256)
+data8 0x3FCD88E93FB2F450 //ln(1/frcpa(1+  66/256)
+data8 0x3FCDEDD437EAEF01 //ln(1/frcpa(1+  67/256)
+data8 0x3FCE530EFFE71012 //ln(1/frcpa(1+  68/256)
+data8 0x3FCEB89A1648B971 //ln(1/frcpa(1+  69/256)
+data8 0x3FCF1E75FADF9BDE //ln(1/frcpa(1+  70/256)
+data8 0x3FCF84A32EAD7C35 //ln(1/frcpa(1+  71/256)
+data8 0x3FCFEB2233EA07CD //ln(1/frcpa(1+  72/256)
+data8 0x3FD028F9C7035C1C //ln(1/frcpa(1+  73/256)
+data8 0x3FD05C8BE0D9635A //ln(1/frcpa(1+  74/256)
+data8 0x3FD085EB8F8AE797 //ln(1/frcpa(1+  75/256)
+data8 0x3FD0B9C8E32D1911 //ln(1/frcpa(1+  76/256)
+data8 0x3FD0EDD060B78081 //ln(1/frcpa(1+  77/256)
+data8 0x3FD122024CF0063F //ln(1/frcpa(1+  78/256)
+data8 0x3FD14BE2927AECD4 //ln(1/frcpa(1+  79/256)
+data8 0x3FD180618EF18ADF //ln(1/frcpa(1+  80/256)
+data8 0x3FD1B50BBE2FC63B //ln(1/frcpa(1+  81/256)
+data8 0x3FD1DF4CC7CF242D //ln(1/frcpa(1+  82/256)
+data8 0x3FD214456D0EB8D4 //ln(1/frcpa(1+  83/256)
+data8 0x3FD23EC5991EBA49 //ln(1/frcpa(1+  84/256)
+data8 0x3FD2740D9F870AFB //ln(1/frcpa(1+  85/256)
+data8 0x3FD29ECDABCDFA04 //ln(1/frcpa(1+  86/256)
+data8 0x3FD2D46602ADCCEE //ln(1/frcpa(1+  87/256)
+data8 0x3FD2FF66B04EA9D4 //ln(1/frcpa(1+  88/256)
+data8 0x3FD335504B355A37 //ln(1/frcpa(1+  89/256)
+data8 0x3FD360925EC44F5D //ln(1/frcpa(1+  90/256)
+data8 0x3FD38BF1C3337E75 //ln(1/frcpa(1+  91/256)
+data8 0x3FD3C25277333184 //ln(1/frcpa(1+  92/256)
+data8 0x3FD3EDF463C1683E //ln(1/frcpa(1+  93/256)
+data8 0x3FD419B423D5E8C7 //ln(1/frcpa(1+  94/256)
+data8 0x3FD44591E0539F49 //ln(1/frcpa(1+  95/256)
+data8 0x3FD47C9175B6F0AD //ln(1/frcpa(1+  96/256)
+data8 0x3FD4A8B341552B09 //ln(1/frcpa(1+  97/256)
+data8 0x3FD4D4F3908901A0 //ln(1/frcpa(1+  98/256)
+data8 0x3FD501528DA1F968 //ln(1/frcpa(1+  99/256)
+data8 0x3FD52DD06347D4F6 //ln(1/frcpa(1+ 100/256)
+data8 0x3FD55A6D3C7B8A8A //ln(1/frcpa(1+ 101/256)
+data8 0x3FD5925D2B112A59 //ln(1/frcpa(1+ 102/256)
+data8 0x3FD5BF406B543DB2 //ln(1/frcpa(1+ 103/256)
+data8 0x3FD5EC433D5C35AE //ln(1/frcpa(1+ 104/256)
+data8 0x3FD61965CDB02C1F //ln(1/frcpa(1+ 105/256)
+data8 0x3FD646A84935B2A2 //ln(1/frcpa(1+ 106/256)
+data8 0x3FD6740ADD31DE94 //ln(1/frcpa(1+ 107/256)
+data8 0x3FD6A18DB74A58C5 //ln(1/frcpa(1+ 108/256)
+data8 0x3FD6CF31058670EC //ln(1/frcpa(1+ 109/256)
+data8 0x3FD6F180E852F0BA //ln(1/frcpa(1+ 110/256)
+data8 0x3FD71F5D71B894F0 //ln(1/frcpa(1+ 111/256)
+data8 0x3FD74D5AEFD66D5C //ln(1/frcpa(1+ 112/256)
+data8 0x3FD77B79922BD37E //ln(1/frcpa(1+ 113/256)
+data8 0x3FD7A9B9889F19E2 //ln(1/frcpa(1+ 114/256)
+data8 0x3FD7D81B037EB6A6 //ln(1/frcpa(1+ 115/256)
+data8 0x3FD8069E33827231 //ln(1/frcpa(1+ 116/256)
+data8 0x3FD82996D3EF8BCB //ln(1/frcpa(1+ 117/256)
+data8 0x3FD85855776DCBFB //ln(1/frcpa(1+ 118/256)
+data8 0x3FD8873658327CCF //ln(1/frcpa(1+ 119/256)
+data8 0x3FD8AA75973AB8CF //ln(1/frcpa(1+ 120/256)
+data8 0x3FD8D992DC8824E5 //ln(1/frcpa(1+ 121/256)
+data8 0x3FD908D2EA7D9512 //ln(1/frcpa(1+ 122/256)
+data8 0x3FD92C59E79C0E56 //ln(1/frcpa(1+ 123/256)
+data8 0x3FD95BD750EE3ED3 //ln(1/frcpa(1+ 124/256)
+data8 0x3FD98B7811A3EE5B //ln(1/frcpa(1+ 125/256)
+data8 0x3FD9AF47F33D406C //ln(1/frcpa(1+ 126/256)
+data8 0x3FD9DF270C1914A8 //ln(1/frcpa(1+ 127/256)
+data8 0x3FDA0325ED14FDA4 //ln(1/frcpa(1+ 128/256)
+data8 0x3FDA33440224FA79 //ln(1/frcpa(1+ 129/256)
+data8 0x3FDA57725E80C383 //ln(1/frcpa(1+ 130/256)
+data8 0x3FDA87D0165DD199 //ln(1/frcpa(1+ 131/256)
+data8 0x3FDAAC2E6C03F896 //ln(1/frcpa(1+ 132/256)
+data8 0x3FDADCCC6FDF6A81 //ln(1/frcpa(1+ 133/256)
+data8 0x3FDB015B3EB1E790 //ln(1/frcpa(1+ 134/256)
+data8 0x3FDB323A3A635948 //ln(1/frcpa(1+ 135/256)
+data8 0x3FDB56FA04462909 //ln(1/frcpa(1+ 136/256)
+data8 0x3FDB881AA659BC93 //ln(1/frcpa(1+ 137/256)
+data8 0x3FDBAD0BEF3DB165 //ln(1/frcpa(1+ 138/256)
+data8 0x3FDBD21297781C2F //ln(1/frcpa(1+ 139/256)
+data8 0x3FDC039236F08819 //ln(1/frcpa(1+ 140/256)
+data8 0x3FDC28CB1E4D32FD //ln(1/frcpa(1+ 141/256)
+data8 0x3FDC4E19B84723C2 //ln(1/frcpa(1+ 142/256)
+data8 0x3FDC7FF9C74554C9 //ln(1/frcpa(1+ 143/256)
+data8 0x3FDCA57B64E9DB05 //ln(1/frcpa(1+ 144/256)
+data8 0x3FDCCB130A5CEBB0 //ln(1/frcpa(1+ 145/256)
+data8 0x3FDCF0C0D18F326F //ln(1/frcpa(1+ 146/256)
+data8 0x3FDD232075B5A201 //ln(1/frcpa(1+ 147/256)
+data8 0x3FDD490246DEFA6B //ln(1/frcpa(1+ 148/256)
+data8 0x3FDD6EFA918D25CD //ln(1/frcpa(1+ 149/256)
+data8 0x3FDD9509707AE52F //ln(1/frcpa(1+ 150/256)
+data8 0x3FDDBB2EFE92C554 //ln(1/frcpa(1+ 151/256)
+data8 0x3FDDEE2F3445E4AF //ln(1/frcpa(1+ 152/256)
+data8 0x3FDE148A1A2726CE //ln(1/frcpa(1+ 153/256)
+data8 0x3FDE3AFC0A49FF40 //ln(1/frcpa(1+ 154/256)
+data8 0x3FDE6185206D516E //ln(1/frcpa(1+ 155/256)
+data8 0x3FDE882578823D52 //ln(1/frcpa(1+ 156/256)
+data8 0x3FDEAEDD2EAC990C //ln(1/frcpa(1+ 157/256)
+data8 0x3FDED5AC5F436BE3 //ln(1/frcpa(1+ 158/256)
+data8 0x3FDEFC9326D16AB9 //ln(1/frcpa(1+ 159/256)
+data8 0x3FDF2391A2157600 //ln(1/frcpa(1+ 160/256)
+data8 0x3FDF4AA7EE03192D //ln(1/frcpa(1+ 161/256)
+data8 0x3FDF71D627C30BB0 //ln(1/frcpa(1+ 162/256)
+data8 0x3FDF991C6CB3B379 //ln(1/frcpa(1+ 163/256)
+data8 0x3FDFC07ADA69A910 //ln(1/frcpa(1+ 164/256)
+data8 0x3FDFE7F18EB03D3E //ln(1/frcpa(1+ 165/256)
+data8 0x3FE007C053C5002E //ln(1/frcpa(1+ 166/256)
+data8 0x3FE01B942198A5A1 //ln(1/frcpa(1+ 167/256)
+data8 0x3FE02F74400C64EB //ln(1/frcpa(1+ 168/256)
+data8 0x3FE04360BE7603AD //ln(1/frcpa(1+ 169/256)
+data8 0x3FE05759AC47FE34 //ln(1/frcpa(1+ 170/256)
+data8 0x3FE06B5F1911CF52 //ln(1/frcpa(1+ 171/256)
+data8 0x3FE078BF0533C568 //ln(1/frcpa(1+ 172/256)
+data8 0x3FE08CD9687E7B0E //ln(1/frcpa(1+ 173/256)
+data8 0x3FE0A10074CF9019 //ln(1/frcpa(1+ 174/256)
+data8 0x3FE0B5343A234477 //ln(1/frcpa(1+ 175/256)
+data8 0x3FE0C974C89431CE //ln(1/frcpa(1+ 176/256)
+data8 0x3FE0DDC2305B9886 //ln(1/frcpa(1+ 177/256)
+data8 0x3FE0EB524BAFC918 //ln(1/frcpa(1+ 178/256)
+data8 0x3FE0FFB54213A476 //ln(1/frcpa(1+ 179/256)
+data8 0x3FE114253DA97D9F //ln(1/frcpa(1+ 180/256)
+data8 0x3FE128A24F1D9AFF //ln(1/frcpa(1+ 181/256)
+data8 0x3FE1365252BF0865 //ln(1/frcpa(1+ 182/256)
+data8 0x3FE14AE558B4A92D //ln(1/frcpa(1+ 183/256)
+data8 0x3FE15F85A19C765B //ln(1/frcpa(1+ 184/256)
+data8 0x3FE16D4D38C119FA //ln(1/frcpa(1+ 185/256)
+data8 0x3FE18203C20DD133 //ln(1/frcpa(1+ 186/256)
+data8 0x3FE196C7BC4B1F3B //ln(1/frcpa(1+ 187/256)
+data8 0x3FE1A4A738B7A33C //ln(1/frcpa(1+ 188/256)
+data8 0x3FE1B981C0C9653D //ln(1/frcpa(1+ 189/256)
+data8 0x3FE1CE69E8BB106B //ln(1/frcpa(1+ 190/256)
+data8 0x3FE1DC619DE06944 //ln(1/frcpa(1+ 191/256)
+data8 0x3FE1F160A2AD0DA4 //ln(1/frcpa(1+ 192/256)
+data8 0x3FE2066D7740737E //ln(1/frcpa(1+ 193/256)
+data8 0x3FE2147DBA47A394 //ln(1/frcpa(1+ 194/256)
+data8 0x3FE229A1BC5EBAC3 //ln(1/frcpa(1+ 195/256)
+data8 0x3FE237C1841A502E //ln(1/frcpa(1+ 196/256)
+data8 0x3FE24CFCE6F80D9A //ln(1/frcpa(1+ 197/256)
+data8 0x3FE25B2C55CD5762 //ln(1/frcpa(1+ 198/256)
+data8 0x3FE2707F4D5F7C41 //ln(1/frcpa(1+ 199/256)
+data8 0x3FE285E0842CA384 //ln(1/frcpa(1+ 200/256)
+data8 0x3FE294294708B773 //ln(1/frcpa(1+ 201/256)
+data8 0x3FE2A9A2670AFF0C //ln(1/frcpa(1+ 202/256)
+data8 0x3FE2B7FB2C8D1CC1 //ln(1/frcpa(1+ 203/256)
+data8 0x3FE2C65A6395F5F5 //ln(1/frcpa(1+ 204/256)
+data8 0x3FE2DBF557B0DF43 //ln(1/frcpa(1+ 205/256)
+data8 0x3FE2EA64C3F97655 //ln(1/frcpa(1+ 206/256)
+data8 0x3FE3001823684D73 //ln(1/frcpa(1+ 207/256)
+data8 0x3FE30E97E9A8B5CD //ln(1/frcpa(1+ 208/256)
+data8 0x3FE32463EBDD34EA //ln(1/frcpa(1+ 209/256)
+data8 0x3FE332F4314AD796 //ln(1/frcpa(1+ 210/256)
+data8 0x3FE348D90E7464D0 //ln(1/frcpa(1+ 211/256)
+data8 0x3FE35779F8C43D6E //ln(1/frcpa(1+ 212/256)
+data8 0x3FE36621961A6A99 //ln(1/frcpa(1+ 213/256)
+data8 0x3FE37C299F3C366A //ln(1/frcpa(1+ 214/256)
+data8 0x3FE38AE2171976E7 //ln(1/frcpa(1+ 215/256)
+data8 0x3FE399A157A603E7 //ln(1/frcpa(1+ 216/256)
+data8 0x3FE3AFCCFE77B9D1 //ln(1/frcpa(1+ 217/256)
+data8 0x3FE3BE9D503533B5 //ln(1/frcpa(1+ 218/256)
+data8 0x3FE3CD7480B4A8A3 //ln(1/frcpa(1+ 219/256)
+data8 0x3FE3E3C43918F76C //ln(1/frcpa(1+ 220/256)
+data8 0x3FE3F2ACB27ED6C7 //ln(1/frcpa(1+ 221/256)
+data8 0x3FE4019C2125CA93 //ln(1/frcpa(1+ 222/256)
+data8 0x3FE4181061389722 //ln(1/frcpa(1+ 223/256)
+data8 0x3FE42711518DF545 //ln(1/frcpa(1+ 224/256)
+data8 0x3FE436194E12B6BF //ln(1/frcpa(1+ 225/256)
+data8 0x3FE445285D68EA69 //ln(1/frcpa(1+ 226/256)
+data8 0x3FE45BCC464C893A //ln(1/frcpa(1+ 227/256)
+data8 0x3FE46AED21F117FC //ln(1/frcpa(1+ 228/256)
+data8 0x3FE47A1527E8A2D3 //ln(1/frcpa(1+ 229/256)
+data8 0x3FE489445EFFFCCC //ln(1/frcpa(1+ 230/256)
+data8 0x3FE4A018BCB69835 //ln(1/frcpa(1+ 231/256)
+data8 0x3FE4AF5A0C9D65D7 //ln(1/frcpa(1+ 232/256)
+data8 0x3FE4BEA2A5BDBE87 //ln(1/frcpa(1+ 233/256)
+data8 0x3FE4CDF28F10AC46 //ln(1/frcpa(1+ 234/256)
+data8 0x3FE4DD49CF994058 //ln(1/frcpa(1+ 235/256)
+data8 0x3FE4ECA86E64A684 //ln(1/frcpa(1+ 236/256)
+data8 0x3FE503C43CD8EB68 //ln(1/frcpa(1+ 237/256)
+data8 0x3FE513356667FC57 //ln(1/frcpa(1+ 238/256)
+data8 0x3FE522AE0738A3D8 //ln(1/frcpa(1+ 239/256)
+data8 0x3FE5322E26867857 //ln(1/frcpa(1+ 240/256)
+data8 0x3FE541B5CB979809 //ln(1/frcpa(1+ 241/256)
+data8 0x3FE55144FDBCBD62 //ln(1/frcpa(1+ 242/256)
+data8 0x3FE560DBC45153C7 //ln(1/frcpa(1+ 243/256)
+data8 0x3FE5707A26BB8C66 //ln(1/frcpa(1+ 244/256)
+data8 0x3FE587F60ED5B900 //ln(1/frcpa(1+ 245/256)
+data8 0x3FE597A7977C8F31 //ln(1/frcpa(1+ 246/256)
+data8 0x3FE5A760D634BB8B //ln(1/frcpa(1+ 247/256)
+data8 0x3FE5B721D295F10F //ln(1/frcpa(1+ 248/256)
+data8 0x3FE5C6EA94431EF9 //ln(1/frcpa(1+ 249/256)
+data8 0x3FE5D6BB22EA86F6 //ln(1/frcpa(1+ 250/256)
+data8 0x3FE5E6938645D390 //ln(1/frcpa(1+ 251/256)
+data8 0x3FE5F673C61A2ED2 //ln(1/frcpa(1+ 252/256)
+data8 0x3FE6065BEA385926 //ln(1/frcpa(1+ 253/256)
+data8 0x3FE6164BFA7CC06B //ln(1/frcpa(1+ 254/256)
+data8 0x3FE62643FECF9743 //ln(1/frcpa(1+ 255/256)
+//
+// [2;4)
+data8 0xBEB2CC7A38B9355F,0x3F035F2D1833BF4C // A10,A9
+data8 0xBFF51BAA7FD27785,0x3FFC9D5D5B6CDEFF // A2,A1
+data8 0xBF421676F9CB46C7,0x3F7437F2FA1436C6 // A8,A7
+data8 0xBFD7A7041DE592FE,0x3FE9F107FEE8BD29 // A4,A3
+// [4;8)
+data8 0x3F6BBBD68451C0CD,0xBF966EC3272A16F7 // A10,A9
+data8 0x40022A24A39AD769,0x4014190EDF49C8C5 // A2,A1
+data8 0x3FB130FD016EE241,0xBFC151B46E635248 // A8,A7
+data8 0x3FDE8F611965B5FE,0xBFEB5110EB265E3D // A4,A3
+// [8;16)
+data8 0x3F736EF93508626A,0xBF9FE5DBADF58AF1 // A10,A9
+data8 0x40110A9FC5192058,0x40302008A6F96B29 // A2,A1
+data8 0x3FB8E74E0CE1E4B5,0xBFC9B5DA78873656 // A8,A7
+data8 0x3FE99D0DF10022DC,0xBFF829C0388F9484 // A4,A3
+// [16;32)
+data8 0x3F7FFF9D6D7E9269,0xBFAA780A249AEDB1 // A10,A9
+data8 0x402082A807AEA080,0x4045ED9868408013 // A2,A1
+data8 0x3FC4E1E54C2F99B7,0xBFD5DE2D6FFF1490 // A8,A7
+data8 0x3FF75FC89584AE87,0xC006B4BADD886CAE // A4,A3
+// [32;64)
+data8 0x3F8CE54375841A5F,0xBFB801ABCFFA1BE2 // A10,A9
+data8 0x403040A8B1815BDA,0x405B99A917D24B7A // A2,A1
+data8 0x3FD30CAB81BFFA03,0xBFE41AEF61ECF48B // A8,A7
+data8 0x400650CC136BEC43,0xC016022046E8292B // A4,A3
+// [64;128)
+data8 0x3F9B69BD22CAA8B8,0xBFC6D48875B7A213 // A10,A9
+data8 0x40402028CCAA2F6D,0x40709AACEB3CBE0F // A2,A1
+data8 0x3FE22C6A5924761E,0xBFF342F5F224523D // A8,A7
+data8 0x4015CD405CCA331F,0xC025AAD10482C769 // A4,A3
+// [128;256)
+data8 0x3FAAAD9CD0E40D06,0xBFD63FC8505D80CB // A10,A9
+data8 0x40501008D56C2648,0x408364794B0F4376 // A2,A1
+data8 0x3FF1BE0126E00284,0xC002D8E3F6F7F7CA // A8,A7
+data8 0x40258C757E95D860,0xC0357FA8FD398011 // A4,A3
+// [256;512)
+data8 0x3FBA4DAC59D49FEB,0xBFE5F476D1C43A77 // A10,A9
+data8 0x40600800D890C7C6,0x40962C42AAEC8EF0 // A2,A1
+data8 0x40018680ECF19B89,0xC012A3EB96FB7BA4 // A8,A7
+data8 0x40356C4CDD3B60F9,0xC0456A34BF18F440 // A4,A3
+// [512;1024)
+data8 0x3FCA1B54F6225A5A,0xBFF5CD67BA10E048 // A10,A9
+data8 0x407003FED94C58C2,0x40A8F30B4ACBCD22 // A2,A1
+data8 0x40116A135EB66D8C,0xC022891B1CED527E // A8,A7
+data8 0x40455C4617FDD8BC,0xC0555F82729E59C4 // A4,A3
+// [1024;2048)
+data8 0x3FD9FFF9095C6EC9,0xC005B88CB25D76C9 // A10,A9
+data8 0x408001FE58FA734D,0x40BBB953BAABB0F3 // A2,A1
+data8 0x40215B2F9FEB5D87,0xC0327B539DEA5058 // A8,A7
+data8 0x40555444B3E8D64D,0xC0655A2B26F9FC8A // A4,A3
+// [2048;4096)
+data8 0x3FE9F065A1C3D6B1,0xC015ACF6FAE8D78D // A10,A9
+data8 0x409000FE383DD2B7,0x40CE7F5C1E8BCB8B // A2,A1
+data8 0x40315324E5DB2EBE,0xC04274194EF70D18 // A8,A7
+data8 0x4065504353FF2207,0xC075577FE1BFE7B6 // A4,A3
+// [4096;8192)
+data8 0x3FF9E6FBC6B1C70D,0xC025A62DAF76F85D // A10,A9
+data8 0x40A0007E2F61EBE8,0x40E0A2A23FB5F6C3 // A2,A1
+data8 0x40414E9BC0A0141A,0xC0527030F2B69D43 // A8,A7
+data8 0x40754E417717B45B,0xC085562A447258E5 // A4,A3
+//
+data8 0xbfdffffffffaea15 // P1
+data8 0x3FDD8B618D5AF8FE // point of local minimum on [1;2]
+data8 0x3FED67F1C864BEB5 // ln(sqrt(2*Pi))
+data8 0x4008000000000000 // 3.0
+//
+data8 0xBF9E1C289FB224AB,0x3FBF7422445C9460 // A6,A5
+data8 0xBFF01E76D66F8D8A // A0
+data8 0xBFE2788CFC6F91DA // A1 [1.0;1.25)
+data8 0x3FCB8CC69000EB5C,0xBFD41997A0C2C641 // A6,A5
+data8 0x3FFCAB0BFA0EA462 // A0
+data8 0xBFBF19B9BCC38A42 // A0 [1.25;1.5)
+data8 0x3FD51EE4DE0A364C,0xBFE00D7F98A16E4B // A6,A5
+data8 0x40210CE1F327E9E4 // A0
+data8 0x4001DB08F9DFA0CC // A0 [1.5;1.75)
+data8 0x3FE24F606742D252,0xBFEC81D7D12574EC // A6,A5
+data8 0x403BE636A63A9C27 // A0
+data8 0x4000A0CB38D6CF0A // A0 [1.75;2.0)
+data8 0x3FF1029A9DD542B4,0xBFFAD37C209D3B25 // A6,A5
+data8 0x405385E6FD9BE7EA // A0
+data8 0x478895F1C0000000 // Overflow boundary
+data8 0x400062D97D26B523,0xC00A03E1529FF023 // A6,A5
+data8 0x4069204C51E566CE // A0
+data8 0x0000000000000000 // pad
+data8 0x40101476B38FD501,0xC0199DE7B387C0FC // A6,A5
+data8 0x407EB8DAEC83D759 // A0
+data8 0x0000000000000000 // pad
+data8 0x401FDB008D65125A,0xC0296B506E665581 // A6,A5
+data8 0x409226D93107EF66 // A0
+data8 0x0000000000000000 // pad
+data8 0x402FB3EAAF3E7B2D,0xC039521142AD8E0D // A6,A5
+data8 0x40A4EFA4F072792E // A0
+data8 0x0000000000000000 // pad
+data8 0x403FA024C66B2563,0xC0494569F250E691 // A6,A5
+data8 0x40B7B747C9235BB8 // A0
+data8 0x0000000000000000 // pad
+data8 0x404F9607D6DA512C,0xC0593F0B2EDDB4BC // A6,A5
+data8 0x40CA7E29C5F16DE2 // A0
+data8 0x0000000000000000 // pad
+data8 0x405F90C5F613D98D,0xC0693BD130E50AAF // A6,A5
+data8 0x40DD4495238B190C // A0
+data8 0x0000000000000000 // pad
+//
+// polynomial approximation of ln(sin(Pi*x)/(Pi*x)), |x| <= 0.5
+data8 0xBFD58731A486E820,0xBFA4452CC28E15A9 // S16,S14
+data8 0xBFD013F6E1B86C4F,0xBFD5B3F19F7A341F // S8,S6
+data8 0xBFC86A0D5252E778,0xBFC93E08C9EE284B // S12,S10
+data8 0xBFE15132555C9EDD,0xBFFA51A662480E35 // S4,S2
+//
+// [1.0;1.25)
+data8 0xBFA697D6775F48EA,0x3FB9894B682A98E7 // A9,A8
+data8 0xBFCA8969253CFF55,0x3FD15124EFB35D9D // A5,A4
+data8 0xBFC1B00158AB719D,0x3FC5997D04E7F1C1 // A7,A6
+data8 0xBFD9A4D50BAFF989,0x3FEA51A661F5176A // A3,A2
+// [1.25;1.5)
+data8 0x3F838E0D35A6171A,0xBF831BBBD61313B7 // A8,A7
+data8 0x3FB08B40196425D0,0xBFC2E427A53EB830 // A4,A3
+data8 0x3F9285DDDC20D6C3,0xBFA0C90C9C223044 // A6,A5
+data8 0x3FDEF72BC8F5287C,0x3D890B3DAEBC1DFC // A2,A1
+// [1.5;1.75)
+data8 0x3F65D5A7EB31047F,0xBFA44EAC9BFA7FDE // A8,A7
+data8 0x40051FEFE7A663D8,0xC012A5CFE00A2522 // A4,A3
+data8 0x3FD0E1583AB00E08,0xBFF084AF95883BA5 // A6,A5
+data8 0x40185982877AE0A2,0xC015F83DB73B57B7 // A2,A1
+// [1.75;2.0)
+data8 0x3F4A9222032EB39A,0xBF8CBC9587EEA5A3 // A8,A7
+data8 0x3FF795400783BE49,0xC00851BC418B8A25 // A4,A3
+data8 0x3FBBC992783E8C5B,0xBFDFA67E65E89B29 // A6,A5
+data8 0x4012B408F02FAF88,0xC013284CE7CB0C39 // A2,A1
+//
+// roots
+data8 0xC003A7FC9600F86C // -2.4570247382208005860
+data8 0xC009260DBC9E59AF // -3.1435808883499798405
+data8 0xC005FB410A1BD901 // -2.7476826467274126919
+data8 0xC00FA471547C2FE5 // -3.9552942848585979085
+//
+// polynomial approximation of ln(GAMMA(x)) near roots
+// near -2.4570247382208005860
+data8 0x3FF694A6058D9592,0x40136EEBB003A92B // R3,R2
+data8 0x3FF83FE966AF5360,0x3C90323B6D1FE86D // R1,R0
+// near -3.1435808883499798405
+data8 0x405C11371268DA38,0x4039D4D2977D2C23 // R3,R2
+data8 0x401F20A65F2FAC62,0x3CDE9605E3AE7A62 // R1,R0
+// near -2.7476826467274126919
+data8 0xC034185AC31314FF,0x4023267F3C28DFE3 // R3,R2
+data8 0xBFFEA12DA904B194,0x3CA8FB8530BA7689 // R1,R0
+// near -2.7476826467274126919
+data8 0xC0AD25359E70C888,0x406F76DEAEA1B8C6 // R3,R2
+data8 0xC034B99D966C5644,0xBCBDDC0336980B58 // R1,R0
+LOCAL_OBJECT_END(lgammaf_data)
+
+//*********************************************************************
+
+.section .text
+GLOBAL_LIBM_ENTRY(__libm_lgammaf)
+{ .mfi
+      getf.exp      GR_SignExp = f8
+      frcpa.s1      FR_InvX,p0 = f1,f8
+      mov           GR_ExpOf2 = 0x10000
+}
+{ .mfi
+      addl          GR_ad_Data = @ltoff(lgammaf_data),gp
+      fcvt.fx.s1    FR_int_N = f8
+      mov           GR_ExpMask = 0x1ffff
+};;
+{ .mfi
+      getf.sig      GR_Sig = f8
+      fclass.m      p13,p0 = f8,0x1EF // is x NaTVal, NaN,
+                                      // +/-0, +/-INF or +/-deno?
+      mov           GR_ExpBias = 0xffff
+}
+{ .mfi
+      ld8           GR_ad_Data = [GR_ad_Data]
+      fma.s1        FR_Xp1 = f8,f1,f1
+      mov           GR_StirlBound = 0x1000C
+};;
+{ .mfi
+      setf.exp      FR_2 = GR_ExpOf2
+      fmerge.se     FR_x = f1,f8
+      dep.z         GR_Ind = GR_SignExp,3,4
+}
+{ .mfi
+      cmp.eq        p8,p0 = GR_SignExp,GR_ExpBias
+      fcvt.fx.trunc.s1 FR_int_Ntrunc = f8
+      and           GR_Exp = GR_ExpMask,GR_SignExp
+};;
+{ .mfi
+      add           GR_ad_C650 = 0xB20,GR_ad_Data
+      fcmp.lt.s1    p14,p15 = f8,f0
+      extr.u        GR_Ind4T = GR_Sig,55,8
+}
+{ .mfb
+      sub           GR_PureExp = GR_Exp,GR_ExpBias
+      fnorm.s1      FR_NormX = f8
+      // jump if x is NaTVal, NaN, +/-0, +/-INF or +/-deno
+(p13) br.cond.spnt  lgammaf_spec
+};;
+lgammaf_core:
+{ .mfi
+      ldfpd         FR_P1,FR_LocalMin = [GR_ad_C650],16
+      fms.s1        FR_xm2 = f8,f1,f1
+      add           GR_ad_Co = 0x820,GR_ad_Data
+}
+{ .mib
+      ldfpd         FR_P3,FR_P2 = [GR_ad_Data],16
+      cmp.ltu       p9,p0 = GR_SignExp,GR_ExpBias
+      // jump if x is from the interval [1; 2)
+(p8)  br.cond.spnt  lgammaf_1_2
+};;
+{ .mfi
+      setf.sig      FR_int_Ln = GR_PureExp
+      fms.s1        FR_r = FR_InvX,f8,f1
+      shladd        GR_ad_Co = GR_Ind,3,GR_ad_Co
+}
+{ .mib
+      ldfpd         FR_LnSqrt2Pi,FR_3 = [GR_ad_C650],16
+      cmp.lt        p13,p12 = GR_Exp,GR_StirlBound
+      // jump if x is from the interval (0; 1)
+(p9)  br.cond.spnt  lgammaf_0_1
+};;
+{ .mfi
+      ldfpd         FR_Ln2,FR_05 = [GR_ad_Data],16
+      fma.s1        FR_Xp2 = f1,f1,FR_Xp1 // (x+2)
+      shladd        GR_ad_C650 = GR_Ind,2,GR_ad_C650
+}
+{ .mfi
+      add           GR_ad_Ce = 0x20,GR_ad_Co
+      nop.f         0
+      add           GR_ad_C43 = 0x30,GR_ad_Co
+};;
+{ .mfi
+      // load coefficients of polynomial approximation
+      // of ln(GAMMA(x)), 2 <= x < 2^13
+(p13) ldfpd         FR_A10,FR_A9 = [GR_ad_Co],16
+      fcvt.xf       FR_N = FR_int_N
+      cmp.eq.unc    p6,p7 = GR_ExpOf2,GR_SignExp
+}
+{ .mib
+(p13) ldfpd         FR_A8,FR_A7 = [GR_ad_Ce]
+(p14) cmp.le.unc    p9,p0 = GR_StirlBound,GR_Exp
+      // jump if x is less or equal to -2^13
+(p9)  br.cond.spnt  lgammaf_negstirling
+};;
+.pred.rel "mutex",p6,p7
+{ .mfi
+(p13) ldfpd         FR_A6,FR_A5 = [GR_ad_C650],16
+(p6)  fma.s1        FR_x = f0,f0,FR_NormX
+      shladd        GR_ad_T = GR_Ind4T,3,GR_ad_Data
+}
+{ .mfi
+(p13) ldfpd         FR_A4,FR_A3 = [GR_ad_C43]
+(p7)  fms.s1        FR_x = FR_x,f1,f1
+(p14) mov           GR_ReqBound = 0x20005
+};;
+{ .mfi
+(p13) ldfpd         FR_A2,FR_A1 = [GR_ad_Co],16
+      fms.s1        FR_xm2 = FR_xm2,f1,f1
+(p14) extr.u        GR_Arg = GR_Sig,60,4
+}
+{ .mfi
+      mov           GR_SignOfGamma = 1 // set sign of gamma(x) to 1
+      fcvt.xf       FR_Ntrunc = FR_int_Ntrunc
+      nop.i         0
+};;
+{ .mfi
+      ldfd          FR_T = [GR_ad_T]
+      fma.s1        FR_r2 = FR_r,FR_r,f0
+      shl           GR_ReqBound = GR_ReqBound,3
+}
+{ .mfi
+      add           GR_ad_Co = 0xCA0,GR_ad_Data
+      fnma.s1       FR_Req = FR_Xp1,FR_NormX,f0 // -x*(x+1)
+(p14) shladd        GR_Arg = GR_Exp,4,GR_Arg
+};;
+{ .mfi
+(p13) ldfd          FR_A0 = [GR_ad_C650]
+      fma.s1        FR_Xp3 = FR_2,f1,FR_Xp1 // (x+3)
+(p14) cmp.le.unc    p9,p0 = GR_Arg,GR_ReqBound
+}
+{ .mfi
+(p14) add           GR_ad_Ce = 0x20,GR_ad_Co
+      fma.s1        FR_Xp4 = FR_2,FR_2,FR_NormX // (x+4)
+(p15) add           GR_ad_OvfBound = 0xBB8,GR_ad_Data
+};;
+{ .mfi
+      // load coefficients of polynomial approximation
+      // of ln(sin(Pi*xf)/(Pi*xf)), |xf| <= 0.5
+(p14) ldfpd         FR_S16,FR_S14 = [GR_ad_Co],16
+(p14) fms.s1        FR_Xf = FR_NormX,f1,FR_N  // xf = x - [x]
+(p14) sub           GR_SignOfGamma = r0,GR_SignOfGamma // set sign of
+                                                       // gamma(x) to -1
+}
+{ .mfb
+(p14) ldfpd         FR_S12,FR_S10 = [GR_ad_Ce],16
+      fma.s1        FR_Xp5 = FR_2,FR_2,FR_Xp1 // (x+5)
+      // jump if x is from the interval (-9; 0)
+(p9)  br.cond.spnt  lgammaf_negrecursion
+};;
+{ .mfi
+(p14) ldfpd         FR_S8,FR_S6 = [GR_ad_Co],16
+      fma.s1        FR_P32 = FR_P3,FR_r,FR_P2
+      nop.i         0
+}
+{ .mfb
+(p14) ldfpd         FR_S4,FR_S2 = [GR_ad_Ce],16
+      fma.s1        FR_x2 = FR_x,FR_x,f0
+      // jump if x is from the interval (-2^13; -9)
+(p14) br.cond.spnt  lgammaf_negpoly
+};;
+{ .mfi
+      ldfd          FR_OverflowBound = [GR_ad_OvfBound]
+(p12) fcvt.xf       FR_N = FR_int_Ln
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+}
+{ .mfi
+      nop.m         0
+(p12) fma.s1        FR_P10 = FR_P1,FR_r,f1
+      nop.i         0
+};;
+.pred.rel "mutex",p6,p7
+.pred.rel "mutex",p9,p10
+{ .mfi
+      // store sign of gamma(x) as 32-bit int
+(p9)  st4           [r33] = GR_SignOfGamma
+(p6)  fma.s1        FR_xx = FR_x,FR_xm2,f0
+      nop.i         0
+}
+{ .mfi
+      // store sign of gamma(x) as 64-bit int
+(p10) st8           [r33] = GR_SignOfGamma
+(p7)  fma.s1        FR_xx = f0,f0,FR_x
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_A9 = FR_A10,FR_x,FR_A9
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_A7 = FR_A8,FR_x,FR_A7
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_A5 = FR_A6,FR_x,FR_A5
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_A3 = FR_A4,FR_x,FR_A3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p15) fcmp.eq.unc.s1 p8,p0 = FR_NormX,FR_2 // is input argument 2.0?
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_A1 = FR_A2,FR_x,FR_A1
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p12) fma.s1        FR_T = FR_N,FR_Ln2,FR_T
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p12) fma.s1        FR_P32 = FR_P32,FR_r2,FR_P10
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_x4 = FR_x2,FR_x2,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_x3 = FR_x2,FR_xx,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_A7 = FR_A9,FR_x2,FR_A7
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p8)  fma.s.s0      f8 = f0,f0,f0
+(p8)  br.ret.spnt   b0 // fast exit for 2.0
+};;
+{ .mfi
+      nop.m         0
+(p6)  fma.s1        FR_A0 = FR_A0,FR_xm2,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_A3 = FR_A5,FR_x2,FR_A3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p15) fcmp.le.unc.s1 p8,p0 = FR_OverflowBound,FR_NormX // overflow test
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p12) fms.s1        FR_xm05 = FR_NormX,f1,FR_05
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p12) fma.s1        FR_Ln = FR_P32,FR_r,FR_T
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p12) fms.s1        FR_LnSqrt2Pi = FR_LnSqrt2Pi,f1,FR_NormX
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p13) fma.s1        FR_A0 = FR_A1,FR_xx,FR_A0
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p13) fma.s1        FR_A3 = FR_A7,FR_x4,FR_A3
+      // jump if result overflows
+(p8)  br.cond.spnt  lgammaf_overflow
+};;
+.pred.rel "mutex",p12,p13
+{ .mfi
+      nop.m         0
+(p12) fma.s.s0      f8 = FR_Ln,FR_xm05,FR_LnSqrt2Pi
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p13) fma.s.s0      f8 = FR_A3,FR_x3,FR_A0
+      br.ret.sptk   b0
+};;
+// branch for calculating of ln(GAMMA(x)) for 0 < x < 1
+//---------------------------------------------------------------------
+.align 32
+lgammaf_0_1:
+{ .mfi
+      getf.sig      GR_Ind = FR_Xp1
+      fma.s1        FR_r2 = FR_r,FR_r,f0
+      mov           GR_fff7 = 0xFFF7
+}
+{ .mfi
+      ldfpd         FR_Ln2,FR_05 = [GR_ad_Data],16
+      fma.s1        FR_P32 = FR_P3,FR_r,FR_P2
+      // input argument can't be equal to 1.0
+      cmp.eq        p0,p14 = r0,r0
+};;
+{ .mfi
+      getf.exp      GR_Exp = FR_w
+      fcvt.xf       FR_N = FR_int_Ln
+      add           GR_ad_Co = 0xCE0,GR_ad_Data
+}
+{ .mfi
+      shladd        GR_ad_T = GR_Ind4T,3,GR_ad_Data
+      fma.s1        FR_P10 = FR_P1,FR_r,f1
+      add           GR_ad_Ce = 0xD00,GR_ad_Data
+};;
+{ .mfi
+      ldfd          FR_T = [GR_ad_T]
+      fma.s1        FR_w2 = FR_w,FR_w,f0
+      extr.u        GR_Ind = GR_Ind,61,2
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Q32 = FR_P3,FR_w,FR_P2
+////      add           GR_ad_C0 = 0xB30,GR_ad_Data
+      add           GR_ad_C0 = 0xB38,GR_ad_Data
+};;
+{ .mfi
+      and           GR_Exp = GR_Exp,GR_ExpMask
+      nop.f         0
+      shladd        GR_IndX8 = GR_Ind,3,r0
+}
+{ .mfi
+      shladd        GR_IndX2 = GR_Ind,1,r0
+      fma.s1        FR_Q10 = FR_P1,FR_w,f1
+      cmp.eq        p6,p15 = 0,GR_Ind
+};;
+{ .mfi
+      shladd        GR_ad_Co = GR_IndX8,3,GR_ad_Co
+(p6)  fma.s1        FR_x = f0,f0,FR_NormX
+      shladd        GR_ad_C0 = GR_IndX2,4,GR_ad_C0
+}
+{ .mfi
+      shladd        GR_ad_Ce = GR_IndX8,3,GR_ad_Ce
+      nop.f         0
+(p15) cmp.eq.unc    p7,p8 = 1,GR_Ind
+};;
+.pred.rel "mutex",p7,p8
+{ .mfi
+      ldfpd         FR_A8,FR_A7 = [GR_ad_Co],16
+(p7)  fms.s1        FR_x = FR_NormX,f1,FR_LocalMin
+      cmp.ge        p10,p11 = GR_Exp,GR_fff7
+}
+{ .mfb
+      ldfpd         FR_A6,FR_A5 = [GR_ad_Ce],16
+(p8)  fma.s1        FR_x = f1,f1,FR_NormX
+      br.cond.sptk  lgamma_0_2_core
+};;
+// branch for calculating of ln(GAMMA(x)) for 1 <= x < 2
+//---------------------------------------------------------------------
+.align 32
+lgammaf_1_2:
+{ .mfi
+      add           GR_ad_Co = 0xCF0,GR_ad_Data
+      fcmp.eq.s1    p14,p0 = f1,FR_NormX // is input argument 1.0?
+      extr.u        GR_Ind = GR_Sig,61,2
+}
+{ .mfi
+      add           GR_ad_Ce = 0xD10,GR_ad_Data
+      nop.f         0
+////      add           GR_ad_C0 = 0xB40,GR_ad_Data
+      add           GR_ad_C0 = 0xB48,GR_ad_Data
+};;
+{ .mfi
+      shladd        GR_IndX8 = GR_Ind,3,r0
+      nop.f         0
+      shladd        GR_IndX2 = GR_Ind,1,r0
+}
+{ .mfi
+      cmp.eq        p6,p15 = 0,GR_Ind // p6 <- x from [1;1.25)
+      nop.f         0
+      cmp.ne        p9,p0 = r0,r0
+};;
+{ .mfi
+      shladd        GR_ad_Co = GR_IndX8,3,GR_ad_Co
+(p6)  fms.s1        FR_x = FR_NormX,f1,f1 // reduced x for [1;1.25)
+      shladd        GR_ad_C0 = GR_IndX2,4,GR_ad_C0
+}
+{ .mfi
+      shladd        GR_ad_Ce = GR_IndX8,3,GR_ad_Ce
+(p14) fma.s.s0      f8 = f0,f0,f0
+(p15) cmp.eq.unc    p7,p8 = 1,GR_Ind // p7 <- x from [1.25;1.5)
+};;
+.pred.rel "mutex",p7,p8
+{ .mfi
+      ldfpd         FR_A8,FR_A7 = [GR_ad_Co],16
+(p7)  fms.s1        FR_x = FR_xm2,f1,FR_LocalMin
+      nop.i         0
+}
+{ .mfi
+      ldfpd         FR_A6,FR_A5 = [GR_ad_Ce],16
+(p8)  fma.s1        FR_x = f0,f0,FR_NormX
+(p9)  cmp.eq.unc    p10,p11 = r0,r0
+};;
+lgamma_0_2_core:
+{ .mmi
+      ldfpd         FR_A4,FR_A3 = [GR_ad_Co],16
+      ldfpd         FR_A2,FR_A1 = [GR_ad_Ce],16
+      mov           GR_SignOfGamma = 1 // set sign of gamma(x) to 1
+};;
+{ .mfi
+//      add           GR_ad_C0 = 8,GR_ad_C0
+      ldfd          FR_A0 = [GR_ad_C0]
+      nop.f         0
+      // set p13 if signgum is 32-bit int
+      // set p15 if signgum is 64-bit int
+      cmp.eq        p15,p13 = 8,r34
+};;
+.pred.rel "mutex",p13,p15
+{ .mmf
+      // store sign of gamma(x)
+(p13) st4           [r33] = GR_SignOfGamma // as 32-bit int
+(p15) st8           [r33] = GR_SignOfGamma // as 64-bit int
+(p11) fma.s1        FR_Q32 = FR_Q32,FR_w2,FR_Q10
+};;
+{ .mfb
+      nop.m         0
+(p10) fma.s1        FR_P32 = FR_P32,FR_r2,FR_P10
+(p14) br.ret.spnt   b0 // fast exit for 1.0
+};;
+{ .mfi
+      nop.m         0
+(p10) fma.s1        FR_T = FR_N,FR_Ln2,FR_T
+      cmp.eq        p6,p7 = 0,GR_Ind // p6 <- x from [1;1.25)
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x2 = FR_x,FR_x,f0
+      cmp.eq        p8,p0 = r0,r0 // set p8 to 1 that means we on [1;2]
+};;
+{ .mfi
+      nop.m         0
+(p11) fma.s1        FR_Ln = FR_Q32,FR_w,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      nop.f         0
+      nop.i         0
+};;
+.pred.rel "mutex",p6,p7
+{ .mfi
+      nop.m         0
+(p6)  fma.s1        FR_xx = f0,f0,FR_x
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p7)  fma.s1        FR_xx = f0,f0,f1
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A7 = FR_A8,FR_x,FR_A7
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A5 = FR_A6,FR_x,FR_A5
+(p9)  cmp.ne        p8,p0 = r0,r0 // set p8 to 0 that means we on [0;1]
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A3 = FR_A4,FR_x,FR_A3
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A1 = FR_A2,FR_x,FR_A1
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x4 = FR_x2,FR_x2,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p10) fma.s1        FR_Ln = FR_P32,FR_r,FR_T
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A5 = FR_A7,FR_x2,FR_A5
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A1 = FR_A3,FR_x2,FR_A1
+      nop.i         0
+};;
+.pred.rel "mutex",p9,p8
+{ .mfi
+      nop.m         0
+(p9)  fms.d.s1      FR_A0 = FR_A0,FR_xx,FR_Ln
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p8)  fms.s1        FR_A0 = FR_A0,FR_xx,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.d.s1      FR_A1 = FR_A5,FR_x4,FR_A1
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      nop.f         0
+      nop.i         0
+};;
+.pred.rel "mutex",p6,p7
+{ .mfi
+      nop.m         0
+(p6)  fma.s.s0      f8 = FR_A1,FR_x2,FR_A0
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p7)  fma.s.s0      f8 = FR_A1,FR_x,FR_A0
+      br.ret.sptk   b0
+};;
+// branch for calculating of ln(GAMMA(x)) for -9 < x < 1
+//---------------------------------------------------------------------
+.align 32
+lgammaf_negrecursion:
+{ .mfi
+      getf.sig      GR_N = FR_int_Ntrunc
+      fms.s1        FR_1pXf = FR_Xp2,f1,FR_Ntrunc // 1 + (x+1) - [x]
+      mov           GR_Neg2 = 2
+}
+{ .mfi
+      add           GR_ad_Co = 0xCE0,GR_ad_Data
+      fms.s1        FR_Xf = FR_Xp1,f1,FR_Ntrunc // (x+1) - [x]
+      mov           GR_Neg4 = 4
+};;
+{ .mfi
+      add           GR_ad_Ce = 0xD00,GR_ad_Data
+      fma.s1        FR_Xp6 = FR_2,FR_2,FR_Xp2 // (x+6)
+      add           GR_ad_C0 = 0xB30,GR_ad_Data
+}
+{ .mfi
+      sub           GR_Neg2 = r0,GR_Neg2
+      fma.s1        FR_Xp7 = FR_2,FR_3,FR_Xp1 // (x+7)
+      sub           GR_Neg4 = r0,GR_Neg4
+};;
+{ .mfi
+      cmp.ne        p8,p0 = r0,GR_N
+      fcmp.eq.s1    p13,p0 = FR_NormX,FR_Ntrunc
+      and           GR_IntNum = 0xF,GR_N
+}
+{ .mfi
+      cmp.lt        p6,p0 = GR_N,GR_Neg2
+      fma.s1        FR_Xp8 = FR_2,FR_3,FR_Xp2 // (x+8)
+      cmp.lt        p7,p0 = GR_N,GR_Neg4
+};;
+{ .mfi
+      getf.d        GR_Arg = FR_NormX
+(p6)  fma.s1        FR_Xp2 = FR_Xp2,FR_Xp3,f0
+(p8)  tbit.z.unc    p14,p15 = GR_IntNum,0
+}
+{ .mfi
+      sub           GR_RootInd = 0xE,GR_IntNum
+(p7)  fma.s1        FR_Xp4 = FR_Xp4,FR_Xp5,f0
+      add           GR_ad_Root = 0xDE0,GR_ad_Data
+};;
+{ .mfi
+      shladd        GR_ad_Root = GR_RootInd,3,GR_ad_Root
+      fms.s1        FR_x = FR_Xp1,f1,FR_Ntrunc // (x+1) - [x]
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+      nop.f         0
+(p13) br.cond.spnt  lgammaf_singularity
+};;
+.pred.rel "mutex",p14,p15
+{ .mfi
+      cmp.gt        p6,p0 = 0xA,GR_IntNum
+(p14) fma.s1        FR_Req = FR_Req,FR_Xf,f0
+      cmp.gt        p7,p0 = 0xD,GR_IntNum
+}
+{ .mfi
+(p15) mov           GR_SignOfGamma = 1 // set sign of gamma(x) to 1
+(p15) fnma.s1       FR_Req = FR_Req,FR_Xf,f0
+      cmp.leu       p0,p13 = 2,GR_RootInd
+};;
+{ .mfi
+      nop.m         0
+(p6)  fma.s1        FR_Xp6 = FR_Xp6,FR_Xp7,f0
+(p13) add           GR_ad_RootCo = 0xE00,GR_ad_Data
+};;
+{ .mfi
+      nop.m         0
+      fcmp.eq.s1    p12,p11 = FR_1pXf,FR_2
+      nop.i         0
+};;
+{ .mfi
+      getf.sig      GR_Sig = FR_1pXf
+      fcmp.le.s1    p9,p0 = FR_05,FR_Xf
+      nop.i         0
+}
+{ .mfi
+(p13) shladd        GR_RootInd = GR_RootInd,4,r0
+(p7)  fma.s1        FR_Xp2 = FR_Xp2,FR_Xp4,f0
+(p8)  cmp.gt.unc    p10,p0 = 0x9,GR_IntNum
+};;
+.pred.rel "mutex",p11,p12
+{ .mfi
+      nop.m         0
+(p10) fma.s1        FR_Req = FR_Req,FR_Xp8,f0
+(p11) extr.u        GR_Ind = GR_Sig,61,2
+}
+{ .mfi
+(p13) add           GR_RootInd = GR_RootInd,GR_RootInd
+      nop.f         0
+(p12) mov           GR_Ind = 3
+};;
+{ .mfi
+      shladd        GR_IndX2 = GR_Ind,1,r0
+      nop.f         0
+      cmp.gt        p14,p0 = 2,GR_Ind
+}
+{ .mfi
+      shladd        GR_IndX8 = GR_Ind,3,r0
+      nop.f         0
+      cmp.eq        p6,p0 = 1,GR_Ind
+};;
+.pred.rel "mutex",p6,p9
+{ .mfi
+      shladd        GR_ad_Co = GR_IndX8,3,GR_ad_Co
+(p6)  fms.s1        FR_x = FR_Xf,f1,FR_LocalMin
+      cmp.gt        p10,p0 = 0xB,GR_IntNum
+}
+{ .mfi
+      shladd        GR_ad_Ce = GR_IndX8,3,GR_ad_Ce
+(p9)  fma.s1        FR_x = f0,f0,FR_1pXf
+      shladd        GR_ad_C0 = GR_IndX2,4,GR_ad_C0
+};;
+{ .mfi
+      // load coefficients of polynomial approximation
+      // of ln(GAMMA(x)), 1 <= x < 2
+      ldfpd         FR_A8,FR_A7 = [GR_ad_Co],16
+(p10) fma.s1        FR_Xp2 = FR_Xp2,FR_Xp6,f0
+      add           GR_ad_C0 = 8,GR_ad_C0
+}
+{ .mfi
+      ldfpd         FR_A6,FR_A5 = [GR_ad_Ce],16
+      nop.f         0
+(p14) add           GR_ad_Root = 0x10,GR_ad_Root
+};;
+{ .mfi
+      ldfpd         FR_A4,FR_A3 = [GR_ad_Co],16
+      nop.f         0
+      add           GR_ad_RootCe = 0xE10,GR_ad_Data
+}
+{ .mfi
+      ldfpd         FR_A2,FR_A1 = [GR_ad_Ce],16
+      nop.f         0
+(p14) add           GR_RootInd = 0x40,GR_RootInd
+};;
+{ .mmi
+      ldfd          FR_A0 = [GR_ad_C0]
+(p13) add           GR_ad_RootCo = GR_ad_RootCo,GR_RootInd
+(p13) add           GR_ad_RootCe = GR_ad_RootCe,GR_RootInd
+};;
+{ .mmi
+(p13) ld8           GR_Root = [GR_ad_Root]
+(p13) ldfd          FR_Root = [GR_ad_Root]
+      mov           GR_ExpBias = 0xffff
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x2 = FR_x,FR_x,f0
+      nop.i         0
+}
+{ .mlx
+(p8)  cmp.gt.unc    p10,p0 = 0xF,GR_IntNum
+      movl          GR_Dx = 0x000000014F8B588E
+};;
+{ .mfi
+      // load coefficients of polynomial approximation
+      // of ln(GAMMA(x)), x is close to one of negative roots
+(p13) ldfpd         FR_R3,FR_R2 = [GR_ad_RootCo]
+      // arguments for logarithm
+(p10) fma.s1        FR_Req = FR_Req,FR_Xp2,f0
+      mov           GR_ExpMask = 0x1ffff
+}
+{ .mfi
+(p13) ldfpd         FR_R1,FR_R0 = [GR_ad_RootCe]
+      nop.f         0
+      // set p9 if signgum is 32-bit int
+      // set p8 if signgum is 64-bit int
+      cmp.eq        p8,p9 = 8,r34
+};;
+.pred.rel "mutex",p9,p8
+{ .mfi
+(p9)  st4           [r33] = GR_SignOfGamma // as 32-bit int
+      fma.s1        FR_A7 = FR_A8,FR_x,FR_A7
+(p13) sub           GR_Root = GR_Arg,GR_Root
+}
+{ .mfi
+(p8)  st8           [r33] = GR_SignOfGamma // as 64-bit int
+      fma.s1        FR_A5 = FR_A6,FR_x,FR_A5
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fms.s1        FR_w = FR_Req,f1,f1
+(p13) add           GR_Root = GR_Root,GR_Dx
+}
+{ .mfi
+      nop.m         0
+      nop.f         0
+(p13) add           GR_2xDx = GR_Dx,GR_Dx
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A3 = FR_A4,FR_x,FR_A3
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A1 = FR_A2,FR_x,FR_A1
+(p13) cmp.leu.unc   p10,p0 = GR_Root,GR_2xDx
+};;
+{ .mfi
+      nop.m         0
+      frcpa.s1      FR_InvX,p0 = f1,FR_Req
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p10) fms.s1        FR_rx = FR_NormX,f1,FR_Root
+      nop.i         0
+};;
+{ .mfi
+      getf.exp      GR_SignExp = FR_Req
+      fma.s1        FR_x4 = FR_x2,FR_x2,f0
+      nop.i         0
+};;
+{ .mfi
+      getf.sig      GR_Sig = FR_Req
+      fma.s1        FR_A5 = FR_A7,FR_x2,FR_A5
+      nop.i         0
+};;
+{ .mfi
+      sub           GR_PureExp = GR_SignExp,GR_ExpBias
+      fma.s1        FR_w2 = FR_w,FR_w,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Q32 = FR_P3,FR_w,FR_P2
+      nop.i         0
+};;
+{ .mfi
+      setf.sig      FR_int_Ln = GR_PureExp
+      fma.s1        FR_A1 = FR_A3,FR_x2,FR_A1
+      extr.u        GR_Ind4T = GR_Sig,55,8
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Q10 = FR_P1,FR_w,f1
+      nop.i         0
+};;
+{ .mfi
+      shladd        GR_ad_T = GR_Ind4T,3,GR_ad_Data
+      fms.s1        FR_r = FR_InvX,FR_Req,f1
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p10) fms.s1        FR_rx2 = FR_rx,FR_rx,f0
+      nop.i         0
+};;
+{ .mfi
+      ldfd          FR_T = [GR_ad_T]
+(p10) fma.s1        FR_R2 = FR_R3,FR_rx,FR_R2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p10) fma.s1        FR_R0 = FR_R1,FR_rx,FR_R0
+      nop.i         0
+};;
+{ .mfi
+      getf.exp      GR_Exp = FR_w
+      fma.s1        FR_A1 = FR_A5,FR_x4,FR_A1
+      mov           GR_ExpMask = 0x1ffff
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Q32 = FR_Q32, FR_w2,FR_Q10
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_r2 = FR_r,FR_r,f0
+      mov           GR_fff7 = 0xFFF7
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P32 = FR_P3,FR_r,FR_P2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P10 = FR_P1,FR_r,f1
+      and           GR_Exp = GR_ExpMask,GR_Exp
+}
+{ .mfb
+      nop.m         0
+(p10) fma.s.s0      f8 = FR_R2,FR_rx2,FR_R0
+(p10) br.ret.spnt   b0 // exit for arguments close to negative roots
+};;
+{ .mfi
+      nop.m         0
+      fcvt.xf       FR_N = FR_int_Ln
+      nop.i         0
+}
+{ .mfi
+      cmp.ge        p14,p15 = GR_Exp,GR_fff7
+      nop.f         0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A0 = FR_A1,FR_x,FR_A0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+(p15) fma.s1        FR_Ln = FR_Q32,FR_w,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p14) fma.s1        FR_P32 = FR_P32,FR_r2,FR_P10
+      cmp.eq        p6,p7 = 0,GR_Ind
+};;
+{ .mfi
+      nop.m         0
+(p14) fma.s1        FR_T = FR_N,FR_Ln2,FR_T
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+(p14) fma.s1        FR_Ln = FR_P32,FR_r,FR_T
+      nop.i         0
+};;
+.pred.rel "mutex",p6,p7
+{ .mfi
+      nop.m         0
+(p6)  fms.s.s0      f8 = FR_A0,FR_x,FR_Ln
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+(p7)  fms.s.s0      f8 = FR_A0,f1,FR_Ln
+      br.ret.sptk   b0
+};;
+
+// branch for calculating of ln(GAMMA(x)) for x < -2^13
+//---------------------------------------------------------------------
+.align 32
+lgammaf_negstirling:
+{ .mfi
+      shladd        GR_ad_T = GR_Ind4T,3,GR_ad_Data
+      fms.s1        FR_Xf = FR_NormX,f1,FR_N  // xf = x - [x]
+      mov           GR_SingBound = 0x10016
+}
+{ .mfi
+      add           GR_ad_Co = 0xCA0,GR_ad_Data
+      fma.s1        FR_P32 = FR_P3,FR_r,FR_P2
+      nop.i         0
+};;
+{ .mfi
+      ldfd          FR_T = [GR_ad_T]
+      fcvt.xf       FR_int_Ln = FR_int_Ln
+      cmp.le        p6,p0 = GR_SingBound,GR_Exp
+}
+{ .mfb
+      add           GR_ad_Ce = 0x20,GR_ad_Co
+      fma.s1        FR_r2 = FR_r,FR_r,f0
+(p6)  br.cond.spnt  lgammaf_singularity
+};;
+{ .mfi
+      // load coefficients of polynomial approximation
+      // of ln(sin(Pi*xf)/(Pi*xf)), |xf| <= 0.5
+      ldfpd         FR_S16,FR_S14 = [GR_ad_Co],16
+      fma.s1        FR_P10 = FR_P1,FR_r,f1
+      nop.i         0
+}
+{ .mfi
+      ldfpd         FR_S12,FR_S10 = [GR_ad_Ce],16
+      fms.s1        FR_xm05 = FR_NormX,f1,FR_05
+      nop.i         0
+};;
+{ .mmi
+      ldfpd         FR_S8,FR_S6 = [GR_ad_Co],16
+      ldfpd         FR_S4,FR_S2 = [GR_ad_Ce],16
+      nop.i         0
+};;
+{ .mfi
+      getf.sig      GR_N = FR_int_Ntrunc // signgam calculation
+      fma.s1        FR_Xf2 = FR_Xf,FR_Xf,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      frcpa.s1      FR_InvXf,p0 = f1,FR_Xf
+      nop.i         0
+};;
+{ .mfi
+      getf.d        GR_Arg = FR_Xf
+      fcmp.eq.s1    p6,p0 = FR_NormX,FR_N
+      mov           GR_ExpBias = 0x3FF
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_T = FR_int_Ln,FR_Ln2,FR_T
+      extr.u        GR_Exp = GR_Arg,52,11
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P32 = FR_P32,FR_r2,FR_P10
+      nop.i         0
+};;
+{ .mfi
+      sub           GR_PureExp = GR_Exp,GR_ExpBias
+      fma.s1        FR_S14 = FR_S16,FR_Xf2,FR_S14
+      extr.u        GR_Ind4T = GR_Arg,44,8
+}
+{ .mfb
+      mov           GR_SignOfGamma = 1 // set signgam to -1
+      fma.s1        FR_S10 = FR_S12,FR_Xf2,FR_S10
+(p6)  br.cond.spnt  lgammaf_singularity
+};;
+{ .mfi
+      setf.sig      FR_int_Ln = GR_PureExp
+      fms.s1        FR_rf = FR_InvXf,FR_Xf,f1
+      // set p14 if GR_N is even
+      tbit.z        p14,p0 = GR_N,0
+}
+{ .mfi
+      shladd        GR_ad_T = GR_Ind4T,3,GR_ad_Data
+      fma.s1        FR_Xf4 = FR_Xf2,FR_Xf2,f0
+      nop.i         0
+};;
+{ .mfi
+(p14) sub           GR_SignOfGamma = r0,GR_SignOfGamma // set signgam to -1
+      fma.s1        FR_S6 = FR_S8,FR_Xf2,FR_S6
+      nop.i         0
+}
+{ .mfi
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+      fma.s1        FR_S2 = FR_S4,FR_Xf2,FR_S2
+      nop.i         0
+};;
+{ .mfi
+      ldfd          FR_Tf = [GR_ad_T]
+      fma.s1        FR_Ln = FR_P32,FR_r,FR_T
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_LnSqrt2Pi = FR_LnSqrt2Pi,f1,FR_NormX
+      nop.i         0
+};;
+.pred.rel "mutex",p9,p10
+{ .mfi
+(p9)  st4           [r33] = GR_SignOfGamma  // as 32-bit int
+      fma.s1        FR_rf2 = FR_rf,FR_rf,f0
+      nop.i         0
+}
+{ .mfi
+(p10) st8           [r33] = GR_SignOfGamma  // as 64-bit int
+      fma.s1        FR_S10 = FR_S14,FR_Xf4,FR_S10
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P32f = FR_P3,FR_rf,FR_P2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Xf8 = FR_Xf4,FR_Xf4,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P10f = FR_P1,FR_rf,f1
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S2 = FR_S6,FR_Xf4,FR_S2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fms.s1        FR_Ln = FR_Ln,FR_xm05,FR_LnSqrt2Pi
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fcvt.xf       FR_Nf = FR_int_Ln
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S2 = FR_S10,FR_Xf8,FR_S2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Tf = FR_Nf,FR_Ln2,FR_Tf
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P32f = FR_P32f,FR_rf2,FR_P10f // ??????
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_Ln = FR_S2,FR_Xf2,FR_Ln
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Lnf = FR_P32f,FR_rf,FR_Tf
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+      fms.s.s0      f8 = FR_Ln,f1,FR_Lnf
+      br.ret.sptk   b0
+};;
+// branch for calculating of ln(GAMMA(x)) for -2^13 < x < -9
+//---------------------------------------------------------------------
+.align 32
+lgammaf_negpoly:
+{ .mfi
+      getf.d        GR_Arg = FR_Xf
+      frcpa.s1      FR_InvXf,p0 = f1,FR_Xf
+      mov           GR_ExpBias = 0x3FF
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Xf2 = FR_Xf,FR_Xf,f0
+      nop.i         0
+};;
+{ .mfi
+      getf.sig      GR_N = FR_int_Ntrunc
+      fcvt.xf       FR_N = FR_int_Ln
+      mov           GR_SignOfGamma = 1
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A9 = FR_A10,FR_x,FR_A9
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P10 = FR_P1,FR_r,f1
+      extr.u        GR_Exp = GR_Arg,52,11
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_x4 = FR_x2,FR_x2,f0
+      nop.i         0
+};;
+{ .mfi
+      sub           GR_PureExp = GR_Exp,GR_ExpBias
+      fma.s1        FR_A7 = FR_A8,FR_x,FR_A7
+      tbit.z        p14,p0 = GR_N,0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A5 = FR_A6,FR_x,FR_A5
+      nop.i         0
+};;
+{ .mfi
+      setf.sig      FR_int_Ln = GR_PureExp
+      fma.s1        FR_A3 = FR_A4,FR_x,FR_A3
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A1 = FR_A2,FR_x,FR_A1
+(p14) sub           GR_SignOfGamma = r0,GR_SignOfGamma
+};;
+{ .mfi
+      nop.m         0
+      fms.s1        FR_rf = FR_InvXf,FR_Xf,f1
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Xf4 = FR_Xf2,FR_Xf2,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S14 = FR_S16,FR_Xf2,FR_S14
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S10 = FR_S12,FR_Xf2,FR_S10
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_T = FR_N,FR_Ln2,FR_T
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P32 = FR_P32,FR_r2,FR_P10
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S6 = FR_S8,FR_Xf2,FR_S6
+      extr.u        GR_Ind4T = GR_Arg,44,8
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S2 = FR_S4,FR_Xf2,FR_S2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A7 = FR_A9,FR_x2,FR_A7
+      nop.i         0
+}
+{ .mfi
+      shladd        GR_ad_T = GR_Ind4T,3,GR_ad_Data
+      fma.s1        FR_A3 = FR_A5,FR_x2,FR_A3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Xf8 = FR_Xf4,FR_Xf4,f0
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_rf2 = FR_rf,FR_rf,f0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P32f = FR_P3,FR_rf,FR_P2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P10f = FR_P1,FR_rf,f1
+      nop.i         0
+};;
+{ .mfi
+      ldfd          FR_Tf = [GR_ad_T]
+      fma.s1        FR_Ln = FR_P32,FR_r,FR_T
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A0 = FR_A1,FR_x,FR_A0
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S10 = FR_S14,FR_Xf4,FR_S10
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_S2 = FR_S6,FR_Xf4,FR_S2
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fcvt.xf       FR_Nf = FR_int_Ln
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        FR_A3 = FR_A7,FR_x4,FR_A3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fcmp.eq.s1    p13,p0 = FR_NormX,FR_Ntrunc
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fnma.s1       FR_x3 = FR_x2,FR_x,f0 // -x^3
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_P32f = FR_P32f,FR_rf2,FR_P10f
+      nop.i         0
+};;
+{ .mfb
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+      fma.s1        FR_S2 = FR_S10,FR_Xf8,FR_S2
+(p13) br.cond.spnt  lgammaf_singularity
+};;
+.pred.rel "mutex",p9,p10
+{ .mmf
+(p9)  st4           [r33] = GR_SignOfGamma  // as 32-bit int
+(p10) st8           [r33] = GR_SignOfGamma  // as 64-bit int
+      fms.s1        FR_A0 = FR_A3,FR_x3,FR_A0 // -A3*x^3-A0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Tf = FR_Nf,FR_Ln2,FR_Tf
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Ln = FR_S2,FR_Xf2,FR_Ln // S2*Xf^2+Ln
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fma.s1        FR_Lnf = FR_P32f,FR_rf,FR_Tf
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      fms.s1        FR_Ln = FR_A0,f1,FR_Ln
+      nop.i         0
+};;
+{ .mfb
+      nop.m         0
+      fms.s.s0      f8 = FR_Ln,f1,FR_Lnf
+      br.ret.sptk   b0
+};;
+// branch for handling +/-0, NaT, QNaN, +/-INF and denormalised numbers
+//---------------------------------------------------------------------
+.align 32
+lgammaf_spec:
+{ .mfi
+      getf.exp      GR_SignExp = FR_NormX
+      fclass.m      p6,p0 = f8,0x21 // is arg +INF?
+      mov           GR_SignOfGamma = 1 // set signgam to 1
+};;
+{ .mfi
+      getf.sig      GR_Sig = FR_NormX
+      fclass.m      p7,p0 = f8,0xB // is x deno?
+      // set p11 if signgum is 32-bit int
+      // set p12 if signgum is 64-bit int
+      cmp.eq        p12,p11 = 8,r34
+};;
+.pred.rel "mutex",p11,p12
+{ .mfi
+      // store sign of gamma(x) as 32-bit int
+(p11) st4           [r33] = GR_SignOfGamma
+      fclass.m      p8,p0 = f8,0x1C0 // is arg NaT or NaN?
+      dep.z         GR_Ind = GR_SignExp,3,4
+}
+{ .mib
+      // store sign of gamma(x) as 64-bit int
+(p12) st8           [r33] = GR_SignOfGamma
+      and           GR_Exp = GR_ExpMask,GR_SignExp
+(p6)  br.ret.spnt   b0 // exit for +INF
+};;
+{ .mfi
+      sub           GR_PureExp = GR_Exp,GR_ExpBias
+      fclass.m      p9,p0 = f8,0x22 // is arg -INF?
+      extr.u        GR_Ind4T = GR_Sig,55,8
+}
+{ .mfb
+      nop.m         0
+(p7)  fma.s0        FR_tmp = f1,f1,f8
+(p7)  br.cond.sptk  lgammaf_core
+};;
+{ .mfb
+      nop.m         0
+(p8)  fms.s.s0      f8 = f8,f1,f8
+(p8)  br.ret.spnt   b0 // exit for NaT and NaN
+};;
+{ .mfb
+      nop.m         0
+(p9)  fmerge.s      f8 = f1,f8
+(p9)  br.ret.spnt   b0 // exit -INF
+};;
+// branch for handling negative integers and +/-0
+//---------------------------------------------------------------------
+.align 32
+lgammaf_singularity:
+{ .mfi
+      mov           GR_SignOfGamma = 1 // set signgam to 1
+      fclass.m      p6,p0 = f8,0x6 // is x -0?
+      mov           GR_TAG = 109 // negative
+}
+{ .mfi
+      mov           GR_ad_SignGam = r33
+      fma.s1        FR_X = f0,f0,f8
+      nop.i         0
+};;
+{ .mfi
+      nop.m         0
+      frcpa.s0      f8,p0 = f1,f0
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+}
+{ .mib
+      nop.m         0
+(p6)  sub           GR_SignOfGamma = r0,GR_SignOfGamma
+      br.cond.sptk  lgammaf_libm_err
+};;
+// overflow (x > OVERFLOV_BOUNDARY)
+//---------------------------------------------------------------------
+.align 32
+lgammaf_overflow:
+{ .mfi
+      nop.m         0
+      nop.f         0
+      mov           r8 = 0x1FFFE
+};;
+{ .mfi
+      setf.exp      f9 = r8
+      fmerge.s      FR_X = f8,f8
+      mov           GR_TAG = 108 // overflow
+};;
+{ .mfi
+      mov           GR_ad_SignGam = r33
+      nop.f         0
+      // set p9  if signgum is 32-bit int
+      // set p10 if signgum is 64-bit int
+      cmp.eq        p10,p9 = 8,r34
+}
+{ .mfi
+      nop.m         0
+      fma.s.s0      f8 = f9,f9,f0 // Set I,O and +INF result
+      nop.i         0
+};;
+// gate to __libm_error_support#
+//---------------------------------------------------------------------
+.align 32
+lgammaf_libm_err:
+{ .mmi
+      alloc        r32 = ar.pfs,1,4,4,0
+      mov          GR_Parameter_TAG = GR_TAG
+      nop.i        0
+};;
+.pred.rel "mutex",p9,p10
+{ .mmi
+      // store sign of gamma(x) as 32-bit int
+(p9)  st4          [GR_ad_SignGam] = GR_SignOfGamma
+      // store sign of gamma(x) as 64-bit int
+(p10) st8          [GR_ad_SignGam] = GR_SignOfGamma
+      nop.i        0
+};;
+GLOBAL_LIBM_END(__libm_lgammaf)
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+      add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+      nop.f 0
+.save ar.pfs,GR_SAVE_PFS
+      mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+      add sp=-64,sp                           // Create new stack
+      nop.f 0
+      mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+      stfs [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
+      add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+      mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+      stfs [GR_Parameter_X] = FR_X                  // STORE Parameter 1
+                                                    // on stack
+      add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
+      nop.b 0
+}
+{ .mib
+      stfs [GR_Parameter_Y] = FR_RESULT             // STORE Parameter 3
+                                                    // on stack
+      add   GR_Parameter_Y = -16,GR_Parameter_Y
+      br.call.sptk b0=__libm_error_support#         // Call error handling
+                                                    // function
+};;
+{ .mmi
+      nop.m 0
+      nop.m 0
+      add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+      ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+      add   sp = 64,sp                       // Restore stack pointer
+      mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+      mov   gp = GR_SAVE_GP                  // Restore gp
+      mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+      br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_lgammal.S
@@ -0,0 +1,7677 @@
+.file "libm_lgammal.s"
+
+
+// Copyright (c) 2002 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,INCLUDING,BUT NOT
+// LIMITED TO,THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT,INDIRECT,INCIDENTAL,SPECIAL,
+// EXEMPLARY,OR CONSEQUENTIAL DAMAGES (INCLUDING,BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,DATA,OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY,WHETHER IN CONTRACT,STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE,EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code,and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 03/28/02  Original version
+// 05/20/02  Cleaned up namespace and sf0 syntax
+// 08/21/02  Added support of SIGN(GAMMA(x)) calculation
+// 09/26/02  Algorithm description improved
+// 10/21/02  Now it returns SIGN(GAMMA(x))=-1 for negative zero
+// 02/10/03  Reordered header: .section, .global, .proc, .align
+// 03/31/05  Reformatted delimiters between data tables
+//
+//*********************************************************************
+//
+// Function: __libm_lgammal(long double x, int* signgam, int szsigngam)
+// computes the principal value of the logarithm of the GAMMA function
+// of x. Signum of GAMMA(x) is stored to memory starting at the address
+// specified by the signgam.
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8 (Input and Return Value)
+//                              f9-f15
+//                              f32-f127
+//
+//    General Purpose Registers:
+//      r2, r3, r8-r11, r14-r31
+//      r32-r65
+//      r66-r69 (Used to pass arguments to error handling routine)
+//
+//    Predicate Registers:      p6-p15
+//
+//*********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    __libm_lgammal(+inf) = +inf
+//    __libm_lgammal(-inf) = QNaN
+//    __libm_lgammal(+/-0) = +inf
+//    __libm_lgammal(x<0, x - integer) = QNaN
+//    __libm_lgammal(SNaN) = QNaN
+//    __libm_lgammal(QNaN) = QNaN
+//
+//*********************************************************************
+//
+// ALGORITHM DESCRIPTION
+//
+// Below we suppose that there is log(z) function which takes an long
+// double argument and returns result as a pair of long double numbers
+// lnHi and lnLo (such that sum lnHi + lnLo provides ~80 correct bits
+// of significand). Algorithm description for such log(z) function
+// see below.
+// Also, it this algorithm description we use the following notational
+// conventions:
+// a) pair A = (Ahi, Alo) means number A represented as sum of Ahi and Alo
+// b) C = A + B = (Ahi, Alo) + (Bhi, Blo) means multi-precision addition.
+//    The result would be C = (Chi, Clo). Notice, that Clo shouldn't be
+//    equal to Alo + Blo
+// c) D = A*B = (Ahi, Alo)*(Bhi, Blo) = (Dhi, Dlo) multi-precisiion
+//    multiplication.
+//
+// So, lgammal has the following computational paths:
+// 1) |x| < 0.5
+//    P = A1*|x| + A2*|x|^2 + ... + A22*|x|^22
+//    A1, A2, A3 represented as a sum of two double precision
+//    numbers and multi-precision computations are used for 3 higher
+//    terms of the polynomial. We get polynomial as a sum of two
+//    double extended numbers: P = (Phi, Plo)
+//    1.1) x > 0
+//         lgammal(x) = P - log(|x|) = (Phi, Plo) - (lnHi(|x|), lnLo(|x|))
+//    1.2) x < 0
+//         lgammal(x) = -P - log(|x|) - log(sin(Pi*x)/(Pi*x))
+//         P and log(|x|) are computed by the same way as in 1.1;
+//         - log(sin(Pi*x)/(Pi*x)) is approximated by a polynomial Plnsin.
+//         Plnsin:= fLnSin2*|x|^2 + fLnSin4*|x|^4 + ... + fLnSin36*|x|^36
+//         The first coefficient of Plnsin is represented as sum of two
+//         double precision numbers (fLnSin2, fLnSin2L). Multi-precision
+//         computations for higher two terms of Plnsin are used.
+//         So, the final result is reconstructed by the following formula
+//         lgammal(x) = (-(Phi, Plo) - (lnHi(|x|), lnLo(|x|))) -
+//                      - (PlnsinHi,PlnsinLo)
+//
+// 2)    0.5 <= x <   0.75  -> t = x - 0.625
+//     -0.75 <  x <= -0.5   -> t = x + 0.625
+//      2.25 <= x <   4.0   -> t = x/2 - 1.5
+//       4.0 <= x <   8.0   -> t = x/4 - 1.5
+//       -0.5 < x <= -0.40625 -> t = x + 0.5
+//       -2.6005859375 < x <= -2.5 -> t = x + 2.5
+//       1.3125 <= x < 1.5625 -> t = x - LOC_MIN, where LOC_MIN is point in
+//                                   which lgammal has local minimum. Exact
+//                                   value can be found in the table below,
+//                                   approximate value is ~1.46
+//
+//    lgammal(x) is approximated by the polynomial of 25th degree: P25(t)
+//    P25(t) = A0 + A1*t + ... + A25*t^25 = (Phi, Plo) + t^4*P21(t),
+//    where
+//    (Phi, Plo) is sum of four highest terms of the polynomial P25(t):
+//    (Phi, Plo) = ((A0, A0L) + (A1, A1L)*t) + t^2 *((A2, A2L) + (A3, A3L)*t),
+//    (Ai, AiL) - coefficients represented as pairs of DP numbers.
+//
+//    P21(t) = (PolC(t)*t^8 + PolD(t))*t^8 + PolE(t),
+//    where
+//    PolC(t) = C21*t^5 + C20*t^4 + ... + C16,
+//    C21 = A25, C20 = A24, ..., C16 = A20
+//
+//    PolD(t) = D7*t^7 + D6*t^6 + ... + D0,
+//    D7 = A19, D6 = A18, ..., D0 = A12
+//
+//    PolE(t) = E7*t^7 + E6*t^6 + ... + E0,
+//    E7 = A11, E6 = A10, ..., E0 = A4
+//
+//    Cis and Dis are represented as double precision numbers,
+//    Eis are represented as double extended numbers.
+//
+// 3) 0.75 <=  x < 1.3125   -> t = x - 1.0
+//    1.5625 <= x < 2.25   -> t = x - 2.0
+//    lgammal(x) is approximated by the polynomial of 25th degree: P25(t)
+//    P25(t) = A1*t + ... + A25*t^25, and computations are carried out
+//    by similar way as in the previous case
+//
+// 4) 10.0 < x <= Overflow Bound ("positive Sterling" range)
+//    lgammal(x) is approximated using Sterling's formula:
+//    lgammal(x) ~ ((x*(lnHi(x) - 1, lnLo(x))) - 0.5*(lnHi(x), lnLo(x))) +
+//                 + ((Chi, Clo) + S(1/x))
+//    where
+//    C = (Chi, Clo) - pair of double precision numbers representing constant
+//    0.5*ln(2*Pi);
+//    S(1/x) = 1/x * (B2 + B4*(1/x)^2 + ... + B20*(1/x)^18), B2, ..., B20 are
+//    Bernulli numbers. S is computed in native precision and then added to
+//    Clo;
+//    lnHi(x) - 1 is computed in native precision and the multiprecision
+//    multiplication (x, 0) *(lnHi(x) - 1, lnLo(x)) is used.
+//
+// 5) -INF < x <= -2^63, any negative integer < 0
+//    All numbers in this range are integers -> error handler is called
+//
+// 6) -2^63 < x <= -0.75 ("negative Sterling" range), x is "far" from root,
+//    lgammal(-t) for positive t is approximated using the following formula:
+//    lgammal(-t) = -lgammal(t)-log(t)-log(|dT|)+log(sin(Pi*|dT|)/(Pi*|dT|))
+//        where dT = -t -round_to_nearest_integer(-t)
+//    Last item is approximated by the same polynomial as described in 1.2.
+//    We split the whole range into three subranges due to different ways of
+//    approximation of the first terms.
+//    6.1) -2^63 < x < -6.0 ("negative Sterling" range)
+//       lgammal(t) is approximated exactly as in #4. The only difference that
+//       for -13.0 < x < -6.0 subrange instead of Bernulli numbers we use their
+//       minimax approximation on this range.
+//       log(t), log(|dT|) are approximated by the log routine mentioned above.
+//    6.2) -6.0 < x <= -0.75, |x + 1|> 2^(-7)
+//       log(t), log(|dT|) are approximated by the log routine mentioned above,
+//       lgammal(t) is approximated by polynomials of the 25th degree similar
+//       to ones from #2. Arguments z of the polynomials are as follows
+//       a) 0.75 <= t < 1.0 - 2^(-7),  z = 2*t - 1.5
+//       b) 1.0 - 2^(-7)  < t < 2.0,   z = t - 1.5
+//       c) 2.0  < t < 3.0,   z = t/2 - 1.5
+//       d) 3.0  < t < 4.0,   z = t/2 - 1.5. Notice, that range reduction is
+//          the same as in case c) but the set of coefficients is different
+//       e) 4.0  < t < 6.0,   z = t/4 - 1.5
+//    6.3) |x + 1| <= 2^(-7)
+//       log(1 + (x-1)) is approximated by Taylor series,
+//       log(sin(Pi*|dT|)/(Pi*|dT|)) is still approximated by polynomial but
+//       it has just 4th degree.
+//       log(|dT|) is approximated by the log routine mentioned above.
+//       lgammal(-x) is approximated by polynomial of 8th degree from (-x + 1).
+//
+// 7) -20.0 < x < -2.0, x falls in root "neighbourhood".
+//    "Neighbourhood" means that |lgammal(x)| < epsilon, where epsilon is
+//    different for every root (and it is stored in the table), but typically
+//    it is ~ 0.15. There are 35 roots significant from "double extended"
+//    point of view. We split all the roots into two subsets: "left" and "right"
+//    roots. Considering [-(N+1), -N] range we call root as "left" one if it
+//    lies closer to -(N+1) and "right" otherwise. There is no "left" root in
+//    the [-20, -19] range (it exists, but is insignificant for double extended
+//    precision). To determine if x falls in root "neighbourhood" we store
+//    significands of all the 35 roots as well as epsilon values (expressed
+//    by the left and right bound).
+//    In these ranges we approximate lgammal(x) by polynomial series of 19th
+//    degree:
+//    lgammal(x) = P19(t) = A0 + A1*t + ...+ A19*t^19, where t = x - EDP_Root,
+//    EDP_Root is the exact value of the corresponding root rounded to double
+//    extended precision. So, we have 35 different polynomials which make our
+//    table rather big. We may hope that x falls in root "neighbourhood"
+//    quite rarely -> there might be no need in frequent use of different
+//    polynomials.
+//    A0, A1, A2, A3 are represented as pairs of double precision numbers,
+//    A4, A5 are long doubles, and to decrease the size of the table we
+//    keep the rest of coefficients in just double precision
+//
+//*********************************************************************
+// Algorithm for log(X) = (lnHi(X), lnLo(X))
+//
+//   ALGORITHM
+//
+//   Here we use a table lookup method. The basic idea is that in
+//   order to compute logl(Arg) for an argument Arg in [1,2), we
+//   construct a value G such that G*Arg is close to 1 and that
+//   logl(1/G) is obtainable easily from a table of values calculated
+//   beforehand. Thus
+//
+//      logl(Arg) = logl(1/G) + logl(G*Arg)
+//                = logl(1/G) + logl(1 + (G*Arg - 1))
+//
+//   Because |G*Arg - 1| is small, the second term on the right hand
+//   side can be approximated by a short polynomial. We elaborate
+//   this method in four steps.
+//
+//   Step 0: Initialization
+//
+//   We need to calculate logl( X ). Obtain N, S_hi such that
+//
+//      X = 2^N * S_hi exactly
+//
+//   where S_hi in [1,2)
+//
+//   Step 1: Argument Reduction
+//
+//   Based on S_hi, obtain G_1, G_2, G_3 from a table and calculate
+//
+//      G := G_1 * G_2 * G_3
+//      r := (G * S_hi - 1)
+//
+//   These G_j's have the property that the product is exactly
+//   representable and that |r| < 2^(-12) as a result.
+//
+//   Step 2: Approximation
+//
+//
+//   logl(1 + r) is approximated by a short polynomial poly(r).
+//
+//   Step 3: Reconstruction
+//
+//
+//   Finally, logl( X ) is given by
+//
+//   logl( X )   =   logl( 2^N * S_hi )
+//                 ~=~  N*logl(2) + logl(1/G) + logl(1 + r)
+//                 ~=~  N*logl(2) + logl(1/G) + poly(r).
+//
+//   IMPLEMENTATION
+//
+//   Step 0. Initialization
+//   ----------------------
+//
+//   Z := X
+//   N := unbaised exponent of Z
+//   S_hi := 2^(-N) * Z
+//
+//   Step 1. Argument Reduction
+//   --------------------------
+//
+//   Let
+//
+//      Z = 2^N * S_hi = 2^N * 1.d_1 d_2 d_3 ... d_63
+//
+//   We obtain G_1, G_2, G_3 by the following steps.
+//
+//
+//      Define          X_0 := 1.d_1 d_2 ... d_14. This is extracted
+//                      from S_hi.
+//
+//      Define          A_1 := 1.d_1 d_2 d_3 d_4. This is X_0 truncated
+//                      to lsb = 2^(-4).
+//
+//      Define          index_1 := [ d_1 d_2 d_3 d_4 ].
+//
+//      Fetch           Z_1 := (1/A_1) rounded UP in fixed point with
+//      fixed point     lsb = 2^(-15).
+//                      Z_1 looks like z_0.z_1 z_2 ... z_15
+//                      Note that the fetching is done using index_1.
+//                      A_1 is actually not needed in the implementation
+//                      and is used here only to explain how is the value
+//                      Z_1 defined.
+//
+//      Fetch           G_1 := (1/A_1) truncated to 21 sig. bits.
+//      floating pt.    Again, fetching is done using index_1. A_1
+//                      explains how G_1 is defined.
+//
+//      Calculate       X_1 := X_0 * Z_1 truncated to lsb = 2^(-14)
+//                           = 1.0 0 0 0 d_5 ... d_14
+//                      This is accomplished by integer multiplication.
+//                      It is proved that X_1 indeed always begin
+//                      with 1.0000 in fixed point.
+//
+//
+//      Define          A_2 := 1.0 0 0 0 d_5 d_6 d_7 d_8. This is X_1
+//                      truncated to lsb = 2^(-8). Similar to A_1,
+//                      A_2 is not needed in actual implementation. It
+//                      helps explain how some of the values are defined.
+//
+//      Define          index_2 := [ d_5 d_6 d_7 d_8 ].
+//
+//      Fetch           Z_2 := (1/A_2) rounded UP in fixed point with
+//      fixed point     lsb = 2^(-15). Fetch done using index_2.
+//                      Z_2 looks like z_0.z_1 z_2 ... z_15
+//
+//      Fetch           G_2 := (1/A_2) truncated to 21 sig. bits.
+//      floating pt.
+//
+//      Calculate       X_2 := X_1 * Z_2 truncated to lsb = 2^(-14)
+//                           = 1.0 0 0 0 0 0 0 0 d_9 d_10 ... d_14
+//                      This is accomplished by integer multiplication.
+//                      It is proved that X_2 indeed always begin
+//                      with 1.00000000 in fixed point.
+//
+//
+//      Define          A_3 := 1.0 0 0 0 0 0 0 0 d_9 d_10 d_11 d_12 d_13 1.
+//                      This is 2^(-14) + X_2 truncated to lsb = 2^(-13).
+//
+//      Define          index_3 := [ d_9 d_10 d_11 d_12 d_13 ].
+//
+//      Fetch           G_3 := (1/A_3) truncated to 21 sig. bits.
+//      floating pt.    Fetch is done using index_3.
+//
+//      Compute         G := G_1 * G_2 * G_3.
+//
+//      This is done exactly since each of G_j only has 21 sig. bits.
+//
+//      Compute
+//
+//               r := (G*S_hi - 1)
+//
+//
+//  Step 2. Approximation
+//  ---------------------
+//
+//   This step computes an approximation to logl( 1 + r ) where r is the
+//   reduced argument just obtained. It is proved that |r| <= 1.9*2^(-13);
+//   thus logl(1+r) can be approximated by a short polynomial:
+//
+//      logl(1+r) ~=~ poly = r + Q1 r^2 + ... + Q4 r^5
+//
+//
+//  Step 3. Reconstruction
+//  ----------------------
+//
+//   This step computes the desired result of logl(X):
+//
+//      logl(X)  =   logl( 2^N * S_hi )
+//               =   N*logl(2) + logl( S_hi )
+//               =   N*logl(2) + logl(1/G) +
+//                      logl(1 + G*S_hi - 1 )
+//
+//   logl(2), logl(1/G_j) are stored as pairs of (single,double) numbers:
+//   log2_hi, log2_lo, log1byGj_hi, log1byGj_lo. The high parts are
+//   single-precision numbers and the low parts are double precision
+//   numbers. These have the property that
+//
+//      N*log2_hi + SUM ( log1byGj_hi )
+//
+//   is computable exactly in double-extended precision (64 sig. bits).
+//   Finally
+//
+//      lnHi(X) := N*log2_hi + SUM ( log1byGj_hi )
+//      lnLo(X) := poly_hi + [ poly_lo +
+//              ( SUM ( log1byGj_lo ) + N*log2_lo ) ]
+//
+//
+//*********************************************************************
+// General Purpose Registers
+// scratch registers
+rPolDataPtr              = r2
+rLnSinDataPtr            = r3
+rExpX                    = r8
+rSignifX                 = r9
+rDelta                   = r10
+rSignExpX                = r11
+GR_ad_z_1                = r14
+r17Ones                  = r15
+GR_Index1                = r16
+rSignif1andQ             = r17
+GR_X_0                   = r18
+GR_X_1                   = r19
+GR_X_2                   = r20
+GR_Z_1                   = r21
+GR_Z_2                   = r22
+GR_N                     = r23
+rExpHalf                 = r24
+rExp8                    = r25
+rX0Dx                    = r25
+GR_ad_tbl_1              = r26
+GR_ad_tbl_2              = r27
+GR_ad_tbl_3              = r28
+GR_ad_q                  = r29
+GR_ad_z_1                = r30
+GR_ad_z_2                = r31
+// stacked registers
+rPFS_SAVED               = r32
+GR_ad_z_3                = r33
+rSgnGamAddr              = r34
+rSgnGamSize              = r35
+rLogDataPtr              = r36
+rZ1offsett               = r37
+rTmpPtr                  = r38
+rTmpPtr2                 = r39
+rTmpPtr3                 = r40
+rExp2                    = r41
+rExp2tom7                = r42
+rZ625                    = r42
+rExpOne                  = r43
+rNegSingularity          = r44
+rXint                    = r45
+rTbl1Addr                = r46
+rTbl2Addr                = r47
+rTbl3Addr                = r48
+rZ2Addr                  = r49
+rRootsAddr               = r50
+rRootsBndAddr            = r51
+rRoot                    = r52
+rRightBound              = r53
+rLeftBound               = r54
+rSignifDx                = r55
+rBernulliPtr             = r56
+rLnSinTmpPtr             = r56
+rIndex1Dx                = r57
+rIndexPol                = r58
+GR_Index3                = r59
+GR_Index2                = r60
+rSgnGam                  = r61
+rXRnd                    = r62
+
+GR_SAVE_B0               = r63
+GR_SAVE_GP               = r64
+GR_SAVE_PFS              = r65
+// output parameters when calling error handling routine
+GR_Parameter_X           = r66
+GR_Parameter_Y           = r67
+GR_Parameter_RESULT      = r68
+GR_Parameter_TAG         = r69
+
+//********************************************************************
+// Floating Point Registers
+// CAUTION: due to the lack of registers there exist (below in the code)
+// sometimes "unconventional" use of declared registers
+//
+fAbsX                    = f6
+fDelX4                   = f6
+fSignifX                 = f7
+// macros for error handling routine
+FR_X                     = f10 // first argument
+FR_Y                     = f1  // second argument (lgammal has just one)
+FR_RESULT                = f8  // result
+
+// First 7 Bernulli numbers
+fB2                      = f9
+fLnDeltaL                = f9
+fXSqr                    = f9
+fB4                      = f10
+fX4                      = f10
+fB6                      = f11
+fX6                      = f11
+fB8                      = f12
+fXSqrL                   = f12
+fB10                     = f13
+fRes7H                   = f13
+fB12                     = f14
+fRes7L                   = f14
+fB14                     = f15
+
+// stack registers
+// Polynomial coefficients: A0, ..., A25
+fA0                      = f32
+fA0L                     = f33
+fInvXL                   = f33
+fA1                      = f34
+fA1L                     = f35
+fA2                      = f36
+fA2L                     = f37
+fA3                      = f38
+fA3L                     = f39
+fA4                      = f40
+fA4L                     = f41
+fRes6H                   = f41
+fA5                      = f42
+fB2L                     = f42
+fA5L                     = f43
+fMinNegStir              = f43
+fRes6L                   = f43
+fA6                      = f44
+fMaxNegStir              = f44
+fA7                      = f45
+fLnDeltaH                = f45
+fA8                      = f46
+fBrnL                    = f46
+fA9                      = f47
+fBrnH                    = f47
+fA10                     = f48
+fRes5L                   = f48
+fA11                     = f49
+fRes5H                   = f49
+fA12                     = f50
+fDx6                     = f50
+fA13                     = f51
+fDx8                     = f51
+fA14                     = f52
+fDx4                     = f52
+fA15                     = f53
+fYL                      = f53
+fh3Dx                    = f53
+fA16                     = f54
+fYH                      = f54
+fH3Dx                    = f54
+fA17                     = f55
+fResLnDxL                = f55
+fG3Dx                    = f55
+fA18                     = f56
+fResLnDxH                = f56
+fh2Dx                    = f56
+fA19                     = f57
+fFloatNDx                = f57
+fA20                     = f58
+fPolyHiDx                = f58
+fhDx                     = f58
+fA21                     = f59
+fRDxCub                  = f59
+fHDx                     = f59
+fA22                     = f60
+fRDxSq                   = f60
+fGDx                     = f60
+fA23                     = f61
+fPolyLoDx                = f61
+fInvX3                   = f61
+fA24                     = f62
+fRDx                     = f62
+fInvX8                   = f62
+fA25                     = f63
+fInvX4                   = f63
+fPol                     = f64
+fPolL                    = f65
+// Coefficients of ln(sin(Pi*x)/Pi*x)
+fLnSin2                  = f66
+fLnSin2L                 = f67
+fLnSin4                  = f68
+fLnSin6                  = f69
+fLnSin8                  = f70
+fLnSin10                 = f71
+fLnSin12                 = f72
+fLnSin14                 = f73
+fLnSin16                 = f74
+fLnSin18                 = f75
+fDelX8                   = f75
+fLnSin20                 = f76
+fLnSin22                 = f77
+fDelX6                   = f77
+fLnSin24                 = f78
+fLnSin26                 = f79
+fLnSin28                 = f80
+fLnSin30                 = f81
+fhDelX                   = f81
+fLnSin32                 = f82
+fLnSin34                 = f83
+fLnSin36                 = f84
+fXint                    = f85
+fDxSqr                   = f85
+fRes3L                   = f86
+fRes3H                   = f87
+fRes4H                   = f88
+fRes4L                   = f89
+fResH                    = f90
+fResL                    = f91
+fDx                      = f92
+FR_MHalf                 = f93
+fRes1H                   = f94
+fRes1L                   = f95
+fRes2H                   = f96
+fRes2L                   = f97
+FR_FracX                 = f98
+fRcpX                    = f99
+fLnSinH                  = f99
+fTwo                     = f100
+fMOne                    = f100
+FR_G                     = f101
+FR_H                     = f102
+FR_h                     = f103
+FR_G2                    = f104
+FR_H2                    = f105
+FR_poly_lo               = f106
+FR_poly_hi               = f107
+FR_h2                    = f108
+FR_rsq                   = f109
+FR_r                     = f110
+FR_log2_hi               = f111
+FR_log2_lo               = f112
+fFloatN                  = f113
+FR_Q4                    = f114
+FR_G3                    = f115
+FR_H3                    = f116
+FR_h3                    = f117
+FR_Q3                    = f118
+FR_Q2                    = f119
+FR_Q1                    = f120
+fThirteen                = f121
+fSix                     = f121
+FR_rcub                  = f121
+// Last three Bernulli numbers
+fB16                     = f122
+fB18                     = f123
+fB20                     = f124
+fInvX                    = f125
+fLnSinL                  = f125
+fDxSqrL                  = f126
+fFltIntX                 = f126
+fRoot                    = f127
+fNormDx                  = f127
+
+// Data tables
+//==============================================================
+RODATA
+// ************* DO NOT CHANGE THE ORDER OF THESE TABLES *************
+.align 16
+LOCAL_OBJECT_START(lgammal_right_roots_data)
+// List of all right roots themselves
+data8 0x9D3FE4B007C360AB, 0x0000C000 // Range [-3, -2]
+data8 0xC9306DE4F2CD7BEE, 0x0000C000 // Range [-4, -3]
+data8 0x814273C2CCAC0618, 0x0000C001 // Range [-5, -4]
+data8 0xA04352BF85B6C865, 0x0000C001 // Range [-6, -5]
+data8 0xC00B592C4BE4676C, 0x0000C001 // Range [-7, -6]
+data8 0xE0019FEF6FF0F5BF, 0x0000C001 // Range [-8, -7]
+data8 0x80001A01459FC9F6, 0x0000C002 // Range [-9, -8]
+data8 0x900002E3BB47D86D, 0x0000C002 // Range [-10, -9]
+data8 0xA0000049F93BB992, 0x0000C002 // Range [-11, -10]
+data8 0xB0000006B9915316, 0x0000C002 // Range [-12, -11]
+data8 0xC00000008F76C773, 0x0000C002 // Range [-13, -12]
+data8 0xD00000000B09230A, 0x0000C002 // Range [-14, -13]
+data8 0xE000000000C9CBA5, 0x0000C002 // Range [-15, -14]
+data8 0xF0000000000D73FA, 0x0000C002 // Range [-16, -15]
+data8 0x8000000000006BA0, 0x0000C003 // Range [-17, -16]
+data8 0x8800000000000655, 0x0000C003 // Range [-18, -17]
+data8 0x900000000000005A, 0x0000C003 // Range [-19, -18]
+data8 0x9800000000000005, 0x0000C003 // Range [-20, -19]
+// List of bounds of ranges with special polynomial approximation near root
+// Only significands of bounds are actually stored
+data8 0xA000000000000000, 0x9800000000000000 // Bounds for root on [-3, -2]
+data8 0xCAB88035C5EFBB41, 0xC7E05E31F4B02115 // Bounds for root on [-4, -3]
+data8 0x817831B899735C72, 0x8114633941B8053A // Bounds for root on [-5, -4]
+data8 0xA04E8B34C6AA9476, 0xA039B4A42978197B // Bounds for root on [-6, -5]
+data8 0xC00D3D5E588A78A9, 0xC009BA25F7E858A6 // Bounds for root on [-7, -6]
+data8 0xE001E54202991EB4, 0xE001648416CE897F // Bounds for root on [-8, -7]
+data8 0x80001E56D13A6B9F, 0x8000164A3BAD888A // Bounds for root on [-9, -8]
+data8 0x9000035F0529272A, 0x9000027A0E3D94F0 // Bounds for root on [-10, -9]
+data8 0xA00000564D705880, 0xA000003F67EA0CC7 // Bounds for root on [-11, -10]
+data8 0xB0000007D87EE0EF, 0xB0000005C3A122A5 // Bounds for root on [-12, -11]
+data8 0xC0000000A75FE8B1, 0xC00000007AF818AC // Bounds for root on [-13, -12]
+data8 0xD00000000CDFFE36, 0xD000000009758BBF // Bounds for root on [-14, -13]
+data8 0xE000000000EB6D96, 0xE000000000ACF7B2 // Bounds for root on [-15, -14]
+data8 0xF0000000000FB1F9, 0xF0000000000B87FB // Bounds for root on [-16, -15]
+data8 0x8000000000007D90, 0x8000000000005C40 // Bounds for root on [-17, -16]
+data8 0x8800000000000763, 0x880000000000056D // Bounds for root on [-18, -17]
+data8 0x9000000000000069, 0x900000000000004D // Bounds for root on [-19, -18]
+data8 0x9800000000000006, 0x9800000000000005 // Bounds for root on [-20, -19]
+// List of all left roots themselves
+data8 0xAFDA0850DEC8065E, 0x0000C000 // Range [-3, -2]
+data8 0xFD238AA3E17F285C, 0x0000C000 // Range [-4, -3]
+data8 0x9FBABBD37757E6A2, 0x0000C001 // Range [-5, -4]
+data8 0xBFF497AC8FA06AFC, 0x0000C001 // Range [-6, -5]
+data8 0xDFFE5FBB5C377FE8, 0x0000C001 // Range [-7, -6]
+data8 0xFFFFCBFC0ACE7879, 0x0000C001 // Range [-8, -7]
+data8 0x8FFFFD1C425E8100, 0x0000C002 // Range [-9, -8]
+data8 0x9FFFFFB606BDFDCD, 0x0000C002 // Range [-10, -9]
+data8 0xAFFFFFF9466E9F1B, 0x0000C002 // Range [-11, -10]
+data8 0xBFFFFFFF70893874, 0x0000C002 // Range [-12, -11]
+data8 0xCFFFFFFFF4F6DCF6, 0x0000C002 // Range [-13, -12]
+data8 0xDFFFFFFFFF36345B, 0x0000C002 // Range [-14, -13]
+data8 0xEFFFFFFFFFF28C06, 0x0000C002 // Range [-15, -14]
+data8 0xFFFFFFFFFFFF28C0, 0x0000C002 // Range [-16, -15]
+data8 0x87FFFFFFFFFFF9AB, 0x0000C003 // Range [-17, -16]
+data8 0x8FFFFFFFFFFFFFA6, 0x0000C003 // Range [-18, -17]
+data8 0x97FFFFFFFFFFFFFB, 0x0000C003 // Range [-19, -18]
+data8 0x0000000000000000, 0x00000000 // pad to keep logic in the main path
+// List of bounds of ranges with special polynomial approximation near root
+// Only significands of bounds are actually stored
+data8 0xB235880944CC758E, 0xADD2F1A9FBE76C8B // Bounds for root on [-3, -2]
+data8 0xFD8E7844F307B07C, 0xFCA655C2152BDE4D // Bounds for root on [-4, -3]
+data8 0x9FC4D876EE546967, 0x9FAEE4AF68BC4292 // Bounds for root on [-5, -4]
+data8 0xBFF641FFBFCC44F1, 0xBFF2A47919F4BA89 // Bounds for root on [-6, -5]
+data8 0xDFFE9C803DEFDD59, 0xDFFE18932EB723FE // Bounds for root on [-7, -6]
+data8 0xFFFFD393FA47AFC3, 0xFFFFC317CF638AE1 // Bounds for root on [-8, -7]
+data8 0x8FFFFD8840279925, 0x8FFFFC9DCECEEE92 // Bounds for root on [-9, -8]
+data8 0x9FFFFFC0D34E2AF8, 0x9FFFFFA9619AA3B7 // Bounds for root on [-10, -9]
+data8 0xAFFFFFFA41C18246, 0xAFFFFFF82025A23C // Bounds for root on [-11, -10]
+data8 0xBFFFFFFF857ACB4E, 0xBFFFFFFF58032378 // Bounds for root on [-12, -11]
+data8 0xCFFFFFFFF6934AB8, 0xCFFFFFFFF313EF0A // Bounds for root on [-13, -12]
+data8 0xDFFFFFFFFF53A9E9, 0xDFFFFFFFFF13B5A5 // Bounds for root on [-14, -13]
+data8 0xEFFFFFFFFFF482CB, 0xEFFFFFFFFFF03F4F // Bounds for root on [-15, -14]
+data8 0xFFFFFFFFFFFF482D, 0xFFFFFFFFFFFF03F5 // Bounds for root on [-16, -15]
+data8 0x87FFFFFFFFFFFA98, 0x87FFFFFFFFFFF896 // Bounds for root on [-17, -16]
+data8 0x8FFFFFFFFFFFFFB3, 0x8FFFFFFFFFFFFF97 // Bounds for root on [-18, -17]
+data8 0x97FFFFFFFFFFFFFC, 0x97FFFFFFFFFFFFFB // Bounds for root on [-19, -18]
+LOCAL_OBJECT_END(lgammal_right_roots_data)
+
+LOCAL_OBJECT_START(lgammal_0_Half_data)
+// Polynomial coefficients for the lgammal(x), 0.0 < |x| < 0.5
+data8 0xBFD9A4D55BEAB2D6, 0xBC8AA3C097746D1F //A3
+data8 0x3FEA51A6625307D3, 0x3C7180E7BD2D0DCC //A2
+data8 0xBFE2788CFC6FB618, 0xBC9E9346C4692BCC //A1
+data8 0x8A8991563EC1BD13, 0x00003FFD //A4
+data8 0xD45CE0BD52C27EF2, 0x0000BFFC //A5
+data8 0xADA06587FA2BBD47, 0x00003FFC //A6
+data8 0x9381D0ED2194902A, 0x0000BFFC //A7
+data8 0x80859B3CF92D4192, 0x00003FFC //A8
+data8 0xE4033517C622A946, 0x0000BFFB //A9
+data8 0xCD00CE67A51FC82A, 0x00003FFB //A10
+data8 0xBA44E2A96C3B5700, 0x0000BFFB //A11
+data8 0xAAAD008FA46DBD99, 0x00003FFB //A12
+data8 0x9D604AC65A41153D, 0x0000BFFB //A13
+data8 0x917CECB864B5A861, 0x00003FFB //A14
+data8 0x85A4810EB730FDE4, 0x0000BFFB //A15
+data8 0xEF2761C38BD21F77, 0x00003FFA //A16
+data8 0xC913043A128367DA, 0x0000BFFA //A17
+data8 0x96A29B71FF7AFFAA, 0x00003FFA //A18
+data8 0xBB9FFA1A5FE649BB, 0x0000BFF9 //A19
+data8 0xB17982CD2DAA0EE3, 0x00003FF8 //A20
+data8 0xDE1DDCBFFB9453F0, 0x0000BFF6 //A21
+data8 0x87FBF5D7ACD9FA9D, 0x00003FF4 //A22
+LOCAL_OBJECT_END(lgammal_0_Half_data)
+
+LOCAL_OBJECT_START(Constants_Q)
+// log2_hi, log2_lo, Q_4, Q_3, Q_2, and Q_1
+data4  0x00000000,0xB1721800,0x00003FFE,0x00000000
+data4  0x4361C4C6,0x82E30865,0x0000BFE2,0x00000000
+data4  0x328833CB,0xCCCCCAF2,0x00003FFC,0x00000000
+data4  0xA9D4BAFB,0x80000077,0x0000BFFD,0x00000000
+data4  0xAAABE3D2,0xAAAAAAAA,0x00003FFD,0x00000000
+data4  0xFFFFDAB7,0xFFFFFFFF,0x0000BFFD,0x00000000
+LOCAL_OBJECT_END(Constants_Q)
+
+LOCAL_OBJECT_START(Constants_Z_1)
+// Z1 - 16 bit fixed
+data4  0x00008000
+data4  0x00007879
+data4  0x000071C8
+data4  0x00006BCB
+data4  0x00006667
+data4  0x00006187
+data4  0x00005D18
+data4  0x0000590C
+data4  0x00005556
+data4  0x000051EC
+data4  0x00004EC5
+data4  0x00004BDB
+data4  0x00004925
+data4  0x0000469F
+data4  0x00004445
+data4  0x00004211
+LOCAL_OBJECT_END(Constants_Z_1)
+
+LOCAL_OBJECT_START(Constants_G_H_h1)
+// G1 and H1 - IEEE single and h1 - IEEE double
+data4  0x3F800000,0x00000000,0x00000000,0x00000000
+data4  0x3F70F0F0,0x3D785196,0x617D741C,0x3DA163A6
+data4  0x3F638E38,0x3DF13843,0xCBD3D5BB,0x3E2C55E6
+data4  0x3F579430,0x3E2FF9A0,0xD86EA5E7,0xBE3EB0BF
+data4  0x3F4CCCC8,0x3E647FD6,0x86B12760,0x3E2E6A8C
+data4  0x3F430C30,0x3E8B3AE7,0x5C0739BA,0x3E47574C
+data4  0x3F3A2E88,0x3EA30C68,0x13E8AF2F,0x3E20E30F
+data4  0x3F321640,0x3EB9CEC8,0xF2C630BD,0xBE42885B
+data4  0x3F2AAAA8,0x3ECF9927,0x97E577C6,0x3E497F34
+data4  0x3F23D708,0x3EE47FC5,0xA6B0A5AB,0x3E3E6A6E
+data4  0x3F1D89D8,0x3EF8947D,0xD328D9BE,0xBDF43E3C
+data4  0x3F17B420,0x3F05F3A1,0x0ADB090A,0x3E4094C3
+data4  0x3F124920,0x3F0F4303,0xFC1FE510,0xBE28FBB2
+data4  0x3F0D3DC8,0x3F183EBF,0x10FDE3FA,0x3E3A7895
+data4  0x3F088888,0x3F20EC80,0x7CC8C98F,0x3E508CE5
+data4  0x3F042108,0x3F29516A,0xA223106C,0xBE534874
+LOCAL_OBJECT_END(Constants_G_H_h1)
+
+LOCAL_OBJECT_START(Constants_Z_2)
+// Z2 - 16 bit fixed
+data4  0x00008000
+data4  0x00007F81
+data4  0x00007F02
+data4  0x00007E85
+data4  0x00007E08
+data4  0x00007D8D
+data4  0x00007D12
+data4  0x00007C98
+data4  0x00007C20
+data4  0x00007BA8
+data4  0x00007B31
+data4  0x00007ABB
+data4  0x00007A45
+data4  0x000079D1
+data4  0x0000795D
+data4  0x000078EB
+LOCAL_OBJECT_END(Constants_Z_2)
+
+LOCAL_OBJECT_START(Constants_G_H_h2)
+// G2 and H2 - IEEE single and h2 - IEEE double
+data4  0x3F800000,0x00000000,0x00000000,0x00000000
+data4  0x3F7F00F8,0x3B7F875D,0x22C42273,0x3DB5A116
+data4  0x3F7E03F8,0x3BFF015B,0x21F86ED3,0x3DE620CF
+data4  0x3F7D08E0,0x3C3EE393,0x484F34ED,0xBDAFA07E
+data4  0x3F7C0FC0,0x3C7E0586,0x3860BCF6,0xBDFE07F0
+data4  0x3F7B1880,0x3C9E75D2,0xA78093D6,0x3DEA370F
+data4  0x3F7A2328,0x3CBDC97A,0x72A753D0,0x3DFF5791
+data4  0x3F792FB0,0x3CDCFE47,0xA7EF896B,0x3DFEBE6C
+data4  0x3F783E08,0x3CFC15D0,0x409ECB43,0x3E0CF156
+data4  0x3F774E38,0x3D0D874D,0xFFEF71DF,0xBE0B6F97
+data4  0x3F766038,0x3D1CF49B,0x5D59EEE8,0xBE080483
+data4  0x3F757400,0x3D2C531D,0xA9192A74,0x3E1F91E9
+data4  0x3F748988,0x3D3BA322,0xBF72A8CD,0xBE139A06
+data4  0x3F73A0D0,0x3D4AE46F,0xF8FBA6CF,0x3E1D9202
+data4  0x3F72B9D0,0x3D5A1756,0xBA796223,0xBE1DCCC4
+data4  0x3F71D488,0x3D693B9D,0xB6B7C239,0xBE049391
+LOCAL_OBJECT_END(Constants_G_H_h2)
+
+LOCAL_OBJECT_START(Constants_G_H_h3)
+// G3 and H3 - IEEE single and h3 - IEEE double
+data4  0x3F7FFC00,0x38800100,0x562224CD,0x3D355595
+data4  0x3F7FF400,0x39400480,0x06136FF6,0x3D8200A2
+data4  0x3F7FEC00,0x39A00640,0xE8DE9AF0,0x3DA4D68D
+data4  0x3F7FE400,0x39E00C41,0xB10238DC,0xBD8B4291
+data4  0x3F7FDC00,0x3A100A21,0x3B1952CA,0xBD89CCB8
+data4  0x3F7FD400,0x3A300F22,0x1DC46826,0xBDB10707
+data4  0x3F7FCC08,0x3A4FF51C,0xF43307DB,0x3DB6FCB9
+data4  0x3F7FC408,0x3A6FFC1D,0x62DC7872,0xBD9B7C47
+data4  0x3F7FBC10,0x3A87F20B,0x3F89154A,0xBDC3725E
+data4  0x3F7FB410,0x3A97F68B,0x62B9D392,0xBD93519D
+data4  0x3F7FAC18,0x3AA7EB86,0x0F21BD9D,0x3DC18441
+data4  0x3F7FA420,0x3AB7E101,0x2245E0A6,0xBDA64B95
+data4  0x3F7F9C20,0x3AC7E701,0xAABB34B8,0x3DB4B0EC
+data4  0x3F7F9428,0x3AD7DD7B,0x6DC40A7E,0x3D992337
+data4  0x3F7F8C30,0x3AE7D474,0x4F2083D3,0x3DC6E17B
+data4  0x3F7F8438,0x3AF7CBED,0x811D4394,0x3DAE314B
+data4  0x3F7F7C40,0x3B03E1F3,0xB08F2DB1,0xBDD46F21
+data4  0x3F7F7448,0x3B0BDE2F,0x6D34522B,0xBDDC30A4
+data4  0x3F7F6C50,0x3B13DAAA,0xB1F473DB,0x3DCB0070
+data4  0x3F7F6458,0x3B1BD766,0x6AD282FD,0xBDD65DDC
+data4  0x3F7F5C68,0x3B23CC5C,0xF153761A,0xBDCDAB83
+data4  0x3F7F5470,0x3B2BC997,0x341D0F8F,0xBDDADA40
+data4  0x3F7F4C78,0x3B33C711,0xEBC394E8,0x3DCD1BD7
+data4  0x3F7F4488,0x3B3BBCC6,0x52E3E695,0xBDC3532B
+data4  0x3F7F3C90,0x3B43BAC0,0xE846B3DE,0xBDA3961E
+data4  0x3F7F34A0,0x3B4BB0F4,0x785778D4,0xBDDADF06
+data4  0x3F7F2CA8,0x3B53AF6D,0xE55CE212,0x3DCC3ED1
+data4  0x3F7F24B8,0x3B5BA620,0x9E382C15,0xBDBA3103
+data4  0x3F7F1CC8,0x3B639D12,0x5C5AF197,0x3D635A0B
+data4  0x3F7F14D8,0x3B6B9444,0x71D34EFC,0xBDDCCB19
+data4  0x3F7F0CE0,0x3B7393BC,0x52CD7ADA,0x3DC74502
+data4  0x3F7F04F0,0x3B7B8B6D,0x7D7F2A42,0xBDB68F17
+LOCAL_OBJECT_END(Constants_G_H_h3)
+
+LOCAL_OBJECT_START(lgammal_data)
+// Positive overflow value
+data8 0xB8D54C8BFFFDEBF4, 0x00007FF1
+LOCAL_OBJECT_END(lgammal_data)
+
+LOCAL_OBJECT_START(lgammal_Stirling)
+// Coefficients needed for Strirling's formula
+data8 0x3FED67F1C864BEB4 // High part of 0.5*ln(2*Pi)
+data8 0x3C94D252F2400510 // Low part of 0.5*ln(2*Pi)
+//
+// Bernulli numbers used in Striling's formula for -2^63 < |x| < -13.0
+//(B1H, B1L) = 8.3333333333333333333262747254e-02
+data8 0x3FB5555555555555, 0x3C55555555555555
+data8 0xB60B60B60B60B60B, 0x0000BFF6 //B2 = -2.7777777777777777777777777778e-03
+data8 0xD00D00D00D00D00D, 0x00003FF4 //B3 = 7.9365079365079365079365079365e-04
+data8 0x9C09C09C09C09C0A, 0x0000BFF4 //B4 = -5.9523809523809523809523809524e-04
+data8 0xDCA8F158C7F91AB8, 0x00003FF4 //B5 = 8.4175084175084175084175084175e-04
+data8 0xFB5586CCC9E3E410, 0x0000BFF5 //B6 = -1.9175269175269175269175269175e-03
+data8 0xD20D20D20D20D20D, 0x00003FF7 //B7 = 6.4102564102564102564102564103e-03
+data8 0xF21436587A9CBEE1, 0x0000BFF9 //B8 = -2.9550653594771241830065359477e-02
+data8 0xB7F4B1C0F033FFD1, 0x00003FFC //B9 = 1.7964437236883057316493849002e-01
+data8 0xB23B3808C0F9CF6E, 0x0000BFFF //B10 = -1.3924322169059011164274322169e+00
+// Polynomial coefficients for Stirling's formula, -13.0 < x < -6.0
+data8 0x3FB5555555555555, 0x3C4D75060289C58B //A0
+data8 0xB60B60B60B0F0876, 0x0000BFF6 //A1
+data8 0xD00D00CE54B1256C, 0x00003FF4 //A2
+data8 0x9C09BF46B58F75E1, 0x0000BFF4 //A3
+data8 0xDCA8483BC91ACC6D, 0x00003FF4 //A4
+data8 0xFB3965C939CC9FEE, 0x0000BFF5 //A5
+data8 0xD0723ADE3F0BC401, 0x00003FF7 //A6
+data8 0xE1ED7434E81F0B73, 0x0000BFF9 //A7
+data8 0x8069C6982F993283, 0x00003FFC //A8
+data8 0xC271F65BFA5BEE3F, 0x0000BFFD //A9
+LOCAL_OBJECT_END(lgammal_Stirling)
+
+LOCAL_OBJECT_START(lgammal_lnsin_data)
+// polynomial approximation of -ln(sin(Pi*x)/(Pi*x)), 0 < x <= 0.5
+data8 0x3FFA51A6625307D3, 0x3C81873332FAF94C //A2
+data8 0x8A8991563EC241C3, 0x00003FFE //A4
+data8 0xADA06588061805DF, 0x00003FFD //A6
+data8 0x80859B57C338D0F7, 0x00003FFD //A8
+data8 0xCD00F1C2D78754BD, 0x00003FFC //A10
+data8 0xAAB56B1D3A1F4655, 0x00003FFC //A12
+data8 0x924B6F2FBBED12B1, 0x00003FFC //A14
+data8 0x80008E58765F43FC, 0x00003FFC //A16
+data8 0x3FBC718EC115E429//A18
+data8 0x3FB99CE544FE183E//A20
+data8 0x3FB7251C09EAAD89//A22
+data8 0x3FB64A970733628C//A24
+data8 0x3FAC92D6802A3498//A26
+data8 0x3FC47E1165261586//A28
+data8 0xBFCA1BAA434750D4//A30
+data8 0x3FE460001C4D5961//A32
+data8 0xBFE6F06A3E4908AD//A34
+data8 0x3FE300889EBB203A//A36
+LOCAL_OBJECT_END(lgammal_lnsin_data)
+
+LOCAL_OBJECT_START(lgammal_half_3Q_data)
+// Polynomial coefficients for the lgammal(x), 0.5 <= x < 0.75
+data8 0xBFF7A648EE90C62E, 0x3C713F326857E066 // A3, A0L
+data8 0xBFF73E4B8BA780AE, 0xBCA953BC788877EF // A1, A1L
+data8 0x403774DCD58D0291, 0xC0415254D5AE6623 // D0, D1
+data8 0x40B07213855CBFB0, 0xC0B8855E25D2D229 // C20, C21
+data8 0x3FFB359F85FF5000, 0x3C9BAECE6EF9EF3A // A2, A2L
+data8 0x3FD717D498A3A8CC, 0xBC9088E101CFEDFA  // A0, A3L
+data8 0xAFEF36CC5AEC3FF0, 0x00004002 // E6
+data8 0xABE2054E1C34E791, 0x00004001 // E4
+data8 0xB39343637B2900D1, 0x00004000 // E2
+data8 0xD74FB710D53F58F6, 0x00003FFF // E0
+data8 0x4070655963BA4256, 0xC078DA9D263C4EA3 // D6, D7
+data8 0x405CD2B6A9B90978, 0xC065B3B9F4F4F171 // D4, D5
+data8 0x4049BC2204CF61FF, 0xC05337227E0BA152 // D2, D3
+data8 0x4095509A50C07A96, 0xC0A0747949D2FB45 // C18, C19
+data8 0x4082ECCBAD709414, 0xC08CD02FB088A702 // C16, C17
+data8 0xFFE4B2A61B508DD5, 0x0000C002 // E7
+data8 0xF461ADB8AE17E0A5, 0x0000C001 // E5
+data8 0xF5BE8B0B90325F20, 0x0000C000 // E3
+data8 0x877B275F3FB78DCA, 0x0000C000 // E1
+LOCAL_OBJECT_END(lgammal_half_3Q_data)
+
+LOCAL_OBJECT_START(lgammal_half_3Q_neg_data)
+// Polynomial coefficients for the lgammal(x), -0.75 < x <= -0.5
+data8 0xC014836EFD94899C, 0x3C9835679663B44F // A3, A0L
+data8 0xBFF276C7B4FB1875, 0xBC92D3D9FA29A1C0 // A1, A1L
+data8 0x40C5178F24E1A435, 0xC0D9DE84FBC5D76A // D0, D1
+data8 0x41D4D1B236BF6E93, 0xC1EBB0445CE58550 // C20, C21
+data8 0x4015718CD67F63D3, 0x3CC5354B6F04B59C // A2, A2L
+data8 0x3FF554493087E1ED, 0xBCB72715E37B02B9 // A0, A3L
+data8 0xE4AC7E915FA72229, 0x00004009 // E6
+data8 0xA28244206395FCC6, 0x00004007 // E4
+data8 0xFB045F19C07B2544, 0x00004004 // E2
+data8 0xE5C8A6E6A9BA7D7B, 0x00004002 // E0
+data8 0x4143943B55BF5118, 0xC158AC05EA675406 // D6, D7
+data8 0x4118F6833D19717C, 0xC12F51A6F375CC80 // D4, D5
+data8 0x40F00C209483481C, 0xC103F1DABF750259 // D2, D3
+data8 0x4191038F2D8F9E40, 0xC1A413066DA8AE4A // C18, C19
+data8 0x4170B537EDD833DE, 0xC1857E79424C61CE // C16, C17
+data8 0x8941D8AB4855DB73, 0x0000C00B // E7
+data8 0xBB822B131BD2E813, 0x0000C008 // E5
+data8 0x852B4C03B83D2D4F, 0x0000C006 // E3
+data8 0xC754CA7E2DDC0F1F, 0x0000C003 // E1
+LOCAL_OBJECT_END(lgammal_half_3Q_neg_data)
+
+LOCAL_OBJECT_START(lgammal_2Q_4_data)
+// Polynomial coefficients for the lgammal(x), 2.25 <= |x| < 4.0
+data8 0xBFCA4D55BEAB2D6F, 0x3C7ABC9DA14141F5 // A3, A0L
+data8 0x3FFD8773039049E7, 0x3C66CB7957A95BA4 // A1, A1L
+data8 0x3F45C3CC79E91E7D, 0xBF3A8E5005937E97 // D0, D1
+data8 0x3EC951E35E1C9203, 0xBEB030A90026C5DF // C20, C21
+data8 0x3FE94699894C1F4C, 0x3C91884D21D123F1 // A2, A2L
+data8 0x3FE62E42FEFA39EF, 0xBC66480CEB70870F // A0, A3L
+data8 0xF1C2EAFF0B3A7579, 0x00003FF5 // E6
+data8 0xB36AF863926B55A3, 0x00003FF7 // E4
+data8 0x9620656185BB44CA, 0x00003FF9 // E2
+data8 0xA264558FB0906AFF, 0x00003FFB // E0
+data8 0x3F03D59E9666C961, 0xBEF91115893D84A6 // D6, D7
+data8 0x3F19333611C46225, 0xBF0F89EB7D029870 // D4, D5
+data8 0x3F3055A96B347AFE, 0xBF243B5153E178A8 // D2, D3
+data8 0x3ED9A4AEF30C4BB2, 0xBED388138B1CEFF2 // C18, C19
+data8 0x3EEF7945A3C3A254, 0xBEE36F32A938EF11 // C16, C17
+data8 0x9028923F47C82118, 0x0000BFF5 // E7
+data8 0xCE0DAAFB6DC93B22, 0x0000BFF6 // E5
+data8 0xA0D0983B34AC4C8D, 0x0000BFF8 // E3
+data8 0x94D6C50FEB8B0CE7, 0x0000BFFA // E1
+LOCAL_OBJECT_END(lgammal_2Q_4_data)
+
+LOCAL_OBJECT_START(lgammal_4_8_data)
+// Polynomial coefficients for the lgammal(x), 4.0 <= |x| < 8.0
+data8 0xBFD6626BC9B31B54, 0x3CAA53C82493A92B // A3, A0L
+data8 0x401B4C420A50AD7C, 0x3C8C6E9929F789A3 // A1, A1L
+data8 0x3F49410427E928C2, 0xBF3E312678F8C146 // D0, D1
+data8 0x3ED51065F7CD5848, 0xBED052782A03312F // C20, C21
+data8 0x3FF735973273D5EC, 0x3C831DFC65BF8CCF // A2, A2L
+data8 0x401326643C4479C9, 0xBC6FA0498C5548A6 // A0, A3L
+data8 0x9382D8B3CD4EB7E3, 0x00003FF6 // E6
+data8 0xE9F92CAD8A85CBCD, 0x00003FF7 // E4
+data8 0xD58389FE38258CEC, 0x00003FF9 // E2
+data8 0x81310136363AE8AA, 0x00003FFC // E0
+data8 0x3F04F0AE38E78570, 0xBEF9E2144BB8F03C // D6, D7
+data8 0x3F1B5E992A6CBC2A, 0xBF10F3F400113911 // D4, D5
+data8 0x3F323EE00AAB7DEE, 0xBF2640FDFA9FB637 // D2, D3
+data8 0x3ED2143EBAFF067A, 0xBEBBDEB92D6FF35D // C18, C19
+data8 0x3EF173A42B69AAA4, 0xBEE78B9951A2EAA5 // C16, C17
+data8 0xAB3CCAC6344E52AA, 0x0000BFF5 // E7
+data8 0x81ACCB8915B16508, 0x0000BFF7 // E5
+data8 0xDA62C7221102C426, 0x0000BFF8 // E3
+data8 0xDF1BD44C4083580A, 0x0000BFFA // E1
+LOCAL_OBJECT_END(lgammal_4_8_data)
+
+LOCAL_OBJECT_START(lgammal_loc_min_data)
+// Polynomial coefficients for the lgammal(x), 1.3125 <= x < 1.5625
+data8 0xBB16C31AB5F1FB71, 0x00003FFF // xMin - point of local minimum
+data8 0xBFC2E4278DC6BC23, 0xBC683DA8DDCA9650 // A3, A0L
+data8 0x3BD4DB7D0CA61D5F, 0x386E719EDD01D801 // A1, A1L
+data8 0x3F4CC72638E1D93F, 0xBF4228EC9953CCB9 // D0, D1
+data8 0x3ED222F97A04613E,0xBED3DDD58095CB6C  // C20, C21
+data8 0x3FDEF72BC8EE38AB, 0x3C863AFF3FC48940 // A2, A2L
+data8 0xBFBF19B9BCC38A41,  0xBC7425F1BFFC1442// A0, A3L
+data8 0x941890032BEB34C3, 0x00003FF6 // E6
+data8 0xC7E701591CE534BC, 0x00003FF7 // E4
+data8 0x93373CBD05138DD4, 0x00003FF9 // E2
+data8 0x845A14A6A81C05D6, 0x00003FFB // E0
+data8 0x3F0F6C4DF6D47A13, 0xBF045DCDB5B49E19 // D6, D7
+data8 0x3F22E23345DDE59C, 0xBF1851159AFB1735 // D4, D5
+data8 0x3F37101EA4022B78, 0xBF2D721E6323AF13 // D2, D3
+data8 0x3EE691EBE82DF09D, 0xBEDD42550961F730 // C18, C19
+data8 0x3EFA793EDE99AD85, 0xBEF14000108E70BE // C16, C17
+data8 0xB7CBC033ACE0C99C, 0x0000BFF5 // E7
+data8 0xF178D1F7B1A45E27, 0x0000BFF6 // E5
+data8 0xA8FCFCA8106F471C, 0x0000BFF8 // E3
+data8 0x864D46FA898A9AD2, 0x0000BFFA // E1
+LOCAL_OBJECT_END(lgammal_loc_min_data)
+
+LOCAL_OBJECT_START(lgammal_03Q_1Q_data)
+// Polynomial coefficients for the lgammal(x), 0.75 <= |x| < 1.3125
+data8 0x3FD151322AC7D848, 0x3C7184DE0DB7B4EE // A4, A2L
+data8 0x3FD9A4D55BEAB2D6, 0x3C9E934AAB10845F // A3, A1L
+data8 0x3FB111289C381259, 0x3FAFFFCFB32AE18D // D2, D3
+data8 0x3FB3B1D9E0E3E00D, 0x3FB2496F0D3768DF // D0, D1
+data8 0xBA461972C057D439, 0x00003FFB         // E6
+data8 0x3FEA51A6625307D3, 0x3C76ABC886A72DA2 // A2, A4L
+data8 0x3FA8EFE46B32A70E, 0x3F8F31B3559576B6 // C17, C20
+data8 0xE403383700387D85, 0x00003FFB // E4
+data8 0x9381D0EE74BF7251, 0x00003FFC // E2
+data8 0x3FAA2177A6D28177, 0x3FA4895E65FBD995 // C18, C19
+data8 0x3FAAED2C77DBEE5D, 0x3FA94CA59385512C // D6, D7
+data8 0x3FAE1F522E8A5941, 0x3FAC785EF56DD87E // D4, D5
+data8 0x3FB556AD5FA56F0A, 0x3FA81F416E87C783 // E7, C16
+data8 0xCD00F1C2DC2C9F1E, 0x00003FFB // E5
+data8 0x3FE2788CFC6FB618, 0x3C8E52519B5B17CB // A1, A3L
+data8 0x80859B57C3E7F241, 0x00003FFC // E3
+data8 0xADA065880615F401, 0x00003FFC // E1
+data8 0xD45CE0BD530AB50E, 0x00003FFC // E0
+LOCAL_OBJECT_END(lgammal_03Q_1Q_data)
+
+LOCAL_OBJECT_START(lgammal_13Q_2Q_data)
+// Polynomial coefficients for the lgammal(x), 1.5625 <= |x| < 2.25
+data8 0x3F951322AC7D8483, 0x3C71873D88C6539D // A4, A2L
+data8 0xBFB13E001A557606, 0x3C56CB907018A101 // A3, A1L
+data8 0xBEC11B2EC1E7F6FC, 0x3EB0064ED9824CC7 // D2, D3
+data8 0xBEE3CBC963EC103A, 0x3ED2597A330C107D // D0, D1
+data8 0xBC6F2DEBDFE66F38, 0x0000BFF0 // E6
+data8 0x3FD4A34CC4A60FA6, 0x3C3AFC9BF775E8A0 // A2, A4L
+data8 0x3E48B0C542F85B32, 0xBE347F12EAF787AB // C17, C20
+data8 0xE9FEA63B6984FA1E, 0x0000BFF2 // E4
+data8 0x9C562E15FC703BBF, 0x0000BFF5 // E2
+data8 0xBE3C12A50AB0355E, 0xBE1C941626AE4717 // C18, C19
+data8 0xBE7AFA8714342BC4,0x3E69A12D2B7761CB // D6, D7
+data8 0xBE9E25EF1D526730, 0x3E8C762291889B99 // D4, D5
+data8 0x3EF580DCEE754733, 0xBE57C811D070549C // E7, C16
+data8 0xD093D878BE209C98, 0x00003FF1 // E5
+data8 0x3FDB0EE6072093CE, 0xBC6024B9E81281C4 // A1, A3L
+data8 0x859B57C31CB77D96, 0x00003FF4 // E3
+data8 0xBD6EB756DB617E8D, 0x00003FF6 // E1
+data8 0xF2027E10C7AF8C38, 0x0000BFF7 // E0
+LOCAL_OBJECT_END(lgammal_13Q_2Q_data)
+
+LOCAL_OBJECT_START(lgammal_8_10_data)
+// Polynomial coefficients for the lgammal(x), 8.0 <= |x| < 10.0
+// Multi Precision terms
+data8 0x40312008A3A23E5C, 0x3CE020B4F2E4083A //A1
+data8 0x4025358E82FCB70C, 0x3CD4A5A74AF7B99C //A0
+// Native precision terms
+data8 0xF0AA239FFBC616D2, 0x00004000 //A2
+data8 0x96A8EA798FE57D66, 0x0000BFFF //A3
+data8 0x8D501B7E3B9B9BDB, 0x00003FFE //A4
+data8 0x9EE062401F4B1DC2, 0x0000BFFD //A5
+data8 0xC63FD8CD31E93431, 0x00003FFC //A6
+data8 0x8461101709C23C30, 0x0000BFFC //A7
+data8 0xB96D7EA7EF3648B2, 0x00003FFB //A8
+data8 0x86886759D2ACC906, 0x0000BFFB //A9
+data8 0xC894B6E28265B183, 0x00003FFA //A10
+data8 0x98C4348CAD821662, 0x0000BFFA //A11
+data8 0xEC9B092226A94DF2, 0x00003FF9 //A12
+data8 0xB9F169FF9B98CDDC, 0x0000BFF9 //A13
+data8 0x9A3A32BB040894D3, 0x00003FF9 //A14
+data8 0xF9504CCC1003B3C3, 0x0000BFF8 //A15
+LOCAL_OBJECT_END(lgammal_8_10_data)
+
+LOCAL_OBJECT_START(lgammal_03Q_6_data)
+// Polynomial coefficients for the lgammal(x), 0.75 <= |x| < 1.0
+data8 0xBFBC47DCA479E295, 0xBC607E6C1A379D55 //A3
+data8 0x3FCA051C372609ED, 0x3C7B02D73EB7D831 //A0
+data8 0xBFE15FAFA86B04DB, 0xBC3F52EE4A8945B5 //A1
+data8 0x3FD455C4FF28F0BF, 0x3C75F8C6C99F30BB //A2
+data8 0xD2CF04CD934F03E1, 0x00003FFA //A4
+data8 0xDB4ED667E29256E1, 0x0000BFF9 //A5
+data8 0xF155A33A5B6021BF, 0x00003FF8 //A6
+data8 0x895E9B9D386E0338, 0x0000BFF8 //A7
+data8 0xA001BE94B937112E, 0x00003FF7 //A8
+data8 0xBD82846E490ED048, 0x0000BFF6 //A9
+data8 0xE358D24EC30DBB5D, 0x00003FF5 //A10
+data8 0x89C4F3652446B78B, 0x0000BFF5 //A11
+data8 0xA86043E10280193D, 0x00003FF4 //A12
+data8 0xCF3A2FBA61EB7682, 0x0000BFF3 //A13
+data8 0x3F300900CC9200EC //A14
+data8 0xBF23F42264B94AE8 //A15
+data8 0x3F18EEF29895FE73 //A16
+data8 0xBF0F3C4563E3EDFB //A17
+data8 0x3F0387DBBC385056 //A18
+data8 0xBEF81B4004F92900 //A19
+data8 0x3EECA6692A9A5B81 //A20
+data8 0xBEDF61A0059C15D3 //A21
+data8 0x3ECDA9F40DCA0111 //A22
+data8 0xBEB60FE788217BAF //A23
+data8 0x3E9661D795DFC8C6 //A24
+data8 0xBE66C7756A4EDEE5 //A25
+// Polynomial coefficients for the lgammal(x), 1.0 <= |x| < 2.0
+data8 0xBFC1AE55B180726B, 0xBC7DE1BC478453F5 //A3
+data8 0xBFBEEB95B094C191, 0xBC53456FF6F1C9D9 //A0
+data8 0x3FA2AED059BD608A, 0x3C0B65CC647D557F //A1
+data8 0x3FDDE9E64DF22EF2, 0x3C8993939A8BA8E4 //A2
+data8 0xF07C206D6B100CFF, 0x00003FFA //A4
+data8 0xED2CEA9BA52FE7FB, 0x0000BFF9 //A5
+data8 0xFCE51CED52DF3602, 0x00003FF8 //A6
+data8 0x8D45D27872326619, 0x0000BFF8 //A7
+data8 0xA2B78D6BCEBE27F7, 0x00003FF7 //A8
+data8 0xBF6DC0996A895B6F, 0x0000BFF6 //A9
+data8 0xE4B9AD335AF82D79, 0x00003FF5 //A10
+data8 0x8A451880195362A1, 0x0000BFF5 //A11
+data8 0xA8BE35E63089A7A9, 0x00003FF4 //A12
+data8 0xCF7FA175FA11C40C, 0x0000BFF3 //A13
+data8 0x3F300C282FAA3B02 //A14
+data8 0xBF23F6AEBDA68B80 //A15
+data8 0x3F18F6860E2224DD //A16
+data8 0xBF0F542B3CE32F28 //A17
+data8 0x3F039436218C9BF8 //A18
+data8 0xBEF8AE6307677AEC //A19
+data8 0x3EF0B55527B3A211 //A20
+data8 0xBEE576AC995E7605 //A21
+data8 0x3ED102DDC1365D2D //A22
+data8 0xBEC442184F97EA54 //A23
+data8 0x3ED4D2283DFE5FC6 //A24
+data8 0xBECB9219A9B46787 //A25
+// Polynomial coefficients for the lgammal(x), 2.0 <= |x| < 3.0
+data8 0xBFCA4D55BEAB2D6F, 0xBC66F80E5BFD5AF5 //A3
+data8 0x3FE62E42FEFA39EF, 0x3C7ABC9E3B347E3D //A0
+data8 0x3FFD8773039049E7, 0x3C66CB9007C426EA //A1
+data8 0x3FE94699894C1F4C, 0x3C918726EB111663 //A2
+data8 0xA264558FB0906209, 0x00003FFB //A4
+data8 0x94D6C50FEB902ADC, 0x0000BFFA //A5
+data8 0x9620656184243D17, 0x00003FF9 //A6
+data8 0xA0D0983B8BCA910B, 0x0000BFF8 //A7
+data8 0xB36AF8559B222BD3, 0x00003FF7 //A8
+data8 0xCE0DACB3260AE6E5, 0x0000BFF6 //A9
+data8 0xF1C2C0BF0437C7DB, 0x00003FF5 //A10
+data8 0x902A2F2F3AB74A92, 0x0000BFF5 //A11
+data8 0xAE05009B1B2C6E4C, 0x00003FF4 //A12
+data8 0xD5B71F6456D7D4CB, 0x0000BFF3 //A13
+data8 0x3F2F0351D71BC9C6 //A14
+data8 0xBF2B53BC56A3B793 //A15
+data8 0xBF18B12DC6F6B861 //A16
+data8 0xBF43EE6EB5215C2F //A17
+data8 0xBF5474787CDD455E //A18
+data8 0xBF642B503C9C060A //A19
+data8 0xBF6E07D1AA254AA3 //A20
+data8 0xBF71C785443AAEE8 //A21
+data8 0xBF6F67BF81B71052 //A22
+data8 0xBF63E4BCCF4FFABF //A23
+data8 0xBF50067F8C671D5A //A24
+data8 0xBF29C770D680A5AC //A25
+// Polynomial coefficients for the lgammal(x), 4.0 <= |x| < 6.0
+data8 0xBFD6626BC9B31B54, 0xBC85AABE08680902 //A3
+data8 0x401326643C4479C9, 0x3CAA53C26F31E364 //A0
+data8 0x401B4C420A50AD7C, 0x3C8C76D55E57DD8D //A1
+data8 0x3FF735973273D5EC, 0x3C83A0B78E09188A //A2
+data8 0x81310136363AAB6D, 0x00003FFC //A4
+data8 0xDF1BD44C4075C0E6, 0x0000BFFA //A5
+data8 0xD58389FE38D8D664, 0x00003FF9 //A6
+data8 0xDA62C7221D5B5F87, 0x0000BFF8 //A7
+data8 0xE9F92CAD0263E157, 0x00003FF7 //A8
+data8 0x81ACCB8606C165FE, 0x0000BFF7 //A9
+data8 0x9382D8D263D1C2A3, 0x00003FF6 //A10
+data8 0xAB3CCBA4C853B12C, 0x0000BFF5 //A11
+data8 0xCA0818BBCCC59296, 0x00003FF4 //A12
+data8 0xF18912691CBB5BD0, 0x0000BFF3 //A13
+data8 0x3F323EF5D8330339 //A14
+data8 0xBF2641132EA571F7 //A15
+data8 0x3F1B5D9576175CA9 //A16
+data8 0xBF10F56A689C623D //A17
+data8 0x3F04CACA9141A18D //A18
+data8 0xBEFA307AC9B4E85D //A19
+data8 0x3EF4B625939FBE32 //A20
+data8 0xBECEE6AC1420F86F //A21
+data8 0xBE9A95AE2E485964 //A22
+data8 0xBF039EF47F8C09BB //A23
+data8 0xBF05345957F7B7A9 //A24
+data8 0xBEF85AE6385D4CCC //A25
+// Polynomial coefficients for the lgammal(x), 3.0 <= |x| < 4.0
+data8 0xBFCA4D55BEAB2D6F, 0xBC667B20FF46C6A8 //A3
+data8 0x3FE62E42FEFA39EF, 0x3C7ABC9E3B398012 //A0
+data8 0x3FFD8773039049E7, 0x3C66CB9070238D77 //A1
+data8 0x3FE94699894C1F4C, 0x3C91873D8839B1CD //A2
+data8 0xA264558FB0906D7E, 0x00003FFB //A4
+data8 0x94D6C50FEB8AFD72, 0x0000BFFA //A5
+data8 0x9620656185B68F14, 0x00003FF9 //A6
+data8 0xA0D0983B34B7088A, 0x0000BFF8 //A7
+data8 0xB36AF863964AA440, 0x00003FF7 //A8
+data8 0xCE0DAAFB5497AFB8, 0x0000BFF6 //A9
+data8 0xF1C2EAFA79CC2864, 0x00003FF5 //A10
+data8 0x9028922A839572B8, 0x0000BFF5 //A11
+data8 0xAE1E62F870BA0278, 0x00003FF4 //A12
+data8 0xD4726F681E2ABA29, 0x0000BFF3 //A13
+data8 0x3F30559B9A02FADF //A14
+data8 0xBF243ADEB1266CAE //A15
+data8 0x3F19303B6F552603 //A16
+data8 0xBF0F768C288EC643 //A17
+data8 0x3F039D5356C21DE1 //A18
+data8 0xBEF81BCA8168E6BE //A19
+data8 0x3EEC74A53A06AD54 //A20
+data8 0xBEDED52D1A5DACDF //A21
+data8 0x3ECCB4C2C7087342 //A22
+data8 0xBEB4F1FAFDFF5C2F //A23
+data8 0x3E94C80B52D58904 //A24
+data8 0xBE64A328CBE92A27 //A25
+LOCAL_OBJECT_END(lgammal_03Q_6_data)
+
+LOCAL_OBJECT_START(lgammal_1pEps_data)
+// Polynomial coefficients for the lgammal(x), 1 - 2^(-7) <= |x| < 1 + 2^(-7)
+data8 0x93C467E37DB0C7A5, 0x00003FFE //A1
+data8 0xD28D3312983E9919, 0x00003FFE //A2
+data8 0xCD26AADF559A47E3, 0x00003FFD //A3
+data8 0x8A8991563EC22E81, 0x00003FFD //A4
+data8 0x3FCA8B9C168D52FE //A5
+data8 0x3FC5B40CB0696370 //A6
+data8 0x3FC270AC2229A65D //A7
+data8 0x3FC0110AF10FCBFC //A8
+// Polynomial coefficients for the log1p(x), - 2^(-7) <= |x| <  2^(-7)
+data8 0x3FBC71C71C71C71C //P8
+data8 0xBFC0000000000000 //P7
+data8 0x3FC2492492492492 //P6
+data8 0xBFC5555555555555 //P5
+data8 0x3FC999999999999A //P4
+data8 0xBFD0000000000000 //P3
+data8 0x3FD5555555555555 //P2
+data8 0xBFE0000000000000 //P1
+// short version of "lnsin" polynomial
+data8 0xD28D3312983E9918, 0x00003FFF //A2
+data8 0x8A8991563EC241B6, 0x00003FFE //A4
+data8 0xADA06588061830A5, 0x00003FFD //A6
+data8 0x80859B57C31CB746, 0x00003FFD //A8
+LOCAL_OBJECT_END(lgammal_1pEps_data)
+
+LOCAL_OBJECT_START(lgammal_neg2andHalf_data)
+// Polynomial coefficients for the lgammal(x), -2.005859375 <= x < -2.5
+data8 0xBF927781D4BB093A, 0xBC511D86D85B7045 // A3, A0L
+data8 0x3FF1A68793DEFC15, 0x3C9852AE2DA7DEEF // A1, A1L
+data8 0x408555562D45FAFD, 0xBF972CDAFE5FEFAD // D0, D1
+data8 0xC18682331EF492A5, 0xC1845E3E0D29606B // C20, C21
+data8 0x4013141822E16979, 0x3CCF8718B6E75F6C // A2, A2L
+data8 0xBFACCBF9F5ED0F15, 0xBBDD1AEB73297401 // A0, A3L
+data8 0xCCCDB17423046445, 0x00004006 // E6
+data8 0x800514E230A3A452, 0x00004005 // E4
+data8 0xAAE9A48EC162E76F, 0x00004003 // E2
+data8 0x81D4F88B3F3EA0FC, 0x00004002 // E0
+data8 0x40CF3F3E35238DA0, 0xC0F8B340945F1A7E // D6, D7
+data8 0x40BF89EC0BD609C6, 0xC095897242AEFEE2 // D4, D5
+data8 0x40A2482FF01DBC5C, 0xC02095E275FDCF62 // D2, D3
+data8 0xC1641354F2312A6A, 0xC17B3657F85258E9 // C18, C19
+data8 0xC11F964E9ECBE2C9, 0xC146D7A90F70696C // C16, C17
+data8 0xE7AECDE6AF8EA816, 0x0000BFEF // E7
+data8 0xD711252FEBBE1091, 0x0000BFEB // E5
+data8 0xE648BD10F8C43391, 0x0000BFEF // E3
+data8 0x948A1E78AA00A98D, 0x0000BFF4 // E1
+LOCAL_OBJECT_END(lgammal_neg2andHalf_data)
+
+LOCAL_OBJECT_START(lgammal_near_neg_half_data)
+// Polynomial coefficients for the lgammal(x), -0.5 < x < -0.40625
+data8 0xBFC1AE55B180726C, 0x3C8053CD734E6A1D // A3, A0L
+data8 0x3FA2AED059BD608A, 0x3C0CD3D2CDBA17F4 // A1, A1L
+data8 0x40855554DBCD1E1E, 0x3F96C51AC2BEE9E1 // D0, D1
+data8 0xC18682331EF4927D, 0x41845E3E0D295DFC // C20, C21
+data8 0x4011DE9E64DF22EF, 0x3CA692B70DAD6B7B // A2, A2L
+data8 0x3FF43F89A3F0EDD6, 0xBC4955AED0FA087D // A0, A3L
+data8 0xCCCD3F1DF4A2C1DD, 0x00004006 // E6
+data8 0x80028ADE33C7FCD9, 0x00004005 // E4
+data8 0xAACA474E485507EF, 0x00004003 // E2
+data8 0x80F07C206D6B0ECD, 0x00004002 // E0
+data8 0x40CF3F3E33E83056, 0x40F8B340944633D9 // D6, D7
+data8 0x40BF89EC059931F0, 0x409589723307AD20 // D4, D5
+data8 0x40A2482FD0054824, 0x402095CE7F19D011 // D2, D3
+data8 0xC1641354F2313614, 0x417B3657F8525354 // C18, C19
+data8 0xC11F964E9ECFD21C, 0x4146D7A90F701836 // C16, C17
+data8 0x86A9C01F0EA11E5A, 0x0000BFF5 // E7
+data8 0xBF6D8469142881C0, 0x0000BFF6 // E5
+data8 0x8D45D277BA8255F1, 0x0000BFF8 // E3
+data8 0xED2CEA9BA528BCC3, 0x0000BFF9 // E1
+LOCAL_OBJECT_END(lgammal_near_neg_half_data)
+
+//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+////////////// POLYNOMIAL COEFFICIENTS FOR "NEAR ROOTS" RANGES    /////////////
+////////////// THIS PART OF TABLE SHOULD BE ADDRESSED REALLY RARE /////////////
+//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+LOCAL_OBJECT_START(lgammal_right_roots_polynomial_data)
+// Polynomial coefficients for right root on [-3, -2]
+// Lgammal is approximated by polynomial within [-.056244 ; .158208 ] range
+data8 0xBBBD5E9DCD11030B, 0xB867411D9FF87DD4 //A0
+data8 0x3FF83FE966AF535E, 0x3CAA21235B8A769A //A1
+data8 0x40136EEBB002F55C, 0x3CC3959A6029838E //A2
+data8 0xB4A5302C53C2BEDD, 0x00003FFF //A3
+data8 0x8B8C6BE504F2DA1C, 0x00004002 //A4
+data8 0xB99CFF02593B4D98, 0x00004001 //A5
+data8 0x4038D32F682AA1CF //A6
+data8 0x403809F04EE6C5B5 //A7
+data8 0x40548EAA81634CEE //A8
+data8 0x4059297ADB6BC03D //A9
+data8 0x407286FB8EC5C9DA //A10
+data8 0x407A92E05B744CFB //A11
+data8 0x4091A9D4144258CD //A12
+data8 0x409C4D01D24F367E //A13
+data8 0x40B1871B9A426A83 //A14
+data8 0x40BE51C48BD9A583 //A15
+data8 0x40D2140D0C6153E7 //A16
+data8 0x40E0FB2C989CE4A3 //A17
+data8 0x40E52739AB005641 //A18
+data8 0x41161E3E6DDF503A //A19
+// Polynomial coefficients for right root on [-4, -3]
+// Lgammal is approximated by polynomial within [-.172797 ; .171573 ] range
+data8 0x3C172712B248E42E, 0x38CB8D17801A5D67 //A0
+data8 0x401F20A65F2FAC54, 0x3CCB9EA1817A824E //A1
+data8 0x4039D4D2977150EF, 0x3CDA42E149B6276A //A2
+data8 0xE089B8926AE2D9CB, 0x00004005 //A3
+data8 0x933901EBBB586C37, 0x00004008 //A4
+data8 0xCCD319BED1CFA1CD, 0x0000400A //A5
+data8 0x40D293C3F78D3C37 //A6
+data8 0x40FBB97AA0B6DD02 //A7
+data8 0x41251EA3345E5EB9 //A8
+data8 0x415057F65C92E7B0 //A9
+data8 0x41799C865241B505 //A10
+data8 0x41A445209EFE896B //A11
+data8 0x41D02D21880C953B //A12
+data8 0x41F9FFDE8C63E16D //A13
+data8 0x422504DC8302D2BE //A14
+data8 0x425111BF18C95414 //A15
+data8 0x427BCBE74A2B8EF7 //A16
+data8 0x42A7256F59B286F7 //A17
+data8 0x42D462D1586DE61F //A18
+data8 0x42FBB1228D6C5118 //A19
+// Polynomial coefficients for right root on [-5, -4]
+// Lgammal is approximated by polynomial within [-.163171 ; .161988 ] range
+data8 0x3C5840FBAFDEE5BB, 0x38CAC0336E8C490A //A0
+data8 0x403ACA5CF4921642, 0x3CCEDCDDA5491E56 //A1
+data8 0x40744415CD813F8E, 0x3CFBFEBC17E39146 //A2
+data8 0xAACD88D954E3E1BD, 0x0000400B //A3
+data8 0xCB68C710D75ED802, 0x0000400F //A4
+data8 0x8130F5AB997277AC, 0x00004014 //A5
+data8 0x41855E3DBF99EBA7 //A6
+data8 0x41CD14FE49C49FC2 //A7
+data8 0x421433DCE281F07D //A8
+data8 0x425C8399C7A92B6F //A9
+data8 0x42A45FBE67840F1A //A10
+data8 0x42ED68D75F9E6C98 //A11
+data8 0x433567291C27E5BE //A12
+data8 0x437F5ED7A9D9FD28 //A13
+data8 0x43C720A65C8AB711 //A14
+data8 0x441120A6C1D40B9B //A15
+data8 0x44596F561F2D1CBE //A16
+data8 0x44A3507DA81D5C01 //A17
+data8 0x44EF06A31E39EEDF //A18
+data8 0x45333774C99F523F //A19
+// Polynomial coefficients for right root on [-6, -5]
+// Lgammal is approximated by polynomial within [-.156450 ; .156126 ] range
+data8 0x3C71B82D6B2B3304, 0x3917186E3C0DC231 //A0
+data8 0x405ED72E0829AE02, 0x3C960C25157980EB //A1
+data8 0x40BCECC32EC22F9B, 0x3D5D8335A32F019C //A2
+data8 0x929EC2B1FB931F17, 0x00004012 //A3
+data8 0xD112EF96D37316DE, 0x00004018 //A4
+data8 0x9F00BB9BB13416AB, 0x0000401F //A5
+data8 0x425F7D8D5BDCB223 //A6
+data8 0x42C9A8D00C776CC6 //A7
+data8 0x433557FD8C481424 //A8
+data8 0x43A209221A953EF0 //A9
+data8 0x440EDC98D5618AB7 //A10
+data8 0x447AABD25E367378 //A11
+data8 0x44E73DE20CC3B288 //A12
+data8 0x455465257B4E0BD8 //A13
+data8 0x45C2011532085353 //A14
+data8 0x462FEE4CC191945B //A15
+data8 0x469C63AEEFEF0A7F //A16
+data8 0x4709D045390A3810 //A17
+data8 0x4778D360873C9F64 //A18
+data8 0x47E26965BE9A682A //A19
+// Polynomial coefficients for right root on [-7, -6]
+// Lgammal is approximated by polynomial within [-.154582 ; .154521 ] range
+data8 0x3C75F103A1B00A48, 0x391C041C190C726D //A0
+data8 0x40869DE49E3AF2AA, 0x3D1C17E1F813063B //A1
+data8 0x410FCE23484CFD10, 0x3DB6F38C2F11DAB9 //A2
+data8 0xEF281D1E1BE2055A, 0x00004019 //A3
+data8 0xFCE3DA92AC55DFF8, 0x00004022 //A4
+data8 0x8E9EA838A20BD58E, 0x0000402C //A5
+data8 0x4354F21E2FB9E0C9 //A6
+data8 0x43E9500994CD4F09 //A7
+data8 0x447F3A2C23C033DF //A8
+data8 0x45139152656606D8 //A9
+data8 0x45A8D45F8D3BF2E8 //A10
+data8 0x463FD32110E5BFE5 //A11
+data8 0x46D490B3BDBAE0BE //A12
+data8 0x476AC3CAD905DD23 //A13
+data8 0x48018558217AD473 //A14
+data8 0x48970AF371D30585 //A15
+data8 0x492E6273A8BEFFE3 //A16
+data8 0x49C47CC9AE3F1073 //A17
+data8 0x4A5D38E8C35EFF45 //A18
+data8 0x4AF0123E89694CD8 //A19
+// Polynomial coefficients for right root on [-8, -7]
+// Lgammal is approximated by polynomial within [-.154217 ; .154208 ] range
+data8 0xBCD2507D818DDD68, 0xB97F6940EA2871A0 //A0
+data8 0x40B3B407AA387BCB, 0x3D6320238F2C43D1 //A1
+data8 0x41683E85DAAFBAC7, 0x3E148D085958EA3A //A2
+data8 0x9F2A95AF1E10A548, 0x00004022 //A3
+data8 0x92F21522F482300E, 0x0000402E //A4
+data8 0x90B51AB03A1F244D, 0x0000403A //A5
+data8 0x44628E1C70EF534F //A6
+data8 0x452393E2BC32D244 //A7
+data8 0x45E5164141F4BA0B //A8
+data8 0x46A712B3A8AF5808 //A9
+data8 0x47698FD36CEDD0F2 //A10
+data8 0x482C9AE6BBAA3637 //A11
+data8 0x48F023821857C8E9 //A12
+data8 0x49B2569053FC106F //A13
+data8 0x4A74F646D5C1604B //A14
+data8 0x4B3811CF5ABA4934 //A15
+data8 0x4BFBB5DD6C84E233 //A16
+data8 0x4CC05021086F637B //A17
+data8 0x4D8450A345B0FB49 //A18
+data8 0x4E43825848865DB2 //A19
+// Polynomial coefficients for right root on [-9, -8]
+// Lgammal is approximated by polynomial within [-.154160 ; .154158 ] range
+data8 0x3CDF4358564F2B46, 0x397969BEE6042F81 //A0
+data8 0x40E3B088FED67721, 0x3D82787BA937EE85 //A1
+data8 0x41C83A3893550EF4, 0x3E542ED57E244DA8 //A2
+data8 0x9F003C6DC56E0B8E, 0x0000402B //A3
+data8 0x92BDF64A3213A699, 0x0000403A //A4
+data8 0x9074F503AAD417AF, 0x00004049 //A5
+data8 0x4582843E1313C8CD //A6
+data8 0x467387BD6A7826C1 //A7
+data8 0x4765074E788CF440 //A8
+data8 0x4857004DD9D1E09D //A9
+data8 0x4949792ED7530EAF //A10
+data8 0x4A3C7F089A292ED3 //A11
+data8 0x4B30125BF0AABB86 //A12
+data8 0x4C224175195E307E //A13
+data8 0x4D14DC4C8B32C08D //A14
+data8 0x4E07F1DB2786197E //A15
+data8 0x4EFB8EA1C336DACB //A16
+data8 0x4FF03797EACD0F23 //A17
+data8 0x50E4304A8E68A730 //A18
+data8 0x51D3618FB2EC9F93 //A19
+// Polynomial coefficients for right root on [-10, -9]
+// Lgammal is approximated by polynomial within [-.154152 ; .154152 ] range
+data8 0x3D42F34DA97ECF0C, 0x39FD1256F345B0D0 //A0
+data8 0x4116261203919787, 0x3DC12D44055588EB //A1
+data8 0x422EA8F32FB7FE99, 0x3ED849CE4E7B2D77 //A2
+data8 0xE25BAF73477A57B5, 0x00004034 //A3
+data8 0xEB021FD10060504A, 0x00004046 //A4
+data8 0x8220A208EE206C5F, 0x00004059 //A5
+data8 0x46B2C3903EC9DA14 //A6
+data8 0x47D64393744B9C67 //A7
+data8 0x48FAF79CCDC604DD //A8
+data8 0x4A20975DB8061EBA //A9
+data8 0x4B44AB9CBB38DB21 //A10
+data8 0x4C6A032F60094FE9 //A11
+data8 0x4D908103927634B4 //A12
+data8 0x4EB516CA21D30861 //A13
+data8 0x4FDB1BF12C58D318 //A14
+data8 0x510180AAE094A553 //A15
+data8 0x5226A8F2A2D45D57 //A16
+data8 0x534E00B6B0C8B809 //A17
+data8 0x5475022FE21215B2 //A18
+data8 0x5596B02BF6C5E19B //A19
+// Polynomial coefficients for right root on [-11, -10]
+// Lgammal is approximated by polynomial within [-.154151 ; .154151 ] range
+data8 0x3D7AA9C2E2B1029C, 0x3A15FB37578544DB //A0
+data8 0x414BAF825A0C91D4, 0x3DFB9DA2CE398747 //A1
+data8 0x4297F3EC8AE0AF03, 0x3F34208B55FB8781 //A2
+data8 0xDD0C97D3197F56DE, 0x0000403E //A3
+data8 0x8F6F3AF7A5499674, 0x00004054 //A4
+data8 0xC68DA1AF6D878EEB, 0x00004069 //A5
+data8 0x47F1E4E1E2197CE0 //A6
+data8 0x494A8A28E597C3EB //A7
+data8 0x4AA4175D0D35D705 //A8
+data8 0x4BFEE6F0AF69E814 //A9
+data8 0x4D580FE7B3DBB3C6 //A10
+data8 0x4EB2ECE60E4608AF //A11
+data8 0x500E04BE3E2B4F24 //A12
+data8 0x5167F9450F0FB8FD //A13
+data8 0x52C342BDE747603F //A14
+data8 0x541F1699D557268C //A15
+data8 0x557927C5F079864E //A16
+data8 0x56D4D10FEEDB030C //A17
+data8 0x5832385DF86AD28A //A18
+data8 0x598898914B4D6523 //A19
+// Polynomial coefficients for right root on [-12, -11]
+// Lgammal is approximated by polynomial within [-.154151 ; .154151 ] range
+data8 0xBD96F61647C58B03, 0xBA3ABB0C2A6C755B //A0
+data8 0x418308A82714B70D, 0x3E1088FC6A104C39 //A1
+data8 0x4306A493DD613C39, 0x3FB2341ECBF85741 //A2
+data8 0x8FA8FE98339474AB, 0x00004049 //A3
+data8 0x802CCDF570BA7942, 0x00004062 //A4
+data8 0xF3F748AF11A32890, 0x0000407A //A5
+data8 0x493E3B567EF178CF //A6
+data8 0x4ACED38F651BA362 //A7
+data8 0x4C600B357337F946 //A8
+data8 0x4DF0F71A52B54CCF //A9
+data8 0x4F8229F3B9FA2C70 //A10
+data8 0x5113A4C4979B770E //A11
+data8 0x52A56BC367F298D5 //A12
+data8 0x543785CF31842DC0 //A13
+data8 0x55C9FC37E3E40896 //A14
+data8 0x575CD5D1BA556C82 //A15
+data8 0x58F00A7AD99A9E08 //A16
+data8 0x5A824088688B008D //A17
+data8 0x5C15F75EF7E08EBD //A18
+data8 0x5DA462EA902F0C90 //A19
+// Polynomial coefficients for right root on [-13, -12]
+// Lgammal is approximated by polynomial within [-.154151 ; .154151 ] range
+data8 0x3DC3191752ACFC9D, 0x3A26CB6629532DBF //A0
+data8 0x41BC8CFC051191BD, 0x3E68A84DA4E62AF2 //A1
+data8 0x43797926294A0148, 0x400F345FF3723CFF //A2
+data8 0xF26D2AF700B82625, 0x00004053 //A3
+data8 0xA238B24A4B1F7B15, 0x00004070 //A4
+data8 0xE793B5C0A41A264F, 0x0000408C //A5
+data8 0x4A9585BDDACE863D //A6
+data8 0x4C6075953448088A //A7
+data8 0x4E29B2F38D1FC670 //A8
+data8 0x4FF4619B079C440F //A9
+data8 0x51C05DAE118D8AD9 //A10
+data8 0x538A8C7F87326AD4 //A11
+data8 0x5555B6937588DAB3 //A12
+data8 0x5721E1F8B6E6A7DB //A13
+data8 0x58EDA1D7A77DD6E5 //A14
+data8 0x5AB8A9616B7DC9ED //A15
+data8 0x5C84942AA209ED17 //A16
+data8 0x5E518FC34C6F54EF //A17
+data8 0x601FB3F17BCCD9A0 //A18
+data8 0x61E61128D512FE97 //A1
+// Polynomial coefficients for right root on [-14, -13]
+// Lgammal is approximated by polynomial within [-.154151 ; .154151 ] range
+data8 0xBE170D646421B3F5, 0xBAAD95F79FCB5097 //A0
+data8 0x41F7328CBFCD9AC7, 0x3E743B8B1E8AEDB1 //A1
+data8 0x43F0D0FA2DBDA237, 0x40A0422D6A227B55 //A2
+data8 0x82082DF2D32686CC, 0x0000405F //A3
+data8 0x8D64EE9B42E68B43, 0x0000407F //A4
+data8 0xA3FFD82E08C5F1F1, 0x0000409F //A5
+data8 0x4BF8C49D99123454 //A6
+data8 0x4DFEC79DDF11342F //A7
+data8 0x50038615A892F6BD //A8
+data8 0x520929453DB32EF1 //A9
+data8 0x54106A7808189A7F //A10
+data8 0x5615A302D03C207B //A11
+data8 0x581CC175AA736F5E //A12
+data8 0x5A233E071147C017 //A13
+data8 0x5C29E81917243F22 //A14
+data8 0x5E3184B0B5AC4707 //A15
+data8 0x6037C11DE62D8388 //A16
+data8 0x6240787C4B1C9D6C //A17
+data8 0x6448289235E80977 //A18
+data8 0x664B5352C6C3449E //A19
+// Polynomial coefficients for right root on [-15, -14]
+// Lgammal is approximated by polynomial within [-.154151 ; .154151 ] range
+data8 0x3E562C2E34A9207D, 0x3ADC00DA3DFF7A83 //A0
+data8 0x42344C3B2F0D90AB, 0x3EB8A2E979F24536 //A1
+data8 0x4469BFFF28B50D07, 0x41181E3D05C1C294 //A2
+data8 0xAE38F64DCB24D9F8, 0x0000406A //A3
+data8 0xA5C3F52C1B350702, 0x0000408E //A4
+data8 0xA83BC857BCD67A1B, 0x000040B2 //A5
+data8 0x4D663B4727B4D80A //A6
+data8 0x4FA82C965B0F7788 //A7
+data8 0x51EAD58C02908D95 //A8
+data8 0x542E427970E073D8 //A9
+data8 0x56714644C558A818 //A10
+data8 0x58B3EC2040C77BAE //A11
+data8 0x5AF72AE6A83D45B1 //A12
+data8 0x5D3B214F611F5D12 //A13
+data8 0x5F7FF5E49C54E92A //A14
+data8 0x61C2E917AB765FB2 //A15
+data8 0x64066FD70907B4C1 //A16
+data8 0x664B3998D60D0F9B //A17
+data8 0x689178710782FA8B //A18
+data8 0x6AD14A66C1C7BEC3 //A19
+// Polynomial coefficients for right root on [-16, -15]
+// Lgammal is approximated by polynomial within [-.154151 ; .154151 ] range
+data8 0xBE6D7E7192615BAE, 0xBB0137677D7CC719 //A0
+data8 0x4273077763F6628C, 0x3F09250FB8FC8EC9 //A1
+data8 0x44E6A1BF095B1AB3, 0x4178D5A74F6CB3B3 //A2
+data8 0x8F8E0D5060FCC76E, 0x00004076 //A3
+data8 0x800CC1DCFF092A63, 0x0000409E //A4
+data8 0xF3AB0BA9D14CDA72, 0x000040C5 //A5
+data8 0x4EDE3000A2F6D54F //A6
+data8 0x515EC613B9C8E241 //A7
+data8 0x53E003309FEEEA96 //A8
+data8 0x5660ED908D7C9A90 //A9
+data8 0x58E21E9B517B1A50 //A10
+data8 0x5B639745E4374EE2 //A11
+data8 0x5DE55BB626B2075D //A12
+data8 0x606772B7506BA747 //A13
+data8 0x62E9E581AB2E057B //A14
+data8 0x656CBAD1CF85D396 //A15
+data8 0x67EFF4EBD7989872 //A16
+data8 0x6A722D2B19B7E2F9 //A17
+data8 0x6CF5DEB3073B0743 //A18
+data8 0x6F744AC11550B93A //A19
+// Polynomial coefficients for right root on [-17, -16]
+// Lgammal is approximated by polynomial within [-.154151 ; .154151 ] range
+data8 0xBEDCC6291188207E, 0xBB872E3FDD48F5B7 //A0
+data8 0x42B3076EE7525EF9, 0x3F6687A5038CA81C //A1
+data8 0x4566A1AAD96EBCB5, 0x421F0FEDFBF548D2 //A2
+data8 0x8F8D4D3DE9850DBA, 0x00004082 //A3
+data8 0x800BDD6DA2CE1859, 0x000040AE //A4
+data8 0xF3A8EC4C9CDC1CE5, 0x000040D9 //A5
+data8 0x505E2FAFDB812628 //A6
+data8 0x531EC5B3A7508719 //A7
+data8 0x55E002F77E99B628 //A8
+data8 0x58A0ED4C9B4DAE54 //A9
+data8 0x5B621E4A8240F90C //A10
+data8 0x5E2396E5C8849814 //A11
+data8 0x60E55B43D8C5CE71 //A12
+data8 0x63A7722F5D45D01D //A13
+data8 0x6669E4E010DCE45A //A14
+data8 0x692CBA120D5E78F6 //A15
+data8 0x6BEFF4045350B22E //A16
+data8 0x6EB22C9807C21819 //A17
+data8 0x7175DE20D04617C4 //A18
+data8 0x74344AB87C6D655F //A19
+// Polynomial coefficients for right root on [-18, -17]
+// Lgammal is approximated by polynomial within [-.154151 ; .154151 ] range
+data8 0xBF28AEEE7B61D77C, 0xBBDBBB5FC57ABF79 //A0
+data8 0x42F436F56B3B8A0C, 0x3FA43EE3C5C576E9 //A1
+data8 0x45E98A22535D115D, 0x42984678BE78CC48 //A2
+data8 0xAC176F3775E6FCFC, 0x0000408E //A3
+data8 0xA3114F53A9FEB922, 0x000040BE //A4
+data8 0xA4D168A8334ABF41, 0x000040EE //A5
+data8 0x51E5B0E7EC7182BB //A6
+data8 0x54E77D67B876EAB6 //A7
+data8 0x57E9F7C30C09C4B6 //A8
+data8 0x5AED29B0488614CA //A9
+data8 0x5DF09486F87E79F9 //A10
+data8 0x60F30B199979654E //A11
+data8 0x63F60E02C7DCCC5F //A12
+data8 0x66F9B8A00EB01684 //A13
+data8 0x69FE2D3ED0700044 //A14
+data8 0x6D01C8363C7DCC84 //A15
+data8 0x700502B29C2F06E3 //A16
+data8 0x730962B4500F4A61 //A17
+data8 0x76103C6ED099192A //A18
+data8 0x79100C7132CFD6E3 //A19
+// Polynomial coefficients for right root on [-19, -18]
+// Lgammal is approximated by polynomial within [-.154151 ; .154151 ] range
+data8 0x3F3C19A53328A0C3, 0x3BE04ADC3FBE1458 //A0
+data8 0x4336C16C16C16C19, 0x3FE58CE3AC4A7C28 //A1
+data8 0x46702E85C0898B70, 0x432C922E412CEC6E //A2
+data8 0xF57B99A1C034335D, 0x0000409A //A3
+data8 0x82EC9634223DF909, 0x000040CF //A4
+data8 0x94F66D7557E2EA60, 0x00004103 //A5
+data8 0x5376118B79AE34D0 //A6
+data8 0x56BAE7106D52E548 //A7
+data8 0x5A00BD48CC8E25AB //A8
+data8 0x5D4529722821B493 //A9
+data8 0x608B1654AF31BBC1 //A10
+data8 0x63D182CC98AEA859 //A11
+data8 0x6716D43D5EEB05E8 //A12
+data8 0x6A5DF884FC172E1C //A13
+data8 0x6DA3CA7EBB97976B //A14
+data8 0x70EA416D0BE6D2EF //A15
+data8 0x743176C31EBB65F2 //A16
+data8 0x7777C401A8715CF9 //A17
+data8 0x7AC1110C6D350440 //A18
+data8 0x7E02D0971CF84865 //A19
+// Polynomial coefficients for right root on [-20, -19]
+// Lgammal is approximated by polynomial within [-.154151 ; .154151 ] range
+data8 0xBFAB767F9BE21803, 0xBC5ACEF5BB1BD8B5 //A0
+data8 0x4379999999999999, 0x4029241C7F5914C8 //A1
+data8 0x46F47AE147AE147A, 0x43AC2979B64B9D7E //A2
+data8 0xAEC33E1F67152993, 0x000040A7 //A3
+data8 0xD1B71758E219616F, 0x000040DF //A4
+data8 0x8637BD05AF6CF468, 0x00004118 //A5
+data8 0x55065E9F80F293DE //A6
+data8 0x588EADA78C44EE66 //A7
+data8 0x5C15798EE22DEF09 //A8
+data8 0x5F9E8ABFD644FA63 //A9
+data8 0x6325FD7FE29BD7CD //A10
+data8 0x66AFFC5C57E1F802 //A11
+data8 0x6A3774CD7D5C0181 //A12
+data8 0x6DC152724DE2A6FE //A13
+data8 0x7149BB138EB3D0C2 //A14
+data8 0x74D32FF8A70896C2 //A15
+data8 0x785D3749F9C72BD7 //A16
+data8 0x7BE5CCF65EBC4E40 //A17
+data8 0x7F641A891B5FC652 //A18
+data8 0x7FEFFFFFFFFFFFFF //A19
+LOCAL_OBJECT_END(lgammal_right_roots_polynomial_data)
+
+LOCAL_OBJECT_START(lgammal_left_roots_polynomial_data)
+// Polynomial coefficients for left root on [-3, -2]
+// Lgammal is approximated by polynomial within [.084641 ; -.059553 ] range
+data8 0xBC0844590979B82E, 0xB8BC7CE8CE2ECC3B //A0
+data8 0xBFFEA12DA904B18C, 0xBC91A6B2BAD5EF6E //A1
+data8 0x4023267F3C265A51, 0x3CD7055481D03AED //A2
+data8 0xA0C2D618645F8E00, 0x0000C003 //A3
+data8 0xFA8256664F8CD2BE, 0x00004004 //A4
+data8 0xC2C422C103F57158, 0x0000C006 //A5
+data8 0x4084373F7CC70AF5 //A6
+data8 0xC0A12239BDD6BB95 //A7
+data8 0x40BDBA65E2709397 //A8
+data8 0xC0DA2D2504DFB085 //A9
+data8 0x40F758173CA5BF3C //A10
+data8 0xC11506C65C267E72 //A11
+data8 0x413318EE3A6B05FC //A12
+data8 0xC1517767F247DA98 //A13
+data8 0x41701237B4754D73 //A14
+data8 0xC18DB8A03BC5C3D8 //A15
+data8 0x41AB80953AC14A07 //A16
+data8 0xC1C9B7B76638D0A4 //A17
+data8 0x41EA727E3033E2D9 //A18
+data8 0xC20812C297729142 //A19
+//
+// Polynomial coefficients for left root on [-4, -3]
+// Lgammal is approximated by polynomial within [.147147 ; -.145158 ] range
+data8 0xBC3130AE5C4F54DB, 0xB8ED23294C13398A //A0
+data8 0xC034B99D966C5646, 0xBCE2E5FE3BC3DBB9 //A1
+data8 0x406F76DEAE0436BD, 0x3D14974DDEC057BD //A2
+data8 0xE929ACEA5979BE96, 0x0000C00A //A3
+data8 0xF47C14F8A0D52771, 0x0000400E //A4
+data8 0x88B7BC036937481C, 0x0000C013 //A5
+data8 0x4173E8F3AB9FC266 //A6
+data8 0xC1B7DBBE062FB11B //A7
+data8 0x41FD2F76DE7A47A7 //A8
+data8 0xC242225FE53B124D //A9
+data8 0x4286D12AE2FBFA30 //A10
+data8 0xC2CCFFC267A3C4C0 //A11
+data8 0x431294E10008E014 //A12
+data8 0xC357FAC8C9A2DF6A //A13
+data8 0x439F2190AB9FAE01 //A14
+data8 0xC3E44C1D8E8C67C3 //A15
+data8 0x442A8901105D5A38 //A16
+data8 0xC471C4421E908C3A //A17
+data8 0x44B92CD4D59D6D17 //A18
+data8 0xC4FB3A078B5247FA //A19
+// Polynomial coefficients for left root on [-5, -4]
+// Lgammal is approximated by polynomial within [.155671 ; -.155300 ] range
+data8 0xBC57BF3C6E8A94C1, 0xB902FB666934AC9E //A0
+data8 0xC05D224A3EF9E41F, 0xBCF6F5713913E440 //A1
+data8 0x40BB533C678A3955, 0x3D688E53E3C72538 //A2
+data8 0x869FBFF732E99B84, 0x0000C012 //A3
+data8 0xBA9537AD61392DEC, 0x00004018 //A4
+data8 0x89EAE8B1DEA06B05, 0x0000C01F //A5
+data8 0x425A8C5C53458D3C //A6
+data8 0xC2C5068B3ED6509B //A7
+data8 0x4330FFA575E99B4E //A8
+data8 0xC39BEC12DDDF7669 //A9
+data8 0x44073825725F74F9 //A10
+data8 0xC47380EBCA299047 //A11
+data8 0x44E084DD9B666437 //A12
+data8 0xC54C2DA6BF787ACF //A13
+data8 0x45B82D65C8D6FA42 //A14
+data8 0xC624D62113FE950A //A15
+data8 0x469200CC19B45016 //A16
+data8 0xC6FFDDC6DD938E2E //A17
+data8 0x476DD7C07184B9F9 //A18
+data8 0xC7D554A30085C052 //A19
+// Polynomial coefficients for left root on [-6, -5]
+// Lgammal is approximated by polynomial within [.157425 ; -.157360 ] range
+data8 0x3C9E20A87C8B79F1, 0x39488BE34B2427DB //A0
+data8 0xC08661F6A43A5E12, 0xBD3D912526D759CC //A1
+data8 0x410F79DCB794F270, 0x3DB9BEE7CD3C1BF5 //A2
+data8 0xEB7404450D0005DB, 0x0000C019 //A3
+data8 0xF7AE9846DFE4D4AB, 0x00004022 //A4
+data8 0x8AF535855A95B6DA, 0x0000C02C //A5
+data8 0x43544D54E9FE240E //A6
+data8 0xC3E8684E40CE6CFC //A7
+data8 0x447DF44C1D803454 //A8
+data8 0xC512AC305439B2BA //A9
+data8 0x45A79226AF79211A //A10
+data8 0xC63E0DFF7244893A //A11
+data8 0x46D35216C3A83AF3 //A12
+data8 0xC76903BE0C390E28 //A13
+data8 0x48004A4DECFA4FD5 //A14
+data8 0xC8954FBD243DB8BE //A15
+data8 0x492BF3A31EB18DDA //A16
+data8 0xC9C2C6A864521F3A //A17
+data8 0x4A5AB127C62E8DA1 //A18
+data8 0xCAECF60EF3183C57 //A19
+// Polynomial coefficients for left root on [-7, -6]
+// Lgammal is approximated by polynomial within [.157749 ; -.157739 ] range
+data8 0x3CC9B9E8B8D551D6, 0x3961813C8E1E10DB //A0
+data8 0xC0B3ABF7A5CEA91F, 0xBD55638D4BCB4CC4 //A1
+data8 0x4168349A25504236, 0x3E0287ECE50CCF76 //A2
+data8 0x9EC8ED6E4C219E67, 0x0000C022 //A3
+data8 0x9279EB1B799A3FF3, 0x0000402E //A4
+data8 0x90213EF8D9A5DBCF, 0x0000C03A //A5
+data8 0x4462775E857FB71C //A6
+data8 0xC52377E70B45FDBF //A7
+data8 0x45E4F3D28EDA8C28 //A8
+data8 0xC6A6E85571BD2D0B //A9
+data8 0x47695BB17E74DF74 //A10
+data8 0xC82C5AC0ED6A662F //A11
+data8 0x48EFF8159441C2E3 //A12
+data8 0xC9B22602C1B68AE5 //A13
+data8 0x4A74BA8CE7B34100 //A14
+data8 0xCB37C7E208482E4B //A15
+data8 0x4BFB5A1D57352265 //A16
+data8 0xCCC01CB3021212FF //A17
+data8 0x4D841613AC3431D1 //A18
+data8 0xCE431C9E9EE43AD9 //A19
+// Polynomial coefficients for left root on [-8, -7]
+// Lgammal is approximated by polynomial within [.157799 ; -.157798 ] range
+data8 0xBCF9C7A33AD9478C, 0xB995B0470F11E5ED //A0
+data8 0xC0E3AF76FE4C2F8B, 0xBD8DBCD503250511 //A1
+data8 0x41C838E76CAAF0D5, 0x3E5D79F5E2E069C3 //A2
+data8 0x9EF345992B262CE0, 0x0000C02B //A3
+data8 0x92AE0292985FD559, 0x0000403A //A4
+data8 0x90615420C08F7D8C, 0x0000C049 //A5
+data8 0x45828139342CEEB7 //A6
+data8 0xC67384066C31E2D3 //A7
+data8 0x476502BC4DAC2C35 //A8
+data8 0xC856FAADFF22ADC6 //A9
+data8 0x49497243255AB3CE //A10
+data8 0xCA3C768489520F6B //A11
+data8 0x4B300D1EA47AF838 //A12
+data8 0xCC223B0508AC620E //A13
+data8 0x4D14D46583338CD8 //A14
+data8 0xCE07E7A87AA068E4 //A15
+data8 0x4EFB811AD2F8BEAB //A16
+data8 0xCFF0351B51508523 //A17
+data8 0x50E4364CCBF53100 //A18
+data8 0xD1D33CFD0BF96FA6 //A19
+// Polynomial coefficients for left root on [-9, -8]
+// Lgammal is approximated by polynomial within [.157806 ; -.157806 ] range
+data8 0x3D333E4438B1B9D4, 0x39E7B956B83964C1 //A0
+data8 0xC11625EDFC63DCD8, 0xBDCF39625709EFAC //A1
+data8 0x422EA8C150480F16, 0x3EC16ED908AB7EDD //A2
+data8 0xE2598725E2E11646, 0x0000C034 //A3
+data8 0xEAFF2346DE3EBC98, 0x00004046 //A4
+data8 0x821E90DE12A0F05F, 0x0000C059 //A5
+data8 0x46B2C334AE5366FE //A6
+data8 0xC7D64314B43191B6 //A7
+data8 0x48FAF6ED5899E01B //A8
+data8 0xCA2096E4472AF37D //A9
+data8 0x4B44AAF49FB7E4C8 //A10
+data8 0xCC6A02469F2BD920 //A11
+data8 0x4D9080626D2EFC07 //A12
+data8 0xCEB515EDCF0695F7 //A13
+data8 0x4FDB1AC69BF36960 //A14
+data8 0xD1017F8274339270 //A15
+data8 0x5226A684961BAE2F //A16
+data8 0xD34E085C088404A5 //A17
+data8 0x547511892FF8960E //A18
+data8 0xD5968FA3B1ED67A9 //A19
+// Polynomial coefficients for left root on [-10, -9]
+// Lgammal is approximated by polynomial within [.157807 ; -.157807 ] range
+data8 0xBD355818A2B42BA2, 0xB9B7320B6A0D61EA //A0
+data8 0xC14BAF7DA5F3770E, 0xBDE64AF9A868F719 //A1
+data8 0x4297F3E8791F9CD3, 0x3F2A553E59B4835E //A2
+data8 0xDD0C5F7E551BD13C, 0x0000C03E //A3
+data8 0x8F6F0A3B2EB08BBB, 0x00004054 //A4
+data8 0xC68D4D5AD230BA08, 0x0000C069 //A5
+data8 0x47F1E4D8C35D1A3E //A6
+data8 0xC94A8A191DB0A466 //A7
+data8 0x4AA4174F65FE6AE8 //A8
+data8 0xCBFEE6D90F94E9DD //A9
+data8 0x4D580FD3438BE16C //A10
+data8 0xCEB2ECD456D50224 //A11
+data8 0x500E049F7FE64546 //A12
+data8 0xD167F92D9600F378 //A13
+data8 0x52C342AE2B43261A //A14
+data8 0xD41F15DEEDA4B67E //A15
+data8 0x55792638748AFB7D //A16
+data8 0xD6D4D760074F6E6B //A17
+data8 0x5832469D58ED3FA9 //A18
+data8 0xD988769F3DC76642 //A19
+// Polynomial coefficients for left root on [-11, -10]
+// Lgammal is approximated by polynomial within [.157807 ; -.157807 ] range
+data8 0xBDA050601F39778A, 0xBA0D4D1CE53E8241 //A0
+data8 0xC18308A7D8EA4039, 0xBE370C379D3EAD41 //A1
+data8 0x4306A49380644E6C, 0x3FBBB143C0E7B5C8 //A2
+data8 0x8FA8FB233E4AA6D2, 0x0000C049 //A3
+data8 0x802CC9D8AEAC207D, 0x00004062 //A4
+data8 0xF3F73EE651A37A13, 0x0000C07A //A5
+data8 0x493E3B550A7B9568 //A6
+data8 0xCACED38DAA060929 //A7
+data8 0x4C600B346BAB3BC6 //A8
+data8 0xCDF0F719193E3D26 //A9
+data8 0x4F8229F24528B151 //A10
+data8 0xD113A4C2D32FBBE2 //A11
+data8 0x52A56BC13DC4474D //A12
+data8 0xD43785CFAF5E3CE3 //A13
+data8 0x55C9FC3EA5941202 //A14
+data8 0xD75CD545A3341AF5 //A15
+data8 0x58F009911F77C282 //A16
+data8 0xDA8246294D210BEC //A17
+data8 0x5C1608AAC32C3A8E //A18
+data8 0xDDA446E570A397D5 //A19
+// Polynomial coefficients for left root on [-12, -11]
+// Lgammal is approximated by polynomial within [.157807 ; -.157807 ] range
+data8 0x3DEACBB3081C502E, 0x3A8AA6F01DEDF745 //A0
+data8 0xC1BC8CFBFB0A9912, 0xBE6556B6504A2AE6 //A1
+data8 0x43797926206941D7, 0x40289A9644C2A216 //A2
+data8 0xF26D2A78446D0839, 0x0000C053 //A3
+data8 0xA238B1D937FFED38, 0x00004070 //A4
+data8 0xE793B4F6DE470538, 0x0000C08C //A5
+data8 0x4A9585BDC44DC45D //A6
+data8 0xCC60759520342C47 //A7
+data8 0x4E29B2F3694C0404 //A8
+data8 0xCFF4619AE7B6BBAB //A9
+data8 0x51C05DADF52B89E8 //A10
+data8 0xD38A8C7F48819A4A //A11
+data8 0x5555B6932D687860 //A12
+data8 0xD721E1FACB6C1B5B //A13
+data8 0x58EDA1E2677C8F91 //A14
+data8 0xDAB8A8EC523C1F71 //A15
+data8 0x5C84930133F30411 //A16
+data8 0xDE51952FDFD1EC49 //A17
+data8 0x601FCCEC1BBD25F1 //A18
+data8 0xE1E5F2D76B610920 //A19
+// Polynomial coefficients for left root on [-13, -12]
+// Lgammal is approximated by polynomial within [.157807 ; -.157807 ] range
+data8 0xBE01612F373268ED, 0xBA97B7A18CDF103B //A0
+data8 0xC1F7328CBF7A4FAC, 0xBE89A25A6952F481 //A1
+data8 0x43F0D0FA2DBDA237, 0x40A0422EC1CE6084 //A2
+data8 0x82082DF2D32686C5, 0x0000C05F //A3
+data8 0x8D64EE9B42E68B36, 0x0000407F //A4
+data8 0xA3FFD82E08C630C9, 0x0000C09F //A5
+data8 0x4BF8C49D99123466 //A6
+data8 0xCDFEC79DDF1119ED //A7
+data8 0x50038615A892D242 //A8
+data8 0xD20929453DC8B537 //A9
+data8 0x54106A78083BA1EE //A10
+data8 0xD615A302C69E27B2 //A11
+data8 0x581CC175870FF16F //A12
+data8 0xDA233E0979E12B74 //A13
+data8 0x5C29E822BC568C80 //A14
+data8 0xDE31845DB5340FBC //A15
+data8 0x6037BFC6D498D5F9 //A16
+data8 0xE2407D92CD613E82 //A17
+data8 0x64483B9B62367EB7 //A18
+data8 0xE64B2DC830E8A799 //A1
+// Polynomial coefficients for left root on [-14, -13]
+// Lgammal is approximated by polynomial within [.157807 ; -.157807 ] range
+data8 0x3E563D0B930B371F, 0x3AE779957E14F012 //A0
+data8 0xC2344C3B2F083767, 0xBEC0B7769AA3DD66 //A1
+data8 0x4469BFFF28B50D07, 0x41181E3F13ED2401 //A2
+data8 0xAE38F64DCB24D9EE, 0x0000C06A //A3
+data8 0xA5C3F52C1B3506F2, 0x0000408E //A4
+data8 0xA83BC857BCD6BA92, 0x0000C0B2 //A5
+data8 0x4D663B4727B4D81A //A6
+data8 0xCFA82C965B0F62E9 //A7
+data8 0x51EAD58C02905B71 //A8
+data8 0xD42E427970FA56AD //A9
+data8 0x56714644C57D8476 //A10
+data8 0xD8B3EC2037EC95F2 //A11
+data8 0x5AF72AE68BBA5B3D //A12
+data8 0xDD3B2152C67AA6B7 //A13
+data8 0x5F7FF5F082861B8B //A14
+data8 0xE1C2E8BE125A5B7A //A15
+data8 0x64066E92FE9EBE7D //A16
+data8 0xE64B4201CDF9F138 //A17
+data8 0x689186351E58AA88 //A18
+data8 0xEAD132A585DFC60A //A19
+// Polynomial coefficients for left root on [-15, -14]
+// Lgammal is approximated by polynomial within [.157807 ; -.157807 ] range
+data8 0xBE6D7DDE12700AC1, 0xBB1E025BF1667FB5 //A0
+data8 0xC273077763F60AD5, 0xBF2A1698184C7A9A //A1
+data8 0x44E6A1BF095B1AB3, 0x4178D5AE8A4A2874 //A2
+data8 0x8F8E0D5060FCC767, 0x0000C076 //A3
+data8 0x800CC1DCFF092A57, 0x0000409E //A4
+data8 0xF3AB0BA9D14D37D1, 0x0000C0C5 //A5
+data8 0x4EDE3000A2F6D565 //A6
+data8 0xD15EC613B9C8C800 //A7
+data8 0x53E003309FEECCAA //A8
+data8 0xD660ED908D8B15C4 //A9
+data8 0x58E21E9B51A1C4AE //A10
+data8 0xDB639745DB82210D //A11
+data8 0x5DE55BB60C68FCF6 //A12
+data8 0xE06772BA3FCA23C6 //A13
+data8 0x62E9E58B4F702C31 //A14
+data8 0xE56CBA49B071ABE2 //A15
+data8 0x67EFF31E4F2BA36A //A16
+data8 0xEA7232C8804F32C3 //A17
+data8 0x6CF5EFEE929A0928 //A18
+data8 0xEF742EE03EC3E8FF //A19
+// Polynomial coefficients for left root on [-16, -15]
+// Lgammal is approximated by polynomial within [.157807 ; -.157807 ] range
+data8 0xBEDCC628FEAC7A1B, 0xBB80582C8BEBB198 //A0
+data8 0xC2B3076EE752595E, 0xBF5388F55AFAE53E //A1
+data8 0x4566A1AAD96EBCB5, 0x421F0FEFE2444293 //A2
+data8 0x8F8D4D3DE9850DB2, 0x0000C082 //A3
+data8 0x800BDD6DA2CE184C, 0x000040AE //A4
+data8 0xF3A8EC4C9CDC7A43, 0x0000C0D9 //A5
+data8 0x505E2FAFDB81263F //A6
+data8 0xD31EC5B3A7506CD9 //A7
+data8 0x55E002F77E999810 //A8
+data8 0xD8A0ED4C9B5C2900 //A9
+data8 0x5B621E4A8267C401 //A10
+data8 0xDE2396E5BFCFDA7A //A11
+data8 0x60E55B43BE6F9A79 //A12
+data8 0xE3A772324C7405FA //A13
+data8 0x6669E4E9B7E57A2D //A14
+data8 0xE92CB989F8A8FB37 //A15
+data8 0x6BEFF2368849A36E //A16
+data8 0xEEB23234FE191D55 //A17
+data8 0x7175EF5D1080B105 //A18
+data8 0xF4342ED7B1B7BE31 //A19
+// Polynomial coefficients for left root on [-17, -16]
+// Lgammal is approximated by polynomial within [.157807 ; -.157807 ] range
+data8 0xBF28AEEE7B58C790, 0xBBC4448DE371FA0A //A0
+data8 0xC2F436F56B3B89B1, 0xBF636755245AC63A //A1
+data8 0x45E98A22535D115D, 0x4298467DA93DB784 //A2
+data8 0xAC176F3775E6FCF2, 0x0000C08E //A3
+data8 0xA3114F53A9FEB908, 0x000040BE //A4
+data8 0xA4D168A8334AFE5A, 0x0000C0EE //A5
+data8 0x51E5B0E7EC7182CF //A6
+data8 0xD4E77D67B876D6B4 //A7
+data8 0x57E9F7C30C098C83 //A8
+data8 0xDAED29B0489EF7A7 //A9
+data8 0x5DF09486F8A524B8 //A10
+data8 0xE0F30B19910A2393 //A11
+data8 0x63F60E02AB3109F4 //A12
+data8 0xE6F9B8A3431854D5 //A13
+data8 0x69FE2D4A6D94218E //A14
+data8 0xED01C7E272A73560 //A15
+data8 0x7005017D82B186B6 //A16
+data8 0xF3096A81A69BD8AE //A17
+data8 0x76104951BAD67D5C //A18
+data8 0xF90FECC99786FD5B //A19
+// Polynomial coefficients for left root on [-18, -17]
+// Lgammal is approximated by polynomial within [.157807 ; -.157807 ] range
+data8 0x3F3C19A53328E26A, 0x3BE238D7BA036B3B //A0
+data8 0xC336C16C16C16C13, 0xBFEACE245DEC56F3 //A1
+data8 0x46702E85C0898B70, 0x432C922B64FD1DA4 //A2
+data8 0xF57B99A1C0343350, 0x0000C09A //A3
+data8 0x82EC9634223DF90D, 0x000040CF //A4
+data8 0x94F66D7557E3237D, 0x0000C103 //A5
+data8 0x5376118B79AE34D6 //A6
+data8 0xD6BAE7106D52CE49 //A7
+data8 0x5A00BD48CC8E11AB //A8
+data8 0xDD4529722833E2DF //A9
+data8 0x608B1654AF5F46AF //A10
+data8 0xE3D182CC90D8723F //A11
+data8 0x6716D43D46706AA0 //A12
+data8 0xEA5DF888C5B428D3 //A13
+data8 0x6DA3CA85888931A6 //A14
+data8 0xF0EA40EF2AC7E070 //A15
+data8 0x743175D1A251AFCD //A16
+data8 0xF777CB6E2B550D73 //A17
+data8 0x7AC11E468A134A51 //A18
+data8 0xFE02B6BDD0FC40AA //A19
+// Polynomial coefficients for left root on [-19, -18]
+// Lgammal is approximated by polynomial within [.157807 ; -.157807 ] range
+data8 0xBFAB767F9BE217FC, 0xBC4A5541CE0D8D0D //A0
+data8 0xC379999999999999, 0xC01A84981B490BE8 //A1
+data8 0x46F47AE147AE147A, 0x43AC2987BBC466EB //A2
+data8 0xAEC33E1F67152987, 0x0000C0A7 //A3
+data8 0xD1B71758E2196153, 0x000040DF //A4
+data8 0x8637BD05AF6D420E, 0x0000C118 //A5
+data8 0x55065E9F80F293B2 //A6
+data8 0xD88EADA78C44BFA7 //A7
+data8 0x5C15798EE22EC6CD //A8
+data8 0xDF9E8ABFD67895CF //A9
+data8 0x6325FD7FE13B0DE0 //A10
+data8 0xE6AFFC5C3DE70858 //A11
+data8 0x6A3774CE81C70D43 //A12
+data8 0xEDC1527412D8129F //A13
+data8 0x7149BABCDA8B7A72 //A14
+data8 0xF4D330AD49071BB5 //A15
+data8 0x785D4046F4C5F1FD //A16
+data8 0xFBE59BFEDBA73FAF //A17
+data8 0x7F64BEF2B2EC8DA1 //A18
+data8 0xFFEFFFFFFFFFFFFF //A19
+LOCAL_OBJECT_END(lgammal_left_roots_polynomial_data)
+
+
+//==============================================================
+// Code
+//==============================================================
+
+.section .text
+GLOBAL_LIBM_ENTRY(__libm_lgammal)
+{ .mfi
+      getf.exp           rSignExpX = f8
+      // Test x for NaTVal, NaN, +/-0, +/-INF, denormals
+      fclass.m           p6,p0  = f8,0x1EF
+      addl               r17Ones = 0x1FFFF, r0 // exponent mask
+}
+{ .mfi
+      addl               GR_ad_z_1 = @ltoff(Constants_Z_1#),gp
+      fcvt.fx.s1         fXint = f8 // Convert arg to int (int repres. in FR)
+      adds               rDelta = 0x3FC, r0
+}
+;;
+{ .mfi
+      getf.sig           rSignifX = f8
+      fcmp.lt.s1         p15, p14 = f8, f0
+      shl                rDelta = rDelta, 20 // single precision 1.5
+}
+{ .mfi
+      ld8                GR_ad_z_1 = [GR_ad_z_1]// get pointer to Constants_Z_1
+      fma.s1             fTwo = f1, f1, f1      // 2.0
+      addl               rExp8 = 0x10002, r0    // exponent of 8.0
+}
+;;
+{ .mfi
+      alloc              rPFS_SAVED = ar.pfs, 0, 34, 4, 0 // get some registers
+      fmerge.s           fAbsX = f1, f8                   // |x|
+      and                rExpX = rSignExpX, r17Ones       // mask sign bit
+}
+{ .mib
+      addl               rExpHalf = 0xFFFE, r0 // exponent of 0.5
+      addl               rExp2 = 0x10000, r0 // exponent of 2.0
+      // branch out if x is NaTVal, NaN, +/-0, +/-INF, or denormalized number
+(p6)  br.cond.spnt       lgammal_spec
+}
+;;
+_deno_back_to_main_path:
+{ .mfi
+      // Point to Constants_G_H_h1
+      add                rTbl1Addr = 0x040, GR_ad_z_1
+      frcpa.s1           fRcpX, p0 = f1, f8 // initial approximation of 1/x
+      extr.u             GR_Index1 = rSignifX, 59, 4
+}
+{ .mib
+(p14) cmp.ge.unc         p8, p0 = rExpX, rExp8 // p8 = 1 if x >= 8.0
+      adds               rZ625 = 0x3F2, r0
+(p8)  br.cond.spnt       lgammal_big_positive // branch out if x >= 8.0
+}
+;;
+{ .mfi
+      shladd             rZ1offsett = GR_Index1, 2, GR_ad_z_1  // Point to Z_1
+      fmerge.se          fSignifX =  f1, f8 // sifnificand of x
+      // Get high 15 bits of significand
+      extr.u             GR_X_0 = rSignifX, 49, 15
+}
+{ .mib
+      cmp.lt.unc         p9, p0 = rExpX, rExpHalf // p9 = 1 if |x| < 0.5
+      // set p11 if 2 <= x < 4
+(p14) cmp.eq.unc         p11, p0 = rExpX, rExp2
+(p9)  br.cond.spnt       lgammal_0_half // branch out if |x| < 0.5
+}
+;;
+{ .mfi
+      ld4                GR_Z_1 = [rZ1offsett] // Load Z_1
+      fms.s1             fA5L = f1, f1, f8 // for 0.75 <= x < 1.3125 path
+      shl                rZ625 = rZ625, 20 // sinfle precision 0.625
+}
+{ .mib
+      setf.s             FR_MHalf = rDelta
+      // set p10 if x >= 4.0
+(p14) cmp.gt.unc         p10, p0 = rExpX, rExp2
+      // branch to special path for 4.0 <= x < 8
+(p10) br.cond.spnt       lgammal_4_8
+}
+;;
+{ .mfi
+      // for 1.3125 <= x < 1.5625 path
+      addl               rPolDataPtr= @ltoff(lgammal_loc_min_data),gp
+      // argument of polynomial approximation for 1.5625 <= x < 2.25
+      fms.s1             fB4 = f8, f1, fTwo
+      cmp.eq             p12, p0 = rExpX, rExpHalf
+}
+{ .mib
+      addl               rExpOne = 0xFFFF, r0 // exponent of 1.0
+     // set p10 if significand of x >= 1.125
+(p11) cmp.le             p11, p0 = 2, GR_Index1
+(p11) br.cond.spnt       lgammal_2Q_4
+}
+;;
+{ .mfi
+      // point to xMin for 1.3125 <= x < 1.5625 path
+      ld8                rPolDataPtr = [rPolDataPtr]
+      fcvt.xf            fFltIntX = fXint // RTN(x)
+(p14) cmp.eq.unc         p13, p7 = rExpX, rExpOne // p13 set if 1.0 <= x < 2.0
+}
+{ .mib
+      setf.s             FR_FracX = rZ625
+      // set p12 if |x| < 0.75
+(p12) cmp.gt.unc         p12, p0 = 8, GR_Index1
+      // branch out to special path for |x| < 0.75
+(p12) br.cond.spnt       lgammal_half_3Q
+}
+;;
+.pred.rel "mutex", p7, p13
+{ .mfi
+      getf.sig           rXRnd = fXint // integer part of the input value
+      fnma.s1            fInvX = f8, fRcpX, f1 // start of 1st NR iteration
+      // Get bits 30-15 of X_0 * Z_1
+      pmpyshr2.u         GR_X_1 = GR_X_0,GR_Z_1,15
+}
+{ .mib
+(p7)  cmp.eq             p6, p0 = rExpX, rExp2 // p6 set if 2.0 <= x < 2.25
+(p13) cmp.le             p6, p0 = 9, GR_Index1
+      // branch to special path 1.5625 <= x < 2.25
+(p6)  br.cond.spnt       lgammal_13Q_2Q
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      shladd             GR_ad_tbl_1 = GR_Index1, 4, rTbl1Addr // Point to G_1
+      fma.s1             fSix = fTwo, fTwo, fTwo // 6.0
+      add                GR_ad_q = -0x60, GR_ad_z_1   // Point to Constants_Q
+}
+{ .mib
+      add                rTmpPtr3 = -0x50, GR_ad_z_1
+(p13) cmp.gt             p7, p0 = 5, GR_Index1
+      // branch to special path 0.75 <= x < 1.3125
+(p7)  br.cond.spnt       lgammal_03Q_1Q
+}
+;;
+{ .mfi
+      add                rTmpPtr = 8, GR_ad_tbl_1
+      fma.s1             fRoot = f8, f1, f1 // x + 1
+       // Absolute value of int arg. Will be used as index in table with roots
+      sub                rXRnd = r0, rXRnd
+}
+{ .mib
+      ldfe               fA5L = [rPolDataPtr], 16 // xMin
+      addl               rNegSingularity = 0x3003E, r0
+(p14) br.cond.spnt       lgammal_loc_min
+}
+;;
+{ .mfi
+      ldfps              FR_G, FR_H = [GR_ad_tbl_1], 8 // Load G_1, H_1
+      nop.f              0
+      add                rZ2Addr = 0x140, GR_ad_z_1  // Point to Constants_Z_2
+}
+{ .mib
+      ldfd               FR_h = [rTmpPtr] // Load h_1
+      // If arg is less or equal to -2^63
+      cmp.geu.unc        p8,p0 = rSignExpX, rNegSingularity
+      // Singularity for x < -2^63 since all such arguments are integers
+      // branch to special code which deals with singularity
+(p8)  br.cond.spnt       lgammal_singularity
+}
+;;
+{ .mfi
+      ldfe               FR_log2_hi = [GR_ad_q], 32 // Load log2_hi
+      nop.f              0
+      extr.u             GR_Index2 = GR_X_1, 6, 4 // Extract bits 6-9 of X_1
+}
+{ .mfi
+      ldfe               FR_log2_lo = [rTmpPtr3], 32 // Load log2_lo
+      fms.s1             fDx = f8, f1, fFltIntX // x - RTN(x)
+      // index in table with roots and bounds
+      adds               rXint = -2, rXRnd
+}
+;;
+{ .mfi
+      ldfe               FR_Q4 = [GR_ad_q], 32      // Load Q4
+      nop.f              0
+      // set p12 if x may be close to negative root: -19.5 < x < -2.0
+      cmp.gtu            p12, p0 = 18, rXint
+}
+{ .mfi
+      shladd             GR_ad_z_2 = GR_Index2, 2, rZ2Addr  // Point to Z_2
+      fma.s1             fRcpX = fInvX, fRcpX, fRcpX // end of 1st NR iteration
+      // Point to Constants_G_H_h2
+      add                rTbl2Addr = 0x180, GR_ad_z_1
+}
+;;
+{ .mfi
+      shladd             GR_ad_tbl_2 = GR_Index2, 4, rTbl2Addr // Point to G_2
+      // set p9 if x is integer and negative
+      fcmp.eq.s1         p9, p0 = f8,fFltIntX
+      // Point to Constants_G_H_h3
+      add                rTbl3Addr = 0x280, GR_ad_z_1
+}
+{ .mfi
+      ld4                GR_Z_2 = [GR_ad_z_2] // Load Z_2
+      nop.f              0
+      sub                GR_N = rExpX, rExpHalf, 1
+}
+;;
+{ .mfi
+      ldfe               FR_Q3 = [rTmpPtr3], 32 // Load Q3
+      nop.f              0
+      // Point to lnsin polynomial coefficients
+      adds               rLnSinDataPtr = 864, rTbl3Addr
+}
+{ .mfi
+      ldfe               FR_Q2 = [GR_ad_q],32 // Load Q2
+      nop.f              0
+      add                rTmpPtr = 8, GR_ad_tbl_2
+}
+;;
+{ .mfi
+      ldfe               FR_Q1 = [rTmpPtr3] // Load Q1
+      fcmp.lt.s1         p0, p15 = fAbsX, fSix // p15 is set when x < -6.0
+      // point to table with roots and bounds
+      adds               rRootsBndAddr = -1296, GR_ad_z_1
+}
+{ .mfb
+      // Put integer N into rightmost significand
+      setf.sig           fFloatN = GR_N
+      fma.s1             fThirteen = fSix, fTwo, f1 // 13.0
+      // Singularity if -2^63 < x < 0 and x is integer
+      // branch to special code which deals with singularity
+(p9)  br.cond.spnt       lgammal_singularity
+}
+;;
+{ .mfi
+      ldfps              FR_G2, FR_H2 = [GR_ad_tbl_2]  // Load G_2, H_2
+      // y = |x|/2^(exponent(x)) - 1.5
+      fms.s1             FR_FracX = fSignifX, f1, FR_MHalf
+      // Get bits 30-15 of X_1 * Z_2
+      pmpyshr2.u         GR_X_2 = GR_X_1,GR_Z_2,15
+}
+{ .mfi
+      ldfd               FR_h2 = [rTmpPtr] // Load h_2
+      fma.s1             fDxSqr = fDx, fDx, f0 // deltaX^2
+      adds               rTmpPtr3 = 128, rLnSinDataPtr
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      getf.exp           rRoot = fRoot // sign and biased exponent of (x + 1)
+      nop.f              0
+      // set p6 if -4 < x <= -2
+      cmp.eq             p6, p0 = rExpX, rExp2
+}
+{ .mfi
+      ldfpd              fLnSin2, fLnSin2L = [rLnSinDataPtr], 16
+      fnma.s1            fInvX = f8, fRcpX, f1 // start of 2nd NR iteration
+      sub                rIndexPol = rExpX, rExpHalf // index of polynom
+}
+;;
+{ .mfi
+      ldfe               fLnSin4 = [rLnSinDataPtr], 96
+      // p10 is set if x is potential "right" root
+      // p11 set for possible "left" root
+      fcmp.lt.s1         p10, p11 = fDx, f0
+      shl                rIndexPol = rIndexPol, 6  // (i*16)*4
+}
+{ .mfi
+      ldfpd              fLnSin18, fLnSin20 = [rTmpPtr3], 16
+      nop.f              0
+      mov                rExp2tom7 = 0x0fff8 // Exponent of 2^-7
+}
+;;
+{ .mfi
+      getf.sig           rSignifDx = fDx // Get significand of RTN(x)
+      nop.f              0
+      // set p6 if -4 < x <= -3.0
+(p6)  cmp.le.unc         p6, p0 = 0x8, GR_Index1
+}
+{ .mfi
+      ldfpd              fLnSin22, fLnSin24 = [rTmpPtr3], 16
+      nop.f              0
+      // mask sign bit in the exponent of (x + 1)
+      and                rRoot = rRoot, r17Ones
+}
+;;
+{ .mfi
+      ldfe               fLnSin16 = [rLnSinDataPtr], -80
+      nop.f              0
+      extr.u             GR_Index3 = GR_X_2, 1, 5 // Extract bits 1-5 of X_2
+}
+{ .mfi
+      ldfpd              fLnSin26, fLnSin28 = [rTmpPtr3], 16
+      nop.f              0
+      and                rXRnd = 1, rXRnd
+}
+;;
+{ .mfi
+      shladd             GR_ad_tbl_3 = GR_Index3, 4, rTbl3Addr // Point to G_3
+      fms.s1             fDxSqrL = fDx, fDx, fDxSqr // low part of deltaX^2
+      // potential "left" root
+(p11) adds               rRootsBndAddr = 560, rRootsBndAddr
+}
+{ .mib
+      ldfpd              fLnSin30, fLnSin32 = [rTmpPtr3], 16
+      // set p7 if |x+1| < 2^-7
+      cmp.lt             p7, p0 =  rRoot, rExp2tom7
+      // branch to special path for |x+1| < 2^-7
+(p7)  br.cond.spnt       _closeToNegOne
+}
+;;
+{ .mfi
+      ldfps              FR_G3, FR_H3 = [GR_ad_tbl_3], 8 // Load G_3, H_3
+      fcmp.lt.s1         p14, p0 = fAbsX, fThirteen // set p14 if x > -13.0
+      // base address of polynomial on range [-6.0, -0.75]
+      adds               rPolDataPtr = 3440, rTbl3Addr
+}
+{ .mfi
+      // (i*16)*4 + (i*16)*8 - offset of polynomial on range [-6.0, -0.75]
+      shladd             rTmpPtr = rIndexPol, 2, rIndexPol
+      fma.s1             fXSqr = FR_FracX, FR_FracX, f0 // y^2
+      // point to left "near root" bound
+(p12) shladd             rRootsBndAddr = rXint, 4, rRootsBndAddr
+}
+;;
+{ .mfi
+      ldfpd              fLnSin34, fLnSin36 = [rTmpPtr3], 16
+      fma.s1             fRcpX = fInvX, fRcpX, fRcpX // end of 2nd NR iteration
+      // add special offset if -4 < x <= -3.0
+(p6)  adds               rPolDataPtr = 640, rPolDataPtr
+}
+{ .mfi
+      // point to right "near root" bound
+      adds               rTmpPtr2 = 8, rRootsBndAddr
+      fnma.s1            fMOne = f1, f1, f0 // -1.0
+      // Point to Bernulli numbers
+      adds               rBernulliPtr = 544, rTbl3Addr
+}
+;;
+{ .mfi
+      // left bound of "near root" range
+(p12) ld8                rLeftBound = [rRootsBndAddr]
+      fmerge.se          fNormDx = f1, fDx // significand of DeltaX
+      // base address + offset for polynomial coeff. on range [-6.0, -0.75]
+      add                rPolDataPtr = rPolDataPtr, rTmpPtr
+}
+{ .mfi
+      // right bound of "near root" range
+(p12) ld8                rRightBound = [rTmpPtr2]
+      fcvt.xf            fFloatN = fFloatN
+      // special "Bernulli" numbers for Stirling's formula for -13 < x < -6
+(p14) adds               rBernulliPtr = 160, rBernulliPtr
+}
+;;
+{ .mfi
+      ldfd               FR_h3 = [GR_ad_tbl_3] // Load h_3
+      fmpy.s1            FR_G = FR_G, FR_G2 // G = G_1 * G_2
+      adds               rTmpPtr3 = -160, rTmpPtr3
+}
+{ .mfb
+      adds               rTmpPtr = 80, rPolDataPtr
+      fadd.s1            FR_H = FR_H, FR_H2 // H = H_1 + H_2
+      // p15 is set if -2^63 < x < 6.0 and x is not an integer
+      // branch to path with implementation using Stirling's formula for neg. x
+(p15) br.cond.spnt       _negStirling
+}
+;;
+{ .mfi
+      ldfpd              fA3, fA3L = [rPolDataPtr], 16 // A3
+      fma.s1             fDelX4 = fDxSqr, fDxSqr, f0 // deltaX^4
+      // Get high 4 bits of signif
+      extr.u             rIndex1Dx = rSignifDx, 59, 4
+}
+{ .mfi
+      ldfe               fA5 = [rTmpPtr], -16 // A5
+      fadd.s1            FR_h = FR_h, FR_h2 // h = h_1 + h_2
+      adds               rLnSinTmpPtr = 16, rLnSinDataPtr
+}
+;;
+{ .mfi
+      ldfpd              fA0, fA0L = [rPolDataPtr], 16 // A0
+      fma.s1             fLnSin20 = fLnSin20, fDxSqr, fLnSin18
+      // Get high 15 bits of significand
+      extr.u             rX0Dx = rSignifDx, 49, 15
+}
+{ .mfi
+      ldfe               fA4 = [rTmpPtr], 192 // A4
+      fms.s1             fXSqrL = FR_FracX, FR_FracX, fXSqr // low part of y^2
+      shladd             GR_ad_z_1 = rIndex1Dx, 2, GR_ad_z_1 // Point to Z_1
+}
+;;
+{ .mfi
+      ldfpd              fA1, fA1L = [rPolDataPtr], 16 // A1
+      fma.s1             fX4 = fXSqr, fXSqr, f0 // y^4
+      adds               rTmpPtr2 = 32, rTmpPtr
+}
+{ .mfi
+      ldfpd              fA18, fA19 = [rTmpPtr], 16 // A18, A19
+      fma.s1             fLnSin24 = fLnSin24, fDxSqr, fLnSin22
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fLnSin6 = [rLnSinDataPtr], 32
+      fma.s1             fLnSin28 = fLnSin28, fDxSqr, fLnSin26
+      nop.i              0
+}
+{ .mfi
+      ldfe               fLnSin8 = [rLnSinTmpPtr], 32
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA20, fA21 = [rTmpPtr], 16 // A20, A21
+      fma.s1             fLnSin32 = fLnSin32, fDxSqr, fLnSin30
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA22, fA23 = [rTmpPtr2], 16 // A22, A23
+      fma.s1             fB20 = f1, f1, FR_MHalf // 2.5
+(p12) cmp.ltu.unc        p6, p0 = rSignifX, rLeftBound
+}
+;;
+{ .mfi
+      ldfpd              fA2, fA2L = [rPolDataPtr], 16 // A2
+      fmpy.s1            FR_G = FR_G, FR_G3 // G = (G_1 * G_2) * G_3
+      // set p6 if x falls in "near root" range
+(p6)  cmp.geu.unc        p6, p0 = rSignifX, rRightBound
+}
+{ .mfb
+      adds               rTmpPtr3 = -64, rTmpPtr
+      fadd.s1            FR_H = FR_H, FR_H3 // H = (H_1 + H_2) + H_3
+      // branch to special path if x falls in "near root" range
+(p6)  br.cond.spnt       _negRoots
+}
+;;
+{ .mfi
+      ldfpd              fA24, fA25 = [rTmpPtr2], 16 // A24, A25
+      fma.s1             fLnSin36 = fLnSin36, fDxSqr, fLnSin34
+(p11) cmp.eq.unc         p7, p0 = 1,rXint // p7 set if  -3.0 < x < -2.5
+}
+{ .mfi
+      adds               rTmpPtr = -48, rTmpPtr
+      fma.s1             fLnSin20 = fLnSin20, fDxSqr, fLnSin16
+      addl               rDelta = 0x5338, r0 // significand of -2.605859375
+}
+;;
+{ .mfi
+      getf.exp           GR_N =  fDx // Get N = exponent of DeltaX
+      fma.s1             fX6 = fX4, fXSqr, f0 // y^6
+      // p7 set if -2.605859375 <= x < -2.5
+(p7)  cmp.gt.unc         p7, p0 = rDelta, GR_X_0
+}
+{ .mfb
+      ld4                GR_Z_1 = [GR_ad_z_1] // Load Z_1
+      fma.s1             fDelX8 = fDelX4, fDelX4, f0 // deltaX^8
+      // branch to special path for -2.605859375 <= x < -2.5
+(p7)  br.cond.spnt       _neg2andHalf
+}
+;;
+{ .mfi
+      ldfpd              fA14, fA15 = [rTmpPtr3], 16 // A14, A15
+      fadd.s1            FR_h = FR_h, FR_h3 // h = (h_1 + h_2) + h_3
+      adds               rTmpPtr2 = 128 , rPolDataPtr
+}
+{ .mfi
+      ldfpd              fA16, fA17 = [rTmpPtr], 16 // A16, A17
+      fma.s1             fLnSin28 = fLnSin28, fDelX4, fLnSin24
+      adds               rPolDataPtr = 144 , rPolDataPtr
+}
+;;
+{ .mfi
+      ldfe               fLnSin10 = [rLnSinDataPtr], 32
+      fma.s1             fRes1H = fA3, FR_FracX, f0 // (A3*y)hi
+      and                GR_N = GR_N, r17Ones // mask sign bit
+}
+{ .mfi
+      ldfe               fLnSin12 = [rLnSinTmpPtr]
+      fma.s1             fDelX6 = fDxSqr, fDelX4, f0 // DeltaX^6
+      shladd             GR_ad_tbl_1 = rIndex1Dx, 4, rTbl1Addr // Point to G_1
+}
+;;
+{ .mfi
+      ldfe               fA13 = [rPolDataPtr], -32 // A13
+      fma.s1             fA4 = fA5, FR_FracX, fA4   // A5*y + A4
+      // Get bits 30-15 of X_0 * Z_1
+      pmpyshr2.u         GR_X_1 = rX0Dx, GR_Z_1, 15
+}
+{ .mfi
+      ldfe               fA12 = [rTmpPtr2], -32 // A12
+      fms.s1             FR_r = FR_G, fSignifX, f1 // r = G * S_hi - 1
+      sub                GR_N = GR_N, rExpHalf, 1 // unbisaed exponent of DeltaX
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+.pred.rel "mutex",p10,p11
+{ .mfi
+      ldfe               fA11 = [rPolDataPtr], -32 // A11
+      // High part of log(|x|) = Y_hi = N * log2_hi + H
+      fma.s1             fResH = fFloatN, FR_log2_hi, FR_H
+(p10) cmp.eq             p8, p9 = rXRnd, r0
+}
+{ .mfi
+      ldfe               fA10 = [rTmpPtr2], -32 // A10
+      fma.s1             fRes6H = fA1, FR_FracX, f0 // (A1*y)hi
+(p11) cmp.eq             p9, p8 = rXRnd, r0
+}
+;;
+{ .mfi
+      ldfe               fA9 = [rPolDataPtr], -32 // A9
+      fma.s1             fB14 = fLnSin6, fDxSqr, f0 // (LnSin6*deltaX^2)hi
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+}
+{ .mfi
+      ldfe               fA8 = [rTmpPtr2], -32 // A8
+      fma.s1             fA18 = fA19, FR_FracX, fA18
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fA7 = [rPolDataPtr] // A7
+      fma.s1             fA23 = fA23, FR_FracX, fA22
+      nop.i              0
+}
+{ .mfi
+      ldfe               fA6 = [rTmpPtr2] // A6
+      fma.s1             fA21 = fA21, FR_FracX, fA20
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fLnSin14 = [rLnSinDataPtr]
+      fms.s1             fRes1L = fA3, FR_FracX, fRes1H // delta((A3*y)hi)
+      extr.u             GR_Index2 = GR_X_1, 6, 4 // Extract bits 6-9 of X_1
+}
+{ .mfi
+      setf.sig           fFloatNDx = GR_N
+      fadd.s1            fPol = fRes1H, fA2 // (A3*y + A2)hi
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfps              FR_G, FR_H = [GR_ad_tbl_1], 8 // Load G_1, H_1
+      fma.s1             fRes2H = fA4, fXSqr, f0 // ((A5 + A4*y)*y^2)hi
+      nop.i              0
+}
+{ .mfi
+      shladd             GR_ad_z_2 = GR_Index2, 2, rZ2Addr  // Point to Z_2
+      fma.s1             fA25 = fA25, FR_FracX, fA24
+      shladd             GR_ad_tbl_2 = GR_Index2, 4, rTbl2Addr  // Point to G_2
+}
+;;
+.pred.rel "mutex",p8,p9
+{ .mfi
+      ld4                GR_Z_2 = [GR_ad_z_2] // Load Z_2
+      fms.s1             fRes6L = fA1, FR_FracX, fRes6H // delta((A1*y)hi)
+      // sign of GAMMA(x) is negative
+(p8)  adds               rSgnGam = -1, r0
+}
+{ .mfi
+      adds               rTmpPtr = 8, GR_ad_tbl_2
+      fadd.s1            fRes3H = fRes6H, fA0 // (A1*y + A0)hi
+      // sign of GAMMA(x) is positive
+(p9)  adds               rSgnGam = 1, r0
+}
+;;
+{ .mfi
+      ldfps              FR_G2, FR_H2 = [GR_ad_tbl_2] // Load G_2, H_2
+      // (LnSin6*deltaX^2 + LnSin4)hi
+      fadd.s1            fLnSinH = fB14, fLnSin4
+      nop.i              0
+}
+{ .mfi
+      ldfd               FR_h2 = [rTmpPtr] // Load h_2
+      fms.s1             fB16 = fLnSin6, fDxSqr, fB14 // delta(LnSin6*deltaX^2)
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfd               fhDelX = [GR_ad_tbl_1] // Load h_1
+      fma.s1             fA21 = fA21, fXSqr, fA18
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin36 = fLnSin36, fDelX4, fLnSin32
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes1L = fA3L, FR_FracX, fRes1L // (A3*y)lo
+      // Get bits 30-15 of X_1 * Z_
+      pmpyshr2.u         GR_X_2 = GR_X_1,GR_Z_2,15
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fPolL = fA2, fPol
+      nop.i              0
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      nop.m              0
+     // delta(((A5 + A4*y)*y^2)hi)
+      fms.s1             fRes2L = fA4, fXSqr, fRes2H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // (((A5 + A4*y)*y^2) + A3*y + A2)hi
+      fadd.s1            fRes4H = fRes2H, fPol
+      nop.i              0
+}
+;;
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      fma.s1             fRes6L = fA1L, FR_FracX, fRes6L // (A1*y)lo
+      nop.i              0
+}
+{ .mfi
+      // store signgam if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      fsub.s1            fRes3L = fA0, fRes3H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fLnSinL = fLnSin4, fLnSinH
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // ((LnSin6*deltaX^2 + LnSin4)*deltaX^2)hi
+      fma.s1             fB18 = fLnSinH, fDxSqr, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      adds               rTmpPtr = 8, rTbl3Addr
+      fma.s1             fB16 = fLnSin6, fDxSqrL, fB16 // (LnSin6*deltaX^2)lo
+      extr.u             GR_Index3 = GR_X_2, 1, 5 // Extract bits 1-5 of X_2
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA25 = fA25, fXSqr, fA23
+      nop.i              0
+}
+;;
+{ .mfi
+      shladd             GR_ad_tbl_3 = GR_Index3, 4, rTbl3Addr // Point to G_3
+      fadd.s1            fPolL = fPolL, fRes1H
+      nop.i              0
+}
+{ .mfi
+      shladd             rTmpPtr = GR_Index3, 4, rTmpPtr // Point to G_3
+      fadd.s1            fRes1L = fRes1L, fA2L // (A3*y)lo + A2lo
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfps              FR_G3, FR_H3 = [GR_ad_tbl_3] // Load G_3, H_3
+      fma.s1             fRes2L = fA4, fXSqrL, fRes2L // ((A5 + A4*y)*y^2)lo
+      nop.i              0
+}
+{ .mfi
+      ldfd               FR_h3 = [rTmpPtr] // Load h_3
+      fsub.s1            fRes4L = fPol, fRes4H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // ((((A5 + A4*y)*y^2) + A3*y + A2)*y^2)hi
+      fma.s1             fRes7H = fRes4H, fXSqr, f0
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA15 = fA15, FR_FracX, fA14
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes3L = fRes3L, fRes6H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes6L = fRes6L, fA0L // (A1*y)lo + A0lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fLnSinL = fLnSinL, fB14
+
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // delta((LnSin6*deltaX^2 + LnSin4)*deltaX^2)
+      fms.s1             fB20 = fLnSinH, fDxSqr, fB18
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fPolL = fPolL, fRes1L // (A3*y + A2)lo
+
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // ((LnSin6*deltaX^2 + LnSin4)*deltaX^2 + LnSin2)hi
+      fadd.s1            fLnSin6 = fB18, fLnSin2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes4L = fRes4L, fRes2H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA17 = fA17, FR_FracX, fA16
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // delta(((((A5 + A4*y)*y^2) + A3*y + A2)*y^2)
+      fms.s1             fRes7L = fRes4H, fXSqr, fRes7H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fPol = fRes7H, fRes3H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes3L = fRes3L, fRes6L // (A1*y + A0)lo
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA25 = fA25, fX4, fA21
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // (LnSin6*deltaX^2 + LnSin4)lo
+      fadd.s1            fLnSinL = fLnSinL, fB16
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB20 = fLnSinH, fDxSqrL, fB20
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fLnSin4 = fLnSin2, fLnSin6
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // (((LnSin6*deltaX^2 + LnSin4)*deltaX^2 + LnSin2)*DeltaX^2)hi
+      fma.s1             fLnSinH = fLnSin6, fDxSqr, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // ((A5 + A4*y)*y^2)lo + (A3*y + A2)lo
+      fadd.s1            fRes2L = fRes2L, fPolL
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA17 = fA17, fXSqr, fA15
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // ((((A5 + A4*y)*y^2) + A3*y + A2)*y^2)lo
+      fma.s1             fRes7L = fRes4H, fXSqrL, fRes7L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fPolL = fRes3H, fPol
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA13 = fA13, FR_FracX, fA12
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA11 = fA11, FR_FracX, fA10
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // ((LnSin6*deltaX^2 + LnSin4)*deltaX^2)lo
+      fma.s1             fB20 = fLnSinL, fDxSqr, fB20
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fmpy.s1            FR_G = FR_G, FR_G2 // G = G_1 * G_2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fLnSin4 = fLnSin4, fB18
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fms.s1             fLnSinL = fLnSin6, fDxSqr, fLnSinH
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // (((A5 + A4*y)*y^2) + A3*y + A2)lo
+      fadd.s1            fRes4L = fRes4L, fRes2L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fhDelX = fhDelX, FR_h2 // h = h_1 + h_2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes7L = fRes7L, fRes3L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fPolL = fPolL, fRes7H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fcvt.xf            fFloatNDx = fFloatNDx
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            FR_H = FR_H, FR_H2 // H = H_1 + H_2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fmpy.s1            FR_G = FR_G, FR_G3 // G = (G_1 * G_2) * G_3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // ((LnSin6*deltaX^2 + LnSin4)*deltaX^2)lo + (LnSin2)lo
+      fadd.s1            fLnSin2L = fLnSin2L, fB20
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA25 = fA25, fX4, fA17
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA13 = fA13, fXSqr, fA11
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA9 = fA9, FR_FracX, fA8
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA7 = fA7, FR_FracX, fA6
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin36 = fLnSin36, fDelX8, fLnSin28
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin14 = fLnSin14, fDxSqr, fLnSin12
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin10 = fLnSin10, fDxSqr, fLnSin8
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            FR_H = FR_H, FR_H3 // H = (H_1 + H_2) + H_3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fRDx = FR_G, fNormDx, f1 // r = G * S_hi - 1
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // poly_lo = r * Q4 + Q3
+      fma.s1             FR_poly_lo = FR_r, FR_Q4, FR_Q3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fmpy.s1            FR_rsq = FR_r, FR_r // rsq = r * r
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // ((((A5 + A4*y)*y^2) + A3*y + A2)*y^2)lo + (A1*y + A0)lo
+      fma.s1             fRes7L = fRes4L, fXSqr, fRes7L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA25 = fA25, fX4, fA13
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA9 = fA9, fXSqr, fA7
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // h = N * log2_lo + h
+      fma.s1             FR_h = fFloatN, FR_log2_lo, FR_h
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fhDelX = fhDelX, FR_h3 // h = (h_1 + h_2) + h_3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin36 = fLnSin36, fDelX6, fLnSin20
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin14 = fLnSin14, fDelX4, fLnSin10
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = r * Q4 + Q3
+      fma.s1             fPolyLoDx = fRDx, FR_Q4, FR_Q3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fmpy.s1            fRDxSq = fRDx, fRDx // rsq = r * r
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // Y_hi = N * log2_hi + H
+      fma.s1             fResLnDxH = fFloatNDx, FR_log2_hi, FR_H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             FR_rcub = FR_rsq, FR_r, f0 // rcub = r^3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA9 = fA25, fX4, fA9
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fPolL = fPolL, fRes7L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fLnSin4 = fLnSin4, fLnSin2L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // h = N * log2_lo + h
+      fma.s1             fhDelX = fFloatNDx, FR_log2_lo, fhDelX
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin36 = fLnSin36, fDelX8, fLnSin14
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // ((LnSin6*deltaX^2 + LnSin4)*deltaX^2 + LnSin2)lo
+      fma.s1             fLnSinL = fLnSin6, fDxSqrL, fLnSinL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo * r + Q2
+      fma.s1             fPolyLoDx = fPolyLoDx, fRDx, FR_Q2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fRDxCub = fRDxSq, fRDx, f0 // rcub = r^3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      famax.s0              fRes5H = fPol, fResH
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      //  High part of (lgammal(|x|) + log(|x|))
+      fadd.s1            fRes1H = fPol, fResH
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo * r + Q2
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_r, FR_Q2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPolL = fA9, fX6, fPolL // P25lo
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      famin.s0              fRes5L = fPol, fResH
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // High part of -(LnSin + log(|DeltaX|))
+      fnma.s1            fRes2H = fResLnDxH, f1, fLnSinH
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      // (((LnSin6*deltaX^2 + LnSin4)*deltaX^2 + LnSin2)*DeltaX^2)lo
+      fma.s1             fLnSinL = fLnSin4, fDxSqr, fLnSinL
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin36 = fLnSin36, fDelX6, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_hi = Q1 * rsq + r
+      fma.s1             fPolyHiDx = FR_Q1, fRDxSq, fRDx
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo*r^3 + h
+      fma.s1             fPolyLoDx = fPolyLoDx, fRDxCub, fhDelX
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes1L = fRes5H, fRes1H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      //  -(lgammal(|x|) + log(|x|))hi
+      fnma.s1            fRes1H = fRes1H, f1, f0
+
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_hi = Q1 * rsq + r
+      fma.s1             FR_poly_hi = FR_Q1, FR_rsq, FR_r
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo*r^3 + h
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_rcub, FR_h
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fRes2L = fResLnDxH, fMOne, fRes2H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSinL = fLnSin36, fDxSqr, fLnSinL
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // Y_lo = poly_hi + poly_lo
+      fadd.s1            fResLnDxL = fPolyHiDx, fPolyLoDx
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, fRes5L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // high part of the final result
+      fadd.s1            fYH = fRes2H, fRes1H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // Y_lo = poly_hi + poly_lo
+      fadd.s1            fResL = FR_poly_hi, FR_poly_lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      famax.s0              fRes4H = fRes2H, fRes1H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      famin.s0              fRes4L = fRes2H, fRes1H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // (LnSin)lo + (log(|DeltaX|))lo
+      fsub.s1            fLnSinL = fLnSinL, fResLnDxL
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2L = fRes2L, fLnSinH
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      //(lgammal(|x|))lo + (log(|x|))lo
+      fadd.s1            fPolL = fResL, fPolL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fYL = fRes4H, fYH
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // Low part of -(LnSin + log(|DeltaX|))
+      fadd.s1            fRes2L = fRes2L, fLnSinL
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      //  High part of (lgammal(|x|) + log(|x|))
+      fadd.s1            fRes1L = fRes1L, fPolL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fYL = fYL, fRes4L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes2L = fRes2L, fRes1L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // low part of the final result
+      fadd.s1            fYL = fYL, fRes2L
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      // final result for -6.0 < x <= -0.75, non-integer, "far" from roots
+      fma.s0             f8 = fYH, f1, fYL
+      // exit here for -6.0 < x <= -0.75, non-integer, "far" from roots
+      br.ret.sptk        b0
+}
+;;
+
+// here if |x+1| < 2^(-7)
+.align 32
+_closeToNegOne:
+{ .mfi
+      getf.exp           GR_N =  fDx // Get N = exponent of x
+      fmerge.se          fAbsX =  f1, fDx // Form |deltaX|
+      // Get high 4 bits of significand of deltaX
+      extr.u             rIndex1Dx = rSignifDx, 59, 4
+}
+{ .mfi
+      addl               rPolDataPtr= @ltoff(lgammal_1pEps_data),gp
+      fma.s1             fA0L = fDxSqr, fDxSqr, f0 // deltaX^4
+      // sign of GAMMA is positive if p10 is set to 1
+(p10) adds               rSgnGam = 1, r0
+}
+;;
+{ .mfi
+      shladd             GR_ad_z_1 = rIndex1Dx, 2, GR_ad_z_1 // Point to Z_1
+      fnma.s1            fResL = fDx, f1, f0 // -(x+1)
+      // Get high 15 bits of significand
+      extr.u             GR_X_0 = rSignifDx, 49, 15
+}
+{ .mfi
+      ld8                rPolDataPtr = [rPolDataPtr]
+      nop.f              0
+      shladd             GR_ad_tbl_1 = rIndex1Dx, 4, rTbl1Addr // Point to G_1
+}
+;;
+{ .mfi
+      ld4                GR_Z_1 = [GR_ad_z_1] // Load Z_1
+      nop.f              0
+      and                GR_N = GR_N, r17Ones // mask sign bit
+}
+{ .mfi
+      adds               rTmpPtr = 8, GR_ad_tbl_1
+      nop.f              0
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+}
+;;
+{ .mfi
+      ldfps              FR_G, FR_H = [GR_ad_tbl_1],8 // Load G_1, H_1
+      nop.f              0
+      adds               rTmpPtr2 = 96, rPolDataPtr
+}
+{ .mfi
+      ldfd               FR_h = [rTmpPtr] // Load h_1
+      nop.f              0
+      // unbiased exponent of deltaX
+      sub                GR_N = GR_N, rExpHalf, 1
+}
+;;
+{ .mfi
+      adds               rTmpPtr3 = 192, rPolDataPtr
+      nop.f              0
+      // sign of GAMMA is negative if p11 is set to 1
+(p11) adds               rSgnGam = -1, r0
+}
+{ .mfi
+      ldfe               fA1 = [rPolDataPtr], 16 // A1
+      nop.f              0
+      nop.i              0
+}
+;;
+{.mfi
+      ldfe               fA2 = [rPolDataPtr], 16 // A2
+      nop.f              0
+      // Get bits 30-15 of X_0 * Z_1
+      pmpyshr2.u         GR_X_1 = GR_X_0,GR_Z_1,15
+}
+{ .mfi
+      ldfpd              fA20, fA19 = [rTmpPtr2], 16 // P8, P7
+      nop.f              0
+      nop.i              0
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      ldfe               fA3 = [rPolDataPtr], 16 // A3
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA18, fA17 = [rTmpPtr2], 16 // P6, P5
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fA4 = [rPolDataPtr], 16 // A4
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA16, fA15 = [rTmpPtr2], 16 // P4, p3
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA5L, fA6 = [rPolDataPtr], 16 // A5, A6
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA14, fA13 = [rTmpPtr2], 16 // P2, P1
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA7, fA8 = [rPolDataPtr], 16 // A7, A8
+      nop.f              0
+      extr.u             GR_Index2 = GR_X_1, 6, 4 // Extract bits 6-9 of X_1
+}
+{ .mfi
+      ldfe               fLnSin2 = [rTmpPtr2], 16
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      shladd             GR_ad_z_2 = GR_Index2, 2, rZ2Addr  // Point to Z_2
+      nop.f              0
+      shladd             GR_ad_tbl_2 = GR_Index2, 4, rTbl2Addr // Point to G_2
+}
+{ .mfi
+      ldfe               fLnSin4 = [rTmpPtr2], 32
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ld4                GR_Z_2 = [GR_ad_z_2] // Load Z_2
+      nop.f              0
+      adds               rTmpPtr = 8, GR_ad_tbl_2
+}
+{ .mfi
+      // Put integer N into rightmost significand
+      setf.sig           fFloatN = GR_N
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fLnSin6 = [rTmpPtr3]
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfe               fLnSin8 = [rTmpPtr2]
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfps              FR_G2, FR_H2 = [GR_ad_tbl_2],8 // Load G_2, H_2
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfd               FR_h2 = [rTmpPtr] // Load h_2
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      fma.s1             fResH = fA20, fResL, fA19 //polynomial for log(|x|)
+     // Get bits 30-15 of X_1 * Z_2
+      pmpyshr2.u         GR_X_2 = GR_X_1,GR_Z_2,15
+}
+{ .mfi
+      // store signgam if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      fma.s1             fA2 = fA2, fDx, fA1 // polynomial for lgammal(|x|)
+      nop.i              0
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      nop.m              0
+      fma.s1             fA18 = fA18, fResL, fA17 //polynomial for log(|x|)
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA16 = fA16, fResL, fA15 //polynomial for log(|x|)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA4 = fA4, fDx, fA3 // polynomial for lgammal(|x|)
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA14 = fA14, fResL, fA13 //polynomial for log(|x|)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA6 = fA6, fDx, fA5L // polynomial for lgammal(|x|)
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fA8, fDx, fA7 // polynomial for lgammal(|x|)
+      extr.u             GR_Index3 = GR_X_2, 1, 5 // Extract bits 1-5 of X_2
+}
+;;
+{ .mfi
+      shladd             GR_ad_tbl_3 = GR_Index3, 4, rTbl3Addr // Point to G_3
+      // loqw part of lnsin polynomial
+      fma.s1             fRes3L = fLnSin4, fDxSqr, fLnSin2
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfps              FR_G3, FR_H3 = [GR_ad_tbl_3], 8 // Load G_3, H_3
+      fcvt.xf            fFloatN = fFloatN // N as FP number
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fResH = fResH, fDxSqr, fA18 // High part of log(|x|)
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfd               FR_h3 = [GR_ad_tbl_3] // Load h_3
+      fma.s1             fA4 = fA4, fDxSqr, fA2 // Low part of lgammal(|x|)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // high part of lnsin polynomial
+      fma.s1             fRes3H = fLnSin8, fDxSqr, fLnSin6
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fmpy.s1            FR_G = FR_G, FR_G2 // G = G_1 * G_2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            FR_H = FR_H, FR_H2 // H = H_1 + H_2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            FR_h = FR_h, FR_h2 // h = h_1 + h_2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA16 = fA16, fDxSqr, fA14 // Low part of log(|x|)
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fPol, fDxSqr, fA6 // High part of lgammal(|x|)
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fResH = fResH, fA0L, fA16 // log(|x|)/deltaX^2 - deltaX
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fmpy.s1            FR_G = FR_G, FR_G3 // G = (G_1 * G_2) * G_3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            FR_H = FR_H, FR_H3 // H = (H_1 + H_2) + H_3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            FR_h = FR_h, FR_h3 // h = (h_1 + h_2) + h_3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fResH = fResH, fDxSqr, fResL // log(|x|)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fPol, fA0L, fA4 // lgammal(|x|)/|x|
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             FR_r = FR_G, fAbsX, f1 // r = G * S_hi - 1
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // high part of log(deltaX)= Y_hi = N * log2_hi + H
+      fma.s1             fRes4H = fFloatN, FR_log2_hi, FR_H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // h = N * log2_lo + h
+      fma.s1             FR_h = fFloatN, FR_log2_lo, FR_h
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fResH = fPol, fDx, fResH // lgammal(|x|) + log(|x|)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // lnsin/deltaX^2
+      fma.s1             fRes3H = fRes3H, fA0L, fRes3L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = r * Q4 + Q3
+      fma.s1             FR_poly_lo = FR_r, FR_Q4, FR_Q3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fmpy.s1            FR_rsq = FR_r, FR_r // rsq = r * r
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // lnSin - log(|x|) - lgammal(|x|)
+      fms.s1             fResH = fRes3H, fDxSqr, fResH
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo * r + Q2
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_r, FR_Q2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             FR_rcub = FR_rsq, FR_r, f0 // rcub = r^3
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      // poly_hi = Q1 * rsq + r
+      fma.s1             FR_poly_hi = FR_Q1, FR_rsq, FR_r
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo*r^3 + h
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_rcub, FR_h
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      // low part of log(|deltaX|) = Y_lo = poly_hi + poly_lo
+      fadd.s1            fRes4L = FR_poly_hi, FR_poly_lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fResH = fResH, fRes4L
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      // final result for |x+1|< 2^(-7) path
+      fsub.s0            f8 = fResH, fRes4H
+      // exit for |x+1|< 2^(-7) path
+      br.ret.sptk        b0
+}
+;;
+
+
+// here if -2^63 < x < -6.0 and x is not an integer
+// Also we are going to filter out cases when x falls in
+// range which is "close enough" to negative root. Rhis case
+// may occur only for -19.5 < x since other roots of lgamma are
+// insignificant from double extended point of view (they are closer
+// to RTN(x) than one ulp(x).
+.align 32
+_negStirling:
+{ .mfi
+      ldfe               fLnSin6 = [rLnSinDataPtr], 32
+      fnma.s1            fInvX = f8, fRcpX, f1 // start of 3rd NR iteration
+      // Get high 4 bits of significand of deltaX
+      extr.u             rIndex1Dx = rSignifDx, 59, 4
+}
+{ .mfi
+      ldfe               fLnSin8 = [rTmpPtr3], 32
+      fadd.s1            FR_h = FR_h, FR_h2 // h = h_1 + h_2
+(p12) cmp.ltu.unc        p6, p0 = rSignifX, rLeftBound
+}
+;;
+{ .mfi
+      ldfe               fLnSin10 = [rLnSinDataPtr], 32
+      fmpy.s1            FR_G = FR_G, FR_G3 // G = (G_1 * G_2) * G_3
+      // Get high 15 bits of significand
+      extr.u             GR_X_0 = rSignifDx, 49, 15
+}
+{ .mfi
+      shladd             GR_ad_z_1 = rIndex1Dx, 2, GR_ad_z_1  // Point to Z_1
+      fadd.s1            FR_H = FR_H, FR_H3 // H = (H_1 + H_2) + H_3
+      // set p6 if x falls in "near root" range
+(p6)  cmp.geu.unc        p6, p0 = rSignifX, rRightBound
+}
+;;
+{ .mfi
+      getf.exp           GR_N =  fDx // Get N = exponent of x
+      fma.s1             fDx4 = fDxSqr, fDxSqr, f0 // deltaX^4
+      adds               rTmpPtr = 96, rBernulliPtr
+}
+{ .mfb
+      ld4                GR_Z_1 = [GR_ad_z_1] // Load Z_1
+      fma.s1             fLnSin34 = fLnSin34, fDxSqr, fLnSin32
+      // branch to special path if x falls in "near root" range
+(p6)  br.cond.spnt       _negRoots
+}
+;;
+.pred.rel "mutex",p10,p11
+{ .mfi
+      ldfe               fLnSin12 = [rTmpPtr3]
+      fma.s1             fLnSin26 = fLnSin26, fDxSqr, fLnSin24
+(p10) cmp.eq             p8, p9 = rXRnd, r0
+}
+{ .mfi
+      ldfe               fLnSin14 = [rLnSinDataPtr]
+      fma.s1             fLnSin30 = fLnSin30, fDxSqr, fLnSin28
+(p11) cmp.eq             p9, p8 = rXRnd, r0
+}
+;;
+{ .mfi
+      ldfpd              fB2, fB2L = [rBernulliPtr], 16
+      fma.s1             fLnSin18 = fLnSin18, fDxSqr, fLnSin16
+      shladd             GR_ad_tbl_1 = rIndex1Dx, 4, rTbl1Addr // Point to G_1
+
+}
+{ .mfi
+      ldfe               fB14 = [rTmpPtr], 16
+      fma.s1             fLnSin22 = fLnSin22, fDxSqr, fLnSin20
+      and                GR_N = GR_N, r17Ones // mask sign bit
+}
+;;
+{ .mfi
+      ldfe               fB4 = [rBernulliPtr], 16
+      fma.s1             fInvX = fInvX, fRcpX, fRcpX // end of 3rd NR iteration
+      // Get bits 30-15 of X_0 * Z_1
+      pmpyshr2.u         GR_X_1 = GR_X_0,GR_Z_1,15
+}
+{ .mfi
+      ldfe               fB16 = [rTmpPtr], 16
+      fadd.s1            FR_h = FR_h, FR_h3 // h = (h_1 + h_2) + h_3
+      adds               rTmpPtr2 = 8, GR_ad_tbl_1
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      ldfe               fB6 = [rBernulliPtr], 16
+      fms.s1             FR_r = FR_G, fSignifX, f1 // r = G * S_hi - 1
+      adds               rTmpPtr3 = -48, rTmpPtr
+}
+{ .mfi
+      ldfe               fB18 = [rTmpPtr], 16
+      // High part of the log(|x|) = Y_hi = N * log2_hi + H
+      fma.s1             fResH = fFloatN, FR_log2_hi, FR_H
+      sub                GR_N = GR_N, rExpHalf, 1 // unbiased exponent of deltaX
+}
+;;
+.pred.rel "mutex",p8,p9
+{ .mfi
+      ldfe               fB8 = [rBernulliPtr], 16
+      fma.s1             fLnSin36 = fLnSin36, fDx4, fLnSin34
+      // sign of GAMMA(x) is negative
+(p8)  adds               rSgnGam = -1, r0
+}
+{ .mfi
+      ldfe               fB20 = [rTmpPtr], -160
+      fma.s1             fRes5H = fLnSin4, fDxSqr, f0
+      // sign of GAMMA(x) is positive
+(p9)  adds               rSgnGam = 1, r0
+
+}
+;;
+{ .mfi
+      ldfe               fB10 = [rBernulliPtr], 16
+      fma.s1             fLnSin30 = fLnSin30, fDx4, fLnSin26
+(p14) adds               rTmpPtr = -160, rTmpPtr
+}
+{ .mfi
+      ldfe               fB12 = [rTmpPtr3], 16
+      fma.s1             fDx8 = fDx4, fDx4, f0 // deltaX^8
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+}
+;;
+{ .mfi
+      ldfps              fGDx, fHDx = [GR_ad_tbl_1], 8 // Load G_1, H_1
+      fma.s1             fDx6 = fDx4, fDxSqr, f0 // deltaX^6
+      extr.u             GR_Index2 = GR_X_1, 6, 4 // Extract bits 6-9 of X_1
+}
+{ .mfi
+      ldfd               fhDx = [rTmpPtr2] // Load h_1
+      fma.s1             fLnSin22 = fLnSin22, fDx4, fLnSin18
+      nop.i              0
+}
+;;
+{ .mfi
+      // Load two parts of C
+      ldfpd              fRes1H, fRes1L = [rTmpPtr], 16
+      fma.s1             fRcpX = fInvX, fInvX, f0  // (1/x)^2
+      shladd             GR_ad_tbl_2 = GR_Index2, 4, rTbl2Addr // Point to G_2
+}
+{ .mfi
+      shladd             GR_ad_z_2 = GR_Index2, 2, rZ2Addr  // Point to Z_2
+      fma.s1             FR_h = fFloatN, FR_log2_lo, FR_h// h = N * log2_lo + h
+      nop.i              0
+}
+;;
+{ .mfi
+      ld4                GR_Z_2 = [GR_ad_z_2] // Load Z_2
+      fnma.s1            fInvXL = f8, fInvX, f1 // relative error of 1/x
+      nop.i              0
+}
+{ .mfi
+      adds               rTmpPtr2 = 8, GR_ad_tbl_2
+      fma.s1             fLnSin8 = fLnSin8, fDxSqr, fLnSin6
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfps              FR_G2, FR_H2 = [GR_ad_tbl_2],8   // Load G_2, H_2
+      // poly_lo = r * Q4 + Q3
+      fma.s1             FR_poly_lo = FR_r, FR_Q4, FR_Q3
+      nop.i              0
+}
+{ .mfi
+      ldfd               fh2Dx = [rTmpPtr2] // Load h_2
+      fmpy.s1            FR_rsq = FR_r, FR_r // rsq = r * r
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA1L = fB2, fInvX, f0 // (B2*(1/x))hi
+      nop.i              0
+}
+{ .mfi
+      // Put integer N into rightmost significand
+      setf.sig           fFloatNDx = GR_N
+      fms.s1             fRes4H = fResH, f1, f1  // ln(|x|)hi - 1
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2H = fRes5H, fLnSin2//(lnSin4*DeltaX^2 + lnSin2)hi
+      // Get bits 30-15 of X_1 * Z_2
+      pmpyshr2.u         GR_X_2 = GR_X_1,GR_Z_2,15
+}
+{ .mfi
+      nop.m              0
+      fms.s1             fRes5L = fLnSin4, fDxSqr, fRes5H
+      nop.i              0
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      nop.m              0
+      fma.s1             fInvX4 = fRcpX, fRcpX, f0 // (1/x)^4
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB6 = fB6, fRcpX, fB4
+      nop.i              0
+}
+;;
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      fma.s1             fB18 = fB18, fRcpX, fB16
+      nop.i              0
+}
+{ .mfi
+      // store signgam if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      fma.s1             fInvXL = fInvXL, fInvX, f0 // low part of 1/x
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo * r + Q2
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_r, FR_Q2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             FR_rcub = FR_rsq, FR_r, f0 // rcub = r^3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes3H = fRes4H, f8, f0 // (-|x|*(ln(|x|)-1))hi
+      extr.u             GR_Index3 = GR_X_2, 1, 5  // Extract bits 1-5 of X_2
+}
+{ .mfi
+      nop.m              0
+      // poly_hi = Q1 * rsq + r
+      fma.s1             FR_poly_hi = FR_Q1, FR_rsq, FR_r
+      nop.i              0
+}
+;;
+{ .mfi
+      shladd             GR_ad_tbl_3 = GR_Index3, 4, rTbl3Addr // Point to G_3
+      fms.s1             fA2L = fB2, fInvX, fA1L // delta(B2*(1/x))
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fnma.s1            fBrnH = fRes1H, f1, fA1L // (-C - S(1/x))hi
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfps              fG3Dx, fH3Dx = [GR_ad_tbl_3],8 // Load G_3, H_3
+      fma.s1             fInvX8 = fInvX4, fInvX4, f0 // (1/x)^8
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB10 = fB10, fRcpX, fB8
+      nop.i              0
+}
+;;
+
+{ .mfi
+      ldfd               fh3Dx = [GR_ad_tbl_3] // Load h_3
+      fma.s1             fB20 = fB20, fInvX4, fB18
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB14 = fB14, fRcpX, fB12
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin36 = fLnSin36, fDx8, fLnSin30
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin12 = fLnSin12, fDxSqr, fLnSin10
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes2L = fLnSin2, fRes2H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fRes2H, fDxSqr, f0 // high part of LnSin
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fnma.s1            fResH = fResH, FR_MHalf, fResH // -0.5*ln(|x|)hi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fmpy.s1            fGDx = fGDx, FR_G2 // G = G_1 * G_2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo*r^3 + h
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_rcub, FR_h
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // B2lo*(1/x)hi+ delta(B2*(1/x))
+      fma.s1             fA2L = fB2L, fInvX, fA2L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB20 = fB20, fInvX4, fB14
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB10 = fB10, fInvX4, fB6
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fcvt.xf            fFloatNDx = fFloatNDx
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin14 = fLnSin14, fDx4, fLnSin12
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin36 = fLnSin36, fDx8, fLnSin22
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fms.s1             fRes3L = fRes4H, f8, fRes3H // delta(-|x|*(ln(|x|)-1))
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fmpy.s1            fGDx = fGDx, fG3Dx // G = (G_1 * G_2) * G_3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // (-|x|*(ln(|x|)-1) - 0.5ln(|x|))hi
+      fadd.s1            fRes4H = fRes3H, fResH
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA2L = fInvXL, fB2, fA2L //(B2*(1/x))lo
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // low part of log(|x|) = Y_lo = poly_hi + poly_lo
+      fadd.s1            fResL = FR_poly_hi, FR_poly_lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB20 = fB20, fInvX8, fB10
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fInvX3 = fInvX, fRcpX, f0 // (1/x)^3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fHDx = fHDx, FR_H2 // H = H_1 + H_2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes5L = fRes5L, fLnSin2L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2L = fRes2L, fRes5H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fhDx = fhDx, fh2Dx // h = h_1 + h_2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fBrnL = fRes1H, fMOne, fBrnH
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fms.s1             FR_r = fGDx, fNormDx, f1 // r = G * S_hi - 1
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes3L = fResL, f8 , fRes3L // (-|x|*(ln(|x|)-1))lo
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes4L = fRes3H, fRes4H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // low part of "Bernulli" polynomial
+      fma.s1             fB20 = fB20, fInvX3, fA2L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fnma.s1            fResL = fResL, FR_MHalf, fResL // -0.5*ln(|x|)lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fHDx = fHDx, fH3Dx // H = (H_1 + H_2) + H_3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fms.s1             fPolL = fRes2H, fDxSqr, fPol
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fhDx = fhDx, fh3Dx // h = (h_1 + h_2) + h_3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // (-|x|*(ln(|x|)-1) - 0.5ln(|x|) - C - S(1/x))hi
+      fadd.s1            fB14 = fRes4H, fBrnH
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = r * Q4 + Q3
+      fma.s1             FR_poly_lo = FR_r, FR_Q4, FR_Q3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fmpy.s1            FR_rsq = FR_r, FR_r // rsq = r * r
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes4L = fRes4L, fResH
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fBrnL = fBrnL, fA1L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // (-|x|*(ln(|x|)-1))lo + (-0.5ln(|x|))lo
+      fadd.s1            fRes3L = fRes3L, fResL
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fnma.s1            fB20 = fRes1L, f1, fB20 // -Clo - S(1/x)lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2L = fRes2L, fRes5L // (lnSin4*DeltaX^2 + lnSin2)lo
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPolL = fDxSqrL, fRes2H, fPolL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin14 = fLnSin14, fDx4, fLnSin8
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin36 = fLnSin36,  fDx8, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo * r + Q2
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_r, FR_Q2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             FR_rcub = FR_rsq, FR_r, f0 // rcub = r^3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_hi = Q1 * rsq + r
+      fma.s1             FR_poly_hi = FR_Q1, FR_rsq, FR_r
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fB12 = fRes4H, fB14
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // (-|x|*(ln(|x|)-1) - 0.5ln(|x|))lo
+      fadd.s1            fRes4L = fRes4L, fRes3L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fBrnL = fBrnL, fB20 // (-C - S(1/x))lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // high part of log(|DeltaX|) = Y_hi = N * log2_hi + H
+      fma.s1             fLnDeltaH = fFloatNDx, FR_log2_hi, fHDx
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // h = N * log2_lo + h
+      fma.s1             fhDx = fFloatNDx, FR_log2_lo, fhDx
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fPolL = fRes2L, fDxSqr, fPolL
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin14 = fLnSin36,  fDxSqr, fLnSin14
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // (-|x|*(ln(|x|)-1) - 0.5ln(|x|))lo + (- C - S(1/x))lo
+      fadd.s1            fBrnL = fBrnL, fRes4L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fB12 = fB12, fBrnH
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo*r^3 + h
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_rcub, fhDx
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fnma.s1            fRes1H = fLnDeltaH, f1, fPol//(-ln(|DeltaX|) + LnSin)hi
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fPolL = fDxSqrL, fRes2L, fPolL
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin36 = fLnSin14, fDx6, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // (-|x|*(ln(|x|)-1) - 0.5ln(|x|) - C - S(1/x))lo
+      fadd.s1            fB12 = fB12, fBrnL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // low part of log(|DeltaX|) =  Y_lo = poly_hi + poly_lo
+      fadd.s1            fLnDeltaL= FR_poly_hi, FR_poly_lo
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fms.s1             fRes1L = fLnDeltaH, fMOne, fRes1H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fPolL = fPolL, fLnSin36
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      //(-|x|*(ln(|x|)-1)-0.5ln(|x|) - C - S(1/x))hi + (-ln(|DeltaX|) + LnSin)hi
+      fadd.s1            f8 = fRes1H, fB14
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      //max((-|x|*(ln(|x|)-1)-0.5ln(|x|) - C - S(1/x))hi,
+      //    (-ln(|DeltaX|) + LnSin)hi)
+      famax.s1           fMaxNegStir = fRes1H, fB14
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      //min((-|x|*(ln(|x|)-1)-0.5ln(|x|) - C - S(1/x))hi,
+      //    (-ln(|DeltaX|) + LnSin)hi)
+      famin.s1           fMinNegStir = fRes1H, fB14
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, fPol
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // (-ln(|DeltaX|))lo + (LnSin)lo
+      fnma.s1            fPolL = fLnDeltaL, f1, fPolL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            f9 = fMaxNegStir, f8 // delta1
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, fPolL // (-ln(|DeltaX|) + LnSin)lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            f9 = f9, fMinNegStir
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, fB12
+      nop.i              0
+}
+;;
+{ .mfi
+      // low part of the result
+      fadd.s1            f9 = f9, fRes1L
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      // final result for -2^63 < x < -6.0 path
+      fma.s0             f8 = f8, f1, f9
+      // exit here  for -2^63 < x < -6.0 path
+      br.ret.sptk        b0
+}
+;;
+
+// here if x falls in neighbourhood of any negative root
+// "neighbourhood" typically means that |lgammal(x)| < 0.17
+// on the [-3.0,-2.0] range |lgammal(x)| has even less
+// magnitude
+// rXint contains index of the root
+// p10 is set if root belongs to "right" ones
+// p11 is set if root belongs to "left" ones
+// lgammal(x) is approximated by polynomial of
+// 19th degree from (x - root) argument
+.align 32
+_negRoots:
+{ .mfi
+      addl          rPolDataPtr= @ltoff(lgammal_right_roots_polynomial_data),gp
+      nop.f              0
+      shl                rTmpPtr2 = rXint, 7 // (i*16)*8
+}
+{ .mfi
+      adds               rRootsAddr = -288, rRootsBndAddr
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fRoot = [rRootsAddr] // FP representation of root
+      nop.f              0
+      shl                rTmpPtr = rXint, 6  // (i*16)*4
+}
+{ .mfi
+(p11) adds               rTmpPtr2 = 3536, rTmpPtr2
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ld8                rPolDataPtr = [rPolDataPtr]
+      nop.f              0
+      shladd             rTmpPtr = rXint, 4, rTmpPtr // (i*16) + (i*16)*4
+}
+{ .mfi
+      adds               rTmpPtr3 = 32, rTmpPtr2
+      nop.f              0
+      nop.i              0
+}
+;;
+.pred.rel "mutex",p10,p11
+{ .mfi
+      add                rTmpPtr3 = rTmpPtr, rTmpPtr3
+      nop.f              0
+(p10) cmp.eq             p8, p9 = rXRnd, r0
+}
+{ .mfi
+      // (i*16) + (i*16)*4 + (i*16)*8
+      add                rTmpPtr = rTmpPtr, rTmpPtr2
+      nop.f              0
+(p11) cmp.eq             p9, p8 = rXRnd, r0
+}
+;;
+{ .mfi
+      add                rTmpPtr2 = rPolDataPtr, rTmpPtr3
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      add                rPolDataPtr = rPolDataPtr, rTmpPtr // begin + offset
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA0, fA0L = [rPolDataPtr], 16 // A0
+      nop.f              0
+      adds               rTmpPtr = 112, rTmpPtr2
+}
+{ .mfi
+      ldfpd              fA2, fA2L = [rTmpPtr2], 16 // A2
+      nop.f              0
+      cmp.eq             p12, p13 = 4, rSgnGamSize
+}
+;;
+{ .mfi
+      ldfpd              fA1, fA1L = [rPolDataPtr], 16 // A1
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfe               fA3 = [rTmpPtr2], 128 // A4
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA12, fA13 = [rTmpPtr], 16 // A12, A13
+      nop.f              0
+      adds               rTmpPtr3 = 64, rPolDataPtr
+}
+{ .mfi
+      ldfpd              fA16, fA17 = [rTmpPtr2], 16 // A16, A17
+      nop.f              0
+      adds               rPolDataPtr = 32, rPolDataPtr
+}
+;;
+.pred.rel "mutex",p8,p9
+{ .mfi
+      ldfpd              fA14, fA15 = [rTmpPtr], 16 // A14, A15
+      nop.f              0
+      // sign of GAMMA(x) is negative
+(p8)  adds               rSgnGam = -1, r0
+}
+{ .mfi
+      ldfpd              fA18, fA19 = [rTmpPtr2], 16 // A18, A19
+      nop.f              0
+      // sign of GAMMA(x) is positive
+(p9)  adds               rSgnGam = 1, r0
+}
+;;
+{ .mfi
+      ldfe               fA4 = [rPolDataPtr], 16 // A4
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA6, fA7 = [rTmpPtr3], 16 // A6, A7
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fA5 = [rPolDataPtr], 16 // A5
+      // if x equals to (rounded) root exactly
+      fcmp.eq.s1         p6, p0 = f8, fRoot
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA8, fA9 = [rTmpPtr3], 16 // A8, A9
+      fms.s1             FR_FracX = f8, f1, fRoot
+      nop.i              0
+}
+;;
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p12) st4                [rSgnGamAddr] = rSgnGam
+      nop.f              0
+      nop.i              0
+}
+{ .mfb
+      // store signgam if size of variable is 8 bytes
+(p13) st8                [rSgnGamAddr] = rSgnGam
+      // answer if x equals to (rounded) root exactly
+(p6)  fadd.s0            f8 = fA0, fA0L
+      // exit if x equals to (rounded) root exactly
+(p6)  br.ret.spnt        b0
+}
+;;
+{ .mmf
+      ldfpd              fA10, fA11 = [rTmpPtr3], 16 // A10, A11
+      nop.m              0
+      nop.f              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fResH = fA2, FR_FracX, f0 // (A2*x)hi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA4L = FR_FracX, FR_FracX, f0 // x^2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA17 = fA17, FR_FracX, fA16
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fma.s1             fA13 = fA13, FR_FracX, fA12
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA19 = fA19, FR_FracX, fA18
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fma.s1             fA15 = fA15, FR_FracX, fA14
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fPol = fA7, FR_FracX, fA6
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fA9 = fA9, FR_FracX, fA8
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fResL = fA2, FR_FracX, fResH // delta(A2*x)
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fadd.s1            fRes1H = fResH, fA1 // (A2*x + A1)hi
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA11 = fA11, FR_FracX, fA10
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fma.s1             fA5L = fA4L, fA4L, f0 // x^4
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA19 = fA19, fA4L, fA17
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fma.s1             fA15 = fA15, fA4L, fA13
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fPol, FR_FracX, fA5
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fma.s1             fA3L = fA4L, FR_FracX, f0 // x^3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // delta(A2*x) + A2L*x = (A2*x)lo
+      fma.s1             fResL = fA2L, FR_FracX, fResL
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fsub.s1            fRes1L = fA1, fRes1H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA11 = fA11, fA4L, fA9
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fma.s1             fA19 = fA19, fA5L, fA15
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fPol = fPol, FR_FracX, fA4
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fResL = fResL, fA1L // (A2*x)lo + A1
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, fResH
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes2H = fRes1H, FR_FracX, f0 // ((A2*x + A1)*x)hi
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fA19 = fA19, fA5L, fA11
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fPol = fPol, FR_FracX, fA3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, fResL // (A2*x + A1)lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // delta((A2*x + A1)*x)
+      fms.s1             fRes2L = fRes1H, FR_FracX, fRes2H
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fadd.s1            fRes3H = fRes2H, fA0 // ((A2*x + A1)*x + A0)hi
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA19 = fA19, fA5L, f0
+      nop.i              0
+}
+
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes2L = fRes1L, FR_FracX, fRes2L // ((A2*x + A1)*x)lo
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fsub.s1            fRes3L = fRes2H, fRes3H
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fPol = fA19, FR_FracX, fPol
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes3L = fRes3L, fA0
+      nop.i              0
+}
+{.mfi
+      nop.m              0
+      fadd.s1            fRes2L = fRes2L, fA0L // ((A2*x + A1)*x)lo + A0L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes3L = fRes3L, fRes2L // (((A2*x + A1)*x) + A0)lo
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fRes3L = fPol, fA3L, fRes3L
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      // final result for arguments which are close to negative roots
+      fma.s0             f8 = fRes3H, f1, fRes3L
+      // exit here for arguments which are close to negative roots
+      br.ret.sptk        b0
+}
+;;
+
+// here if |x| < 0.5
+.align 32
+lgammal_0_half:
+{ .mfi
+      ld4                GR_Z_1 = [rZ1offsett] // Load Z_1
+      fma.s1             fA4L = f8, f8, f0 // x^2
+      addl               rPolDataPtr    = @ltoff(lgammal_0_Half_data), gp
+}
+{ .mfi
+      shladd             GR_ad_tbl_1 = GR_Index1, 4, rTbl1Addr// Point to G_1
+      nop.f              0
+      addl               rLnSinDataPtr    = @ltoff(lgammal_lnsin_data), gp
+}
+;;
+{ .mfi
+      ldfps              FR_G, FR_H = [GR_ad_tbl_1],8 // Load G_1, H_1
+      nop.f              0
+      // Point to Constants_Z_2
+      add                GR_ad_z_2 = 0x140, GR_ad_z_1
+}
+{ .mfi
+      add                GR_ad_q = -0x60, GR_ad_z_1 // Point to Constants_Q
+      nop.f              0
+      // Point to Constants_G_H_h2
+      add                GR_ad_tbl_2 = 0x180, GR_ad_z_1
+}
+;;
+{ .mfi
+      ld8                rPolDataPtr = [rPolDataPtr]
+      nop.f              0
+      // Point to Constants_G_H_h3
+      add                GR_ad_tbl_3 = 0x280, GR_ad_z_1
+}
+{ .mfi
+      ldfd               FR_h = [GR_ad_tbl_1] // Load h_1
+      nop.f              0
+      sub                GR_N = rExpX, rExpHalf, 1
+}
+;;
+{ .mfi
+      ld8                rLnSinDataPtr    = [rLnSinDataPtr]
+      nop.f              0
+      // Get bits 30-15 of X_0 * Z_1
+      pmpyshr2.u         GR_X_1 = GR_X_0,GR_Z_1,15
+}
+{ .mfi
+      ldfe               FR_log2_hi = [GR_ad_q],16 // Load log2_hi
+      nop.f              0
+      sub                GR_N = r0, GR_N
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      ldfe               FR_log2_lo = [GR_ad_q], 16 // Load log2_lo
+      nop.f              0
+      add                rTmpPtr2 = 320, rPolDataPtr
+}
+{ .mfi
+      add                rTmpPtr = 32, rPolDataPtr
+      nop.f              0
+      // exponent of 0.25
+      adds               rExp2 = -1, rExpHalf
+}
+;;
+{ .mfi
+      ldfpd              fA3, fA3L = [rPolDataPtr], 16 // A3
+      fma.s1             fA5L = fA4L, fA4L, f0 // x^4
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA1, fA1L = [rTmpPtr], 16 // A1
+      fms.s1             fB8 = f8, f8, fA4L // x^2 - <x^2>
+      // set p6 if -0.5 < x <= -0.25
+(p15) cmp.eq.unc         p6, p0 = rExpX, rExp2
+}
+;;
+{ .mfi
+      ldfpd              fA2, fA2L = [rPolDataPtr], 16 // A2
+      nop.f              0
+      // set p6 if -0.5 < x <= -0.40625
+(p6)  cmp.le.unc         p6, p0 = 10, GR_Index1
+}
+{ .mfi
+      ldfe               fA21 = [rTmpPtr2], -16 // A21
+      // Put integer N into rightmost significand
+      nop.f              0
+      adds               rTmpPtr = 240, rTmpPtr
+}
+;;
+{ .mfi
+      setf.sig           fFloatN = GR_N
+      nop.f              0
+      extr.u             GR_Index2 = GR_X_1, 6, 4 // Extract bits 6-9 of X_1
+}
+{ .mfi
+      ldfe               FR_Q4 = [GR_ad_q], 16 // Load Q4
+      nop.f              0
+      adds               rPolDataPtr = 304, rPolDataPtr
+}
+;;
+{ .mfi
+      ldfe               fA20 = [rTmpPtr2], -32 // A20
+      nop.f              0
+      shladd             GR_ad_z_2 = GR_Index2, 2, GR_ad_z_2  // Point to Z_2
+}
+{ .mfi
+      ldfe               fA19 = [rTmpPtr], -32 // A19
+      nop.f              0
+      shladd             GR_ad_tbl_2 = GR_Index2, 4, GR_ad_tbl_2// Point to G_2
+}
+;;
+{ .mfi
+      ldfe               fA17 = [rTmpPtr], -32 // A17
+      nop.f              0
+      adds               rTmpPtr3 = 8, GR_ad_tbl_2
+}
+{ .mfb
+      ldfe               fA18 = [rTmpPtr2], -32 // A18
+      nop.f              0
+      // branch to special path for -0.5 < x <= 0.40625
+(p6)  br.cond.spnt       lgammal_near_neg_half
+}
+;;
+{ .mmf
+      ld4                GR_Z_2 = [GR_ad_z_2] // Load Z_2
+      ldfe               fA15 = [rTmpPtr], -32 // A15
+      fma.s1             fB20 = fA5L, fA5L, f0 // x^8
+}
+;;
+{ .mmf
+      ldfe               fA16 = [rTmpPtr2], -32 // A16
+      ldfe               fA13 = [rTmpPtr], -32 // A13
+      fms.s1             fB16 = fA4L, fA4L, fA5L
+}
+;;
+{ .mmf
+      ldfps              FR_G2, FR_H2 = [GR_ad_tbl_2], 8 // Load G_2, H_2
+      ldfd               FR_h2 = [rTmpPtr3] // Load h_2
+      fmerge.s           fB10 = f8, fA5L // sign(x) * x^4
+}
+;;
+{ .mmi
+      ldfe               fA14 = [rTmpPtr2], -32 // A14
+      ldfe               fA11 = [rTmpPtr], -32 // A11
+      // Get bits 30-15 of X_1 * Z_2
+      pmpyshr2.u         GR_X_2 = GR_X_1,GR_Z_2,15
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      ldfe               fA12 = [rTmpPtr2], -32 // A12
+      fma.s1             fRes4H = fA3, fAbsX, f0
+      adds               rTmpPtr3 = 16, GR_ad_q
+}
+{ .mfi
+      ldfe               fA9 = [rTmpPtr], -32 // A9
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mmf
+      ldfe               fA10 = [rTmpPtr2], -32 // A10
+      ldfe               fA7 = [rTmpPtr], -32 // A7
+      fma.s1             fB18 = fB20, fB20, f0 // x^16
+}
+;;
+{ .mmf
+      ldfe               fA8 = [rTmpPtr2], -32 // A8
+      ldfe               fA22 = [rPolDataPtr], 16 // A22
+      fcvt.xf            fFloatN = fFloatN
+}
+;;
+{ .mfi
+      ldfe               fA5 = [rTmpPtr], -32 // A5
+      fma.s1             fA21 = fA21, fAbsX, fA20 // v16
+      extr.u             GR_Index3 = GR_X_2, 1, 5 // Extract bits 1-5 of X_2
+}
+{ .mfi
+      ldfe               fA6 = [rTmpPtr2], -32 // A6
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mmf
+      // Point to G_3
+      shladd             GR_ad_tbl_3 = GR_Index3, 4, GR_ad_tbl_3
+      ldfe               fA4 = [rTmpPtr2], -32 // A4
+      fma.s1             fA19 = fA19, fAbsX, fA18 // v13
+}
+;;
+.pred.rel "mutex",p14,p15
+{ .mfi
+      ldfps              FR_G3, FR_H3 = [GR_ad_tbl_3],8 // Load G_3, H_3
+      fms.s1             fRes4L = fA3, fAbsX, fRes4H
+(p14) adds               rSgnGam = 1, r0
+}
+{ .mfi
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+      fadd.s1            fRes2H = fRes4H, fA2
+(p15) adds               rSgnGam = -1, r0
+}
+;;
+
+{ .mfi
+      ldfd               FR_h3 = [GR_ad_tbl_3] // Load h_3
+      fma.s1             fA17 = fA17, fAbsX, fA16 // v12
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               FR_Q3 = [GR_ad_q], 32 // Load Q3
+      fmpy.s1            FR_G = FR_G, FR_G2 // G = G_1 * G_2
+      nop.i              0
+}
+{ .mfi
+      ldfe               FR_Q2 = [rTmpPtr3], 16 // Load Q2
+      fadd.s1            FR_H = FR_H, FR_H2 // H = H_1 + H_2
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               FR_Q1 = [GR_ad_q] // Load Q1
+      fma.s1             fA15 = fA15, fAbsX, fA14 // v8
+      nop.i              0
+}
+{ .mfi
+      adds               rTmpPtr3 = 32, rLnSinDataPtr
+      fadd.s1            FR_h = FR_h, FR_h2 // h = h_1 + h_2
+      nop.i              0
+}
+;;
+{ .mmf
+      ldfpd              fLnSin2, fLnSin2L = [rLnSinDataPtr], 16
+      ldfe               fLnSin6 = [rTmpPtr3], 32
+      fma.s1             fA13 = fA13, fAbsX, fA12 // v7
+
+}
+;;
+{ .mfi
+      ldfe               fLnSin4 = [rLnSinDataPtr], 32
+      fma.s1             fRes4L = fA3L, fAbsX, fRes4L
+      nop.i              0
+}
+{ .mfi
+      ldfe               fLnSin10 = [rTmpPtr3], 32
+      fsub.s1            fRes2L = fA2, fRes2H
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fLnSin8 = [rLnSinDataPtr], 32
+      fma.s1             fResH = fRes2H, fAbsX, f0
+      nop.i              0
+}
+{ .mfi
+      ldfe               fLnSin14 = [rTmpPtr3], 32
+      fma.s1             fA22 = fA22, fA4L, fA21 // v15
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fLnSin12 = [rLnSinDataPtr], 32
+      fma.s1             fA9 = fA9, fAbsX, fA8 // v4
+      nop.i              0
+}
+{ .mfi
+      ldfd               fLnSin18 = [rTmpPtr3], 16
+      fma.s1             fA11 = fA11, fAbsX, fA10 // v5
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fLnSin16 = [rLnSinDataPtr], 24
+      fma.s1             fA19 = fA19, fA4L, fA17 // v11
+      nop.i              0
+}
+{ .mfi
+      ldfd               fLnSin22 = [rTmpPtr3], 16
+      fma.s1             fPolL = fA7, fAbsX, fA6
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfd               fLnSin20 = [rLnSinDataPtr], 16
+      fmpy.s1            FR_G = FR_G, FR_G3 // G = (G_1 * G_2) * G_3
+      nop.i              0
+}
+{ .mfi
+      ldfd               fLnSin26 = [rTmpPtr3], 16
+      fadd.s1            FR_H = FR_H, FR_H3 // H = (H_1 + H_2) + H_3
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfd               fLnSin24 = [rLnSinDataPtr], 16
+      fadd.s1            fRes2L = fRes2L, fRes4H
+      nop.i              0
+}
+{ .mfi
+      ldfd               fLnSin30 = [rTmpPtr3], 16
+      fadd.s1            fA2L = fA2L, fRes4L
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfd               fLnSin28 = [rLnSinDataPtr], 16
+      fms.s1             fResL = fRes2H, fAbsX, fResH
+      nop.i              0
+}
+{ .mfi
+      ldfd               fLnSin34 = [rTmpPtr3], 8
+      fadd.s1            fRes2H = fResH, fA1
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfd               fLnSin32 = [rLnSinDataPtr]
+      fma.s1             fA11 = fA11, fA4L, fA9 // v3
+      nop.i              0
+}
+{ .mfi
+      ldfd               fLnSin36 = [rTmpPtr3]
+      fma.s1             fA15 = fA15, fA4L, fA13 // v6
+      nop.i              0
+}
+;;
+
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      fadd.s1            FR_h = FR_h, FR_h3 // h = (h_1 + h_2) + h_3
+      nop.i              0
+}
+{ .mfi
+      // store signgam if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      fma.s1             fA5 = fA5, fAbsX, fA4
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             FR_r = FR_G, fSignifX, f1 // r = G * S_hi - 1
+      nop.i              0
+}
+{ .mfi
+      nop.m               0
+      // High part of the log(|x|): Y_hi = N * log2_hi + H
+      fms.s1             FR_log2_hi = fFloatN, FR_log2_hi, FR_H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fA3L = fRes2L, fA2L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA22 = fA22, fA5L, fA19
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes2L = fA1, fRes2H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fRes3H = fRes2H, f8, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA15 = fA15, fA5L, fA11 // v2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin18 = fLnSin18, fA4L, fLnSin16
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // h = N * log2_lo + h
+      fms.s1             FR_h = fFloatN, FR_log2_lo, FR_h
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPolL = fPolL, fA4L, fA5
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = r * Q4 + Q3
+      fma.s1             FR_poly_lo = FR_r, FR_Q4, FR_Q3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fmpy.s1            FR_rsq = FR_r, FR_r // rsq = r * r
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fResL = fA3L, fAbsX, fResL
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin30 = fLnSin30, fA4L, fLnSin28
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2L = fRes2L, fResH
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fms.s1             fRes3L = fRes2H, f8, fRes3H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1H = fRes3H, FR_log2_hi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fB20, fA22, fA15
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin34 = fLnSin34, fA4L, fLnSin32
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin14 = fLnSin14, fA4L, fLnSin12
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo * r + Q2
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_r, FR_Q2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fnma.s1            FR_rcub = FR_rsq, FR_r, f0 // rcub = r^3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_hi = Q1 * rsq + r
+      fma.s1             FR_poly_hi = FR_Q1, FR_rsq, FR_r
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fA1L = fA1L, fResL
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin22 = fLnSin22, fA4L, fLnSin20
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin26 = fLnSin26, fA4L, fLnSin24
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes1L = FR_log2_hi, fRes1H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fPol, fA5L, fPolL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin34 = fLnSin36, fA5L, fLnSin34
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin18 = fLnSin18, fA5L, fLnSin14
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin6 = fLnSin6, fA4L, fLnSin4
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin10 = fLnSin10, fA4L, fLnSin8
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_hi = Q1 * rsq + r
+      fma.s1             FR_poly_hi = FR_Q1, FR_rsq, FR_r
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2L = fRes2L, fA1L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo*r^3 + h
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_rcub, FR_h
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB2 = fLnSin2, fA4L, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, fRes3H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fPol, fB10, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin26 = fLnSin26, fA5L, fLnSin22
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin34 = fLnSin34, fA5L, fLnSin30
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin10 = fLnSin10, fA5L, fLnSin6
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin2L = fLnSin2L, fA4L, f0
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      fma.s1             fRes3L = fRes2L, f8, fRes3L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // Y_lo = poly_hi + poly_lo
+      fsub.s1            FR_log2_lo = FR_poly_lo, FR_poly_hi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fms.s1             fB4 = fLnSin2, fA4L, fB2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2H = fRes1H, fPol
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin34 = fLnSin34, fB20, fLnSin26
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin18 = fLnSin18, fB20, fLnSin10
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fLnSin2L = fB8, fLnSin2, fLnSin2L
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      fadd.s1            FR_log2_lo = FR_log2_lo, fRes3L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes2L = fRes1H, fRes2H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB6 = fLnSin34, fB18, fLnSin18
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fB4 = fLnSin2L, fB4
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, FR_log2_lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2L = fRes2L, fPol
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fB12 = fB6, fA5L, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2L = fRes2L, fRes1L
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      fms.s1             fB14 = fB6, fA5L, fB12
+      nop.i              0
+}
+{ .mfb
+      nop.m              0
+      fadd.s1            fLnSin30 = fB2, fB12
+      // branch out if x is negative
+(p15) br.cond.spnt       _O_Half_neg
+}
+;;
+{ .mfb
+      nop.m              0
+      // sign(x)*Pol(|x|) - log(|x|)
+      fma.s0             f8 = fRes2H, f1, fRes2L
+      // it's an answer already for positive x
+      // exit if 0 < x < 0.5
+      br.ret.sptk        b0
+}
+;;
+
+// here if x is negative and |x| < 0.5
+.align 32
+_O_Half_neg:
+{ .mfi
+      nop.m              0
+      fma.s1             fB14 = fB16, fB6, fB14
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fLnSin16 = fB2, fLnSin30
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fResH = fLnSin30, fRes2H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fLnSin16 = fLnSin16, fB12
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fB4 = fB14, fB4
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fLnSin16 = fB4, fLnSin16
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fResL = fRes2H, fResH
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fResL = fResL, fLnSin30
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fLnSin16 = fLnSin16, fRes2L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fResL = fResL, fLnSin16
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      // final result for -0.5 < x < 0
+      fma.s0             f8 = fResH, f1, fResL
+      // exit for -0.5 < x < 0
+      br.ret.sptk        b0
+}
+;;
+
+// here if x >= 8.0
+// there are two computational paths:
+// 1) For x >10.0 Stirling's formula is used
+// 2) Polynomial approximation for 8.0 <= x <= 10.0
+.align 32
+lgammal_big_positive:
+{ .mfi
+      addl               rPolDataPtr = @ltoff(lgammal_data), gp
+      fmerge.se          fSignifX =  f1, f8
+      // Get high 15 bits of significand
+      extr.u             GR_X_0 = rSignifX, 49, 15
+}
+{.mfi
+      shladd             rZ1offsett = GR_Index1, 2, GR_ad_z_1  // Point to Z_1
+      fnma.s1            fInvX = f8, fRcpX, f1 // start of 1st NR iteration
+      adds               rSignif1andQ = 0x5, r0
+}
+;;
+{.mfi
+      ld4                GR_Z_1 = [rZ1offsett] // Load Z_1
+      nop.f              0
+      shl                rSignif1andQ = rSignif1andQ, 61 // significand of 1.25
+}
+{  .mfi
+      cmp.eq             p8, p0 = rExpX, rExp8 // p8 = 1 if 8.0 <= x < 16
+      nop.f              0
+      adds               rSgnGam = 1, r0 // gamma is positive at this range
+}
+;;
+{ .mfi
+      shladd             GR_ad_tbl_1 = GR_Index1, 4, rTbl1Addr// Point to G_1
+      nop.f              0
+      add                GR_ad_q = -0x60, GR_ad_z_1 // Point to Constants_Q
+}
+{ .mlx
+      ld8                rPolDataPtr    = [rPolDataPtr]
+      movl               rDelta = 0x3FF2000000000000
+}
+;;
+{ .mfi
+      ldfps              FR_G, FR_H = [GR_ad_tbl_1],8 // Load G_1, H_1
+      nop.f              0
+      add                GR_ad_z_2 = 0x140, GR_ad_z_1 // Point to Constants_Z_2
+}
+{ .mfi
+      // Point to Constants_G_H_h2
+      add                GR_ad_tbl_2 = 0x180, GR_ad_z_1
+      nop.f              0
+      // p8 = 1 if 8.0 <= x <= 10.0
+(p8)  cmp.leu.unc        p8, p0 = rSignifX, rSignif1andQ
+}
+;;
+{ .mfi
+      ldfd               FR_h = [GR_ad_tbl_1] // Load h_1
+      nop.f              0
+      // Get bits 30-15 of X_0 * Z_1
+      pmpyshr2.u         GR_X_1 = GR_X_0,GR_Z_1,15
+}
+{ .mfb
+(p8)  setf.d             FR_MHalf = rDelta
+      nop.f              0
+(p8)  br.cond.spnt       lgammal_8_10 // branch out if 8.0 <= x <= 10.0
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      ldfe               fA1 = [rPolDataPtr], 16 // Load overflow threshold
+      fma.s1             fRcpX = fInvX, fRcpX, fRcpX // end of 1st NR iteration
+      // Point to Constants_G_H_h3
+      add                GR_ad_tbl_3 = 0x280, GR_ad_z_1
+}
+{ .mlx
+      nop.m              0
+      movl               rDelta = 0xBFE0000000000000 // -0.5 in DP
+}
+;;
+{ .mfi
+      ldfe               FR_log2_hi = [GR_ad_q],16 // Load log2_hi
+      nop.f              0
+      sub                GR_N = rExpX, rExpHalf, 1 // unbiased exponent of x
+}
+;;
+{ .mfi
+      ldfe               FR_log2_lo = [GR_ad_q],16 // Load log2_lo
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      setf.d             FR_MHalf = rDelta
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      // Put integer N into rightmost significand
+      setf.sig           fFloatN = GR_N
+      nop.f              0
+      extr.u             GR_Index2 = GR_X_1, 6, 4 // Extract bits 6-9 of X_1
+}
+{ .mfi
+      ldfe               FR_Q4 = [GR_ad_q], 16 // Load Q4
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      shladd             GR_ad_z_2 = GR_Index2, 2, GR_ad_z_2  // Point to Z_2
+      nop.f              0
+      shladd             GR_ad_tbl_2 = GR_Index2, 4, GR_ad_tbl_2// Point to G_2
+}
+{ .mfi
+      ldfe               FR_Q3 = [GR_ad_q], 16 // Load Q3
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ld4                GR_Z_2 = [GR_ad_z_2] // Load Z_2
+      fnma.s1            fInvX = f8, fRcpX, f1 // start of 2nd NR iteration
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfps              FR_G2, FR_H2 = [GR_ad_tbl_2], 8 // Load G_2, H_2
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfd               FR_h2 = [GR_ad_tbl_2] // Load h_2
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               FR_Q2 = [GR_ad_q],16 // Load Q2
+      nop.f              0
+      // Get bits 30-15 of X_1 * Z_2
+      pmpyshr2.u         GR_X_2 = GR_X_1,GR_Z_2,15
+}
+;;
+//
+//    For performance, don't use result of pmpyshr2.u for 4 cycles.
+//
+{ .mfi
+      ldfe               FR_Q1 = [GR_ad_q] // Load Q1
+      fcmp.gt.s1         p7,p0 = f8, fA1 // check if x > overflow threshold
+      nop.i              0
+}
+;;
+{.mfi
+      ldfpd              fA0, fA0L = [rPolDataPtr], 16 // Load two parts of C
+      fma.s1             fRcpX = fInvX, fRcpX, fRcpX // end of 2nd NR iteration
+      nop.i              0
+}
+;;
+{ .mfb
+      ldfpd              fB2, fA1 = [rPolDataPtr], 16
+      nop.f              0
+(p7)  br.cond.spnt       lgammal_overflow // branch if x > overflow threshold
+}
+;;
+{.mfi
+      ldfe               fB4 = [rPolDataPtr], 16
+      fcvt.xf            fFloatN = fFloatN
+      extr.u             GR_Index3 = GR_X_2, 1, 5 // Extract bits 1-5 of X_2
+}
+;;
+{ .mfi
+      shladd             GR_ad_tbl_3 = GR_Index3, 4, GR_ad_tbl_3// Point to G_3
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfe               fB6 = [rPolDataPtr], 16
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfps              FR_G3, FR_H3 = [GR_ad_tbl_3], 8 // Load G_3, H_3
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfd               FR_h3 = [GR_ad_tbl_3] // Load h_3
+      fmpy.s1            FR_G = FR_G, FR_G2 // G = G_1 * G_2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            FR_H = FR_H, FR_H2 // H = H_1 + H_2
+      nop.i              0
+}
+;;
+
+{ .mfi
+      ldfe               fB8 = [rPolDataPtr], 16
+      fadd.s1            FR_h = FR_h, FR_h2 // h = h_1 + h_2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fnma.s1            fInvX = f8, fRcpX, f1 // start of 3rd NR iteration
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fB10 = [rPolDataPtr], 16
+      nop.f              0
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+}
+;;
+{ .mfi
+      ldfe               fB12 = [rPolDataPtr], 16
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fB14 = [rPolDataPtr], 16
+      nop.f              0
+      nop.i              0
+}
+;;
+
+{ .mfi
+      ldfe               fB16 = [rPolDataPtr], 16
+      // get double extended coefficients from two doubles
+      // two doubles are needed in Stitling's formula for negative x
+      fadd.s1            fB2 = fB2, fA1
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fB18 = [rPolDataPtr], 16
+      fma.s1             fInvX = fInvX, fRcpX, fRcpX // end of 3rd NR iteration
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fB20 = [rPolDataPtr], 16
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      fmpy.s1            FR_G = FR_G, FR_G3 // G = (G_1 * G_2) * G_3
+      nop.i              0
+}
+{ .mfi
+      // store signgam if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      fadd.s1            FR_H = FR_H, FR_H3 // H = (H_1 + H_2) + H_3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            FR_h = FR_h, FR_h3 // h = (h_1 + h_2) + h_3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRcpX = fInvX, fInvX, f0 // 1/x^2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA0L = fB2, fInvX, fA0L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             FR_r = fSignifX, FR_G, f1 // r = G * S_hi - 1
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // High part of the log(x): Y_hi = N * log2_hi + H
+      fma.s1             fRes2H = fFloatN, FR_log2_hi, FR_H
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      // h = N * log2_lo + h
+      fma.s1             FR_h = fFloatN, FR_log2_lo, FR_h
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // High part of the log(x): Y_hi = N * log2_hi + H
+      fma.s1             fRes1H = fFloatN, FR_log2_hi, FR_H
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fPol = fB18, fRcpX, fB16 // v9
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA2L = fRcpX, fRcpX, f0   // v10
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fA3 = fB6, fRcpX, fB4     // v3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA4 = fB10, fRcpX, fB8    // v4
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fRes2H =fRes2H, f1, f1 //  log_Hi(x) -1
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // poly_lo = r * Q4 + Q3
+      fma.s1             FR_poly_lo = FR_r, FR_Q4, FR_Q3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes1H = fRes1H, FR_MHalf, f0 // -0.5*log_Hi(x)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fmpy.s1            FR_rsq = FR_r, FR_r // rsq = r * r
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA7 = fB14, fRcpX, fB12  // v7
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA8 = fA2L, fB20, fPol   // v8
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA2 = fA4, fA2L, fA3    // v2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA4L = fA2L, fA2L, f0    // v5
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fResH = fRes2H, f8, f0 // (x*(ln(x)-1))hi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo * r + Q2
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_r, FR_Q2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             FR_rcub = FR_rsq, FR_r, f0 // rcub = r^3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // poly_hi = Q1 * rsq + r
+      fma.s1             FR_poly_hi = FR_Q1, FR_rsq, FR_r
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA11 = fRcpX, fInvX, f0 // 1/x^3
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA6 = fA8, fA2L, fA7   // v6
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fResL = fRes2H, f8, fResH // d(x*(ln(x)-1))
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes3H = fResH, fRes1H // (x*(ln(x)-1) -0.5ln(x))hi
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // poly_lo = poly_lo*r^3 + h
+      fma.s1             FR_poly_lo = FR_poly_lo, FR_rcub, FR_h
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fA4L, fA6, fA2   // v1
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // raise inexact exception
+      fma.s0             FR_log2_lo = FR_log2_lo, FR_log2_lo, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes4H = fRes3H, fA0 // (x*(ln(x)-1) -0.5ln(x))hi + Chi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes3L = fResH, fRes3H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // Y_lo = poly_hi + poly_lo
+      fadd.s1            fRes2L = FR_poly_hi, FR_poly_lo
+      nop.i              0
+}
+;;
+
+{ .mfi
+      nop.m              0
+      fma.s1             fA0L = fPol, fA11, fA0L // S(1/x) + Clo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes3L = fRes3L, fRes1H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes4L = fRes3H, fRes4H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fResL = fRes2L, f8 , fResL // lo part of x*(ln(x)-1)
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // Clo + S(1/x) - 0.5*logLo(x)
+      fma.s1             fA0L = fRes2L, FR_MHalf, fA0L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes4L = fRes4L, fA0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // Clo + S(1/x) - 0.5*logLo(x) + (x*(ln(x)-1))lo
+      fadd.s1            fA0L = fA0L, fResL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes4L = fRes4L, fRes3L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes4L = fRes4L, fA0L
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      fma.s0             f8 = fRes4H, f1, fRes4L
+      // exit for x > 10.0
+      br.ret.sptk        b0
+}
+;;
+// here if 8.0 <= x <= 10.0
+// Result = P15(y), where y = x/8.0 - 1.5
+.align 32
+lgammal_8_10:
+{ .mfi
+      addl               rPolDataPtr    = @ltoff(lgammal_8_10_data), gp
+      fms.s1             FR_FracX = fSignifX, f1, FR_MHalf // y = x/8.0 - 1.5
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+}
+;;
+{ .mfi
+      ld8                rLnSinDataPtr = [rPolDataPtr]
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ld8                rPolDataPtr = [rPolDataPtr]
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      adds               rZ1offsett = 32, rLnSinDataPtr
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      adds               rLnSinDataPtr = 48, rLnSinDataPtr
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA1, fA1L = [rPolDataPtr], 16 // A1
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfe               fA2 = [rZ1offsett], 32 // A5
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA0, fA0L = [rPolDataPtr], 16 // A0
+      fma.s1             FR_rsq = FR_FracX, FR_FracX, f0 // y^2
+      nop.i              0
+}
+{ .mfi
+      ldfe               fA3 = [rLnSinDataPtr],32 // A5
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mmf
+      ldfe               fA4 = [rZ1offsett], 32 // A4
+      ldfe               fA5 = [rLnSinDataPtr], 32 // A5
+      nop.f              0
+}
+;;
+{ .mmf
+      ldfe               fA6 = [rZ1offsett], 32 // A6
+      ldfe               fA7 = [rLnSinDataPtr], 32 // A7
+      nop.f              0
+}
+;;
+{ .mmf
+      ldfe               fA8 = [rZ1offsett], 32 // A8
+      ldfe               fA9 = [rLnSinDataPtr], 32 // A9
+      nop.f              0
+}
+;;
+{ .mmf
+      ldfe               fA10 = [rZ1offsett], 32 // A10
+      ldfe               fA11 = [rLnSinDataPtr], 32 // A11
+      nop.f              0
+}
+;;
+{ .mmf
+      ldfe               fA12 = [rZ1offsett], 32 // A12
+      ldfe               fA13 = [rLnSinDataPtr], 32 // A13
+      fma.s1             FR_Q4 = FR_rsq, FR_rsq, f0 // y^4
+}
+;;
+{ .mmf
+      ldfe               fA14 = [rZ1offsett], 32 // A14
+      ldfe               fA15 = [rLnSinDataPtr], 32 // A15
+      nop.f              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes1H = FR_FracX, fA1, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA3 = fA3, FR_FracX, fA2 // v4
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA5 = fA5, FR_FracX, fA4 // v5
+      nop.i              0
+}
+;;
+{ .mfi
+      // store sign of GAMMA(x) if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      fma.s1             fA3L = FR_Q4, FR_Q4, f0 // v9 = y^8
+      nop.i              0
+}
+{ .mfi
+      // store sign of GAMMA(x) if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      fma.s1             fA7 = fA7, FR_FracX, fA6 // v7
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA9 = fA9, FR_FracX, fA8 // v8
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fRes1L = FR_FracX, fA1, fRes1H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA11 = fA11, FR_FracX, fA10 // v12
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA13 = fA13, FR_FracX, fA12 // v13
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fRes2H = fRes1H, f1, fA0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA15 = fA15, FR_FracX, fA14 // v16
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA5 = fA5, FR_rsq, fA3 // v3
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA9 = fA9, FR_rsq, fA7 // v6
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes1L = FR_FracX, fA1L, fRes1L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fRes2L = fA0, f1, fRes2H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA13 = fA13, FR_rsq, fA11 // v11
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA9 = fA9, FR_Q4, fA5 // v2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes1L = fRes1L, f1, fA0L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes2L = fRes2L, f1, fRes1H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA15 = fA15, FR_Q4, fA13 // v10
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes2L = fRes1L, f1, fRes2L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fA3L, fA15, fA9
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             f8 = FR_rsq , fPol, fRes2H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fPol, FR_rsq, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fRes1L = fRes2H, f1, f8
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes1L = fRes1L, f1, fPol
+      nop.i              0
+}
+;;
+{.mfi
+      nop.m              0
+      fma.s1             fRes1L = fRes1L, f1, fRes2L
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      fma.s0             f8 = f8, f1, fRes1L
+      // exit for 8.0 <= x <= 10.0
+      br.ret.sptk        b0
+}
+;;
+
+// here if 4.0 <=x < 8.0
+.align 32
+lgammal_4_8:
+{ .mfi
+      addl               rPolDataPtr= @ltoff(lgammal_4_8_data),gp
+      fms.s1             FR_FracX = fSignifX, f1, FR_MHalf
+      adds               rSgnGam = 1, r0
+}
+;;
+{ .mfi
+      ld8                rPolDataPtr = [rPolDataPtr]
+      nop.f              0
+      nop.i              0
+}
+;;
+
+{ .mfb
+      adds               rTmpPtr = 160, rPolDataPtr
+      nop.f              0
+      // branch to special path which computes polynomial of 25th degree
+      br.sptk            lgamma_polynom25
+}
+;;
+
+// here if 2.25 <=x < 4.0
+.align 32
+lgammal_2Q_4:
+{ .mfi
+      addl               rPolDataPtr= @ltoff(lgammal_2Q_4_data),gp
+      fms.s1             FR_FracX = fSignifX, f1, FR_MHalf
+      adds               rSgnGam = 1, r0
+}
+;;
+{ .mfi
+      ld8                rPolDataPtr = [rPolDataPtr]
+      nop.f              0
+      nop.i              0
+}
+;;
+
+{ .mfb
+      adds               rTmpPtr = 160, rPolDataPtr
+      nop.f              0
+      // branch to special path which computes polynomial of 25th degree
+      br.sptk            lgamma_polynom25
+}
+;;
+
+// here if 0.5 <= |x| < 0.75
+.align 32
+lgammal_half_3Q:
+.pred.rel "mutex", p14, p15
+{ .mfi
+(p14) addl               rPolDataPtr= @ltoff(lgammal_half_3Q_data),gp
+     // FR_FracX = x - 0.625 for positive x
+(p14) fms.s1             FR_FracX = f8, f1, FR_FracX
+(p14) adds               rSgnGam = 1, r0
+}
+{ .mfi
+(p15) addl               rPolDataPtr= @ltoff(lgammal_half_3Q_neg_data),gp
+     // FR_FracX = x + 0.625 for negative x
+(p15) fma.s1             FR_FracX = f8, f1, FR_FracX
+(p15) adds               rSgnGam = -1, r0
+}
+;;
+{ .mfi
+      ld8                rPolDataPtr = [rPolDataPtr]
+       nop.f              0
+       nop.i              0
+}
+;;
+{ .mfb
+      adds               rTmpPtr = 160, rPolDataPtr
+      nop.f              0
+      // branch to special path which computes polynomial of 25th degree
+      br.sptk            lgamma_polynom25
+}
+;;
+// here if 1.3125 <= x < 1.5625
+.align 32
+lgammal_loc_min:
+{ .mfi
+      adds               rSgnGam = 1, r0
+      nop.f              0
+      nop.i              0
+}
+{ .mfb
+      adds               rTmpPtr = 160, rPolDataPtr
+      fms.s1             FR_FracX = f8, f1, fA5L
+      br.sptk            lgamma_polynom25
+}
+;;
+// here if -2.605859375 <= x < -2.5
+// special polynomial approximation used since neither "near root"
+// approximation nor reflection formula give satisfactory accuracy on
+// this range
+.align 32
+_neg2andHalf:
+{ .mfi
+      addl               rPolDataPtr= @ltoff(lgammal_neg2andHalf_data),gp
+      fma.s1             FR_FracX = fB20, f1, f8 // 2.5 + x
+      adds               rSgnGam = -1, r0
+}
+;;
+{.mfi
+      ld8                rPolDataPtr = [rPolDataPtr]
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfb
+      adds               rTmpPtr = 160, rPolDataPtr
+      nop.f              0
+      // branch to special path which computes polynomial of 25th degree
+      br.sptk            lgamma_polynom25
+}
+;;
+
+// here if -0.5 < x <= -0.40625
+.align 32
+lgammal_near_neg_half:
+{ .mmf
+      addl               rPolDataPtr= @ltoff(lgammal_near_neg_half_data),gp
+      setf.exp           FR_FracX = rExpHalf
+      nop.f              0
+}
+;;
+{ .mfi
+      ld8                rPolDataPtr = [rPolDataPtr]
+      nop.f              0
+      adds               rSgnGam = -1, r0
+}
+;;
+{ .mfb
+      adds               rTmpPtr = 160, rPolDataPtr
+      fma.s1             FR_FracX = FR_FracX, f1, f8
+      // branch to special path which computes polynomial of 25th degree
+      br.sptk            lgamma_polynom25
+}
+;;
+
+// here if there an answer is P25(x)
+// rPolDataPtr, rTmpPtr point to coefficients
+// x is in FR_FracX register
+.align 32
+lgamma_polynom25:
+{ .mfi
+      ldfpd              fA3, fA0L = [rPolDataPtr], 16 // A3
+      nop.f              0
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+}
+{ .mfi
+      ldfpd              fA18, fA19 = [rTmpPtr], 16 // D7, D6
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA1, fA1L = [rPolDataPtr], 16 // A1
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA16, fA17 = [rTmpPtr], 16 // D4, D5
+      nop.f              0
+}
+;;
+{ .mfi
+      ldfpd              fA12, fA13 = [rPolDataPtr], 16 // D0, D1
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA14, fA15 = [rTmpPtr], 16 // D2, D3
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA24, fA25 = [rPolDataPtr], 16 // C21, C20
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA22, fA23 = [rTmpPtr], 16 // C19, C18
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA2, fA2L = [rPolDataPtr], 16 // A2
+      fma.s1             fA4L = FR_FracX, FR_FracX, f0 // x^2
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA20, fA21 = [rTmpPtr], 16 // C17, C16
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfe               fA11 = [rTmpPtr], 16 // E7
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA0, fA3L = [rPolDataPtr], 16 // A0
+      nop.f              0
+      nop.i              0
+};;
+{ .mfi
+      ldfe               fA10 = [rPolDataPtr], 16 // E6
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfe               fA9 = [rTmpPtr], 16 // E5
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mmf
+      ldfe               fA8 = [rPolDataPtr], 16 // E4
+      ldfe               fA7 = [rTmpPtr], 16 // E3
+      nop.f              0
+}
+;;
+{ .mmf
+      ldfe               fA6 = [rPolDataPtr], 16 // E2
+      ldfe               fA5 = [rTmpPtr], 16 // E1
+      nop.f              0
+}
+;;
+{ .mfi
+      ldfe               fA4 = [rPolDataPtr], 16 // E0
+      fma.s1             fA5L = fA4L, fA4L, f0 // x^4
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fms.s1             fB2 = FR_FracX, FR_FracX, fA4L // x^2 - <x^2>
+      nop.i              0
+}
+;;
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      fma.s1             fRes4H = fA3, FR_FracX, f0 // (A3*x)hi
+      nop.i              0
+}
+{ .mfi
+      // store signgam if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      fma.s1             fA19 = fA19, FR_FracX, fA18 // D7*x + D6
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fResH = fA1, FR_FracX, f0 // (A1*x)hi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB6 = fA1L, FR_FracX, fA0L // A1L*x + A0L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA17 = fA17, FR_FracX, fA16 // D5*x + D4
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA15 = fA15, FR_FracX, fA14 // D3*x + D2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA25 = fA25, FR_FracX, fA24 // C21*x + C20
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA13 = fA13, FR_FracX, fA12 // D1*x + D0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA23 = fA23, FR_FracX, fA22 // C19*x + C18
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA21 = fA21, FR_FracX, fA20 // C17*x + C16
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fRes4L = fA3, FR_FracX, fRes4H // delta((A3*x)hi)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2H = fRes4H, fA2 // (A3*x + A2)hi
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fResL = fA1, FR_FracX, fResH // d(A1*x)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1H = fResH, fA0 // (A1*x + A0)hi
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA19 = fA19, fA4L, fA17 // Dhi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA11 = fA11, FR_FracX, fA10 // E7*x + E6
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // Doing this to raise inexact flag
+      fma.s0             fA10 = fA0, fA0, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA15 = fA15, fA4L, fA13 // Dlo
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // (C21*x + C20)*x^2 + C19*x + C18
+      fma.s1             fA25 = fA25, fA4L, fA23
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA9 = fA9, FR_FracX, fA8 // E5*x + E4
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA7 = fA7, FR_FracX, fA6 // E3*x + E2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes4L = fA3L, FR_FracX, fRes4L // (A3*x)lo
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes2L = fA2, fRes2H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fResL = fResL, fB6 // (A1L*x + A0L) + d(A1*x)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes1L = fA0, fRes1H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA5 = fA5, FR_FracX, fA4 // E1*x + E0
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB8 = fA5L, fA5L, f0  // x^8
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // ((C21*x + C20)*x^2 + C19*x + C18)*x^2 + C17*x + C16
+      fma.s1             fA25 = fA25, fA4L, fA21
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA19 = fA19, fA5L, fA15 // D
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA11 = fA11, fA4L, fA9 // Ehi
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2L = fRes2L, fRes4H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes4L = fRes4L, fA2L // (A3*x)lo + A2L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes3H = fRes2H, fA4L, f0 //  ((A3*x + A2)*x^2)hi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, fResH
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes3L = fRes2H, fB2, f0 // (A3*x + A2)hi*d(x^2)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA7 = fA7, fA4L, fA5 // Elo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA25 = fA25, fB8, fA19 // C*x^8 + D
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2L = fRes2L, fRes4L // (A3*x + A2)lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fB4 = fRes2H, fA4L, fRes3H // d((A3*x + A2)*x^2))
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, fResL // (A1*x + A0)lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fB20 = fRes3H, fRes1H // Phi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA11 = fA11, fA5L, fA7 // E
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      //  ( (A3*x + A2)lo*<x^2> + (A3*x + A2)hi*d(x^2))
+      fma.s1             fRes3L = fRes2L, fA4L, fRes3L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // d((A3*x + A2)*x^2)) + (A1*x + A0)lo
+      fadd.s1            fRes1L = fRes1L, fB4
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fB18 = fRes1H, fB20
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fA25, fB8, fA11
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, fRes3L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fB18 = fB18, fRes3H
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fRes4H = fPol, fA5L, fB20
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fPolL = fPol, fA5L, f0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fB18 = fB18, fRes1L // Plo
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes4L = fB20, fRes4H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fB18 = fB18, fPolL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes4L = fRes4L, fB18
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      fma.s0             f8 = fRes4H, f1, fRes4L
+      // P25(x) computed, exit here
+      br.ret.sptk        b0
+}
+;;
+
+
+// here if 0.75 <= x < 1.3125
+.align 32
+lgammal_03Q_1Q:
+{ .mfi
+      addl               rPolDataPtr= @ltoff(lgammal_03Q_1Q_data),gp
+      fma.s1             FR_FracX = fA5L, f1, f0 // x
+      adds               rSgnGam = 1, r0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB4 = fA5L, fA5L, f0 // x^2
+      nop.i              0
+}
+;;
+{ .mfi
+      ld8                rPolDataPtr = [rPolDataPtr]
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfb
+      adds               rTmpPtr = 144, rPolDataPtr
+      nop.f              0
+      br.sptk            lgamma_polynom24x
+}
+;;
+
+// here if 1.5625 <= x < 2.25
+.align 32
+lgammal_13Q_2Q:
+{ .mfi
+      addl               rPolDataPtr= @ltoff(lgammal_13Q_2Q_data),gp
+      fma.s1             FR_FracX = fB4, f1, f0 // x
+      adds               rSgnGam = 1, r0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB4 = fB4, fB4, f0 // x^2
+      nop.i              0
+}
+;;
+{ .mfi
+      ld8                rPolDataPtr = [rPolDataPtr]
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfb
+      adds               rTmpPtr = 144, rPolDataPtr
+      nop.f              0
+      br.sptk            lgamma_polynom24x
+}
+;;
+
+// here if result is Pol24(x)
+// x is in FR_FracX,
+// rPolDataPtr, rTmpPtr point to coefficients
+.align 32
+lgamma_polynom24x:
+{ .mfi
+      ldfpd              fA4, fA2L = [rPolDataPtr], 16
+      nop.f              0
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+}
+{ .mfi
+      ldfpd              fA23, fA24 = [rTmpPtr], 16 // C18, C19
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA3, fA1L = [rPolDataPtr], 16
+      fma.s1             fA5L = fB4, fB4, f0 // x^4
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA19, fA20 = [rTmpPtr], 16 // D6, D7
+      fms.s1             fB2 = FR_FracX, FR_FracX, fB4 // x^2 - <x^2>
+      nop.i              0
+}
+;;
+{ .mmf
+      ldfpd              fA15, fA16 = [rPolDataPtr], 16 // D2, D3
+      ldfpd              fA17, fA18 = [rTmpPtr], 16 // D4, D5
+      nop.f              0
+}
+;;
+{ .mmf
+      ldfpd              fA13, fA14 = [rPolDataPtr], 16 // D0, D1
+      ldfpd              fA12, fA21 = [rTmpPtr], 16 // E7, C16
+      nop.f              0
+}
+;;
+{ .mfi
+      ldfe               fA11 = [rPolDataPtr], 16 // E6
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfe               fA10 = [rTmpPtr], 16 // E5
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA2, fA4L = [rPolDataPtr], 16
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      ldfpd              fA1, fA3L = [rTmpPtr], 16
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      ldfpd              fA22, fA25 = [rPolDataPtr], 16 // C17, C20
+      fma.s1             fA0 = fA5L, fA5L, f0 // x^8
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA0L = fA5L, FR_FracX, f0 // x^5
+      nop.i              0
+}
+;;
+{ .mmf
+      ldfe               fA9 = [rPolDataPtr], 16 // E4
+      ldfe               fA8 = [rTmpPtr], 16 // E3
+      nop.f              0
+}
+;;
+{ .mmf
+      ldfe               fA7 = [rPolDataPtr], 16 // E2
+      ldfe               fA6 = [rTmpPtr], 16 // E1
+      nop.f              0
+}
+;;
+{ .mfi
+      ldfe               fA5 = [rTmpPtr], 16 // E0
+      fma.s1             fRes4H = fA4, fB4, f0 // A4*<x^2>
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fA24, FR_FracX, fA23 // C19*x + C18
+      nop.i              0
+}
+;;
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      fma.s1             fRes1H = fA3, fB4, f0 // A3*<x^2>
+      nop.i              0
+}
+{ .mfi
+      // store signgam if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      fma.s1             fA1L = fA3, fB2,fA1L //  A3*d(x^2) + A1L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA20 = fA20, FR_FracX, fA19 // D7*x + D6
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA18 = fA18, FR_FracX, fA17 // D5*x + D4
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA16 = fA16, FR_FracX, fA15 // D3*x + D2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA14 = fA14, FR_FracX, fA13 // D1*x + D0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA2L = fA4, fB2,fA2L //  A4*d(x^2) + A2L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA12 = fA12, FR_FracX, fA11 // E7*x + E6
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fRes2L = fA4, fB4, fRes4H  // delta(A4*<x^2>)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2H = fRes4H, fA2       // A4*<x^2> + A2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fms.s1             fRes3L = fA3, fB4, fRes1H  // delta(A3*<x^2>)
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes3H = fRes1H, fA1       // A3*<x^2> + A1
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA20 = fA20, fB4, fA18 // (D7*x + D6)*x^2 + D5*x + D4
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA22 = fA22, FR_FracX, fA21 // C17*x + C16
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA16 = fA16, fB4, fA14 // (D3*x + D2)*x^2 + D1*x + D0
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fA25, fB4, fPol // C20*x^2 + C19*x + C18
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA2L = fA4L, fB4, fA2L //  A4L*<x^2> + A4*d(x^2) + A2L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA1L = fA3L, fB4, fA1L //  A3L*<x^2> + A3*d(x^2) + A1L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes4L = fA2, fRes2H // d1
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fResH = fRes2H, fB4, f0 // (A4*<x^2> + A2)*x^2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes1L = fA1, fRes3H // d1
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fB6 = fRes3H, FR_FracX, f0 // (A3*<x^2> + A1)*x
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fA10 = fA10, FR_FracX, fA9  // E5*x + E4
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA8 = fA8, FR_FracX, fA7 // E3*x + E2
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // (C20*x^2 + C19*x + C18)*x^2 + C17*x + C16
+      fma.s1             fPol = fPol, fB4, fA22
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA6 = fA6, FR_FracX, fA5 // E1*x + E0
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // A4L*<x^2> + A4*d(x^2) + A2L + delta(A4*<x^2>)
+      fadd.s1            fRes2L = fA2L, fRes2L
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // A3L*<x^2> + A3*d(x^2) + A1L + delta(A3*<x^2>)
+      fadd.s1            fRes3L = fA1L, fRes3L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes4L = fRes4L, fRes4H // d2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fms.s1             fResL = fRes2H, fB4, fResH  // d(A4*<x^2> + A2)*x^2)
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes1L = fRes1L, fRes1H // d2
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fms.s1             fB8 = fRes3H, FR_FracX, fB6 // d((A3*<x^2> + A1)*x)
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fB10 = fResH, fB6 // (A4*x^4 + .. + A1*x)hi
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA12 = fA12, fB4, fA10 // Ehi
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      // ((D7*x + D6)*x^2 + D5*x + D4)*x^4 + (D3*x + D2)*x^2 + D1*x + D0
+      fma.s1             fA20 = fA20, fA5L, fA16
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fA8 = fA8, fB4, fA6 // Elo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes2L = fRes2L, fRes4L // (A4*<x^2> + A2)lo
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      // d(A4*<x^2> + A2)*x^2) + A4*<x^2> + A2)*d(x^2)
+      fma.s1             fResL = fRes2H, fB2, fResL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes3L = fRes3L, fRes1L   // (A4*<x^2> + A2)lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fB12 = fB6, fB10
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fPol, fA0, fA20 // PolC*x^8 + PolD
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fma.s1             fPolL = fA12, fA5L, fA8 // E
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fResL = fB4, fRes2L, fResL // ((A4*<x^2> + A2)*x^2)lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes3L = fRes3L, FR_FracX, fB8 // ((A3*<x^2> + A1)*x)lo
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fB12 = fB12, fResH
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fPol = fPol, fA0, fPolL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes3L = fRes3L, fResL
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes2H = fPol, fA0L, fB10
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes3L = fB12, fRes3L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fsub.s1            fRes4L = fB10, fRes2H
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fma.s1             fRes4L = fPol, fA0L, fRes4L
+      nop.i              0
+}
+;;
+{ .mfi
+      nop.m              0
+      fadd.s1            fRes4L = fRes4L, fRes3L
+      nop.i              0
+}
+;;
+{ .mfb
+      nop.m              0
+      // final result for all paths for which the result is Pol24(x)
+      fma.s0             f8 = fRes2H, f1, fRes4L
+      // here is the exit for all paths for which the result is Pol24(x)
+      br.ret.sptk        b0
+}
+;;
+
+
+//  here if x is natval, nan, +/-inf, +/-0, or denormal
+.align 32
+lgammal_spec:
+{ .mfi
+      nop.m              0
+      fclass.m           p9, p0 =  f8, 0xB // +/-denormals
+      nop.i              0
+};;
+{ .mfi
+      nop.m              0
+      fclass.m           p6, p0 =  f8, 0x1E1 // Test x for natval, nan, +inf
+      nop.i              0
+};;
+{ .mfb
+      nop.m              0
+      fclass.m           p7, p0 =  f8, 0x7 // +/-0
+(p9)  br.cond.sptk       lgammal_denormal_input
+};;
+{ .mfb
+      nop.m              0
+      nop.f              0
+      // branch out if x is natval, nan, +inf
+(p6)  br.cond.spnt       lgammal_nan_pinf
+};;
+{ .mfb
+      nop.m              0
+      nop.f              0
+(p7)  br.cond.spnt       lgammal_singularity
+};;
+// if we are still here then x = -inf
+{ .mfi
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+      nop.f              0
+      adds               rSgnGam = 1, r0
+};;
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      nop.f              0
+      nop.i              0
+}
+{ .mfb
+      // store signgam if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      fma.s0             f8 = f8,f8,f0 // return +inf, no call to error support
+      br.ret.spnt        b0
+};;
+
+// here if x is NaN, NatVal or +INF
+.align 32
+lgammal_nan_pinf:
+{ .mfi
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+      nop.f              0
+      adds               rSgnGam = 1, r0
+}
+;;
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      fma.s0             f8 = f8,f1,f8 // return x+x if x is natval, nan, +inf
+      nop.i              0
+}
+{ .mfb
+      // store signgam if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      nop.f              0
+      br.ret.sptk        b0
+}
+;;
+
+// here if x denormal or unnormal
+.align 32
+lgammal_denormal_input:
+{ .mfi
+      nop.m              0
+      fma.s0             fResH = f1, f1, f8 // raise denormal exception
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      fnorm.s1           f8 = f8 // normalize input value
+      nop.i              0
+}
+;;
+{ .mfi
+      getf.sig           rSignifX = f8
+      fmerge.se          fSignifX =  f1, f8
+      nop.i              0
+}
+{ .mfi
+      getf.exp           rSignExpX = f8
+      fcvt.fx.s1         fXint = f8 // Convert arg to int (int repres. in FR)
+      nop.i              0
+}
+;;
+{ .mfi
+      getf.exp           rSignExpX = f8
+      fcmp.lt.s1         p15, p14 = f8, f0
+      nop.i              0
+}
+;;
+{ .mfb
+      and                rExpX = rSignExpX, r17Ones
+      fmerge.s           fAbsX = f1, f8 // |x|
+      br.cond.sptk       _deno_back_to_main_path
+}
+;;
+
+
+// here if overflow (x > overflow_bound)
+.align 32
+lgammal_overflow:
+{ .mfi
+      addl               r8 = 0x1FFFE, r0
+      nop.f              0
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+}
+{ .mfi
+      adds               rSgnGam = 1, r0
+      nop.f              0
+      nop.i              0
+}
+;;
+{ .mfi
+      setf.exp           f9 = r8
+      fmerge.s           FR_X = f8,f8
+      mov                GR_Parameter_TAG = 102 // overflow
+};;
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      nop.f              0
+      nop.i              0
+}
+{ .mfb
+      // store signgam if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      fma.s0             FR_RESULT = f9,f9,f0 // Set I,O and +INF result
+      br.cond.sptk       __libm_error_region
+};;
+
+// here if x is negative integer or +/-0 (SINGULARITY)
+.align 32
+lgammal_singularity:
+{ .mfi
+      adds               rSgnGam = 1, r0
+      fclass.m           p8,p0 = f8,0x6 // is x -0?
+      mov                GR_Parameter_TAG = 103 // negative
+}
+{ .mfi
+      cmp.eq             p6, p7 = 4, rSgnGamSize
+      fma.s1             FR_X = f0,f0,f8
+      nop.i              0
+};;
+{ .mfi
+(p8)  sub                rSgnGam = r0, rSgnGam
+      nop.f              0
+      nop.i              0
+}
+{ .mfi
+      nop.m              0
+      nop.f              0
+      nop.i              0
+};;
+{ .mfi
+      // store signgam if size of variable is 4 bytes
+(p6)  st4                [rSgnGamAddr] = rSgnGam
+      nop.f              0
+      nop.i              0
+}
+{ .mfb
+      // store signgam if size of variable is 8 bytes
+(p7)  st8                [rSgnGamAddr] = rSgnGam
+      frcpa.s0           FR_RESULT, p0 = f1, f0
+      br.cond.sptk       __libm_error_region
+};;
+
+GLOBAL_LIBM_END(__libm_lgammal)
+
+
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfe [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfe [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfe [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#  // Call error handling function
+};;
+{ .mmi
+        add   GR_Parameter_RESULT = 48,sp
+        nop.m 999
+        nop.i 999
+};;
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region#)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_reduce.S
@@ -0,0 +1,1577 @@
+.file "libm_reduce.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History:
+// 02/02/00 Initial Version
+// 05/13/02 Rescheduled for speed, changed interface to pass
+//          parameters in fp registers
+// 02/10/03 Reordered header: .section, .global, .proc, .align;
+//          used data8 for long double data storage
+//
+//*********************************************************************
+//*********************************************************************
+//
+// Function:   __libm_pi_by_two_reduce(x) return r, c, and N where
+//             x = N * pi/4 + (r+c) , where |r+c| <= pi/4.
+//             This function is not designed to be used by the
+//             general user.
+//
+//*********************************************************************
+//
+// Accuracy:       Returns double-precision values
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers:
+//      f8  = Input x, return value r
+//      f9  = return value c
+//      f32-f70
+//
+//    General Purpose Registers:
+//      r8  = return value N
+//      r34-r64
+//
+//    Predicate Registers:      p6-p14
+//
+//*********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    No conditions should be raised.
+//
+//*********************************************************************
+//
+// I. Introduction
+// ===============
+//
+// For the forward trigonometric functions sin, cos, sincos, and
+// tan, the original algorithms for IA 64 handle arguments up to
+// 1 ulp less than 2^63 in magnitude. For double-extended arguments x,
+// |x| >= 2^63, this routine returns N and r_hi, r_lo where
+//
+//    x  is accurately approximated by
+//    2*K*pi  +  N * pi/2  +  r_hi + r_lo,  |r_hi+r_lo| <= pi/4.
+//    CASE = 1 or 2.
+//    CASE is 1 unless |r_hi + r_lo| < 2^(-33).
+//
+// The exact value of K is not determined, but that information is
+// not required in trigonometric function computations.
+//
+// We first assume the argument x in question satisfies x >= 2^(63).
+// In particular, it is positive. Negative x can be handled by symmetry:
+//
+//   -x  is accurately approximated by
+//         -2*K*pi  +  (-N) * pi/2  -  (r_hi + r_lo),  |r_hi+r_lo| <= pi/4.
+//
+// The idea of the reduction is that
+//
+//       x  *  2/pi   =   N_big  +  N  +  f,      |f| <= 1/2
+//
+// Moreover, for double extended x, |f| >= 2^(-75). (This is an
+// non-obvious fact found by enumeration using a special algorithm
+// involving continued fraction.) The algorithm described below
+// calculates N and an accurate approximation of f.
+//
+// Roughly speaking, an appropriate 256-bit (4 X 64) portion of
+// 2/pi is multiplied with x to give the desired information.
+//
+// II. Representation of 2/PI
+// ==========================
+//
+// The value of 2/pi in binary fixed-point is
+//
+//            .101000101111100110......
+//
+// We store 2/pi in a table, starting at the position corresponding
+// to bit position 63
+//
+//   bit position  63 62 ... 0   -1 -2 -3 -4 -5 -6 -7  ....  -16576
+//
+//              0  0  ... 0  . 1  0  1  0  1  0  1  ....    X
+//
+//                              ^
+//                               |__ implied binary pt
+//
+// III. Algorithm
+// ==============
+//
+// This describes the algorithm in the most natural way using
+// unsigned integer multiplication. The implementation section
+// describes how the integer arithmetic is simulated.
+//
+// STEP 0. Initialization
+// ----------------------
+//
+// Let the input argument x be
+//
+//     x = 2^m * ( 1. b_1 b_2 b_3 ... b_63 ),  63 <= m <= 16383.
+//
+// The first crucial step is to fetch four 64-bit portions of 2/pi.
+// To fulfill this goal, we calculate the bit position L of the
+// beginning of these 256-bit quantity by
+//
+//     L :=  62 - m.
+//
+// Note that -16321 <= L <= -1 because 63 <= m <= 16383; and that
+// the storage of 2/pi is adequate.
+//
+// Fetch P_1, P_2, P_3, P_4 beginning at bit position L thus:
+//
+//      bit position  L  L-1  L-2    ...  L-63
+//
+//      P_1    =      b   b    b     ...    b
+//
+// each b can be 0 or 1. Also, let P_0 be the two bits corresponding to
+// bit positions L+2 and L+1. So, when each of the P_j is interpreted
+// with appropriate scaling, we have
+//
+//      2/pi  =  P_big  + P_0 + (P_1 + P_2 + P_3 + P_4)  +  P_small
+//
+// Note that P_big and P_small can be ignored. The reasons are as follow.
+// First, consider P_big. If P_big = 0, we can certainly ignore it.
+// Otherwise, P_big >= 2^(L+3). Now,
+//
+//        P_big * ulp(x) >=  2^(L+3) * 2^(m-63)
+//                   >=  2^(65-m  +  m-63 )
+//                   >=  2^2
+//
+// Thus, P_big * x is an integer of the form 4*K. So
+//
+//       x = 4*K * (pi/2) + x*(P_0 + P_1 + P_2 + P_3 + P_4)*(pi/2)
+//                + x*P_small*(pi/2).
+//
+// Hence, P_big*x corresponds to information that can be ignored for
+// trigonometic function evaluation.
+//
+// Next, we must estimate the effect of ignoring P_small. The absolute
+// error made by ignoring P_small is bounded by
+//
+//       |P_small * x|  <=  ulp(P_4) * x
+//                  <=  2^(L-255) * 2^(m+1)
+//                  <=  2^(62-m-255 + m + 1)
+//                  <=  2^(-192)
+//
+// Since for double-extended precision, x * 2/pi = integer + f,
+// 0.5 >= |f| >= 2^(-75), the relative error introduced by ignoring
+// P_small is bounded by 2^(-192+75) <= 2^(-117), which is acceptable.
+//
+// Further note that if x is split into x_hi + x_lo where x_lo is the
+// two bits corresponding to bit positions 2^(m-62) and 2^(m-63); then
+//
+//       P_0 * x_hi
+//
+// is also an integer of the form 4*K; and thus can also be ignored.
+// Let M := P_0 * x_lo which is a small integer. The main part of the
+// calculation is really the multiplication of x with the four pieces
+// P_1, P_2, P_3, and P_4.
+//
+// Unless the reduced argument is extremely small in magnitude, it
+// suffices to carry out the multiplication of x with P_1, P_2, and
+// P_3. x*P_4 will be carried out and added on as a correction only
+// when it is found to be needed. Note also that x*P_4 need not be
+// computed exactly. A straightforward multiplication suffices since
+// the rounding error thus produced would be bounded by 2^(-3*64),
+// that is 2^(-192) which is small enough as the reduced argument
+// is bounded from below by 2^(-75).
+//
+// Now that we have four 64-bit data representing 2/pi and a
+// 64-bit x. We first need to calculate a highly accurate product
+// of x and P_1, P_2, P_3. This is best understood as integer
+// multiplication.
+//
+//
+// STEP 1. Multiplication
+// ----------------------
+//
+//
+//                     ---------   ---------   ---------
+//                    |  P_1  |   |  P_2  |   |  P_3  |
+//                    ---------   ---------   ---------
+//
+//                                            ---------
+//             X                              |   X   |
+//                                            ---------
+//      ----------------------------------------------------
+//
+//                                 ---------   ---------
+//                               |  A_hi |   |  A_lo |
+//                               ---------   ---------
+//
+//
+//                    ---------   ---------
+//                   |  B_hi |   |  B_lo |
+//                   ---------   ---------
+//
+//
+//        ---------   ---------
+//       |  C_hi |   |  C_lo |
+//       ---------   ---------
+//
+//      ====================================================
+//       ---------   ---------   ---------   ---------
+//       |  S_0  |   |  S_1  |   |  S_2  |   |  S_3  |
+//       ---------   ---------   ---------   ---------
+//
+//
+//
+// STEP 2. Get N and f
+// -------------------
+//
+// Conceptually, after the individual pieces S_0, S_1, ..., are obtained,
+// we have to sum them and obtain an integer part, N, and a fraction, f.
+// Here, |f| <= 1/2, and N is an integer. Note also that N need only to
+// be known to module 2^k, k >= 2. In the case when |f| is small enough,
+// we would need to add in the value x*P_4.
+//
+//
+// STEP 3. Get reduced argument
+// ----------------------------
+//
+// The value f is not yet the reduced argument that we seek. The
+// equation
+//
+//       x * 2/pi = 4K  + N  + f
+//
+// says that
+//
+//         x   =  2*K*pi  + N * pi/2  +  f * (pi/2).
+//
+// Thus, the reduced argument is given by
+//
+//       reduced argument =  f * pi/2.
+//
+// This multiplication must be performed to extra precision.
+//
+// IV. Implementation
+// ==================
+//
+// Step 0. Initialization
+// ----------------------
+//
+// Set sgn_x := sign(x); x := |x|; x_lo := 2 lsb of x.
+//
+// In memory, 2/pi is stored contiguously as
+//
+//  0x00000000 0x00000000 0xA2F....
+//                       ^
+//                       |__ implied binary bit
+//
+// Given x = 2^m * 1.xxxx...xxx; we calculate L := 62 - m. Thus
+// -1 <= L <= -16321. We fetch from memory 5 integer pieces of data.
+//
+// P_0 is the two bits corresponding to bit positions L+2 and L+1
+// P_1 is the 64-bit starting at bit position  L
+// P_2 is the 64-bit starting at bit position  L-64
+// P_3 is the 64-bit starting at bit position  L-128
+// P_4 is the 64-bit starting at bit position  L-192
+//
+// For example, if m = 63, P_0 would be 0 and P_1 would look like
+// 0xA2F...
+//
+// If m = 65, P_0 would be the two msb of 0xA, thus, P_0 is 10 in binary.
+// P_1 in binary would be  1 0 0 0 1 0 1 1 1 1 ....
+//
+// Step 1. Multiplication
+// ----------------------
+//
+// At this point, P_1, P_2, P_3, P_4 are integers. They are
+// supposed to be interpreted as
+//
+//  2^(L-63)     * P_1;
+//  2^(L-63-64)  * P_2;
+//  2^(L-63-128) * P_3;
+// 2^(L-63-192) * P_4;
+//
+// Since each of them need to be multiplied to x, we would scale
+// both x and the P_j's by some convenient factors: scale each
+// of P_j's up by 2^(63-L), and scale x down by 2^(L-63).
+//
+//   p_1 := fcvt.xf ( P_1 )
+//   p_2 := fcvt.xf ( P_2 ) * 2^(-64)
+//   p_3 := fcvt.xf ( P_3 ) * 2^(-128)
+//   p_4 := fcvt.xf ( P_4 ) * 2^(-192)
+//   x   := replace exponent of x by -1
+//          because 2^m    * 1.xxxx...xxx  * 2^(L-63)
+//          is      2^(-1) * 1.xxxx...xxx
+//
+// We are now faced with the task of computing the following
+//
+//                     ---------   ---------   ---------
+//                    |  P_1  |   |  P_2  |   |  P_3  |
+//                    ---------   ---------   ---------
+//
+//                                             ---------
+//             X                              |   X   |
+//                                            ---------
+//       ----------------------------------------------------
+//
+//                                 ---------   ---------
+//                                |  A_hi |   |  A_lo |
+//                                ---------   ---------
+//
+//                     ---------   ---------
+//                    |  B_hi |   |  B_lo |
+//                    ---------   ---------
+//
+//         ---------   ---------
+//        |  C_hi |   |  C_lo |
+//        ---------   ---------
+//
+//      ====================================================
+//       -----------   ---------   ---------   ---------
+//       |    S_0  |   |  S_1  |   |  S_2  |   |  S_3  |
+//       -----------   ---------   ---------   ---------
+//        ^          ^
+//        |          |___ binary point
+//        |
+//        |___ possibly one more bit
+//
+// Let FPSR3 be set to round towards zero with widest precision
+// and exponent range. Unless an explicit FPSR is given,
+// round-to-nearest with widest precision and exponent range is
+// used.
+//
+// Define sigma_C := 2^63; sigma_B := 2^(-1); sigma_C := 2^(-65).
+//
+// Tmp_C := fmpy.fpsr3( x, p_1 );
+// If Tmp_C >= sigma_C then
+//    C_hi := Tmp_C;
+//    C_lo := x*p_1 - C_hi ...fma, exact
+// Else
+//    C_hi := fadd.fpsr3(sigma_C, Tmp_C) - sigma_C
+//                   ...subtraction is exact, regardless
+//                   ...of rounding direction
+//    C_lo := x*p_1 - C_hi ...fma, exact
+// End If
+//
+// Tmp_B := fmpy.fpsr3( x, p_2 );
+// If Tmp_B >= sigma_B then
+//    B_hi := Tmp_B;
+//    B_lo := x*p_2 - B_hi ...fma, exact
+// Else
+//    B_hi := fadd.fpsr3(sigma_B, Tmp_B) - sigma_B
+//                   ...subtraction is exact, regardless
+//                   ...of rounding direction
+//    B_lo := x*p_2 - B_hi ...fma, exact
+// End If
+//
+// Tmp_A := fmpy.fpsr3( x, p_3 );
+// If Tmp_A >= sigma_A then
+//    A_hi := Tmp_A;
+//    A_lo := x*p_3 - A_hi ...fma, exact
+// Else
+//    A_hi := fadd.fpsr3(sigma_A, Tmp_A) - sigma_A
+//                   ...subtraction is exact, regardless
+//                   ...of rounding direction
+//    A_lo := x*p_3 - A_hi ...fma, exact
+// End If
+//
+// ...Note that C_hi is of integer value. We need only the
+// ...last few bits. Thus we can ensure C_hi is never a big
+// ...integer, freeing us from overflow worry.
+//
+// Tmp_C := fadd.fpsr3( C_hi, 2^(70) ) - 2^(70);
+// ...Tmp_C is the upper portion of C_hi
+// C_hi := C_hi - Tmp_C
+// ...0 <= C_hi < 2^7
+//
+// Step 2. Get N and f
+// -------------------
+//
+// At this point, we have all the components to obtain
+// S_0, S_1, S_2, S_3 and thus N and f. We start by adding
+// C_lo and B_hi. This sum together with C_hi gives a good
+// estimation of N and f.
+//
+// A := fadd.fpsr3( B_hi, C_lo )
+// B := max( B_hi, C_lo )
+// b := min( B_hi, C_lo )
+//
+// a := (B - A) + b      ...exact. Note that a is either 0
+//                   ...or 2^(-64).
+//
+// N := round_to_nearest_integer_value( A );
+// f := A - N;            ...exact because lsb(A) >= 2^(-64)
+//                   ...and |f| <= 1/2.
+//
+// f := f + a            ...exact because a is 0 or 2^(-64);
+//                   ...the msb of the sum is <= 1/2
+//                   ...lsb >= 2^(-64).
+//
+// N := convert to integer format( C_hi + N );
+// M := P_0 * x_lo;
+// N := N + M;
+//
+// If sgn_x == 1 (that is original x was negative)
+// N := 2^10 - N
+// ...this maintains N to be non-negative, but still
+// ...equivalent to the (negated N) mod 4.
+// End If
+//
+// If |f| >= 2^(-33)
+//
+// ...Case 1
+// CASE := 1
+// g := A_hi + B_lo;
+// s_hi := f + g;
+// s_lo := (f - s_hi) + g;
+//
+// Else
+//
+// ...Case 2
+// CASE := 2
+// A := fadd.fpsr3( A_hi, B_lo )
+// B := max( A_hi, B_lo )
+// b := min( A_hi, B_lo )
+//
+// a := (B - A) + b      ...exact. Note that a is either 0
+//                   ...or 2^(-128).
+//
+// f_hi := A + f;
+// f_lo := (f - f_hi) + A;
+// ...this is exact.
+// ...f-f_hi is exact because either |f| >= |A|, in which
+// ...case f-f_hi is clearly exact; or otherwise, 0<|f|<|A|
+// ...means msb(f) <= msb(A) = 2^(-64) => |f| = 2^(-64).
+// ...If f = 2^(-64), f-f_hi involves cancellation and is
+// ...exact. If f = -2^(-64), then A + f is exact. Hence
+// ...f-f_hi is -A exactly, giving f_lo = 0.
+//
+// f_lo := f_lo + a;
+//
+// If |f| >= 2^(-50) then
+//    s_hi := f_hi;
+//    s_lo := f_lo;
+// Else
+//    f_lo := (f_lo + A_lo) + x*p_4
+//    s_hi := f_hi + f_lo
+//    s_lo := (f_hi - s_hi) + f_lo
+// End If
+//
+// End If
+//
+// Step 3. Get reduced argument
+// ----------------------------
+//
+// If sgn_x == 0 (that is original x is positive)
+//
+// D_hi := Pi_by_2_hi
+// D_lo := Pi_by_2_lo
+// ...load from table
+//
+// Else
+//
+// D_hi := neg_Pi_by_2_hi
+// D_lo := neg_Pi_by_2_lo
+// ...load from table
+// End If
+//
+// r_hi :=  s_hi*D_hi
+// r_lo :=  s_hi*D_hi - r_hi         ...fma
+// r_lo := (s_hi*D_lo + r_lo) + s_lo*D_hi
+//
+// Return  N, r_hi, r_lo
+//
+FR_input_X = f8
+FR_r_hi    = f8
+FR_r_lo    = f9
+
+FR_X       = f32
+FR_N       = f33
+FR_p_1     = f34
+FR_TWOM33  = f35
+FR_TWOM50  = f36
+FR_g       = f37
+FR_p_2     = f38
+FR_f       = f39
+FR_s_lo    = f40
+FR_p_3     = f41
+FR_f_abs   = f42
+FR_D_lo    = f43
+FR_p_4     = f44
+FR_D_hi    = f45
+FR_Tmp2_C  = f46
+FR_s_hi    = f47
+FR_sigma_A = f48
+FR_A       = f49
+FR_sigma_B = f50
+FR_B       = f51
+FR_sigma_C = f52
+FR_b       = f53
+FR_ScaleP2 = f54
+FR_ScaleP3 = f55
+FR_ScaleP4 = f56
+FR_Tmp_A   = f57
+FR_Tmp_B   = f58
+FR_Tmp_C   = f59
+FR_A_hi    = f60
+FR_f_hi    = f61
+FR_RSHF    = f62
+FR_A_lo    = f63
+FR_B_hi    = f64
+FR_a       = f65
+FR_B_lo    = f66
+FR_f_lo    = f67
+FR_N_fix   = f68
+FR_C_hi    = f69
+FR_C_lo    = f70
+
+GR_N       = r8
+GR_Exp_x   = r36
+GR_Temp    = r37
+GR_BIASL63 = r38
+GR_CASE    = r39
+GR_x_lo    = r40
+GR_sgn_x   = r41
+GR_M       = r42
+GR_BASE    = r43
+GR_LENGTH1 = r44
+GR_LENGTH2 = r45
+GR_ASUB    = r46
+GR_P_0     = r47
+GR_P_1     = r48
+GR_P_2     = r49
+GR_P_3     = r50
+GR_P_4     = r51
+GR_START   = r52
+GR_SEGMENT = r53
+GR_A       = r54
+GR_B       = r55
+GR_C       = r56
+GR_D       = r57
+GR_E       = r58
+GR_TEMP1   = r59
+GR_TEMP2   = r60
+GR_TEMP3   = r61
+GR_TEMP4   = r62
+GR_TEMP5   = r63
+GR_TEMP6   = r64
+GR_rshf    = r64
+
+RODATA
+.align 64
+
+LOCAL_OBJECT_START(Constants_Bits_of_2_by_pi)
+data8 0x0000000000000000,0xA2F9836E4E441529
+data8 0xFC2757D1F534DDC0,0xDB6295993C439041
+data8 0xFE5163ABDEBBC561,0xB7246E3A424DD2E0
+data8 0x06492EEA09D1921C,0xFE1DEB1CB129A73E
+data8 0xE88235F52EBB4484,0xE99C7026B45F7E41
+data8 0x3991D639835339F4,0x9C845F8BBDF9283B
+data8 0x1FF897FFDE05980F,0xEF2F118B5A0A6D1F
+data8 0x6D367ECF27CB09B7,0x4F463F669E5FEA2D
+data8 0x7527BAC7EBE5F17B,0x3D0739F78A5292EA
+data8 0x6BFB5FB11F8D5D08,0x56033046FC7B6BAB
+data8 0xF0CFBC209AF4361D,0xA9E391615EE61B08
+data8 0x6599855F14A06840,0x8DFFD8804D732731
+data8 0x06061556CA73A8C9,0x60E27BC08C6B47C4
+data8 0x19C367CDDCE8092A,0x8359C4768B961CA6
+data8 0xDDAF44D15719053E,0xA5FF07053F7E33E8
+data8 0x32C2DE4F98327DBB,0xC33D26EF6B1E5EF8
+data8 0x9F3A1F35CAF27F1D,0x87F121907C7C246A
+data8 0xFA6ED5772D30433B,0x15C614B59D19C3C2
+data8 0xC4AD414D2C5D000C,0x467D862D71E39AC6
+data8 0x9B0062337CD2B497,0xA7B4D55537F63ED7
+data8 0x1810A3FC764D2A9D,0x64ABD770F87C6357
+data8 0xB07AE715175649C0,0xD9D63B3884A7CB23
+data8 0x24778AD623545AB9,0x1F001B0AF1DFCE19
+data8 0xFF319F6A1E666157,0x9947FBACD87F7EB7
+data8 0x652289E83260BFE6,0xCDC4EF09366CD43F
+data8 0x5DD7DE16DE3B5892,0x9BDE2822D2E88628
+data8 0x4D58E232CAC616E3,0x08CB7DE050C017A7
+data8 0x1DF35BE01834132E,0x6212830148835B8E
+data8 0xF57FB0ADF2E91E43,0x4A48D36710D8DDAA
+data8 0x425FAECE616AA428,0x0AB499D3F2A6067F
+data8 0x775C83C2A3883C61,0x78738A5A8CAFBDD7
+data8 0x6F63A62DCBBFF4EF,0x818D67C12645CA55
+data8 0x36D9CAD2A8288D61,0xC277C9121426049B
+data8 0x4612C459C444C5C8,0x91B24DF31700AD43
+data8 0xD4E5492910D5FDFC,0xBE00CC941EEECE70
+data8 0xF53E1380F1ECC3E7,0xB328F8C79405933E
+data8 0x71C1B3092EF3450B,0x9C12887B20AB9FB5
+data8 0x2EC292472F327B6D,0x550C90A7721FE76B
+data8 0x96CB314A1679E279,0x4189DFF49794E884
+data8 0xE6E29731996BED88,0x365F5F0EFDBBB49A
+data8 0x486CA46742727132,0x5D8DB8159F09E5BC
+data8 0x25318D3974F71C05,0x30010C0D68084B58
+data8 0xEE2C90AA4702E774,0x24D6BDA67DF77248
+data8 0x6EEF169FA6948EF6,0x91B45153D1F20ACF
+data8 0x3398207E4BF56863,0xB25F3EDD035D407F
+data8 0x8985295255C06437,0x10D86D324832754C
+data8 0x5BD4714E6E5445C1,0x090B69F52AD56614
+data8 0x9D072750045DDB3B,0xB4C576EA17F9877D
+data8 0x6B49BA271D296996,0xACCCC65414AD6AE2
+data8 0x9089D98850722CBE,0xA4049407777030F3
+data8 0x27FC00A871EA49C2,0x663DE06483DD9797
+data8 0x3FA3FD94438C860D,0xDE41319D39928C70
+data8 0xDDE7B7173BDF082B,0x3715A0805C93805A
+data8 0x921110D8E80FAF80,0x6C4BFFDB0F903876
+data8 0x185915A562BBCB61,0xB989C7BD401004F2
+data8 0xD2277549F6B6EBBB,0x22DBAA140A2F2689
+data8 0x768364333B091A94,0x0EAA3A51C2A31DAE
+data8 0xEDAF12265C4DC26D,0x9C7A2D9756C0833F
+data8 0x03F6F0098C402B99,0x316D07B43915200C
+data8 0x5BC3D8C492F54BAD,0xC6A5CA4ECD37A736
+data8 0xA9E69492AB6842DD,0xDE6319EF8C76528B
+data8 0x6837DBFCABA1AE31,0x15DFA1AE00DAFB0C
+data8 0x664D64B705ED3065,0x29BF56573AFF47B9
+data8 0xF96AF3BE75DF9328,0x3080ABF68C6615CB
+data8 0x040622FA1DE4D9A4,0xB33D8F1B5709CD36
+data8 0xE9424EA4BE13B523,0x331AAAF0A8654FA5
+data8 0xC1D20F3F0BCD785B,0x76F923048B7B7217
+data8 0x8953A6C6E26E6F00,0xEBEF584A9BB7DAC4
+data8 0xBA66AACFCF761D02,0xD12DF1B1C1998C77
+data8 0xADC3DA4886A05DF7,0xF480C62FF0AC9AEC
+data8 0xDDBC5C3F6DDED01F,0xC790B6DB2A3A25A3
+data8 0x9AAF009353AD0457,0xB6B42D297E804BA7
+data8 0x07DA0EAA76A1597B,0x2A12162DB7DCFDE5
+data8 0xFAFEDB89FDBE896C,0x76E4FCA90670803E
+data8 0x156E85FF87FD073E,0x2833676186182AEA
+data8 0xBD4DAFE7B36E6D8F,0x3967955BBF3148D7
+data8 0x8416DF30432DC735,0x6125CE70C9B8CB30
+data8 0xFD6CBFA200A4E46C,0x05A0DD5A476F21D2
+data8 0x1262845CB9496170,0xE0566B0152993755
+data8 0x50B7D51EC4F1335F,0x6E13E4305DA92E85
+data8 0xC3B21D3632A1A4B7,0x08D4B1EA21F716E4
+data8 0x698F77FF2780030C,0x2D408DA0CD4F99A5
+data8 0x20D3A2B30A5D2F42,0xF9B4CBDA11D0BE7D
+data8 0xC1DB9BBD17AB81A2,0xCA5C6A0817552E55
+data8 0x0027F0147F8607E1,0x640B148D4196DEBE
+data8 0x872AFDDAB6256B34,0x897BFEF3059EBFB9
+data8 0x4F6A68A82A4A5AC4,0x4FBCF82D985AD795
+data8 0xC7F48D4D0DA63A20,0x5F57A4B13F149538
+data8 0x800120CC86DD71B6,0xDEC9F560BF11654D
+data8 0x6B0701ACB08CD0C0,0xB24855510EFB1EC3
+data8 0x72953B06A33540C0,0x7BDC06CC45E0FA29
+data8 0x4EC8CAD641F3E8DE,0x647CD8649B31BED9
+data8 0xC397A4D45877C5E3,0x6913DAF03C3ABA46
+data8 0x18465F7555F5BDD2,0xC6926E5D2EACED44
+data8 0x0E423E1C87C461E9,0xFD29F3D6E7CA7C22
+data8 0x35916FC5E0088DD7,0xFFE26A6EC6FDB0C1
+data8 0x0893745D7CB2AD6B,0x9D6ECD7B723E6A11
+data8 0xC6A9CFF7DF7329BA,0xC9B55100B70DB2E2
+data8 0x24BA74607DE58AD8,0x742C150D0C188194
+data8 0x667E162901767A9F,0xBEFDFDEF4556367E
+data8 0xD913D9ECB9BA8BFC,0x97C427A831C36EF1
+data8 0x36C59456A8D8B5A8,0xB40ECCCF2D891234
+data8 0x576F89562CE3CE99,0xB920D6AA5E6B9C2A
+data8 0x3ECC5F114A0BFDFB,0xF4E16D3B8E2C86E2
+data8 0x84D4E9A9B4FCD1EE,0xEFC9352E61392F44
+data8 0x2138C8D91B0AFC81,0x6A4AFBD81C2F84B4
+data8 0x538C994ECC2254DC,0x552AD6C6C096190B
+data8 0xB8701A649569605A,0x26EE523F0F117F11
+data8 0xB5F4F5CBFC2DBC34,0xEEBC34CC5DE8605E
+data8 0xDD9B8E67EF3392B8,0x17C99B5861BC57E1
+data8 0xC68351103ED84871,0xDDDD1C2DA118AF46
+data8 0x2C21D7F359987AD9,0xC0549EFA864FFC06
+data8 0x56AE79E536228922,0xAD38DC9367AAE855
+data8 0x3826829BE7CAA40D,0x51B133990ED7A948
+data8 0x0569F0B265A7887F,0x974C8836D1F9B392
+data8 0x214A827B21CF98DC,0x9F405547DC3A74E1
+data8 0x42EB67DF9DFE5FD4,0x5EA4677B7AACBAA2
+data8 0xF65523882B55BA41,0x086E59862A218347
+data8 0x39E6E389D49EE540,0xFB49E956FFCA0F1C
+data8 0x8A59C52BFA94C5C1,0xD3CFC50FAE5ADB86
+data8 0xC5476243853B8621,0x94792C8761107B4C
+data8 0x2A1A2C8012BF4390,0x2688893C78E4C4A8
+data8 0x7BDBE5C23AC4EAF4,0x268A67F7BF920D2B
+data8 0xA365B1933D0B7CBD,0xDC51A463DD27DDE1
+data8 0x6919949A9529A828,0xCE68B4ED09209F44
+data8 0xCA984E638270237C,0x7E32B90F8EF5A7E7
+data8 0x561408F1212A9DB5,0x4D7E6F5119A5ABF9
+data8 0xB5D6DF8261DD9602,0x36169F3AC4A1A283
+data8 0x6DED727A8D39A9B8,0x825C326B5B2746ED
+data8 0x34007700D255F4FC,0x4D59018071E0E13F
+data8 0x89B295F364A8F1AE,0xA74B38FC4CEAB2BB
+LOCAL_OBJECT_END(Constants_Bits_of_2_by_pi)
+
+LOCAL_OBJECT_START(Constants_Bits_of_pi_by_2)
+data8 0xC90FDAA22168C234,0x00003FFF
+data8 0xC4C6628B80DC1CD1,0x00003FBF
+LOCAL_OBJECT_END(Constants_Bits_of_pi_by_2)
+
+.section .text
+.global __libm_pi_by_2_reduce#
+.proc __libm_pi_by_2_reduce#
+.align 32
+
+__libm_pi_by_2_reduce:
+
+//    X is in f8
+//    Place the two-piece result r (r_hi) in f8 and c (r_lo) in f9
+//    N is returned in r8
+
+{ .mfi
+      alloc  r34 = ar.pfs,2,34,0,0
+      fsetc.s3 0x00,0x7F     // Set sf3 to round to zero, 82-bit prec, td, ftz
+      nop.i 999
+}
+{ .mfi
+      addl           GR_BASE   = @ltoff(Constants_Bits_of_2_by_pi#), gp
+      nop.f 999
+      mov GR_BIASL63 = 0x1003E
+}
+;;
+
+
+//    L         -1-2-3-4
+//    0 0 0 0 0. 1 0 1 0
+//    M          0 1 2 .... 63, 64 65 ... 127, 128
+//     ---------------------------------------------
+//    Segment 0.        1     ,      2       ,    3
+//    START = M - 63                        M = 128 becomes 65
+//    LENGTH1  = START & 0x3F               65 become position 1
+//    SEGMENT  = shr(START,6) + 1      0 maps to 1,   64 maps to 2,
+//    LENGTH2  = 64 - LENGTH1
+//    Address_BASE = shladd(SEGMENT,3) + BASE
+
+
+{ .mmi
+      getf.exp GR_Exp_x = FR_input_X
+      ld8 GR_BASE = [GR_BASE]
+      mov GR_TEMP5 = 0x0FFFE
+}
+;;
+
+//    Define sigma_C := 2^63; sigma_B := 2^(-1); sigma_A := 2^(-65).
+{ .mmi
+      getf.sig GR_x_lo = FR_input_X
+      mov GR_TEMP6 = 0x0FFBE
+      nop.i 999
+}
+;;
+
+//    Special Code for testing DE arguments
+//          movl GR_BIASL63 = 0x0000000000013FFE
+//          movl GR_x_lo = 0xFFFFFFFFFFFFFFFF
+//          setf.exp FR_X = GR_BIASL63
+//          setf.sig FR_ScaleP3 = GR_x_lo
+//          fmerge.se FR_X = FR_X,FR_ScaleP3
+//    Set sgn_x := sign(x); x := |x|; x_lo := 2 lsb of x.
+//    2/pi is stored contiguously as
+//    0x00000000 0x00000000.0xA2F....
+//    M = EXP - BIAS  ( M >= 63)
+//    Given x = 2^m * 1.xxxx...xxx; we calculate L := 62 - m.
+//    Thus -1 <= L <= -16321.
+{ .mmi
+      setf.exp FR_sigma_B = GR_TEMP5
+      setf.exp FR_sigma_A = GR_TEMP6
+      extr.u GR_M = GR_Exp_x,0,17
+}
+;;
+
+{ .mii
+      and  GR_x_lo = 0x03,GR_x_lo
+      sub  GR_START = GR_M,GR_BIASL63
+      add  GR_BASE = 8,GR_BASE           // To effectively add 1 to SEGMENT
+}
+;;
+
+{ .mii
+      and  GR_LENGTH1 = 0x3F,GR_START
+      shr.u  GR_SEGMENT = GR_START,6
+      nop.i 999
+}
+;;
+
+{ .mmi
+      shladd GR_BASE = GR_SEGMENT,3,GR_BASE
+      sub  GR_LENGTH2 = 0x40,GR_LENGTH1
+      cmp.le p6,p7 = 0x2,GR_LENGTH1
+}
+;;
+
+//    P_0 is the two bits corresponding to bit positions L+2 and L+1
+//    P_1 is the 64-bit starting at bit position  L
+//    P_2 is the 64-bit starting at bit position  L-64
+//    P_3 is the 64-bit starting at bit position  L-128
+//    P_4 is the 64-bit starting at bit position  L-192
+//    P_1 is made up of Alo and Bhi
+//    P_1 = deposit Alo, position 0, length2  into P_1,position length1
+//          deposit Bhi, position length2, length1 into P_1, position 0
+//    P_2 is made up of Blo and Chi
+//    P_2 = deposit Blo, position 0, length2  into P_2, position length1
+//          deposit Chi, position length2, length1 into P_2, position 0
+//    P_3 is made up of Clo and Dhi
+//    P_3 = deposit Clo, position 0, length2  into P_3, position length1
+//          deposit Dhi, position length2, length1 into P_3, position 0
+//    P_4 is made up of Clo and Dhi
+//    P_4 = deposit Dlo, position 0, length2  into P_4, position length1
+//          deposit Ehi, position length2, length1 into P_4, position 0
+{ .mfi
+      ld8 GR_A = [GR_BASE],8
+      fabs FR_X = FR_input_X
+(p7)  cmp.eq.unc p8,p9 = 0x1,GR_LENGTH1
+}
+;;
+
+//    ld_64 A at Base and increment Base by 8
+//    ld_64 B at Base and increment Base by 8
+//    ld_64 C at Base and increment Base by 8
+//    ld_64 D at Base and increment Base by 8
+//    ld_64 E at Base and increment Base by 8
+//                                          A/B/C/D
+//                                    ---------------------
+//    A, B, C, D, and E look like    | length1 | length2   |
+//                                    ---------------------
+//                                       hi        lo
+{ .mlx
+      ld8 GR_B = [GR_BASE],8
+      movl GR_rshf = 0x43e8000000000000   // 1.10000 2^63 for right shift N_fix
+}
+;;
+
+{ .mmi
+      ld8 GR_C = [GR_BASE],8
+      nop.m 999
+(p8)  extr.u GR_Temp = GR_A,63,1
+}
+;;
+
+//    If length1 >= 2,
+//       P_0 = deposit Ahi, position length2, 2 bit into P_0 at position 0.
+{ .mii
+      ld8 GR_D = [GR_BASE],8
+      shl GR_TEMP1 = GR_A,GR_LENGTH1   // MM instruction
+(p6)  shr.u GR_P_0 = GR_A,GR_LENGTH2   // MM instruction
+}
+;;
+
+{ .mii
+      ld8 GR_E = [GR_BASE],-40
+      shl GR_TEMP2 = GR_B,GR_LENGTH1   // MM instruction
+      shr.u GR_P_1 = GR_B,GR_LENGTH2   // MM instruction
+}
+;;
+
+//    Else
+//       Load 16 bit of ASUB from (Base_Address_of_A - 2)
+//       P_0 = ASUB & 0x3
+//       If length1 == 0,
+//          P_0 complete
+//       Else
+//          Deposit element 63 from Ahi and place in element 0 of P_0.
+//       Endif
+//    Endif
+
+{ .mii
+(p7)  ld2 GR_ASUB = [GR_BASE],8
+      shl GR_TEMP3 = GR_C,GR_LENGTH1   // MM instruction
+      shr.u GR_P_2 = GR_C,GR_LENGTH2   // MM instruction
+}
+;;
+
+{ .mii
+      setf.d FR_RSHF = GR_rshf         // Form right shift const 1.100 * 2^63
+      shl GR_TEMP4 = GR_D,GR_LENGTH1   // MM instruction
+      shr.u GR_P_3 = GR_D,GR_LENGTH2   // MM instruction
+}
+;;
+
+{ .mmi
+(p7)  and GR_P_0 = 0x03,GR_ASUB
+(p6)  and GR_P_0 = 0x03,GR_P_0
+      shr.u GR_P_4 = GR_E,GR_LENGTH2   // MM instruction
+}
+;;
+
+{ .mmi
+      nop.m 999
+      or GR_P_1 = GR_P_1,GR_TEMP1
+(p8)  and GR_P_0 = 0x1,GR_P_0
+}
+;;
+
+{ .mmi
+      setf.sig FR_p_1 = GR_P_1
+      or GR_P_2 = GR_P_2,GR_TEMP2
+(p8)  shladd GR_P_0 = GR_P_0,1,GR_Temp
+}
+;;
+
+{ .mmf
+      setf.sig FR_p_2 = GR_P_2
+      or GR_P_3 = GR_P_3,GR_TEMP3
+      fmerge.se FR_X = FR_sigma_B,FR_X
+}
+;;
+
+{ .mmi
+      setf.sig FR_p_3 = GR_P_3
+      or GR_P_4 = GR_P_4,GR_TEMP4
+      pmpy2.r GR_M = GR_P_0,GR_x_lo
+}
+;;
+
+//    P_1, P_2, P_3, P_4 are integers. They should be
+//    2^(L-63)     * P_1;
+//    2^(L-63-64)  * P_2;
+//    2^(L-63-128) * P_3;
+//    2^(L-63-192) * P_4;
+//    Since each of them need to be multiplied to x, we would scale
+//    both x and the P_j's by some convenient factors: scale each
+//    of P_j's up by 2^(63-L), and scale x down by 2^(L-63).
+//    p_1 := fcvt.xf ( P_1 )
+//    p_2 := fcvt.xf ( P_2 ) * 2^(-64)
+//    p_3 := fcvt.xf ( P_3 ) * 2^(-128)
+//    p_4 := fcvt.xf ( P_4 ) * 2^(-192)
+//    x= Set x's exp to -1 because 2^m*1.x...x *2^(L-63)=2^(-1)*1.x...xxx
+//             ---------   ---------   ---------
+//             |  P_1  |   |  P_2  |   |  P_3  |
+//             ---------   ---------   ---------
+//                                           ---------
+//            X                              |   X   |
+//                                           ---------
+//      ----------------------------------------------------
+//                               ---------   ---------
+//                               |  A_hi |   |  A_lo |
+//                               ---------   ---------
+//                   ---------   ---------
+//                   |  B_hi |   |  B_lo |
+//                   ---------   ---------
+//       ---------   ---------
+//       |  C_hi |   |  C_lo |
+//       ---------   ---------
+//     ====================================================
+//    -----------   ---------   ---------   ---------
+//    |    S_0  |   |  S_1  |   |  S_2  |   |  S_3  |
+//    -----------   ---------   ---------   ---------
+//    |            |___ binary point
+//    |___ possibly one more bit
+//
+//    Let FPSR3 be set to round towards zero with widest precision
+//    and exponent range. Unless an explicit FPSR is given,
+//    round-to-nearest with widest precision and exponent range is
+//    used.
+{ .mmi
+      setf.sig FR_p_4 = GR_P_4
+      mov GR_TEMP1 = 0x0FFBF
+      nop.i 999
+}
+;;
+
+{ .mmi
+      setf.exp FR_ScaleP2 = GR_TEMP1
+      mov GR_TEMP2 = 0x0FF7F
+      nop.i 999
+}
+;;
+
+{ .mmi
+      setf.exp FR_ScaleP3 = GR_TEMP2
+      mov GR_TEMP4 = 0x1003E
+      nop.i 999
+}
+;;
+
+{ .mmf
+      setf.exp FR_sigma_C = GR_TEMP4
+      mov GR_Temp = 0x0FFDE
+      fcvt.xuf.s1 FR_p_1 = FR_p_1
+}
+;;
+
+{ .mfi
+      setf.exp FR_TWOM33 = GR_Temp
+      fcvt.xuf.s1 FR_p_2 = FR_p_2
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fcvt.xuf.s1 FR_p_3 = FR_p_3
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fcvt.xuf.s1 FR_p_4 = FR_p_4
+      nop.i 999
+}
+;;
+
+//    Tmp_C := fmpy.fpsr3( x, p_1 );
+//    Tmp_B := fmpy.fpsr3( x, p_2 );
+//    Tmp_A := fmpy.fpsr3( x, p_3 );
+//    If Tmp_C >= sigma_C then
+//      C_hi := Tmp_C;
+//      C_lo := x*p_1 - C_hi ...fma, exact
+//    Else
+//      C_hi := fadd.fpsr3(sigma_C, Tmp_C) - sigma_C
+//      C_lo := x*p_1 - C_hi ...fma, exact
+//    End If
+//    If Tmp_B >= sigma_B then
+//      B_hi := Tmp_B;
+//      B_lo := x*p_2 - B_hi ...fma, exact
+//    Else
+//      B_hi := fadd.fpsr3(sigma_B, Tmp_B) - sigma_B
+//      B_lo := x*p_2 - B_hi ...fma, exact
+//    End If
+//    If Tmp_A >= sigma_A then
+//      A_hi := Tmp_A;
+//      A_lo := x*p_3 - A_hi ...fma, exact
+//    Else
+//      A_hi := fadd.fpsr3(sigma_A, Tmp_A) - sigma_A
+//      Exact, regardless ...of rounding direction
+//      A_lo := x*p_3 - A_hi ...fma, exact
+//    Endif
+{ .mfi
+      nop.m 999
+      fmpy.s3 FR_Tmp_C = FR_X,FR_p_1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      mov GR_TEMP3 = 0x0FF3F
+      fmpy.s1 FR_p_2 = FR_p_2,FR_ScaleP2
+      nop.i 999
+}
+;;
+
+{ .mmf
+      setf.exp FR_ScaleP4 = GR_TEMP3
+      mov GR_TEMP4 = 0x10045
+      fmpy.s1 FR_p_3 = FR_p_3,FR_ScaleP3
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fadd.s3 FR_C_hi = FR_sigma_C,FR_Tmp_C   // For Tmp_C < sigma_C case
+      nop.i 999
+}
+;;
+
+{ .mmf
+      setf.exp FR_Tmp2_C = GR_TEMP4
+      nop.m 999
+      fmpy.s3 FR_Tmp_B = FR_X,FR_p_2
+}
+;;
+
+{ .mfi
+      addl           GR_BASE   = @ltoff(Constants_Bits_of_pi_by_2#), gp
+      fcmp.ge.s1 p12,  p9 = FR_Tmp_C,FR_sigma_C
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fmpy.s3 FR_Tmp_A = FR_X,FR_p_3
+      nop.i 99
+}
+;;
+
+{ .mfi
+      ld8 GR_BASE = [GR_BASE]
+(p12) mov FR_C_hi = FR_Tmp_C
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p9)  fsub.s1 FR_C_hi = FR_C_hi,FR_sigma_C
+      nop.i 999
+}
+;;
+
+
+
+//   End If
+//   Step 3. Get reduced argument
+//   If sgn_x == 0 (that is original x is positive)
+//      D_hi := Pi_by_2_hi
+//      D_lo := Pi_by_2_lo
+//      Load from table
+//   Else
+//      D_hi := neg_Pi_by_2_hi
+//      D_lo := neg_Pi_by_2_lo
+//      Load from table
+//   End If
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_p_4 = FR_p_4,FR_ScaleP4
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s3 FR_B_hi = FR_sigma_B,FR_Tmp_B     // For Tmp_B < sigma_B case
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fadd.s3 FR_A_hi = FR_sigma_A,FR_Tmp_A     // For Tmp_A < sigma_A case
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fcmp.ge.s1 p13, p10 = FR_Tmp_B,FR_sigma_B
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fms.s1 FR_C_lo = FR_X,FR_p_1,FR_C_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe FR_D_hi = [GR_BASE],16
+      fcmp.ge.s1 p14, p11 = FR_Tmp_A,FR_sigma_A
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe FR_D_lo = [GR_BASE]
+(p13) mov FR_B_hi = FR_Tmp_B
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p10) fsub.s1 FR_B_hi = FR_B_hi,FR_sigma_B
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p14) mov FR_A_hi = FR_Tmp_A
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p11) fsub.s1 FR_A_hi = FR_A_hi,FR_sigma_A
+      nop.i 999
+}
+;;
+
+//    Note that C_hi is of integer value. We need only the
+//    last few bits. Thus we can ensure C_hi is never a big
+//    integer, freeing us from overflow worry.
+//    Tmp_C := fadd.fpsr3( C_hi, 2^(70) ) - 2^(70);
+//    Tmp_C is the upper portion of C_hi
+{ .mfi
+      nop.m 999
+      fadd.s3 FR_Tmp_C = FR_C_hi,FR_Tmp2_C
+      tbit.z p12,p9 = GR_Exp_x, 17
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fms.s1 FR_B_lo = FR_X,FR_p_2,FR_B_hi
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s3 FR_A = FR_B_hi,FR_C_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fms.s1 FR_A_lo = FR_X,FR_p_3,FR_A_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fsub.s1 FR_Tmp_C = FR_Tmp_C,FR_Tmp2_C
+      nop.i 999
+}
+;;
+
+//    *******************
+//    Step 2. Get N and f
+//    *******************
+//    We have all the components to obtain
+//    S_0, S_1, S_2, S_3 and thus N and f. We start by adding
+//    C_lo and B_hi. This sum together with C_hi estimates
+//    N and f well.
+//    A := fadd.fpsr3( B_hi, C_lo )
+//    B := max( B_hi, C_lo )
+//    b := min( B_hi, C_lo )
+{ .mfi
+      nop.m 999
+      fmax.s1 FR_B = FR_B_hi,FR_C_lo
+      nop.i 999
+}
+;;
+
+// We use a right-shift trick to get the integer part of A into the rightmost
+// bits of the significand by adding 1.1000..00 * 2^63.  This operation is good
+// if |A| < 2^61, which it is in this case.  We are doing this to save a few
+// cycles over using fcvt.fx followed by fnorm.  The second step of the trick
+// is to subtract the same constant to float the rounded integer into a fp reg.
+
+{ .mfi
+      nop.m 999
+//    N := round_to_nearest_integer_value( A );
+      fma.s1 FR_N_fix = FR_A, f1, FR_RSHF
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmin.s1 FR_b = FR_B_hi,FR_C_lo
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+//    C_hi := C_hi - Tmp_C ...0 <= C_hi < 2^7
+      fsub.s1 FR_C_hi = FR_C_hi,FR_Tmp_C
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+//    a := (B - A) + b: Exact - note that a is either 0 or 2^(-64).
+      fsub.s1 FR_a = FR_B,FR_A
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fms.s1 FR_N = FR_N_fix, f1, FR_RSHF
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_a = FR_a,FR_b
+      nop.i 999
+}
+;;
+
+//    f := A - N; Exact because lsb(A) >= 2^(-64) and |f| <= 1/2.
+//    N := convert to integer format( C_hi + N );
+//    M := P_0 * x_lo;
+//    N := N + M;
+{ .mfi
+      nop.m 999
+      fsub.s1 FR_f = FR_A,FR_N
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_N = FR_N,FR_C_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fsub.s1 FR_D_hi = f0, FR_D_hi
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p9)  fsub.s1 FR_D_lo = f0, FR_D_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_g = FR_A_hi,FR_B_lo          // For Case 1, g=A_hi+B_lo
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s3 FR_A = FR_A_hi,FR_B_lo          // For Case 2, A=A_hi+B_lo w/ sf3
+      nop.i 999
+}
+;;
+
+{ .mfi
+      mov GR_Temp = 0x0FFCD                   // For Case 2, exponent of 2^-50
+      fmax.s1 FR_B = FR_A_hi,FR_B_lo          // For Case 2, B=max(A_hi,B_lo)
+      nop.i 999
+}
+;;
+
+//    f = f + a      Exact because a is 0 or 2^(-64);
+//    the msb of the sum is <= 1/2 and lsb >= 2^(-64).
+{ .mfi
+      setf.exp FR_TWOM50 = GR_Temp            // For Case 2, form 2^-50
+      fcvt.fx.s1 FR_N = FR_N
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_f = FR_f,FR_a
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmin.s1 FR_b = FR_A_hi,FR_B_lo          // For Case 2, b=min(A_hi,B_lo)
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fsub.s1 FR_a = FR_B,FR_A                // For Case 2, a=B-A
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_s_hi = FR_f,FR_g             // For Case 1, s_hi=f+g
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_f_hi = FR_A,FR_f             // For Case 2, f_hi=A+f
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fabs FR_f_abs = FR_f
+      nop.i 999
+}
+;;
+
+{ .mfi
+      getf.sig GR_N = FR_N
+      fsetc.s3 0x7F,0x40                 // Reset sf3 to user settings + td
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fsub.s1 FR_s_lo = FR_f,FR_s_hi          // For Case 1, s_lo=f-s_hi
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fsub.s1 FR_f_lo = FR_f,FR_f_hi          // For Case 2, f_lo=f-f_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 FR_r_hi = FR_s_hi,FR_D_hi       // For Case 1, r_hi=s_hi*D_hi
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_a = FR_a,FR_b                // For Case 2, a=a+b
+      nop.i 999
+}
+;;
+
+
+//    If sgn_x == 1 (that is original x was negative)
+//       N := 2^10 - N
+//       this maintains N to be non-negative, but still
+//       equivalent to the (negated N) mod 4.
+//    End If
+{ .mfi
+      add GR_N = GR_N,GR_M
+      fcmp.ge.s1 p13, p10 = FR_f_abs,FR_TWOM33
+      mov GR_Temp = 0x00400
+}
+;;
+
+{ .mfi
+(p9)  sub GR_N = GR_Temp,GR_N
+      fadd.s1 FR_s_lo = FR_s_lo,FR_g           // For Case 1, s_lo=s_lo+g
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s1 FR_f_lo = FR_f_lo,FR_A           // For Case 2, f_lo=f_lo+A
+      nop.i 999
+}
+;;
+
+//       a := (B - A) + b      Exact.
+//       Note that a is either 0 or 2^(-128).
+//       f_hi := A + f;
+//       f_lo := (f - f_hi) + A
+//       f_lo=f-f_hi is exact because either |f| >= |A|, in which
+//       case f-f_hi is clearly exact; or otherwise, 0<|f|<|A|
+//       means msb(f) <= msb(A) = 2^(-64) => |f| = 2^(-64).
+//       If f = 2^(-64), f-f_hi involves cancellation and is
+//       exact. If f = -2^(-64), then A + f is exact. Hence
+//       f-f_hi is -A exactly, giving f_lo = 0.
+//       f_lo := f_lo + a;
+
+//    If |f| >= 2^(-33)
+//       Case 1
+//       CASE := 1
+//       g := A_hi + B_lo;
+//       s_hi := f + g;
+//       s_lo := (f - s_hi) + g;
+//   Else
+//       Case 2
+//       CASE := 2
+//       A := fadd.fpsr3( A_hi, B_lo )
+//       B := max( A_hi, B_lo )
+//       b := min( A_hi, B_lo )
+
+{ .mfi
+      nop.m 999
+(p10) fcmp.ge.unc.s1 p14, p11 = FR_f_abs,FR_TWOM50
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p13) fms.s1 FR_r_lo = FR_s_hi,FR_D_hi,FR_r_hi //For Case 1, r_lo=s_hi*D_hi+r_hi
+      nop.i 999
+}
+;;
+
+//       If |f| >= 2^(-50) then
+//          s_hi := f_hi;
+//          s_lo := f_lo;
+//       Else
+//          f_lo := (f_lo + A_lo) + x*p_4
+//          s_hi := f_hi + f_lo
+//          s_lo := (f_hi - s_hi) + f_lo
+//       End If
+{ .mfi
+      nop.m 999
+(p14) mov FR_s_hi = FR_f_hi
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p10) fadd.s1 FR_f_lo = FR_f_lo,FR_a
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p14) mov FR_s_lo = FR_f_lo
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p11) fadd.s1 FR_f_lo = FR_f_lo,FR_A_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p11) fma.s1 FR_f_lo = FR_X,FR_p_4,FR_f_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p13) fma.s1 FR_r_lo = FR_s_hi,FR_D_lo,FR_r_lo //For Case 1, r_lo=s_hi*D_lo+r_lo
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p11) fadd.s1 FR_s_hi = FR_f_hi,FR_f_lo
+      nop.i 999
+}
+;;
+
+//   r_hi :=  s_hi*D_hi
+//   r_lo :=  s_hi*D_hi - r_hi  with fma
+//   r_lo := (s_hi*D_lo + r_lo) + s_lo*D_hi
+{ .mfi
+      nop.m 999
+(p10) fmpy.s1 FR_r_hi = FR_s_hi,FR_D_hi
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p11) fsub.s1 FR_s_lo = FR_f_hi,FR_s_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p10) fms.s1 FR_r_lo = FR_s_hi,FR_D_hi,FR_r_hi
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p11) fadd.s1 FR_s_lo = FR_s_lo,FR_f_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p10) fma.s1 FR_r_lo = FR_s_hi,FR_D_lo,FR_r_lo
+      nop.i 999
+}
+;;
+
+//   Return  N, r_hi, r_lo
+//   We do not return CASE
+{ .mfb
+      nop.m 999
+      fma.s1 FR_r_lo = FR_s_lo,FR_D_hi,FR_r_lo
+      br.ret.sptk   b0
+}
+;;
+
+.endp __libm_pi_by_2_reduce#
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_scalblnf.S
@@ -0,0 +1,449 @@
+.file "libm_scalblnf.s"
+
+
+// Copyright (c) 2001 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 08/03/01 Initial version
+// 08/23/01 Corrected error tag number
+// 02/06/02 Corrected to handle 32- or 64-bit integers
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 08/25/03 Improved performance
+//
+// API
+//==============================================================
+// float __libm_scalblnf  (float x, long int n, int long_int_type)
+// input  floating point f8 and long int n (r33)
+// input  long_int_type = 0 if long int defined as 32 bits, = 1 if 64 bits
+// output floating point f8
+//
+// Returns x* 2**n using an fma and detects overflow
+// and underflow.
+//
+//
+// Strategy:
+//  Compute biased exponent of result exp_Result = N + exp_X
+//  Break into ranges:
+//   exp_Result > 0x1007e                 -> Certain overflow
+//   exp_Result = 0x1007e                 -> Possible overflow
+//   0x0ff81 <= exp_Result < 0x1007e      -> No over/underflow (main path)
+//   0x0ff81 - 23 <= exp_Result < 0x0ff81 -> Possible underflow
+//   exp_Result < 0x0ff81 - 23            -> Certain underflow
+
+FR_Big         = f6
+FR_NBig        = f7
+FR_Floating_X  = f8
+FR_Result      = f8
+FR_Result2     = f9
+FR_Result3     = f10
+FR_Norm_X      = f11
+FR_Two_N       = f12
+
+GR_neg_ov_limit= r14
+GR_N_Biased    = r15
+GR_Big         = r16
+GR_NBig        = r17
+GR_exp_Result  = r18
+GR_pos_ov_limit= r19
+GR_Bias        = r20
+GR_N_as_int    = r21
+GR_signexp_X   = r22
+GR_exp_X       = r23
+GR_exp_mask    = r24
+GR_max_exp     = r25
+GR_min_exp     = r26
+GR_min_den_exp = r27
+
+GR_SAVE_B0          = r32
+GR_SAVE_GP          = r33
+GR_SAVE_PFS         = r34
+GR_Parameter_X      = r35
+GR_Parameter_Y      = r36
+GR_Parameter_RESULT = r37
+GR_Tag              = r38
+
+.section .text
+GLOBAL_LIBM_ENTRY(__libm_scalblnf)
+
+//
+//   Is x NAN, INF, ZERO, +-?
+//   Build the exponent Bias
+//
+{    .mfi
+     getf.exp      GR_signexp_X = FR_Floating_X // Get signexp of x
+     fclass.m      p6,p0 = FR_Floating_X, 0xe7  // @snan | @qnan | @inf | @zero
+     mov           GR_Bias = 0x0ffff
+}
+//
+//   Normalize x
+//   Is long integer type 32 bits?
+//
+{    .mfi
+     mov           GR_Big = 35000      // If N this big then certain overflow
+     fnorm.s1      FR_Norm_X = FR_Floating_X
+     cmp.eq        p8,p9 = r34,r0
+}
+;;
+
+//   Sign extend N if long int is 32 bits
+{    .mfi
+(p9) mov           GR_N_as_int = r33     // Copy N if long int is 64 bits
+     fclass.m      p9,p0 = FR_Floating_X, 0x0b // Test for x=unorm
+(p8) sxt4          GR_N_as_int = r33     // Sign extend N if long int is 32 bits
+}
+{ .mfi
+     mov           GR_NBig = -35000    // If N this small then certain underflow
+     nop.f         0
+     mov           GR_max_exp = 0x1007e      // Exponent of maximum float
+}
+;;
+
+//   Create biased exponent for 2**N
+{    .mfi
+     add           GR_N_Biased = GR_Bias,GR_N_as_int
+     nop.f         0
+     cmp.ge        p7, p0 = GR_N_as_int, GR_Big  // Certain overflow?
+}
+{    .mib
+     cmp.le        p8, p0 = GR_N_as_int, GR_NBig // Certain underflow?
+     mov           GR_min_exp = 0x0ff81      // Exponent of minimum float
+(p9) br.cond.spnt  SCALBNF_UNORM              // Branch if x=unorm
+}
+;;
+
+SCALBNF_COMMON:
+// Main path continues.  Also return here from x=unorm path.
+//   Create 2**N
+.pred.rel "mutex",p7,p8
+{    .mfi
+     setf.exp      FR_Two_N = GR_N_Biased
+     nop.f         0
+(p7) mov           GR_N_as_int = GR_Big      // Limit max N
+}
+{    .mfi
+(p8) mov           GR_N_as_int = GR_NBig     // Limit min N
+     nop.f         0
+(p8) cmp.eq        p7,p0 = r0,r0             // Set p7 if |N| big
+}
+;;
+
+//
+//   Create biased exponent for 2**N for N big
+//   Is N zero?
+//
+{    .mfi
+(p7) add           GR_N_Biased = GR_Bias,GR_N_as_int
+     nop.f         0
+     cmp.eq.or     p6,p0 = r33,r0
+}
+{    .mfi
+     mov           GR_pos_ov_limit = 0x1007f // Exponent for positive overflow
+     nop.f         0
+     mov           GR_exp_mask = 0x1ffff     // Exponent mask
+}
+;;
+
+//
+//   Create 2**N for N big
+//   Return x when N = 0 or X = Nan, Inf, Zero
+//
+{    .mfi
+(p7) setf.exp      FR_Two_N = GR_N_Biased
+     nop.f         0
+     mov           GR_min_den_exp = 0x0ff81 - 23 // Exponent of min denorm float
+}
+{    .mfb
+     and           GR_exp_X = GR_exp_mask, GR_signexp_X
+(p6) fma.s.s0      FR_Result = FR_Floating_X, f1, f0
+(p6) br.ret.spnt   b0
+}
+;;
+
+//
+//   Raise Denormal operand flag with compare
+//   Compute biased result exponent
+//
+{    .mfi
+     add           GR_exp_Result = GR_exp_X, GR_N_as_int
+     fcmp.ge.s0    p0,p11 = FR_Floating_X,f0
+     mov           GR_neg_ov_limit = 0x3007f // Exponent for negative overflow
+}
+;;
+
+//
+//   Do final operation
+//
+{    .mfi
+     cmp.lt        p7,p6 = GR_exp_Result, GR_max_exp  // Test no overflow
+     fma.s.s0      FR_Result = FR_Two_N,FR_Norm_X,f0
+     cmp.lt        p9,p0 = GR_exp_Result, GR_min_den_exp // Test sure underflow
+}
+{    .mfb
+     nop.m         0
+     nop.f         0
+(p9) br.cond.spnt  SCALBNF_UNDERFLOW           // Branch if certain underflow
+}
+;;
+
+{    .mib
+(p6) cmp.gt.unc    p6,p8 = GR_exp_Result, GR_max_exp  // Test sure overflow
+(p7) cmp.ge.unc    p7,p9 = GR_exp_Result, GR_min_exp  // Test no over/underflow
+(p7) br.ret.sptk   b0                         // Return from main path
+}
+;;
+
+{    .bbb
+(p6) br.cond.spnt  SCALBNF_OVERFLOW            // Branch if certain overflow
+(p8) br.cond.spnt  SCALBNF_POSSIBLE_OVERFLOW   // Branch if possible overflow
+(p9) br.cond.spnt  SCALBNF_POSSIBLE_UNDERFLOW  // Branch if possible underflow
+}
+;;
+
+// Here if possible underflow.
+// Resulting exponent: 0x0ff81-23 <= exp_Result < 0x0ff81
+SCALBNF_POSSIBLE_UNDERFLOW:
+//
+// Here if possible overflow.
+// Resulting exponent: 0x1007e = exp_Result
+SCALBNF_POSSIBLE_OVERFLOW:
+
+//   Set up necessary status fields
+//
+//   S0 user supplied status
+//   S2 user supplied status + WRE + TD  (Overflows)
+//   S3 user supplied status + FZ + TD   (Underflows)
+//
+{    .mfi
+     nop.m         0
+     fsetc.s3      0x7F,0x41
+     nop.i         0
+}
+{    .mfi
+     nop.m         0
+     fsetc.s2      0x7F,0x42
+     nop.i         0
+}
+;;
+
+//
+//   Do final operation with s2 and s3
+//
+{    .mfi
+     setf.exp      FR_NBig = GR_neg_ov_limit
+     fma.s.s3      FR_Result3 = FR_Two_N,FR_Norm_X,f0
+     nop.i         0
+}
+{    .mfi
+     setf.exp      FR_Big = GR_pos_ov_limit
+     fma.s.s2      FR_Result2 = FR_Two_N,FR_Norm_X,f0
+     nop.i         0
+}
+;;
+
+//   Check for overflow or underflow.
+//   Restore s3
+//   Restore s2
+//
+{    .mfi
+     nop.m         0
+     fsetc.s3      0x7F,0x40
+     nop.i         0
+}
+{    .mfi
+     nop.m         0
+     fsetc.s2      0x7F,0x40
+     nop.i         0
+}
+;;
+
+//
+//   Is the result zero?
+//
+{    .mfi
+     nop.m         0
+     fclass.m      p6, p0 =  FR_Result3, 0x007
+     nop.i         0
+}
+{    .mfi
+     nop.m         0
+     fcmp.ge.s1    p7, p8 = FR_Result2 , FR_Big
+     nop.i         0
+}
+;;
+
+//
+//   Detect masked underflow - Tiny + Inexact Only
+//
+{    .mfi
+     nop.m         0
+(p6) fcmp.neq.unc.s1 p6, p0 = FR_Result , FR_Result2
+     nop.i         0
+}
+;;
+
+//
+//   Is result bigger the allowed range?
+//   Branch out for underflow
+//
+{    .mfb
+     nop.m          0
+(p8) fcmp.le.unc.s1 p9, p10 = FR_Result2 , FR_NBig
+(p6) br.cond.spnt   SCALBNF_UNDERFLOW
+}
+;;
+
+//
+//   Branch out for overflow
+//
+{ .bbb
+(p7) br.cond.spnt   SCALBNF_OVERFLOW
+(p9) br.cond.spnt   SCALBNF_OVERFLOW
+     br.ret.sptk    b0             //   Return from main path.
+}
+;;
+
+// Here if result overflows
+SCALBNF_OVERFLOW:
+{ .mib
+     alloc         r32=ar.pfs,3,0,4,0
+     addl          GR_Tag = 205, r0    // Set error tag for overflow
+     br.cond.sptk  __libm_error_region // Call error support for overflow
+}
+;;
+
+// Here if result underflows
+SCALBNF_UNDERFLOW:
+{ .mib
+     alloc         r32=ar.pfs,3,0,4,0
+     addl          GR_Tag = 206, r0    // Set error tag for underflow
+     br.cond.sptk  __libm_error_region // Call error support for underflow
+}
+;;
+
+// Here if x=unorm
+SCALBNF_UNORM:
+{ .mib
+     getf.exp      GR_signexp_X = FR_Norm_X // Get signexp of normalized x
+     nop.i         0
+     br.cond.sptk  SCALBNF_COMMON            // Return to main path
+}
+;;
+
+
+GLOBAL_LIBM_END(__libm_scalblnf)
+LOCAL_LIBM_ENTRY(__libm_error_region)
+
+//
+// Get stack address of N
+//
+.prologue
+{ .mfi
+    add   GR_Parameter_Y=-32,sp
+    nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+    mov  GR_SAVE_PFS=ar.pfs
+}
+//
+// Adjust sp
+//
+{ .mfi
+.fframe 64
+   add sp=-64,sp
+   nop.f 0
+   mov GR_SAVE_GP=gp
+};;
+
+//
+//  Store N on stack in correct position
+//  Locate the address of x on stack
+//
+{ .mmi
+   st8 [GR_Parameter_Y] =  GR_N_as_int,16
+   add GR_Parameter_X = 16,sp
+.save   b0, GR_SAVE_B0
+   mov GR_SAVE_B0=b0
+};;
+
+//
+// Store x on the stack.
+// Get address for result on stack.
+//
+.body
+{ .mib
+   stfs [GR_Parameter_X] = FR_Norm_X
+   add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+   nop.b 0
+}
+{ .mib
+   stfs [GR_Parameter_Y] = FR_Result
+   add   GR_Parameter_Y = -16,GR_Parameter_Y
+   br.call.sptk b0=__libm_error_support#
+};;
+
+//
+//  Get location of result on stack
+//
+{ .mmi
+   add   GR_Parameter_RESULT = 48,sp
+   nop.m 0
+   nop.i 0
+};;
+
+//
+//  Get the new result
+//
+{ .mmi
+   ldfs  FR_Result = [GR_Parameter_RESULT]
+.restore sp
+   add   sp = 64,sp
+   mov   b0 = GR_SAVE_B0
+};;
+
+//
+//  Restore gp, ar.pfs and return
+//
+{ .mib
+   mov   gp = GR_SAVE_GP
+   mov   ar.pfs = GR_SAVE_PFS
+   br.ret.sptk     b0
+};;
+
+LOCAL_LIBM_END(__libm_error_region)
+
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_sincos.S
@@ -0,0 +1,782 @@
+.file "libm_sincos.s"
+
+
+// Copyright (c) 2002 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/01/02 Initial version
+// 02/18/02 Large arguments processing routine is excluded.
+//          External interface entry points are added
+// 03/13/02 Corrected restore of predicate registers
+// 03/19/02 Added stack unwind around call to __libm_cis_large
+// 09/05/02 Work range is widened by reduction strengthen (3 parts of Pi/16)
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 08/08/03 Improved performance
+// 02/11/04 cis is moved to the separate file.
+// 03/31/05 Reformatted delimiters between data tables
+//
+// API
+//==============================================================
+// 1) void sincos(double, double*s, double*c)
+// 2) __libm_sincos - internal LIBM function, that accepts
+//    argument in f8 and returns cosine through f8, sine through f9
+//
+// Overview of operation
+//==============================================================
+//
+// Step 1
+// ======
+// Reduce x to region -1/2*pi/2^k ===== 0 ===== +1/2*pi/2^k  where k=4
+//    divide x by pi/2^k.
+//    Multiply by 2^k/pi.
+//    nfloat = Round result to integer (round-to-nearest)
+//
+// r = x -  nfloat * pi/2^k
+//    Do this as ((((x -  nfloat * HIGH(pi/2^k))) -
+//                        nfloat * LOW(pi/2^k)) -
+//                        nfloat * LOWEST(pi/2^k) for increased accuracy.
+//    pi/2^k is stored as two numbers that when added make pi/2^k.
+//       pi/2^k = HIGH(pi/2^k) + LOW(pi/2^k)
+//    HIGH and LOW parts are rounded to zero values,
+//    and LOWEST is rounded to nearest one.
+//
+// x = (nfloat * pi/2^k) + r
+//    r is small enough that we can use a polynomial approximation
+//    and is referred to as the reduced argument.
+//
+// Step 3
+// ======
+// Take the unreduced part and remove the multiples of 2pi.
+// So nfloat = nfloat (with lower k+1 bits cleared) + lower k+1 bits
+//
+//    nfloat (with lower k+1 bits cleared) is a multiple of 2^(k+1)
+//    N * 2^(k+1)
+//    nfloat * pi/2^k = N * 2^(k+1) * pi/2^k + (lower k+1 bits) * pi/2^k
+//    nfloat * pi/2^k = N * 2 * pi + (lower k+1 bits) * pi/2^k
+//    nfloat * pi/2^k = N2pi + M * pi/2^k
+//
+//
+// Sin(x) = Sin((nfloat * pi/2^k) + r)
+//        = Sin(nfloat * pi/2^k) * Cos(r) + Cos(nfloat * pi/2^k) * Sin(r)
+//
+//          Sin(nfloat * pi/2^k) = Sin(N2pi + Mpi/2^k)
+//                               = Sin(N2pi)Cos(Mpi/2^k) + Cos(N2pi)Sin(Mpi/2^k)
+//                               = Sin(Mpi/2^k)
+//
+//          Cos(nfloat * pi/2^k) = Cos(N2pi + Mpi/2^k)
+//                               = Cos(N2pi)Cos(Mpi/2^k) + Sin(N2pi)Sin(Mpi/2^k)
+//                               = Cos(Mpi/2^k)
+//
+// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
+//
+//
+// Step 4
+// ======
+// 0 <= M < 2^(k+1)
+// There are 2^(k+1) Sin entries in a table.
+// There are 2^(k+1) Cos entries in a table.
+//
+// Get Sin(Mpi/2^k) and Cos(Mpi/2^k) by table lookup.
+//
+//
+// Step 5
+// ======
+// Calculate Cos(r) and Sin(r) by polynomial approximation.
+//
+// Cos(r) = 1 + r^2 q1  + r^4 q2 + r^6 q3 + ... = Series for Cos
+// Sin(r) = r + r^3 p1  + r^5 p2 + r^7 p3 + ... = Series for Sin
+//
+// and the coefficients q1, q2, ... and p1, p2, ... are stored in a table
+//
+//
+// Calculate
+// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
+//
+// as follows
+//
+//    S[m] = Sin(Mpi/2^k) and C[m] = Cos(Mpi/2^k)
+//    rsq = r*r
+//
+//
+//    P = p1 + r^2p2 + r^4p3 + r^6p4
+//    Q = q1 + r^2q2 + r^4q3 + r^6q4
+//
+//       rcub = r * rsq
+//       Sin(r) = r + rcub * P
+//              = r + r^3p1  + r^5p2 + r^7p3 + r^9p4 + ... = Sin(r)
+//
+//            The coefficients are not exactly these values, but almost.
+//
+//            p1 = -1/6  = -1/3!
+//            p2 = 1/120 =  1/5!
+//            p3 = -1/5040 = -1/7!
+//            p4 = 1/362889 = 1/9!
+//
+//       P =  r + rcub * P
+//
+//    Answer = S[m] Cos(r) + C[m] P
+//
+//       Cos(r) = 1 + rsq Q
+//       Cos(r) = 1 + r^2 Q
+//       Cos(r) = 1 + r^2 (q1 + r^2q2 + r^4q3 + r^6q4)
+//       Cos(r) = 1 + r^2q1 + r^4q2 + r^6q3 + r^8q4 + ...
+//
+//       S[m] Cos(r) = S[m](1 + rsq Q)
+//       S[m] Cos(r) = S[m] + S[m] rsq Q
+//       S[m] Cos(r) = S[m] + s_rsq Q
+//       Q           = S[m] + s_rsq Q
+//
+// Then,
+//
+//    Answer = Q + C[m] P
+
+// Registers used
+//==============================================================
+// general input registers:
+// r14 -> r39
+
+// predicate registers used:
+// p6 -> p14
+//
+// floating-point registers used
+// f9 -> f15
+// f32 -> f67
+
+// Assembly macros
+//==============================================================
+
+cis_Arg                     = f8
+
+cis_Sin_res                 = f9
+cis_Cos_res                 = f8
+
+cis_NORM_f8                 = f10
+cis_W                       = f11
+cis_int_Nfloat              = f12
+cis_Nfloat                  = f13
+
+cis_r                       = f14
+cis_rsq                     = f15
+cis_rcub                    = f32
+
+cis_Inv_Pi_by_16            = f33
+cis_Pi_by_16_hi             = f34
+cis_Pi_by_16_lo             = f35
+
+cis_Inv_Pi_by_64            = f36
+cis_Pi_by_16_lowest         = f37
+cis_r_exact                 = f38
+
+
+cis_P1                      = f39
+cis_Q1                      = f40
+cis_P2                      = f41
+cis_Q2                      = f42
+cis_P3                      = f43
+cis_Q3                      = f44
+cis_P4                      = f45
+cis_Q4                      = f46
+
+cis_P_temp1                 = f47
+cis_P_temp2                 = f48
+
+cis_Q_temp1                 = f49
+cis_Q_temp2                 = f50
+
+cis_P                       = f51
+
+cis_SIG_INV_PI_BY_16_2TO61  = f52
+cis_RSHF_2TO61              = f53
+cis_RSHF                    = f54
+cis_2TOM61                  = f55
+cis_NFLOAT                  = f56
+cis_W_2TO61_RSH             = f57
+
+cis_tmp                     = f58
+
+cis_Sm_sin                  = f59
+cis_Cm_sin                  = f60
+
+cis_Sm_cos                  = f61
+cis_Cm_cos                  = f62
+
+cis_srsq_sin                = f63
+cis_srsq_cos                = f64
+
+cis_Q_sin                   = f65
+cis_Q_cos                   = f66
+cis_Q                       = f67
+
+/////////////////////////////////////////////////////////////
+
+cis_pResSin                 = r33
+cis_pResCos                 = r34
+
+cis_GR_sig_inv_pi_by_16     = r14
+cis_GR_rshf_2to61           = r15
+cis_GR_rshf                 = r16
+cis_GR_exp_2tom61           = r17
+cis_GR_n                    = r18
+cis_GR_n_sin                = r19
+cis_exp_limit               = r20
+cis_r_signexp               = r21
+cis_AD_1                    = r22
+cis_r_sincos                = r23
+cis_r_exp                   = r24
+cis_r_17_ones               = r25
+cis_GR_m_sin                = r26
+cis_GR_32m_sin              = r26
+cis_GR_n_cos                = r27
+cis_GR_m_cos                = r28
+cis_GR_32m_cos              = r28
+cis_AD_2_sin                = r29
+cis_AD_2_cos                = r30
+cis_gr_tmp                  = r31
+
+GR_SAVE_B0                  = r35
+GR_SAVE_GP                  = r36
+rB0_SAVED                   = r37
+GR_SAVE_PFS                 = r38
+GR_SAVE_PR                  = r39
+
+RODATA
+
+.align 16
+// Pi/16 parts
+LOCAL_OBJECT_START(double_cis_pi)
+   data8 0xC90FDAA22168C234, 0x00003FFC // pi/16 1st part
+   data8 0xC4C6628B80DC1CD1, 0x00003FBC // pi/16 2nd part
+   data8 0xA4093822299F31D0, 0x00003F7A // pi/16 3rd part
+LOCAL_OBJECT_END(double_cis_pi)
+
+// Coefficients for polynomials
+LOCAL_OBJECT_START(double_cis_pq_k4)
+   data8 0x3EC71C963717C63A // P4
+   data8 0x3EF9FFBA8F191AE6 // Q4
+   data8 0xBF2A01A00F4E11A8 // P3
+   data8 0xBF56C16C05AC77BF // Q3
+   data8 0x3F8111111110F167 // P2
+   data8 0x3FA555555554DD45 // Q2
+   data8 0xBFC5555555555555 // P1
+   data8 0xBFDFFFFFFFFFFFFC // Q1
+LOCAL_OBJECT_END(double_cis_pq_k4)
+
+// Sincos table (S[m], C[m])
+LOCAL_OBJECT_START(double_sin_cos_beta_k4)
+data8 0x0000000000000000 , 0x00000000 // sin( 0 pi/16)  S0
+data8 0x8000000000000000 , 0x00003fff // cos( 0 pi/16)  C0
+//
+data8 0xc7c5c1e34d3055b3 , 0x00003ffc // sin( 1 pi/16)  S1
+data8 0xfb14be7fbae58157 , 0x00003ffe // cos( 1 pi/16)  C1
+//
+data8 0xc3ef1535754b168e , 0x00003ffd // sin( 2 pi/16)  S2
+data8 0xec835e79946a3146 , 0x00003ffe // cos( 2 pi/16)  C2
+//
+data8 0x8e39d9cd73464364 , 0x00003ffe // sin( 3 pi/16)  S3
+data8 0xd4db3148750d181a , 0x00003ffe // cos( 3 pi/16)  C3
+//
+data8 0xb504f333f9de6484 , 0x00003ffe // sin( 4 pi/16)  S4
+data8 0xb504f333f9de6484 , 0x00003ffe // cos( 4 pi/16)  C4
+//
+data8 0xd4db3148750d181a , 0x00003ffe // sin( 5 pi/16)  C3
+data8 0x8e39d9cd73464364 , 0x00003ffe // cos( 5 pi/16)  S3
+//
+data8 0xec835e79946a3146 , 0x00003ffe // sin( 6 pi/16)  C2
+data8 0xc3ef1535754b168e , 0x00003ffd // cos( 6 pi/16)  S2
+//
+data8 0xfb14be7fbae58157 , 0x00003ffe // sin( 7 pi/16)  C1
+data8 0xc7c5c1e34d3055b3 , 0x00003ffc // cos( 7 pi/16)  S1
+//
+data8 0x8000000000000000 , 0x00003fff // sin( 8 pi/16)  C0
+data8 0x0000000000000000 , 0x00000000 // cos( 8 pi/16)  S0
+//
+data8 0xfb14be7fbae58157 , 0x00003ffe // sin( 9 pi/16)  C1
+data8 0xc7c5c1e34d3055b3 , 0x0000bffc // cos( 9 pi/16)  -S1
+//
+data8 0xec835e79946a3146 , 0x00003ffe // sin(10 pi/16)  C2
+data8 0xc3ef1535754b168e , 0x0000bffd // cos(10 pi/16)  -S2
+//
+data8 0xd4db3148750d181a , 0x00003ffe // sin(11 pi/16)  C3
+data8 0x8e39d9cd73464364 , 0x0000bffe // cos(11 pi/16)  -S3
+//
+data8 0xb504f333f9de6484 , 0x00003ffe // sin(12 pi/16)  S4
+data8 0xb504f333f9de6484 , 0x0000bffe // cos(12 pi/16)  -S4
+//
+data8 0x8e39d9cd73464364 , 0x00003ffe // sin(13 pi/16) S3
+data8 0xd4db3148750d181a , 0x0000bffe // cos(13 pi/16) -C3
+//
+data8 0xc3ef1535754b168e , 0x00003ffd // sin(14 pi/16) S2
+data8 0xec835e79946a3146 , 0x0000bffe // cos(14 pi/16) -C2
+//
+data8 0xc7c5c1e34d3055b3 , 0x00003ffc // sin(15 pi/16) S1
+data8 0xfb14be7fbae58157 , 0x0000bffe // cos(15 pi/16) -C1
+//
+data8 0x0000000000000000 , 0x00000000 // sin(16 pi/16) S0
+data8 0x8000000000000000 , 0x0000bfff // cos(16 pi/16) -C0
+//
+data8 0xc7c5c1e34d3055b3 , 0x0000bffc // sin(17 pi/16) -S1
+data8 0xfb14be7fbae58157 , 0x0000bffe // cos(17 pi/16) -C1
+//
+data8 0xc3ef1535754b168e , 0x0000bffd // sin(18 pi/16) -S2
+data8 0xec835e79946a3146 , 0x0000bffe // cos(18 pi/16) -C2
+//
+data8 0x8e39d9cd73464364 , 0x0000bffe // sin(19 pi/16) -S3
+data8 0xd4db3148750d181a , 0x0000bffe // cos(19 pi/16) -C3
+//
+data8 0xb504f333f9de6484 , 0x0000bffe // sin(20 pi/16) -S4
+data8 0xb504f333f9de6484 , 0x0000bffe // cos(20 pi/16) -S4
+//
+data8 0xd4db3148750d181a , 0x0000bffe // sin(21 pi/16) -C3
+data8 0x8e39d9cd73464364 , 0x0000bffe // cos(21 pi/16) -S3
+//
+data8 0xec835e79946a3146 , 0x0000bffe // sin(22 pi/16) -C2
+data8 0xc3ef1535754b168e , 0x0000bffd // cos(22 pi/16) -S2
+//
+data8 0xfb14be7fbae58157 , 0x0000bffe // sin(23 pi/16) -C1
+data8 0xc7c5c1e34d3055b3 , 0x0000bffc // cos(23 pi/16) -S1
+//
+data8 0x8000000000000000 , 0x0000bfff // sin(24 pi/16) -C0
+data8 0x0000000000000000 , 0x00000000 // cos(24 pi/16) S0
+//
+data8 0xfb14be7fbae58157 , 0x0000bffe // sin(25 pi/16) -C1
+data8 0xc7c5c1e34d3055b3 , 0x00003ffc // cos(25 pi/16) S1
+//
+data8 0xec835e79946a3146 , 0x0000bffe // sin(26 pi/16) -C2
+data8 0xc3ef1535754b168e , 0x00003ffd // cos(26 pi/16) S2
+//
+data8 0xd4db3148750d181a , 0x0000bffe // sin(27 pi/16) -C3
+data8 0x8e39d9cd73464364 , 0x00003ffe // cos(27 pi/16) S3
+//
+data8 0xb504f333f9de6484 , 0x0000bffe // sin(28 pi/16) -S4
+data8 0xb504f333f9de6484 , 0x00003ffe // cos(28 pi/16) S4
+//
+data8 0x8e39d9cd73464364 , 0x0000bffe // sin(29 pi/16) -S3
+data8 0xd4db3148750d181a , 0x00003ffe // cos(29 pi/16) C3
+//
+data8 0xc3ef1535754b168e , 0x0000bffd // sin(30 pi/16) -S2
+data8 0xec835e79946a3146 , 0x00003ffe // cos(30 pi/16) C2
+//
+data8 0xc7c5c1e34d3055b3 , 0x0000bffc // sin(31 pi/16) -S1
+data8 0xfb14be7fbae58157 , 0x00003ffe // cos(31 pi/16) C1
+//
+data8 0x0000000000000000 , 0x00000000 // sin(32 pi/16) S0
+data8 0x8000000000000000 , 0x00003fff // cos(32 pi/16) C0
+LOCAL_OBJECT_END(double_sin_cos_beta_k4)
+
+.section .text
+
+GLOBAL_IEEE754_ENTRY(sincos)
+// cis_GR_sig_inv_pi_by_16 = significand of 16/pi
+{ .mlx
+      getf.exp      cis_r_signexp       = cis_Arg
+      movl          cis_GR_sig_inv_pi_by_16 = 0xA2F9836E4E44152A
+
+}
+// cis_GR_rshf_2to61 = 1.1000 2^(63+63-2)
+{ .mlx
+      addl          cis_AD_1                = @ltoff(double_cis_pi), gp
+      movl          cis_GR_rshf_2to61       = 0x47b8000000000000
+};;
+
+{ .mfi
+      ld8           cis_AD_1            = [cis_AD_1]
+      fnorm.s1      cis_NORM_f8         = cis_Arg
+      cmp.eq        p13, p14            = r0, r0 // p13 set for sincos
+}
+// cis_GR_exp_2tom61 = exponent of scaling factor 2^-61
+{ .mib
+      mov           cis_GR_exp_2tom61   = 0xffff-61
+      nop.i         0
+      br.cond.sptk  _CIS_COMMON
+};;
+GLOBAL_IEEE754_END(sincos)
+libm_alias_double_other (__sincos, sincos)
+
+GLOBAL_LIBM_ENTRY(__libm_sincos)
+// cis_GR_sig_inv_pi_by_16 = significand of 16/pi
+{ .mlx
+      getf.exp      cis_r_signexp       = cis_Arg
+      movl          cis_GR_sig_inv_pi_by_16 = 0xA2F9836E4E44152A
+}
+// cis_GR_rshf_2to61 = 1.1000 2^(63+63-2)
+{ .mlx
+      addl          cis_AD_1            = @ltoff(double_cis_pi), gp
+      movl          cis_GR_rshf_2to61   = 0x47b8000000000000
+};;
+
+// p14 set for __libm_sincos and cis
+{ .mfi
+      ld8           cis_AD_1            = [cis_AD_1]
+      fnorm.s1      cis_NORM_f8         = cis_Arg
+      cmp.eq        p14, p13            = r0, r0
+}
+// cis_GR_exp_2tom61 = exponent of scaling factor 2^-61
+{ .mib
+      mov           cis_GR_exp_2tom61   = 0xffff-61
+      nop.i         0
+      nop.b         0
+};;
+
+_CIS_COMMON:
+//  Form two constants we need
+//  16/pi * 2^-2 * 2^63, scaled by 2^61 since we just loaded the significand
+//  1.1000...000 * 2^(63+63-2) to right shift int(W) into the low significand
+//  fcmp used to set denormal, and invalid on snans
+{ .mfi
+      setf.sig      cis_SIG_INV_PI_BY_16_2TO61 = cis_GR_sig_inv_pi_by_16
+      fclass.m      p6,p0                      = cis_Arg, 0xe7 // if x=0,inf,nan
+      addl          cis_gr_tmp                 = -1, r0
+}
+// 1.1000 2^63 for right shift
+{ .mlx
+      setf.d        cis_RSHF_2TO61             = cis_GR_rshf_2to61
+      movl          cis_GR_rshf                = 0x43e8000000000000
+};;
+
+//  Form another constant
+//  2^-61 for scaling Nfloat
+//  0x1001a is register_bias + 27.
+//  So if f8 >= 2^27, go to large arguments routine
+{ .mfi
+      alloc         GR_SAVE_PFS         = ar.pfs, 3, 5, 0, 0
+      fclass.m      p11,p0              = cis_Arg, 0x0b // Test for x=unorm
+      mov           cis_exp_limit       = 0x1001a
+}
+{ .mib
+      setf.exp      cis_2TOM61          = cis_GR_exp_2tom61
+      nop.i         0
+(p6)  br.cond.spnt  _CIS_SPECIAL_ARGS
+};;
+
+//  Load the two pieces of pi/16
+//  Form another constant
+//  1.1000...000 * 2^63, the right shift constant
+{ .mmb
+      ldfe          cis_Pi_by_16_hi     = [cis_AD_1],16
+      setf.d        cis_RSHF            = cis_GR_rshf
+(p11) br.cond.spnt  _CIS_UNORM          // Branch if x=unorm
+};;
+
+_CIS_COMMON2:
+// Return here if x=unorm
+// Create constant inexact set
+{ .mmi
+      ldfe          cis_Pi_by_16_lo     = [cis_AD_1],16
+      setf.sig      cis_tmp             = cis_gr_tmp
+      nop.i         0
+};;
+
+// Select exponent (17 lsb)
+{ .mfi
+      ldfe          cis_Pi_by_16_lowest = [cis_AD_1],16
+      nop.f         0
+      dep.z         cis_r_exp           = cis_r_signexp, 0, 17
+};;
+
+// Start loading P, Q coefficients
+// p10 is true if we must call routines to handle larger arguments
+// p10 is true if f8 exp is > 0x1001a
+{ .mmb
+      ldfpd         cis_P4,cis_Q4       = [cis_AD_1],16
+      cmp.ge        p10, p0             = cis_r_exp, cis_exp_limit
+(p10) br.cond.spnt  _CIS_LARGE_ARGS // go to |x| >= 2^27 path
+};;
+
+// cis_W = x * cis_Inv_Pi_by_16
+// Multiply x by scaled 16/pi and add large const to shift integer part of W to
+// rightmost bits of significand
+{ .mfi
+      ldfpd         cis_P3,cis_Q3       = [cis_AD_1],16
+      fma.s1 cis_W_2TO61_RSH = cis_NORM_f8,cis_SIG_INV_PI_BY_16_2TO61,cis_RSHF_2TO61
+      nop.i  0
+};;
+
+// get N = (int)cis_int_Nfloat
+// cis_NFLOAT = Round_Int_Nearest(cis_W)
+{ .mmf
+      getf.sig      cis_GR_n            = cis_W_2TO61_RSH
+      ldfpd  cis_P2,cis_Q2   = [cis_AD_1],16
+      fms.s1        cis_NFLOAT          = cis_W_2TO61_RSH,cis_2TOM61,cis_RSHF
+};;
+
+// cis_r = -cis_Nfloat * cis_Pi_by_16_hi + x
+{ .mfi
+      ldfpd         cis_P1,cis_Q1       = [cis_AD_1], 16
+      fnma.s1       cis_r               = cis_NFLOAT,cis_Pi_by_16_hi,cis_NORM_f8
+      nop.i         0
+};;
+
+// Add 2^(k-1) (which is in cis_r_sincos) to N
+{ .mmi
+      add           cis_GR_n_cos        = 0x8, cis_GR_n
+;;
+//Get M (least k+1 bits of N)
+      and           cis_GR_m_sin        = 0x1f,cis_GR_n
+      and           cis_GR_m_cos        = 0x1f,cis_GR_n_cos
+};;
+
+{ .mmi
+      nop.m         0
+      nop.m         0
+      shl           cis_GR_32m_sin      = cis_GR_m_sin,5
+};;
+
+// Add 32*M to address of sin_cos_beta table
+// cis_r =  cis_r -cis_Nfloat * cis_Pi_by_16_lo
+{ .mfi
+      add           cis_AD_2_sin        = cis_GR_32m_sin, cis_AD_1
+      fnma.s1       cis_r               = cis_NFLOAT, cis_Pi_by_16_lo,  cis_r
+      shl           cis_GR_32m_cos      = cis_GR_m_cos,5
+};;
+
+// Add 32*M to address of sin_cos_beta table
+{ .mmf
+      ldfe          cis_Sm_sin          = [cis_AD_2_sin],16
+      add           cis_AD_2_cos        = cis_GR_32m_cos, cis_AD_1
+      fclass.m.unc  p10,p0              = cis_Arg,0x0b  // den. input - uflow
+};;
+
+{ .mfi
+      ldfe          cis_Sm_cos          = [cis_AD_2_cos], 16
+      nop.i         0
+};;
+
+{ .mfi
+      ldfe          cis_Cm_sin          = [cis_AD_2_sin]
+      fma.s1        cis_rsq             = cis_r, cis_r,   f0  // get r^2
+      nop.i         0
+}
+// fmpy forces inexact flag
+{ .mfi
+      nop.m         0
+      fmpy.s0       cis_tmp             = cis_tmp,cis_tmp
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fnma.s1       cis_r_exact         = cis_NFLOAT, cis_Pi_by_16_lowest, cis_r
+      nop.i         0
+};;
+
+{ .mfi
+      ldfe          cis_Cm_cos          = [cis_AD_2_cos]
+      fma.s1        cis_P_temp1         = cis_rsq, cis_P4, cis_P3
+      nop.i         0
+}
+
+{ .mfi
+      nop.m         0
+      fma.s1        cis_Q_temp1         = cis_rsq, cis_Q4, cis_Q3
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fmpy.s1       cis_srsq_sin        = cis_Sm_sin, cis_rsq
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fmpy.s1       cis_srsq_cos        = cis_Sm_cos,cis_rsq
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fma.s1        cis_Q_temp2         = cis_rsq, cis_Q_temp1, cis_Q2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        cis_P_temp2         = cis_rsq, cis_P_temp1, cis_P2
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fmpy.s1       cis_rcub            = cis_r_exact, cis_rsq // get r^3
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fma.s1        cis_Q               = cis_rsq, cis_Q_temp2, cis_Q1
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        cis_P               = cis_rsq, cis_P_temp2, cis_P1
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fma.s1        cis_Q_sin           = cis_srsq_sin,cis_Q, cis_Sm_sin
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        cis_Q_cos           = cis_srsq_cos,cis_Q, cis_Sm_cos
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fma.s1        cis_P               = cis_rcub,cis_P, cis_r_exact // final P
+      nop.i         0
+};;
+
+// If den. arg, force underflow to be set
+{ .mfi
+      nop.m         0
+(p10) fmpy.d.s0     cis_tmp             = cis_Arg,cis_Arg
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fma.d.s0      cis_Sin_res         = cis_Cm_sin,cis_P,cis_Q_sin//Final sin
+      nop.i         0
+}
+{ .mfb
+      nop.m         0
+      fma.d.s0      cis_Cos_res         = cis_Cm_cos,cis_P,cis_Q_cos//Final cos
+(p14) br.ret.sptk   b0  // common exit for __libm_sincos and cis main path
+};;
+
+{ .mmb
+      stfd          [cis_pResSin]       = cis_Sin_res
+      stfd          [cis_pResCos]       = cis_Cos_res
+      br.ret.sptk   b0 // common exit for sincos main path
+};;
+
+_CIS_SPECIAL_ARGS:
+// sin(+/-0) = +/-0
+// sin(Inf)  = NaN
+// sin(NaN)  = NaN
+{ .mfi
+      nop.m         999
+      fma.d.s0      cis_Sin_res          = cis_Arg, f0, f0 // sinf(+/-0,NaN,Inf)
+      nop.i         999
+};;
+// cos(+/-0) = 1.0
+// cos(Inf)  = NaN
+// cos(NaN)  = NaN
+{ .mfb
+      nop.m         999
+      fma.d.s0      cis_Cos_res          = cis_Arg, f0, f1 // cosf(+/-0,NaN,Inf)
+(p14) br.ret.sptk   b0 //spec exit for __libm_sincos and cis main path
+};;
+
+{ .mmb
+      stfd          [cis_pResSin]       = cis_Sin_res
+      stfd          [cis_pResCos]       = cis_Cos_res
+      br.ret.sptk   b0 // common exit for sincos main path
+};;
+
+_CIS_UNORM:
+// Here if x=unorm
+{ .mfb
+      getf.exp      cis_r_signexp       = cis_NORM_f8 // Get signexp of x
+      fcmp.eq.s0    p11,p0              = cis_Arg, f0 // Dummy op to set denorm
+      br.cond.sptk  _CIS_COMMON2        // Return to main path
+};;
+
+GLOBAL_LIBM_END(__libm_sincos)
+
+////  |x| > 2^27 path  ///////
+.proc _CIS_LARGE_ARGS
+_CIS_LARGE_ARGS:
+.prologue
+{ .mfi
+      nop.m         0
+      nop.f         0
+.save ar.pfs, GR_SAVE_PFS
+      mov           GR_SAVE_PFS         = ar.pfs
+}
+;;
+
+{ .mfi
+      mov           GR_SAVE_GP          = gp
+      nop.f         0
+.save b0, GR_SAVE_B0
+      mov           GR_SAVE_B0          = b0
+};;
+
+.body
+// Call of huge arguments sincos
+{ .mib
+      nop.m         0
+      mov           GR_SAVE_PR          = pr
+      br.call.sptk  b0                  = __libm_sincos_large
+};;
+
+{ .mfi
+      mov           gp                  = GR_SAVE_GP
+      nop.f         0
+      mov           pr                  = GR_SAVE_PR, 0x1fffe
+}
+;;
+
+{ .mfi
+      nop.m         0
+      nop.f         0
+      mov           b0                  = GR_SAVE_B0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.d.s0      cis_Cos_res         = cis_Cos_res, f1, f0
+      mov           ar.pfs              = GR_SAVE_PFS
+}
+{ .mfb
+      nop.m         0
+      fma.d.s0      cis_Sin_res         = cis_Sin_res, f1, f0
+(p14) br.ret.sptk   b0  // exit for |x| > 2^27 path (__libm_sincos and cis)
+};;
+
+{ .mmb
+      stfd          [cis_pResSin]       = cis_Sin_res
+      stfd          [cis_pResCos]       = cis_Cos_res
+      br.ret.sptk   b0 // exit for sincos |x| > 2^27 path
+};;
+.endp _CIS_LARGE_ARGS
+
+.type __libm_sincos_large#,@function
+.global __libm_sincos_large#
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_sincos_large.S
@@ -0,0 +1,2755 @@
+.file "libm_sincos_large.s"
+
+
+// Copyright (c) 2002 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/15/02 Initial version
+// 05/13/02 Changed interface to __libm_pi_by_2_reduce
+// 02/10/03 Reordered header: .section, .global, .proc, .align;
+//          used data8 for long double table values
+// 05/15/03 Reformatted data tables
+//
+//
+// Overview of operation
+//==============================================================
+//
+// These functions calculate the sin and cos for inputs
+// greater than 2^10
+//
+// __libm_sin_large#
+// __libm_cos_large#
+// They accept argument in f8
+// and return result in f8 without final rounding
+//
+// __libm_sincos_large#
+// It accepts argument in f8
+// and returns cos in f8 and sin in f9 without final rounding
+//
+//
+//*********************************************************************
+//
+// Accuracy:       Within .7 ulps for 80-bit floating point values
+//                 Very accurate for double precision values
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8 as Input Value, f8 and f9 as Return Values
+//                              f32-f103
+//
+//    General Purpose Registers:
+//      r32-r43
+//      r44-r45 (Used to pass arguments to pi_by_2 reduce routine)
+//
+//    Predicate Registers:      p6-p13
+//
+//*********************************************************************
+//
+//  IEEE Special Conditions:
+//
+//    Denormal  fault raised on denormal inputs
+//    Overflow exceptions do not occur
+//    Underflow exceptions raised when appropriate for sin
+//    (No specialized error handling for this routine)
+//    Inexact raised when appropriate by algorithm
+//
+//    sin(SNaN) = QNaN
+//    sin(QNaN) = QNaN
+//    sin(inf) = QNaN
+//    sin(+/-0) = +/-0
+//    cos(inf) = QNaN
+//    cos(SNaN) = QNaN
+//    cos(QNaN) = QNaN
+//    cos(0) = 1
+//
+//*********************************************************************
+//
+//  Mathematical Description
+//  ========================
+//
+//  The computation of FSIN and FCOS is best handled in one piece of
+//  code. The main reason is that given any argument Arg, computation
+//  of trigonometric functions first calculate N and an approximation
+//  to alpha where
+//
+//  Arg = N pi/2 + alpha, |alpha| <= pi/4.
+//
+//  Since
+//
+//  cos( Arg ) = sin( (N+1) pi/2 + alpha ),
+//
+//  therefore, the code for computing sine will produce cosine as long
+//  as 1 is added to N immediately after the argument reduction
+//  process.
+//
+//  Let M = N if sine
+//      N+1 if cosine.
+//
+//  Now, given
+//
+//  Arg = M pi/2  + alpha, |alpha| <= pi/4,
+//
+//  let I = M mod 4, or I be the two lsb of M when M is represented
+//  as 2's complement. I = [i_0 i_1]. Then
+//
+//  sin( Arg ) = (-1)^i_0  sin( alpha ) if i_1 = 0,
+//             = (-1)^i_0  cos( alpha )     if i_1 = 1.
+//
+//  For example:
+//       if M = -1, I = 11
+//         sin ((-pi/2 + alpha) = (-1) cos (alpha)
+//       if M = 0, I = 00
+//         sin (alpha) = sin (alpha)
+//       if M = 1, I = 01
+//         sin (pi/2 + alpha) = cos (alpha)
+//       if M = 2, I = 10
+//         sin (pi + alpha) = (-1) sin (alpha)
+//       if M = 3, I = 11
+//         sin ((3/2)pi + alpha) = (-1) cos (alpha)
+//
+//  The value of alpha is obtained by argument reduction and
+//  represented by two working precision numbers r and c where
+//
+//  alpha =  r  +  c     accurately.
+//
+//  The reduction method is described in a previous write up.
+//  The argument reduction scheme identifies 4 cases. For Cases 2
+//  and 4, because |alpha| is small, sin(r+c) and cos(r+c) can be
+//  computed very easily by 2 or 3 terms of the Taylor series
+//  expansion as follows:
+//
+//  Case 2:
+//  -------
+//
+//  sin(r + c) = r + c - r^3/6  accurately
+//  cos(r + c) = 1 - 2^(-67)    accurately
+//
+//  Case 4:
+//  -------
+//
+//  sin(r + c) = r + c - r^3/6 + r^5/120    accurately
+//  cos(r + c) = 1 - r^2/2 + r^4/24     accurately
+//
+//  The only cases left are Cases 1 and 3 of the argument reduction
+//  procedure. These two cases will be merged since after the
+//  argument is reduced in either cases, we have the reduced argument
+//  represented as r + c and that the magnitude |r + c| is not small
+//  enough to allow the usage of a very short approximation.
+//
+//  The required calculation is either
+//
+//  sin(r + c)  =  sin(r)  +  correction,  or
+//  cos(r + c)  =  cos(r)  +  correction.
+//
+//  Specifically,
+//
+//  sin(r + c) = sin(r) + c sin'(r) + O(c^2)
+//         = sin(r) + c cos (r) + O(c^2)
+//         = sin(r) + c(1 - r^2/2)  accurately.
+//  Similarly,
+//
+//  cos(r + c) = cos(r) - c sin(r) + O(c^2)
+//         = cos(r) - c(r - r^3/6)  accurately.
+//
+//  We therefore concentrate on accurately calculating sin(r) and
+//  cos(r) for a working-precision number r, |r| <= pi/4 to within
+//  0.1% or so.
+//
+//  The greatest challenge of this task is that the second terms of
+//  the Taylor series
+//
+//  r - r^3/3! + r^r/5! - ...
+//
+//  and
+//
+//  1 - r^2/2! + r^4/4! - ...
+//
+//  are not very small when |r| is close to pi/4 and the rounding
+//  errors will be a concern if simple polynomial accumulation is
+//  used. When |r| < 2^-3, however, the second terms will be small
+//  enough (6 bits or so of right shift) that a normal Horner
+//  recurrence suffices. Hence there are two cases that we consider
+//  in the accurate computation of sin(r) and cos(r), |r| <= pi/4.
+//
+//  Case small_r: |r| < 2^(-3)
+//  --------------------------
+//
+//  Since Arg = M pi/4 + r + c accurately, and M mod 4 is [i_0 i_1],
+//  we have
+//
+//  sin(Arg) = (-1)^i_0 * sin(r + c)    if i_1 = 0
+//       = (-1)^i_0 * cos(r + c)    if i_1 = 1
+//
+//  can be accurately approximated by
+//
+//  sin(Arg) = (-1)^i_0 * [sin(r) + c]  if i_1 = 0
+//           = (-1)^i_0 * [cos(r) - c*r] if i_1 = 1
+//
+//  because |r| is small and thus the second terms in the correction
+//  are unnecessary.
+//
+//  Finally, sin(r) and cos(r) are approximated by polynomials of
+//  moderate lengths.
+//
+//  sin(r) =  r + S_1 r^3 + S_2 r^5 + ... + S_5 r^11
+//  cos(r) =  1 + C_1 r^2 + C_2 r^4 + ... + C_5 r^10
+//
+//  We can make use of predicates to selectively calculate
+//  sin(r) or cos(r) based on i_1.
+//
+//  Case normal_r: 2^(-3) <= |r| <= pi/4
+//  ------------------------------------
+//
+//  This case is more likely than the previous one if one considers
+//  r to be uniformly distributed in [-pi/4 pi/4]. Again,
+//
+//  sin(Arg) = (-1)^i_0 * sin(r + c)    if i_1 = 0
+//           = (-1)^i_0 * cos(r + c)    if i_1 = 1.
+//
+//  Because |r| is now larger, we need one extra term in the
+//  correction. sin(Arg) can be accurately approximated by
+//
+//  sin(Arg) = (-1)^i_0 * [sin(r) + c(1-r^2/2)]      if i_1 = 0
+//           = (-1)^i_0 * [cos(r) - c*r*(1 - r^2/6)]    i_1 = 1.
+//
+//  Finally, sin(r) and cos(r) are approximated by polynomials of
+//  moderate lengths.
+//
+//  sin(r) =  r + PP_1_hi r^3 + PP_1_lo r^3 +
+//                PP_2 r^5 + ... + PP_8 r^17
+//
+//  cos(r) =  1 + QQ_1 r^2 + QQ_2 r^4 + ... + QQ_8 r^16
+//
+//  where PP_1_hi is only about 16 bits long and QQ_1 is -1/2.
+//  The crux in accurate computation is to calculate
+//
+//  r + PP_1_hi r^3   or  1 + QQ_1 r^2
+//
+//  accurately as two pieces: U_hi and U_lo. The way to achieve this
+//  is to obtain r_hi as a 10 sig. bit number that approximates r to
+//  roughly 8 bits or so of accuracy. (One convenient way is
+//
+//  r_hi := frcpa( frcpa( r ) ).)
+//
+//  This way,
+//
+//  r + PP_1_hi r^3 =  r + PP_1_hi r_hi^3 +
+//                          PP_1_hi (r^3 - r_hi^3)
+//              =  [r + PP_1_hi r_hi^3]  +
+//             [PP_1_hi (r - r_hi)
+//                (r^2 + r_hi r + r_hi^2) ]
+//              =  U_hi  +  U_lo
+//
+//  Since r_hi is only 10 bit long and PP_1_hi is only 16 bit long,
+//  PP_1_hi * r_hi^3 is only at most 46 bit long and thus computed
+//  exactly. Furthermore, r and PP_1_hi r_hi^3 are of opposite sign
+//  and that there is no more than 8 bit shift off between r and
+//  PP_1_hi * r_hi^3. Hence the sum, U_hi, is representable and thus
+//  calculated without any error. Finally, the fact that
+//
+//  |U_lo| <= 2^(-8) |U_hi|
+//
+//  says that U_hi + U_lo is approximating r + PP_1_hi r^3 to roughly
+//  8 extra bits of accuracy.
+//
+//  Similarly,
+//
+//  1 + QQ_1 r^2  =  [1 + QQ_1 r_hi^2]  +
+//                      [QQ_1 (r - r_hi)(r + r_hi)]
+//            =  U_hi  +  U_lo.
+//
+//  Summarizing, we calculate r_hi = frcpa( frcpa( r ) ).
+//
+//  If i_1 = 0, then
+//
+//    U_hi := r + PP_1_hi * r_hi^3
+//    U_lo := PP_1_hi * (r - r_hi) * (r^2 + r*r_hi + r_hi^2)
+//    poly := PP_1_lo r^3 + PP_2 r^5 + ... + PP_8 r^17
+//    correction := c * ( 1 + C_1 r^2 )
+//
+//  Else ...i_1 = 1
+//
+//    U_hi := 1 + QQ_1 * r_hi * r_hi
+//    U_lo := QQ_1 * (r - r_hi) * (r + r_hi)
+//    poly := QQ_2 * r^4 + QQ_3 * r^6 + ... + QQ_8 r^16
+//    correction := -c * r * (1 + S_1 * r^2)
+//
+//  End
+//
+//  Finally,
+//
+//  V := poly + ( U_lo + correction )
+//
+//                 /    U_hi  +  V         if i_0 = 0
+//  result := |
+//                 \  (-U_hi) -  V         if i_0 = 1
+//
+//  It is important that in the last step, negation of U_hi is
+//  performed prior to the subtraction which is to be performed in
+//  the user-set rounding mode.
+//
+//
+//  Algorithmic Description
+//  =======================
+//
+//  The argument reduction algorithm is tightly integrated into FSIN
+//  and FCOS which share the same code. The following is complete and
+//  self-contained. The argument reduction description given
+//  previously is repeated below.
+//
+//
+//  Step 0. Initialization.
+//
+//   If FSIN is invoked, set N_inc := 0; else if FCOS is invoked,
+//   set N_inc := 1.
+//
+//  Step 1. Check for exceptional and special cases.
+//
+//   * If Arg is +-0, +-inf, NaN, NaT, go to Step 10 for special
+//     handling.
+//   * If |Arg| < 2^24, go to Step 2 for reduction of moderate
+//     arguments. This is the most likely case.
+//   * If |Arg| < 2^63, go to Step 8 for pre-reduction of large
+//     arguments.
+//   * If |Arg| >= 2^63, go to Step 10 for special handling.
+//
+//  Step 2. Reduction of moderate arguments.
+//
+//  If |Arg| < pi/4     ...quick branch
+//     N_fix := N_inc   (integer)
+//     r     := Arg
+//     c     := 0.0
+//     Branch to Step 4, Case_1_complete
+//  Else        ...cf. argument reduction
+//     N     := Arg * two_by_PI (fp)
+//     N_fix := fcvt.fx( N )    (int)
+//     N     := fcvt.xf( N_fix )
+//     N_fix := N_fix + N_inc
+//     s     := Arg - N * P_1   (first piece of pi/2)
+//     w     := -N * P_2    (second piece of pi/2)
+//
+//     If |s| >= 2^(-33)
+//        go to Step 3, Case_1_reduce
+//     Else
+//        go to Step 7, Case_2_reduce
+//     Endif
+//  Endif
+//
+//  Step 3. Case_1_reduce.
+//
+//  r := s + w
+//  c := (s - r) + w    ...observe order
+//
+//  Step 4. Case_1_complete
+//
+//  ...At this point, the reduced argument alpha is
+//  ...accurately represented as r + c.
+//  If |r| < 2^(-3), go to Step 6, small_r.
+//
+//  Step 5. Normal_r.
+//
+//  Let [i_0 i_1] by the 2 lsb of N_fix.
+//  FR_rsq  := r * r
+//  r_hi := frcpa( frcpa( r ) )
+//  r_lo := r - r_hi
+//
+//  If i_1 = 0, then
+//    poly := r*FR_rsq*(PP_1_lo + FR_rsq*(PP_2 + ... FR_rsq*PP_8))
+//    U_hi := r + PP_1_hi*r_hi*r_hi*r_hi    ...any order
+//    U_lo := PP_1_hi*r_lo*(r*r + r*r_hi + r_hi*r_hi)
+//    correction := c + c*C_1*FR_rsq        ...any order
+//  Else
+//    poly := FR_rsq*FR_rsq*(QQ_2 + FR_rsq*(QQ_3 + ... + FR_rsq*QQ_8))
+//    U_hi := 1 + QQ_1 * r_hi * r_hi        ...any order
+//    U_lo := QQ_1 * r_lo * (r + r_hi)
+//    correction := -c*(r + S_1*FR_rsq*r)   ...any order
+//  Endif
+//
+//  V := poly + (U_lo + correction) ...observe order
+//
+//  result := (i_0 == 0?   1.0 : -1.0)
+//
+//  Last instruction in user-set rounding mode
+//
+//  result := (i_0 == 0?   result*U_hi + V :
+//                        result*U_hi - V)
+//
+//  Return
+//
+//  Step 6. Small_r.
+//
+//  ...Use flush to zero mode without causing exception
+//    Let [i_0 i_1] be the two lsb of N_fix.
+//
+//  FR_rsq := r * r
+//
+//  If i_1 = 0 then
+//     z := FR_rsq*FR_rsq; z := FR_rsq*z *r
+//     poly_lo := S_3 + FR_rsq*(S_4 + FR_rsq*S_5)
+//     poly_hi := r*FR_rsq*(S_1 + FR_rsq*S_2)
+//     correction := c
+//     result := r
+//  Else
+//     z := FR_rsq*FR_rsq; z := FR_rsq*z
+//     poly_lo := C_3 + FR_rsq*(C_4 + FR_rsq*C_5)
+//     poly_hi := FR_rsq*(C_1 + FR_rsq*C_2)
+//     correction := -c*r
+//     result := 1
+//  Endif
+//
+//  poly := poly_hi + (z * poly_lo + correction)
+//
+//  If i_0 = 1, result := -result
+//
+//  Last operation. Perform in user-set rounding mode
+//
+//  result := (i_0 == 0?     result + poly :
+//                          result - poly )
+//  Return
+//
+//  Step 7. Case_2_reduce.
+//
+//  ...Refer to the write up for argument reduction for
+//  ...rationale. The reduction algorithm below is taken from
+//  ...argument reduction description and integrated this.
+//
+//  w := N*P_3
+//  U_1 := N*P_2 + w        ...FMA
+//  U_2 := (N*P_2 - U_1) + w    ...2 FMA
+//  ...U_1 + U_2 is  N*(P_2+P_3) accurately
+//
+//  r := s - U_1
+//  c := ( (s - r) - U_1 ) - U_2
+//
+//  ...The mathematical sum r + c approximates the reduced
+//  ...argument accurately. Note that although compared to
+//  ...Case 1, this case requires much more work to reduce
+//  ...the argument, the subsequent calculation needed for
+//  ...any of the trigonometric function is very little because
+//  ...|alpha| < 1.01*2^(-33) and thus two terms of the
+//  ...Taylor series expansion suffices.
+//
+//  If i_1 = 0 then
+//     poly := c + S_1 * r * r * r  ...any order
+//     result := r
+//  Else
+//     poly := -2^(-67)
+//     result := 1.0
+//  Endif
+//
+//  If i_0 = 1, result := -result
+//
+//  Last operation. Perform in user-set rounding mode
+//
+//  result := (i_0 == 0?     result + poly :
+//                           result - poly )
+//
+//  Return
+//
+//
+//  Step 8. Pre-reduction of large arguments.
+//
+//  ...Again, the following reduction procedure was described
+//  ...in the separate write up for argument reduction, which
+//  ...is tightly integrated here.
+
+//  N_0 := Arg * Inv_P_0
+//  N_0_fix := fcvt.fx( N_0 )
+//  N_0 := fcvt.xf( N_0_fix)
+
+//  Arg' := Arg - N_0 * P_0
+//  w := N_0 * d_1
+//  N := Arg' * two_by_PI
+//  N_fix := fcvt.fx( N )
+//  N := fcvt.xf( N_fix )
+//  N_fix := N_fix + N_inc
+//
+//  s := Arg' - N * P_1
+//  w := w - N * P_2
+//
+//  If |s| >= 2^(-14)
+//     go to Step 3
+//  Else
+//     go to Step 9
+//  Endif
+//
+//  Step 9. Case_4_reduce.
+//
+//    ...first obtain N_0*d_1 and -N*P_2 accurately
+//   U_hi := N_0 * d_1      V_hi := -N*P_2
+//   U_lo := N_0 * d_1 - U_hi   V_lo := -N*P_2 - U_hi   ...FMAs
+//
+//   ...compute the contribution from N_0*d_1 and -N*P_3
+//   w := -N*P_3
+//   w := w + N_0*d_2
+//   t := U_lo + V_lo + w       ...any order
+//
+//   ...at this point, the mathematical value
+//   ...s + U_hi + V_hi  + t approximates the true reduced argument
+//   ...accurately. Just need to compute this accurately.
+//
+//   ...Calculate U_hi + V_hi accurately:
+//   A := U_hi + V_hi
+//   if |U_hi| >= |V_hi| then
+//      a := (U_hi - A) + V_hi
+//   else
+//      a := (V_hi - A) + U_hi
+//   endif
+//   ...order in computing "a" must be observed. This branch is
+//   ...best implemented by predicates.
+//   ...A + a  is U_hi + V_hi accurately. Moreover, "a" is
+//   ...much smaller than A: |a| <= (1/2)ulp(A).
+//
+//   ...Just need to calculate   s + A + a + t
+//   C_hi := s + A      t := t + a
+//   C_lo := (s - C_hi) + A
+//   C_lo := C_lo + t
+//
+//   ...Final steps for reduction
+//   r := C_hi + C_lo
+//   c := (C_hi - r) + C_lo
+//
+//   ...At this point, we have r and c
+//   ...And all we need is a couple of terms of the corresponding
+//   ...Taylor series.
+//
+//   If i_1 = 0
+//      poly := c + r*FR_rsq*(S_1 + FR_rsq*S_2)
+//      result := r
+//   Else
+//      poly := FR_rsq*(C_1 + FR_rsq*C_2)
+//      result := 1
+//   Endif
+//
+//   If i_0 = 1, result := -result
+//
+//   Last operation. Perform in user-set rounding mode
+//
+//   result := (i_0 == 0?     result + poly :
+//                            result - poly )
+//   Return
+//
+//   Large Arguments: For arguments above 2**63, a Payne-Hanek
+//   style argument reduction is used and pi_by_2 reduce is called.
+//
+
+
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(FSINCOS_CONSTANTS)
+
+data4 0x4B800000 // two**24
+data4 0xCB800000 // -two**24
+data4 0x00000000 // pad
+data4 0x00000000 // pad
+data8 0xA2F9836E4E44152A, 0x00003FFE // Inv_pi_by_2
+data8 0xC84D32B0CE81B9F1, 0x00004016 // P_0
+data8 0xC90FDAA22168C235, 0x00003FFF // P_1
+data8 0xECE675D1FC8F8CBB, 0x0000BFBD // P_2
+data8 0xB7ED8FBBACC19C60, 0x0000BF7C // P_3
+data4 0x5F000000 // two**63
+data4 0xDF000000 // -two**63
+data4 0x00000000 // pad
+data4 0x00000000 // pad
+data8 0xA397E5046EC6B45A, 0x00003FE7 // Inv_P_0
+data8 0x8D848E89DBD171A1, 0x0000BFBF // d_1
+data8 0xD5394C3618A66F8E, 0x0000BF7C // d_2
+data8 0xC90FDAA22168C234, 0x00003FFE // pi_by_4
+data8 0xC90FDAA22168C234, 0x0000BFFE // neg_pi_by_4
+data4 0x3E000000 // two**-3
+data4 0xBE000000 // -two**-3
+data4 0x00000000 // pad
+data4 0x00000000 // pad
+data4 0x2F000000 // two**-33
+data4 0xAF000000 // -two**-33
+data4 0x9E000000 // -two**-67
+data4 0x00000000 // pad
+data8 0xCC8ABEBCA21C0BC9, 0x00003FCE // PP_8
+data8 0xD7468A05720221DA, 0x0000BFD6 // PP_7
+data8 0xB092382F640AD517, 0x00003FDE // PP_6
+data8 0xD7322B47D1EB75A4, 0x0000BFE5 // PP_5
+data8 0xFFFFFFFFFFFFFFFE, 0x0000BFFD // C_1
+data8 0xAAAA000000000000, 0x0000BFFC // PP_1_hi
+data8 0xB8EF1D2ABAF69EEA, 0x00003FEC // PP_4
+data8 0xD00D00D00D03BB69, 0x0000BFF2 // PP_3
+data8 0x8888888888888962, 0x00003FF8 // PP_2
+data8 0xAAAAAAAAAAAB0000, 0x0000BFEC // PP_1_lo
+data8 0xD56232EFC2B0FE52, 0x00003FD2 // QQ_8
+data8 0xC9C99ABA2B48DCA6, 0x0000BFDA // QQ_7
+data8 0x8F76C6509C716658, 0x00003FE2 // QQ_6
+data8 0x93F27DBAFDA8D0FC, 0x0000BFE9 // QQ_5
+data8 0xAAAAAAAAAAAAAAAA, 0x0000BFFC // S_1
+data8 0x8000000000000000, 0x0000BFFE // QQ_1
+data8 0xD00D00D00C6E5041, 0x00003FEF // QQ_4
+data8 0xB60B60B60B607F60, 0x0000BFF5 // QQ_3
+data8 0xAAAAAAAAAAAAAA9B, 0x00003FFA // QQ_2
+data8 0xFFFFFFFFFFFFFFFE, 0x0000BFFD // C_1
+data8 0xAAAAAAAAAAAA719F, 0x00003FFA // C_2
+data8 0xB60B60B60356F994, 0x0000BFF5 // C_3
+data8 0xD00CFFD5B2385EA9, 0x00003FEF // C_4
+data8 0x93E4BD18292A14CD, 0x0000BFE9 // C_5
+data8 0xAAAAAAAAAAAAAAAA, 0x0000BFFC // S_1
+data8 0x88888888888868DB, 0x00003FF8 // S_2
+data8 0xD00D00D0055EFD4B, 0x0000BFF2 // S_3
+data8 0xB8EF1C5D839730B9, 0x00003FEC // S_4
+data8 0xD71EA3A4E5B3F492, 0x0000BFE5 // S_5
+data4 0x38800000 // two**-14
+data4 0xB8800000 // -two**-14
+LOCAL_OBJECT_END(FSINCOS_CONSTANTS)
+
+// sin and cos registers
+
+// FR
+FR_Input_X        = f8
+
+FR_r              = f8
+FR_c              = f9
+
+FR_Two_to_63      = f32
+FR_Two_to_24      = f33
+FR_Pi_by_4        = f33
+FR_Two_to_M14     = f34
+FR_Two_to_M33     = f35
+FR_Neg_Two_to_24  = f36
+FR_Neg_Pi_by_4    = f36
+FR_Neg_Two_to_M14 = f37
+FR_Neg_Two_to_M33 = f38
+FR_Neg_Two_to_M67 = f39
+FR_Inv_pi_by_2    = f40
+FR_N_float        = f41
+FR_N_fix          = f42
+FR_P_1            = f43
+FR_P_2            = f44
+FR_P_3            = f45
+FR_s              = f46
+FR_w              = f47
+FR_d_2            = f48
+FR_prelim         = f49
+FR_Z              = f50
+FR_A              = f51
+FR_a              = f52
+FR_t              = f53
+FR_U_1            = f54
+FR_U_2            = f55
+FR_C_1            = f56
+FR_C_2            = f57
+FR_C_3            = f58
+FR_C_4            = f59
+FR_C_5            = f60
+FR_S_1            = f61
+FR_S_2            = f62
+FR_S_3            = f63
+FR_S_4            = f64
+FR_S_5            = f65
+FR_poly_hi        = f66
+FR_poly_lo        = f67
+FR_r_hi           = f68
+FR_r_lo           = f69
+FR_rsq            = f70
+FR_r_cubed        = f71
+FR_C_hi           = f72
+FR_N_0            = f73
+FR_d_1            = f74
+FR_V              = f75
+FR_V_hi           = f75
+FR_V_lo           = f76
+FR_U_hi           = f77
+FR_U_lo           = f78
+FR_U_hiabs        = f79
+FR_V_hiabs        = f80
+FR_PP_8           = f81
+FR_QQ_8           = f81
+FR_PP_7           = f82
+FR_QQ_7           = f82
+FR_PP_6           = f83
+FR_QQ_6           = f83
+FR_PP_5           = f84
+FR_QQ_5           = f84
+FR_PP_4           = f85
+FR_QQ_4           = f85
+FR_PP_3           = f86
+FR_QQ_3           = f86
+FR_PP_2           = f87
+FR_QQ_2           = f87
+FR_QQ_1           = f88
+FR_N_0_fix        = f89
+FR_Inv_P_0        = f90
+FR_corr           = f91
+FR_poly           = f92
+FR_Neg_Two_to_M3  = f93
+FR_Two_to_M3      = f94
+FR_Neg_Two_to_63  = f94
+FR_P_0            = f95
+FR_C_lo           = f96
+FR_PP_1           = f97
+FR_PP_1_lo        = f98
+FR_ArgPrime       = f99
+
+// GR
+GR_Table_Base     = r32
+GR_Table_Base1    = r33
+GR_i_0            = r34
+GR_i_1            = r35
+GR_N_Inc          = r36
+GR_Sin_or_Cos     = r37
+
+GR_SAVE_B0        = r39
+GR_SAVE_GP        = r40
+GR_SAVE_PFS       = r41
+
+// sincos combined routine registers
+
+// GR
+GR_SINCOS_SAVE_PFS    = r32
+GR_SINCOS_SAVE_B0     = r33
+GR_SINCOS_SAVE_GP     = r34
+
+// FR
+FR_SINCOS_ARG         = f100
+FR_SINCOS_RES_SIN     = f101
+
+
+.section .text
+
+
+GLOBAL_LIBM_ENTRY(__libm_sincos_large)
+
+{ .mfi
+        alloc GR_SINCOS_SAVE_PFS = ar.pfs,0,3,0,0
+        fma.s1 FR_SINCOS_ARG     = f8, f1, f0  // Save argument for sin and cos
+        mov GR_SINCOS_SAVE_B0    = b0
+};;
+
+{ .mfb
+        mov GR_SINCOS_SAVE_GP    = gp
+        nop.f  0
+        br.call.sptk b0          = __libm_sin_large // Call sin
+};;
+
+{ .mfi
+        nop.m  0
+        fma.s1 FR_SINCOS_RES_SIN = f8, f1, f0 // Save sin result
+        nop.i  0
+};;
+
+{ .mfb
+        nop.m  0
+        fma.s1 f8                = FR_SINCOS_ARG, f1, f0 // Arg for cos
+        br.call.sptk b0          = __libm_cos_large // Call cos
+};;
+
+{ .mfi
+        mov    gp                = GR_SINCOS_SAVE_GP
+        fma.s1 f9                = FR_SINCOS_RES_SIN, f1, f0 // Out sin result
+        mov    b0                = GR_SINCOS_SAVE_B0
+};;
+
+{ .mib
+        nop.m  0
+        mov ar.pfs               = GR_SINCOS_SAVE_PFS
+        br.ret.sptk                b0 // sincos_large exit
+};;
+
+GLOBAL_LIBM_END(__libm_sincos_large)
+
+
+
+
+GLOBAL_LIBM_ENTRY(__libm_sin_large)
+
+{ .mlx
+alloc GR_Table_Base = ar.pfs,0,12,2,0
+       movl GR_Sin_or_Cos = 0x0 ;;
+}
+
+{ .mmi
+      nop.m 999
+      addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ld8 GR_Table_Base = [GR_Table_Base]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+
+{ .mib
+      nop.m 999
+      nop.i 999
+       br.cond.sptk SINCOS_CONTINUE ;;
+}
+
+GLOBAL_LIBM_END(__libm_sin_large)
+
+GLOBAL_LIBM_ENTRY(__libm_cos_large)
+
+{ .mlx
+alloc GR_Table_Base= ar.pfs,0,12,2,0
+       movl GR_Sin_or_Cos = 0x1 ;;
+}
+
+{ .mmi
+      nop.m 999
+      addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ld8 GR_Table_Base = [GR_Table_Base]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+//
+//     Load Table Address
+//
+SINCOS_CONTINUE:
+
+{ .mmi
+       add GR_Table_Base1 = 96, GR_Table_Base
+       ldfs FR_Two_to_24 = [GR_Table_Base], 4
+       nop.i 999
+}
+;;
+
+{ .mmi
+      nop.m 999
+//
+//     Load 2**24, load 2**63.
+//
+       ldfs FR_Neg_Two_to_24 = [GR_Table_Base], 12
+       mov   r41 = ar.pfs ;;
+}
+
+{ .mfi
+       ldfs FR_Two_to_63 = [GR_Table_Base1], 4
+//
+//     Check for unnormals - unsupported operands. We do not want
+//     to generate denormal exception
+//     Check for NatVals, QNaNs, SNaNs, +/-Infs
+//     Check for EM unsupporteds
+//     Check for Zero
+//
+       fclass.m.unc  p6, p8 =  FR_Input_X, 0x1E3
+       mov   r40 = gp ;;
+}
+
+{ .mfi
+      nop.m 999
+       fclass.nm.unc p8, p0 =  FR_Input_X, 0x1FF
+// GR_Sin_or_Cos denotes
+       mov   r39 = b0
+}
+
+{ .mfb
+       ldfs FR_Neg_Two_to_63 = [GR_Table_Base1], 12
+       fclass.m.unc p10, p0 = FR_Input_X, 0x007
+(p6)   br.cond.spnt SINCOS_SPECIAL ;;
+}
+
+{ .mib
+      nop.m 999
+      nop.i 999
+(p8)   br.cond.spnt SINCOS_SPECIAL ;;
+}
+
+{ .mib
+      nop.m 999
+      nop.i 999
+//
+//     Branch if +/- NaN, Inf.
+//     Load -2**24, load -2**63.
+//
+(p10)  br.cond.spnt SINCOS_ZERO ;;
+}
+
+{ .mmb
+       ldfe FR_Inv_pi_by_2 = [GR_Table_Base], 16
+       ldfe FR_Inv_P_0 = [GR_Table_Base1], 16
+      nop.b 999 ;;
+}
+
+{ .mmb
+      nop.m 999
+       ldfe     FR_d_1 = [GR_Table_Base1], 16
+      nop.b 999 ;;
+}
+//
+//     Raise possible denormal operand flag with useful fcmp
+//     Is x <= -2**63
+//     Load Inv_P_0 for pre-reduction
+//     Load Inv_pi_by_2
+//
+
+{ .mmb
+       ldfe     FR_P_0 = [GR_Table_Base], 16
+       ldfe FR_d_2 = [GR_Table_Base1], 16
+      nop.b 999 ;;
+}
+//
+//     Load P_0
+//     Load d_1
+//     Is x >= 2**63
+//     Is x <= -2**24?
+//
+
+{ .mmi
+       ldfe FR_P_1 = [GR_Table_Base], 16 ;;
+//
+//     Load P_1
+//     Load d_2
+//     Is x >= 2**24?
+//
+       ldfe FR_P_2 = [GR_Table_Base], 16
+      nop.i 999 ;;
+}
+
+{ .mmf
+      nop.m 999
+       ldfe FR_P_3 = [GR_Table_Base], 16
+       fcmp.le.unc.s1   p7, p8 = FR_Input_X, FR_Neg_Two_to_24
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Branch if +/- zero.
+//     Decide about the paths to take:
+//     If -2**24 < FR_Input_X < 2**24 - CASE 1 OR 2
+//     OTHERWISE - CASE 3 OR 4
+//
+       fcmp.le.unc.s1   p10, p11 = FR_Input_X, FR_Neg_Two_to_63
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p8)   fcmp.ge.s1 p7, p0 = FR_Input_X, FR_Two_to_24
+      nop.i 999
+}
+
+{ .mfi
+       ldfe FR_Pi_by_4 = [GR_Table_Base1], 16
+(p11)  fcmp.ge.s1   p10, p0 = FR_Input_X, FR_Two_to_63
+      nop.i 999 ;;
+}
+
+{ .mmi
+       ldfe FR_Neg_Pi_by_4 = [GR_Table_Base1], 16 ;;
+       ldfs FR_Two_to_M3 = [GR_Table_Base1], 4
+      nop.i 999 ;;
+}
+
+{ .mib
+       ldfs FR_Neg_Two_to_M3 = [GR_Table_Base1], 12
+      nop.i 999
+//
+//     Load P_2
+//     Load P_3
+//     Load pi_by_4
+//     Load neg_pi_by_4
+//     Load 2**(-3)
+//     Load -2**(-3).
+//
+(p10)  br.cond.spnt SINCOS_ARG_TOO_LARGE ;;
+}
+
+{ .mib
+      nop.m 999
+      nop.i 999
+//
+//     Branch out if x >= 2**63. Use Payne-Hanek Reduction
+//
+(p7)   br.cond.spnt SINCOS_LARGER_ARG ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Branch if Arg <= -2**24 or Arg >= 2**24 and use pre-reduction.
+//
+       fma.s1   FR_N_float = FR_Input_X, FR_Inv_pi_by_2, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+       fcmp.lt.unc.s1   p6, p7 = FR_Input_X, FR_Pi_by_4
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Select the case when |Arg| < pi/4
+//     Else Select the case when |Arg| >= pi/4
+//
+       fcvt.fx.s1 FR_N_fix = FR_N_float
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     N  = Arg * 2/pi
+//     Check if Arg < pi/4
+//
+(p6)   fcmp.gt.s1 p6, p7 = FR_Input_X, FR_Neg_Pi_by_4
+      nop.i 999 ;;
+}
+//
+//     Case 2: Convert integer N_fix back to normalized floating-point value.
+//     Case 1: p8 is only affected  when p6 is set
+//
+
+{ .mfi
+(p7)   ldfs FR_Two_to_M33 = [GR_Table_Base1], 4
+//
+//     Grab the integer part of N and call it N_fix
+//
+(p6)   fmerge.se FR_r = FR_Input_X, FR_Input_X
+//     If |x| < pi/4, r = x and c = 0
+//     lf |x| < pi/4, is x < 2**(-3).
+//     r = Arg
+//     c = 0
+(p6)   mov GR_N_Inc = GR_Sin_or_Cos ;;
+}
+
+{ .mmf
+      nop.m 999
+(p7)   ldfs FR_Neg_Two_to_M33 = [GR_Table_Base1], 4
+(p6)   fmerge.se FR_c = f0, f0
+}
+
+{ .mfi
+      nop.m 999
+(p6)   fcmp.lt.unc.s1   p8, p9 = FR_Input_X, FR_Two_to_M3
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     lf |x| < pi/4, is -2**(-3)< x < 2**(-3) - set p8.
+//     If |x| >= pi/4,
+//     Create the right N for |x| < pi/4 and otherwise
+//     Case 2: Place integer part of N in GP register
+//
+(p7)   fcvt.xf FR_N_float = FR_N_fix
+      nop.i 999 ;;
+}
+
+{ .mmf
+      nop.m 999
+(p7)   getf.sig GR_N_Inc = FR_N_fix
+(p8)   fcmp.gt.s1 p8, p0 = FR_Input_X, FR_Neg_Two_to_M3 ;;
+}
+
+{ .mib
+      nop.m 999
+      nop.i 999
+//
+//     Load 2**(-33), -2**(-33)
+//
+(p8)   br.cond.spnt SINCOS_SMALL_R ;;
+}
+
+{ .mib
+      nop.m 999
+      nop.i 999
+(p6)   br.cond.sptk SINCOS_NORMAL_R ;;
+}
+//
+//     if |x| < pi/4, branch based on |x| < 2**(-3) or otherwise.
+//
+//
+//     In this branch, |x| >= pi/4.
+//
+
+{ .mfi
+       ldfs FR_Neg_Two_to_M67 = [GR_Table_Base1], 8
+//
+//     Load -2**(-67)
+//
+       fnma.s1  FR_s = FR_N_float, FR_P_1, FR_Input_X
+//
+//     w = N * P_2
+//     s = -N * P_1  + Arg
+//
+       add GR_N_Inc = GR_N_Inc, GR_Sin_or_Cos
+}
+
+{ .mfi
+      nop.m 999
+       fma.s1   FR_w = FR_N_float, FR_P_2, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Adjust N_fix by N_inc to determine whether sine or
+//     cosine is being calculated
+//
+       fcmp.lt.unc.s1 p7, p6 = FR_s, FR_Two_to_M33
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p7)   fcmp.gt.s1 p7, p6 = FR_s, FR_Neg_Two_to_M33
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//     Remember x >= pi/4.
+//     Is s <= -2**(-33) or s >= 2**(-33) (p6)
+//     or -2**(-33) < s < 2**(-33) (p7)
+(p6)   fms.s1 FR_r = FR_s, f1, FR_w
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+(p7)   fma.s1 FR_w = FR_N_float, FR_P_3, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p7)   fma.s1 FR_U_1 = FR_N_float, FR_P_2, FR_w
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+(p6)   fms.s1 FR_c = FR_s, f1, FR_r
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     For big s: r = s - w: No further reduction is necessary
+//     For small s: w = N * P_3 (change sign) More reduction
+//
+(p6)   fcmp.lt.unc.s1 p8, p9 = FR_r, FR_Two_to_M3
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p8)   fcmp.gt.s1 p8, p9 = FR_r, FR_Neg_Two_to_M3
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p7)   fms.s1 FR_r = FR_s, f1, FR_U_1
+      nop.i 999
+}
+
+{ .mfb
+      nop.m 999
+//
+//     For big s: Is |r| < 2**(-3)?
+//     For big s: c = S - r
+//     For small s: U_1 = N * P_2 + w
+//
+//     If p8 is set, prepare to branch to Small_R.
+//     If p9 is set, prepare to branch to Normal_R.
+//     For big s,  r is complete here.
+//
+(p6)   fms.s1 FR_c = FR_c, f1, FR_w
+//
+//     For big s: c = c + w (w has not been negated.)
+//     For small s: r = S - U_1
+//
+(p8)   br.cond.spnt SINCOS_SMALL_R ;;
+}
+
+{ .mib
+      nop.m 999
+      nop.i 999
+(p9)   br.cond.sptk SINCOS_NORMAL_R ;;
+}
+
+{ .mfi
+(p7)   add GR_Table_Base1 = 224, GR_Table_Base1
+//
+//     Branch to SINCOS_SMALL_R or SINCOS_NORMAL_R
+//
+(p7)   fms.s1 FR_U_2 = FR_N_float, FR_P_2, FR_U_1
+//
+//     c = S - U_1
+//     r = S_1 * r
+//
+//
+(p7)   extr.u   GR_i_1 = GR_N_Inc, 0, 1
+}
+
+{ .mmi
+      nop.m 999 ;;
+//
+//     Get [i_0,i_1] - two lsb of N_fix_gr.
+//     Do dummy fmpy so inexact is always set.
+//
+(p7)   cmp.eq.unc p9, p10 = 0x0, GR_i_1
+(p7)   extr.u   GR_i_0 = GR_N_Inc, 1, 1 ;;
+}
+//
+//     For small s: U_2 = N * P_2 - U_1
+//     S_1 stored constant - grab the one stored with the
+//     coefficients.
+//
+
+{ .mfi
+(p7)   ldfe FR_S_1 = [GR_Table_Base1], 16
+//
+//     Check if i_1 and i_0  != 0
+//
+(p10)  fma.s1   FR_poly = f0, f1, FR_Neg_Two_to_M67
+(p7)   cmp.eq.unc p11, p12 = 0x0, GR_i_0 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p7)   fms.s1   FR_s = FR_s, f1, FR_r
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//     S = S - r
+//     U_2 = U_2 + w
+//     load S_1
+//
+(p7)   fma.s1   FR_rsq = FR_r, FR_r, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p7)   fma.s1   FR_U_2 = FR_U_2, f1, FR_w
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//(p7)   fmerge.se FR_Input_X = FR_r, FR_r
+(p7)   fmerge.se FR_prelim = FR_r, FR_r
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//(p10)  fma.s1 FR_Input_X = f0, f1, f1
+(p10)  fma.s1 FR_prelim = f0, f1, f1
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     FR_rsq = r * r
+//     Save r as the result.
+//
+(p7)   fms.s1   FR_c = FR_s, f1, FR_U_1
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     if ( i_1 ==0) poly = c + S_1*r*r*r
+//     else Result = 1
+//
+//(p12)  fnma.s1 FR_Input_X = FR_Input_X, f1, f0
+(p12)  fnma.s1 FR_prelim = FR_prelim, f1, f0
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+(p7)   fma.s1   FR_r = FR_S_1, FR_r, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p7)   fma.d.s1 FR_S_1 = FR_S_1, FR_S_1, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     If i_1 != 0, poly = 2**(-67)
+//
+(p7)   fms.s1 FR_c = FR_c, f1, FR_U_2
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     c = c - U_2
+//
+(p9)   fma.s1 FR_poly = FR_r, FR_rsq, FR_c
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     i_0 != 0, so Result = -Result
+//
+(p11)  fma.s1 FR_Input_X = FR_prelim, f1, FR_poly
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p12)  fms.s1 FR_Input_X = FR_prelim, f1, FR_poly
+//
+//     if (i_0 == 0),  Result = Result + poly
+//     else            Result = Result - poly
+//
+       br.ret.sptk   b0 ;;
+}
+SINCOS_LARGER_ARG:
+
+{ .mfi
+      nop.m 999
+       fma.s1 FR_N_0 = FR_Input_X, FR_Inv_P_0, f0
+      nop.i 999
+}
+;;
+
+//     This path for argument > 2*24
+//     Adjust table_ptr1 to beginning of table.
+//
+
+{ .mmi
+      nop.m 999
+      addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ld8 GR_Table_Base = [GR_Table_Base]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+
+//
+//     Point to  2*-14
+//     N_0 = Arg * Inv_P_0
+//
+
+{ .mmi
+       add GR_Table_Base = 688, GR_Table_Base ;;
+       ldfs FR_Two_to_M14 = [GR_Table_Base], 4
+      nop.i 999 ;;
+}
+
+{ .mfi
+       ldfs FR_Neg_Two_to_M14 = [GR_Table_Base], 0
+      nop.f 999
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Load values 2**(-14) and -2**(-14)
+//
+       fcvt.fx.s1 FR_N_0_fix = FR_N_0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     N_0_fix  = integer part of N_0
+//
+       fcvt.xf FR_N_0 = FR_N_0_fix
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Make N_0 the integer part
+//
+       fnma.s1 FR_ArgPrime = FR_N_0, FR_P_0, FR_Input_X
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+       fma.s1 FR_w = FR_N_0, FR_d_1, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Arg' = -N_0 * P_0 + Arg
+//     w  = N_0 * d_1
+//
+       fma.s1 FR_N_float = FR_ArgPrime, FR_Inv_pi_by_2, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     N = A' * 2/pi
+//
+       fcvt.fx.s1 FR_N_fix = FR_N_float
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     N_fix is the integer part
+//
+       fcvt.xf FR_N_float = FR_N_fix
+      nop.i 999 ;;
+}
+
+{ .mfi
+       getf.sig GR_N_Inc = FR_N_fix
+      nop.f 999
+      nop.i 999 ;;
+}
+
+{ .mii
+      nop.m 999
+      nop.i 999 ;;
+       add GR_N_Inc = GR_N_Inc, GR_Sin_or_Cos ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     N is the integer part of the reduced-reduced argument.
+//     Put the integer in a GP register
+//
+       fnma.s1 FR_s = FR_N_float, FR_P_1, FR_ArgPrime
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+       fnma.s1 FR_w = FR_N_float, FR_P_2, FR_w
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     s = -N*P_1 + Arg'
+//     w = -N*P_2 + w
+//     N_fix_gr = N_fix_gr + N_inc
+//
+       fcmp.lt.unc.s1 p9, p8 = FR_s, FR_Two_to_M14
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p9)   fcmp.gt.s1 p9, p8 = FR_s, FR_Neg_Two_to_M14
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     For |s|  > 2**(-14) r = S + w (r complete)
+//     Else       U_hi = N_0 * d_1
+//
+(p9)   fma.s1 FR_V_hi = FR_N_float, FR_P_2, f0
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+(p9)   fma.s1 FR_U_hi = FR_N_0, FR_d_1, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Either S <= -2**(-14) or S >= 2**(-14)
+//     or -2**(-14) < s < 2**(-14)
+//
+(p8)   fma.s1 FR_r = FR_s, f1, FR_w
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+(p9)   fma.s1 FR_w = FR_N_float, FR_P_3, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     We need abs of both U_hi and V_hi - don't
+//     worry about switched sign of V_hi.
+//
+(p9)   fms.s1 FR_A = FR_U_hi, f1, FR_V_hi
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Big s: finish up c = (S - r) + w (c complete)
+//     Case 4: A =  U_hi + V_hi
+//     Note: Worry about switched sign of V_hi, so subtract instead of add.
+//
+(p9)   fnma.s1 FR_V_lo = FR_N_float, FR_P_2, FR_V_hi
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p9)   fms.s1 FR_U_lo = FR_N_0, FR_d_1, FR_U_hi
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p9)   fmerge.s FR_V_hiabs = f0, FR_V_hi
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//     For big s: c = S - r
+//     For small s do more work: U_lo = N_0 * d_1 - U_hi
+//
+(p9)   fmerge.s FR_U_hiabs = f0, FR_U_hi
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     For big s: Is |r| < 2**(-3)
+//     For big s: if p12 set, prepare to branch to Small_R.
+//     For big s: If p13 set, prepare to branch to Normal_R.
+//
+(p8)   fms.s1 FR_c = FR_s, f1, FR_r
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//     For small S: V_hi = N * P_2
+//                  w = N * P_3
+//     Note the product does not include the (-) as in the writeup
+//     so (-) missing for V_hi and w.
+//
+(p8)   fcmp.lt.unc.s1 p12, p13 = FR_r, FR_Two_to_M3
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p12)  fcmp.gt.s1 p12, p13 = FR_r, FR_Neg_Two_to_M3
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p8)   fma.s1 FR_c = FR_c, f1, FR_w
+      nop.i 999
+}
+
+{ .mfb
+      nop.m 999
+(p9)   fms.s1 FR_w = FR_N_0, FR_d_2, FR_w
+(p12)  br.cond.spnt SINCOS_SMALL_R ;;
+}
+
+{ .mib
+      nop.m 999
+      nop.i 999
+(p13)  br.cond.sptk SINCOS_NORMAL_R ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Big s: Vector off when |r| < 2**(-3).  Recall that p8 will be true.
+//     The remaining stuff is for Case 4.
+//     Small s: V_lo = N * P_2 + U_hi (U_hi is in place of V_hi in writeup)
+//     Note: the (-) is still missing for V_lo.
+//     Small s: w = w + N_0 * d_2
+//     Note: the (-) is now incorporated in w.
+//
+(p9)   fcmp.ge.unc.s1 p10, p11 = FR_U_hiabs, FR_V_hiabs
+       extr.u   GR_i_1 = GR_N_Inc, 0, 1 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     C_hi = S + A
+//
+(p9)   fma.s1 FR_t = FR_U_lo, f1, FR_V_lo
+       extr.u   GR_i_0 = GR_N_Inc, 1, 1 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     t = U_lo + V_lo
+//
+//
+(p10)  fms.s1 FR_a = FR_U_hi, f1, FR_A
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p11)  fma.s1 FR_a = FR_V_hi, f1, FR_A
+      nop.i 999
+}
+;;
+
+{ .mmi
+      nop.m 999
+      addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ld8 GR_Table_Base = [GR_Table_Base]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+
+{ .mfi
+       add GR_Table_Base = 528, GR_Table_Base
+//
+//     Is U_hiabs >= V_hiabs?
+//
+(p9)   fma.s1 FR_C_hi = FR_s, f1, FR_A
+      nop.i 999 ;;
+}
+
+{ .mmi
+       ldfe FR_C_1 = [GR_Table_Base], 16 ;;
+       ldfe FR_C_2 = [GR_Table_Base], 64
+      nop.i 999 ;;
+}
+
+{ .mmf
+      nop.m 999
+//
+//     c = c + C_lo  finished.
+//     Load  C_2
+//
+       ldfe FR_S_1 = [GR_Table_Base], 16
+//
+//     C_lo = S - C_hi
+//
+       fma.s1 FR_t = FR_t, f1, FR_w ;;
+}
+//
+//     r and c have been computed.
+//     Make sure ftz mode is set - should be automatic when using wre
+//     |r| < 2**(-3)
+//     Get [i_0,i_1] - two lsb of N_fix.
+//     Load S_1
+//
+
+{ .mfi
+       ldfe FR_S_2 = [GR_Table_Base], 64
+//
+//     t = t + w
+//
+(p10)  fms.s1 FR_a = FR_a, f1, FR_V_hi
+       cmp.eq.unc p9, p10 = 0x0, GR_i_0
+}
+
+{ .mfi
+      nop.m 999
+//
+//     For larger u than v: a = U_hi - A
+//     Else a = V_hi - A (do an add to account for missing (-) on V_hi
+//
+       fms.s1 FR_C_lo = FR_s, f1, FR_C_hi
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p11)  fms.s1 FR_a = FR_U_hi, f1, FR_a
+       cmp.eq.unc p11, p12 = 0x0, GR_i_1
+}
+
+{ .mfi
+      nop.m 999
+//
+//     If u > v: a = (U_hi - A)  + V_hi
+//     Else      a = (V_hi - A)  + U_hi
+//     In each case account for negative missing from V_hi.
+//
+       fma.s1 FR_C_lo = FR_C_lo, f1, FR_A
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     C_lo = (S - C_hi) + A
+//
+       fma.s1 FR_t = FR_t, f1, FR_a
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     t = t + a
+//
+       fma.s1 FR_C_lo = FR_C_lo, f1, FR_t
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     C_lo = C_lo + t
+//     Adjust Table_Base to beginning of table
+//
+       fma.s1 FR_r = FR_C_hi, f1, FR_C_lo
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Load S_2
+//
+       fma.s1 FR_rsq = FR_r, FR_r, f0
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Table_Base points to C_1
+//     r = C_hi + C_lo
+//
+       fms.s1 FR_c = FR_C_hi, f1, FR_r
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     if i_1 ==0: poly = S_2 * FR_rsq + S_1
+//     else        poly = C_2 * FR_rsq + C_1
+//
+//(p11)  fma.s1 FR_Input_X = f0, f1, FR_r
+(p11)  fma.s1 FR_prelim = f0, f1, FR_r
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//(p12)  fma.s1 FR_Input_X = f0, f1, f1
+(p12)  fma.s1 FR_prelim = f0, f1, f1
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Compute r_cube = FR_rsq * r
+//
+(p11)  fma.s1 FR_poly = FR_rsq, FR_S_2, FR_S_1
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p12)  fma.s1 FR_poly = FR_rsq, FR_C_2, FR_C_1
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//     Compute FR_rsq = r * r
+//     Is i_1 == 0 ?
+//
+       fma.s1 FR_r_cubed = FR_rsq, FR_r, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     c = C_hi - r
+//     Load  C_1
+//
+       fma.s1 FR_c = FR_c, f1, FR_C_lo
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//     if i_1 ==0: poly = r_cube * poly + c
+//     else        poly = FR_rsq * poly
+//
+//(p10)  fms.s1 FR_Input_X = f0, f1, FR_Input_X
+(p10)  fms.s1 FR_prelim = f0, f1, FR_prelim
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     if i_1 ==0: Result = r
+//     else        Result = 1.0
+//
+(p11)  fma.s1 FR_poly = FR_r_cubed, FR_poly, FR_c
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p12)  fma.s1 FR_poly = FR_rsq, FR_poly, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//     if i_0 !=0: Result = -Result
+//
+(p9)   fma.s1 FR_Input_X = FR_prelim, f1, FR_poly
+      nop.i 999 ;;
+}
+
+{ .mfb
+      nop.m 999
+(p10)  fms.s1 FR_Input_X = FR_prelim, f1, FR_poly
+//
+//     if i_0 == 0: Result = Result + poly
+//     else         Result = Result - poly
+//
+       br.ret.sptk   b0 ;;
+}
+SINCOS_SMALL_R:
+
+{ .mii
+      nop.m 999
+        extr.u  GR_i_1 = GR_N_Inc, 0, 1 ;;
+//
+//
+//      Compare both i_1 and i_0 with 0.
+//      if i_1 == 0, set p9.
+//      if i_0 == 0, set p11.
+//
+        cmp.eq.unc p9, p10 = 0x0, GR_i_1 ;;
+}
+
+{ .mfi
+      nop.m 999
+        fma.s1 FR_rsq = FR_r, FR_r, f0
+        extr.u  GR_i_0 = GR_N_Inc, 1, 1 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//  Z = Z * FR_rsq
+//
+(p10)   fnma.s1 FR_c = FR_c, FR_r, f0
+        cmp.eq.unc p11, p12 = 0x0, GR_i_0
+}
+;;
+
+// ******************************************************************
+// ******************************************************************
+// ******************************************************************
+//      r and c have been computed.
+//      We know whether this is the sine or cosine routine.
+//      Make sure ftz mode is set - should be automatic when using wre
+//      |r| < 2**(-3)
+//
+//      Set table_ptr1 to beginning of constant table.
+//      Get [i_0,i_1] - two lsb of N_fix_gr.
+//
+
+{ .mmi
+      nop.m 999
+      addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ld8 GR_Table_Base = [GR_Table_Base]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+
+//
+//      Set table_ptr1 to point to S_5.
+//      Set table_ptr1 to point to C_5.
+//      Compute FR_rsq = r * r
+//
+
+{ .mfi
+(p9)    add GR_Table_Base = 672, GR_Table_Base
+(p10)   fmerge.s FR_r = f1, f1
+(p10)   add GR_Table_Base = 592, GR_Table_Base ;;
+}
+//
+//      Set table_ptr1 to point to S_5.
+//      Set table_ptr1 to point to C_5.
+//
+
+{ .mmi
+(p9)    ldfe FR_S_5 = [GR_Table_Base], -16 ;;
+//
+//      if (i_1 == 0) load S_5
+//      if (i_1 != 0) load C_5
+//
+(p9)    ldfe FR_S_4 = [GR_Table_Base], -16
+      nop.i 999 ;;
+}
+
+{ .mmf
+(p10)   ldfe FR_C_5 = [GR_Table_Base], -16
+//
+//      Z = FR_rsq * FR_rsq
+//
+(p9)    ldfe FR_S_3 = [GR_Table_Base], -16
+//
+//      Compute FR_rsq = r * r
+//      if (i_1 == 0) load S_4
+//      if (i_1 != 0) load C_4
+//
+        fma.s1 FR_Z = FR_rsq, FR_rsq, f0 ;;
+}
+//
+//      if (i_1 == 0) load S_3
+//      if (i_1 != 0) load C_3
+//
+
+{ .mmi
+(p9)    ldfe FR_S_2 = [GR_Table_Base], -16 ;;
+//
+//      if (i_1 == 0) load S_2
+//      if (i_1 != 0) load C_2
+//
+(p9)    ldfe FR_S_1 = [GR_Table_Base], -16
+      nop.i 999
+}
+
+{ .mmi
+(p10)   ldfe FR_C_4 = [GR_Table_Base], -16 ;;
+(p10)   ldfe FR_C_3 = [GR_Table_Base], -16
+      nop.i 999 ;;
+}
+
+{ .mmi
+(p10)   ldfe FR_C_2 = [GR_Table_Base], -16 ;;
+(p10)   ldfe FR_C_1 = [GR_Table_Base], -16
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1 != 0):
+//      poly_lo = FR_rsq * C_5 + C_4
+//      poly_hi = FR_rsq * C_2 + C_1
+//
+(p9)    fma.s1 FR_Z = FR_Z, FR_r, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1 == 0) load S_1
+//      if (i_1 != 0) load C_1
+//
+(p9)    fma.s1 FR_poly_lo = FR_rsq, FR_S_5, FR_S_4
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//      c = -c * r
+//      dummy fmpy's to flag inexact.
+//
+(p9)    fma.d.s1 FR_S_4 = FR_S_4, FR_S_4, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      poly_lo = FR_rsq * poly_lo + C_3
+//      poly_hi = FR_rsq * poly_hi
+//
+        fma.s1  FR_Z = FR_Z, FR_rsq, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p9)    fma.s1 FR_poly_hi = FR_rsq, FR_S_2, FR_S_1
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1 == 0):
+//      poly_lo = FR_rsq * S_5 + S_4
+//      poly_hi = FR_rsq * S_2 + S_1
+//
+(p10)   fma.s1 FR_poly_lo = FR_rsq, FR_C_5, FR_C_4
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1 == 0):
+//      Z = Z * r  for only one of the small r cases - not there
+//      in original implementation notes.
+//
+(p9)    fma.s1 FR_poly_lo = FR_rsq, FR_poly_lo, FR_S_3
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_poly_hi = FR_rsq, FR_C_2, FR_C_1
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.d.s1 FR_C_1 = FR_C_1, FR_C_1, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p9)    fma.s1 FR_poly_hi = FR_poly_hi, FR_rsq, f0
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//      poly_lo = FR_rsq * poly_lo + S_3
+//      poly_hi = FR_rsq * poly_hi
+//
+(p10)   fma.s1 FR_poly_lo = FR_rsq, FR_poly_lo, FR_C_3
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_poly_hi = FR_poly_hi, FR_rsq, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//  if (i_1 == 0): dummy fmpy's to flag inexact
+//  r = 1
+//
+(p9)    fma.s1 FR_poly_hi = FR_r, FR_poly_hi, f0
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//  poly_hi = r * poly_hi
+//
+        fma.s1  FR_poly = FR_Z, FR_poly_lo, FR_c
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p12)   fms.s1  FR_r = f0, f1, FR_r
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      poly_hi = Z * poly_lo + c
+//  if i_0 == 1: r = -r
+//
+        fma.s1  FR_poly = FR_poly, f1, FR_poly_hi
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p12)   fms.s1 FR_Input_X = FR_r, f1, FR_poly
+      nop.i 999
+}
+
+{ .mfb
+      nop.m 999
+//
+//      poly = poly + poly_hi
+//
+(p11)   fma.s1 FR_Input_X = FR_r, f1, FR_poly
+//
+//      if (i_0 == 0) Result = r + poly
+//      if (i_0 != 0) Result = r - poly
+//
+       br.ret.sptk   b0 ;;
+}
+SINCOS_NORMAL_R:
+
+{ .mii
+      nop.m 999
+        extr.u  GR_i_1 = GR_N_Inc, 0, 1 ;;
+//
+//      Set table_ptr1 and table_ptr2 to base address of
+//      constant table.
+        cmp.eq.unc p9, p10 = 0x0, GR_i_1 ;;
+}
+
+{ .mfi
+      nop.m 999
+        fma.s1  FR_rsq = FR_r, FR_r, f0
+        extr.u  GR_i_0 = GR_N_Inc, 1, 1 ;;
+}
+
+{ .mfi
+      nop.m 999
+        frcpa.s1 FR_r_hi, p6 = f1, FR_r
+        cmp.eq.unc p11, p12 = 0x0, GR_i_0
+}
+;;
+
+// ******************************************************************
+// ******************************************************************
+// ******************************************************************
+//
+//      r and c have been computed.
+//      We known whether this is the sine or cosine routine.
+//      Make sure ftz mode is set - should be automatic when using wre
+//      Get [i_0,i_1] - two lsb of N_fix_gr alone.
+//
+
+{ .mmi
+      nop.m 999
+      addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ld8 GR_Table_Base = [GR_Table_Base]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+
+{ .mfi
+(p10)   add GR_Table_Base = 384, GR_Table_Base
+//(p12)   fms.s1 FR_Input_X = f0, f1, f1
+(p12)   fms.s1 FR_prelim = f0, f1, f1
+(p9)    add GR_Table_Base = 224, GR_Table_Base ;;
+}
+
+{ .mmf
+      nop.m 999
+(p10)   ldfe FR_QQ_8 = [GR_Table_Base], 16
+//
+//      if (i_1==0) poly = poly * FR_rsq + PP_1_lo
+//      else        poly = FR_rsq * poly
+//
+//(p11)   fma.s1 FR_Input_X = f0, f1, f1 ;;
+(p11)   fma.s1 FR_prelim = f0, f1, f1 ;;
+}
+
+{ .mmf
+(p10)   ldfe FR_QQ_7 = [GR_Table_Base], 16
+//
+//  Adjust table pointers based on i_0
+//      Compute rsq = r * r
+//
+(p9)    ldfe FR_PP_8 = [GR_Table_Base], 16
+        fma.s1 FR_r_cubed = FR_r, FR_rsq, f0 ;;
+}
+
+{ .mmf
+(p9)    ldfe FR_PP_7 = [GR_Table_Base], 16
+(p10)   ldfe FR_QQ_6 = [GR_Table_Base], 16
+//
+//      Load PP_8 and QQ_8; PP_7 and QQ_7
+//
+        frcpa.s1 FR_r_hi, p6 = f1, FR_r_hi ;;
+}
+//
+//      if (i_1==0) poly =   PP_7 + FR_rsq * PP_8.
+//      else        poly =   QQ_7 + FR_rsq * QQ_8.
+//
+
+{ .mmb
+(p9)    ldfe FR_PP_6 = [GR_Table_Base], 16
+(p10)   ldfe FR_QQ_5 = [GR_Table_Base], 16
+      nop.b 999 ;;
+}
+
+{ .mmb
+(p9)    ldfe FR_PP_5 = [GR_Table_Base], 16
+(p10)   ldfe FR_S_1 = [GR_Table_Base], 16
+      nop.b 999 ;;
+}
+
+{ .mmb
+(p10)   ldfe FR_QQ_1 = [GR_Table_Base], 16
+(p9)    ldfe FR_C_1 = [GR_Table_Base], 16
+      nop.b 999 ;;
+}
+
+{ .mmi
+(p10)   ldfe FR_QQ_4 = [GR_Table_Base], 16 ;;
+(p9)    ldfe FR_PP_1 = [GR_Table_Base], 16
+      nop.i 999 ;;
+}
+
+{ .mmf
+(p10)   ldfe FR_QQ_3 = [GR_Table_Base], 16
+//
+//      if (i_1=0) corr = corr + c*c
+//      else       corr = corr * c
+//
+(p9)    ldfe FR_PP_4 = [GR_Table_Base], 16
+(p10)   fma.s1 FR_poly = FR_rsq, FR_QQ_8, FR_QQ_7 ;;
+}
+//
+//      if (i_1=0) poly = rsq * poly + PP_5
+//      else       poly = rsq * poly + QQ_5
+//      Load PP_4 or QQ_4
+//
+
+{ .mmf
+(p9)    ldfe FR_PP_3 = [GR_Table_Base], 16
+(p10)   ldfe FR_QQ_2 = [GR_Table_Base], 16
+//
+//      r_hi =   frcpa(frcpa(r)).
+//      r_cube = r * FR_rsq.
+//
+(p9)    fma.s1 FR_poly = FR_rsq, FR_PP_8, FR_PP_7 ;;
+}
+//
+//      Do dummy multiplies so inexact is always set.
+//
+
+{ .mfi
+(p9)    ldfe FR_PP_2 = [GR_Table_Base], 16
+//
+//      r_lo = r - r_hi
+//
+(p9)    fma.s1 FR_U_lo = FR_r_hi, FR_r_hi, f0
+      nop.i 999 ;;
+}
+
+{ .mmf
+      nop.m 999
+(p9)    ldfe FR_PP_1_lo = [GR_Table_Base], 16
+(p10)   fma.s1 FR_corr = FR_S_1, FR_r_cubed, FR_r
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_6
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1=0) U_lo = r_hi * r_hi
+//      else       U_lo = r_hi + r
+//
+(p9)    fma.s1 FR_corr = FR_C_1, FR_rsq, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1=0) corr = C_1 * rsq
+//      else       corr = S_1 * r_cubed + r
+//
+(p9)    fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_6
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_U_lo = FR_r_hi, f1, FR_r
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1=0) U_hi = r_hi + U_hi
+//      else       U_hi = QQ_1 * U_hi + 1
+//
+(p9)    fma.s1 FR_U_lo = FR_r, FR_r_hi, FR_U_lo
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//      U_hi = r_hi * r_hi
+//
+        fms.s1 FR_r_lo = FR_r, f1, FR_r_hi
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      Load PP_1, PP_6, PP_5, and C_1
+//      Load QQ_1, QQ_6, QQ_5, and S_1
+//
+        fma.s1 FR_U_hi = FR_r_hi, FR_r_hi, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_5
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fnma.s1 FR_corr = FR_corr, FR_c, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1=0) U_lo = r * r_hi + U_lo
+//      else       U_lo = r_lo * U_lo
+//
+(p9)    fma.s1 FR_corr = FR_corr, FR_c, FR_c
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p9)    fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_5
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1 =0) U_hi = r + U_hi
+//      if (i_1 =0) U_lo = r_lo * U_lo
+//
+//
+(p9)    fma.d.s1 FR_PP_5 = FR_PP_5, FR_PP_4, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p9)    fma.s1 FR_U_lo = FR_r, FR_r, FR_U_lo
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_U_lo = FR_r_lo, FR_U_lo, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1=0) poly = poly * rsq + PP_6
+//      else       poly = poly * rsq + QQ_6
+//
+(p9)    fma.s1 FR_U_hi = FR_r_hi, FR_U_hi, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_4
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_U_hi = FR_QQ_1, FR_U_hi, f1
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.d.s1 FR_QQ_5 = FR_QQ_5, FR_QQ_5, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1!=0) U_hi = PP_1 * U_hi
+//      if (i_1!=0) U_lo = r * r  + U_lo
+//      Load PP_3 or QQ_3
+//
+(p9)    fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_4
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p9)    fma.s1 FR_U_lo = FR_r_lo, FR_U_lo, f0
+      nop.i 999
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_U_lo = FR_QQ_1,FR_U_lo, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p9)    fma.s1 FR_U_hi = FR_PP_1, FR_U_hi, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_3
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      Load PP_2, QQ_2
+//
+(p9)    fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_3
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1==0) poly = FR_rsq * poly  + PP_3
+//      else        poly = FR_rsq * poly  + QQ_3
+//      Load PP_1_lo
+//
+(p9)    fma.s1 FR_U_lo = FR_PP_1, FR_U_lo, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1 =0) poly = poly * rsq + pp_r4
+//      else        poly = poly * rsq + qq_r4
+//
+(p9)    fma.s1 FR_U_hi = FR_r, f1, FR_U_hi
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_2
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1==0) U_lo =  PP_1_hi * U_lo
+//      else        U_lo =  QQ_1 * U_lo
+//
+(p9)    fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_2
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_0==0)  Result = 1
+//      else         Result = -1
+//
+        fma.s1 FR_V = FR_U_lo, f1, FR_corr
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_poly = FR_rsq, FR_poly, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1==0) poly =  FR_rsq * poly + PP_2
+//      else poly =  FR_rsq * poly + QQ_2
+//
+(p9)    fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_1_lo
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p10)   fma.s1 FR_poly = FR_rsq, FR_poly, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      V = U_lo + corr
+//
+(p9)    fma.s1 FR_poly = FR_r_cubed, FR_poly, f0
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//
+//      if (i_1==0) poly = r_cube * poly
+//      else        poly = FR_rsq * poly
+//
+        fma.s1  FR_V = FR_poly, f1, FR_V
+      nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+//(p12)   fms.s1 FR_Input_X = FR_Input_X, FR_U_hi, FR_V
+(p12)   fms.s1 FR_Input_X = FR_prelim, FR_U_hi, FR_V
+      nop.i 999
+}
+
+{ .mfb
+      nop.m 999
+//
+//      V = V + poly
+//
+//(p11)   fma.s1 FR_Input_X = FR_Input_X, FR_U_hi, FR_V
+(p11)   fma.s1 FR_Input_X = FR_prelim, FR_U_hi, FR_V
+//
+//      if (i_0==0) Result = Result * U_hi + V
+//      else        Result = Result * U_hi - V
+//
+       br.ret.sptk   b0 ;;
+}
+
+//
+//      If cosine, FR_Input_X = 1
+//      If sine, FR_Input_X = +/-Zero (Input FR_Input_X)
+//      Results are exact, no exceptions
+//
+SINCOS_ZERO:
+
+{ .mmb
+        cmp.eq.unc p6, p7 = 0x1, GR_Sin_or_Cos
+      nop.m 999
+      nop.b 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p7)    fmerge.s FR_Input_X = FR_Input_X, FR_Input_X
+      nop.i 999
+}
+
+{ .mfb
+      nop.m 999
+(p6)    fmerge.s FR_Input_X = f1, f1
+       br.ret.sptk   b0 ;;
+}
+
+SINCOS_SPECIAL:
+
+//
+//      Path for Arg = +/- QNaN, SNaN, Inf
+//      Invalid can be raised. SNaNs
+//      become QNaNs
+//
+
+{ .mfb
+      nop.m 999
+        fmpy.s1 FR_Input_X = FR_Input_X, f0
+        br.ret.sptk   b0 ;;
+}
+GLOBAL_LIBM_END(__libm_cos_large)
+
+
+// *******************************************************************
+// *******************************************************************
+// *******************************************************************
+//
+//     Special Code to handle very large argument case.
+//     Call int __libm_pi_by_2_reduce(x,r,c) for |arguments| >= 2**63
+//     The interface is custom:
+//       On input:
+//         (Arg or x) is in f8
+//       On output:
+//         r is in f8
+//         c is in f9
+//         N is in r8
+//     Be sure to allocate at least 2 GP registers as output registers for
+//     __libm_pi_by_2_reduce.  This routine uses r49-50. These are used as
+//     scratch registers within the __libm_pi_by_2_reduce routine (for speed).
+//
+//     We know also that __libm_pi_by_2_reduce preserves f10-15, f71-127.  We
+//     use this to eliminate save/restore of key fp registers in this calling
+//     function.
+//
+// *******************************************************************
+// *******************************************************************
+// *******************************************************************
+
+LOCAL_LIBM_ENTRY(__libm_callout_2)
+SINCOS_ARG_TOO_LARGE:
+
+.prologue
+//      Readjust Table ptr
+{ .mfi
+        adds  GR_Table_Base1 = -16, GR_Table_Base1
+        nop.f 999
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+};;
+
+{ .mmi
+        ldfs FR_Two_to_M3 = [GR_Table_Base1],4
+        mov GR_SAVE_GP=gp                       // Save gp
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+
+.body
+//
+//     Call argument reduction with x in f8
+//     Returns with N in r8, r in f8, c in f9
+//     Assumes f71-127 are preserved across the call
+//
+{ .mib
+        ldfs FR_Neg_Two_to_M3 = [GR_Table_Base1],0
+        nop.i 0
+        br.call.sptk b0=__libm_pi_by_2_reduce#
+};;
+
+{ .mfi
+        add   GR_N_Inc = GR_Sin_or_Cos,r8
+        fcmp.lt.unc.s1  p6, p0 = FR_r, FR_Two_to_M3
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+
+{ .mfi
+        mov   gp = GR_SAVE_GP                  // Restore gp
+(p6)    fcmp.gt.unc.s1  p6, p0 = FR_r, FR_Neg_Two_to_M3
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+};;
+
+{ .mbb
+        nop.m 999
+(p6)    br.cond.spnt SINCOS_SMALL_R            // Branch if |r| < 1/4
+        br.cond.sptk SINCOS_NORMAL_R ;;        // Branch if 1/4 <= |r| < pi/4
+}
+
+LOCAL_LIBM_END(__libm_callout_2)
+
+.type   __libm_pi_by_2_reduce#,@function
+.global __libm_pi_by_2_reduce#
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_sincosf.S
@@ -0,0 +1,744 @@
+.file "libm_sincosf.s"
+
+
+// Copyright (c) 2002 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/01/02 Initial version
+// 02/18/02 Large arguments processing routine is excluded.
+//          External interface entry points are added
+// 02/26/02 Added temporary return of results in r8, r9
+// 03/13/02 Corrected restore of predicate registers
+// 03/19/02 Added stack unwind around call to __libm_cisf_large
+// 09/05/02 Work range is widened by reduction strengthen (2 parts of Pi/16)
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 02/11/04 cisf is moved to the separate file.
+// 03/31/05 Reformatted delimiters between data tables
+
+// API
+//==============================================================
+// 1) void sincosf(float, float*s, float*c)
+// 2) __libm_sincosf - internal LIBM function, that accepts
+//    argument in f8 and returns cosine through f8, sine through f9
+
+//
+// Overview of operation
+//==============================================================
+//
+// Step 1
+// ======
+// Reduce x to region -1/2*pi/2^k ===== 0 ===== +1/2*pi/2^k  where k=4
+//    divide x by pi/2^k.
+//    Multiply by 2^k/pi.
+//    nfloat = Round result to integer (round-to-nearest)
+//
+// r = x -  nfloat * pi/2^k
+//    Do this as (x -  nfloat * HIGH(pi/2^k)) - nfloat * LOW(pi/2^k) for increased accuracy.
+//    pi/2^k is stored as two numbers that when added make pi/2^k.
+//       pi/2^k = HIGH(pi/2^k) + LOW(pi/2^k)
+//    HIGH part is rounded to zero, LOW - to nearest
+//
+// x = (nfloat * pi/2^k) + r
+//    r is small enough that we can use a polynomial approximation
+//    and is referred to as the reduced argument.
+//
+// Step 3
+// ======
+// Take the unreduced part and remove the multiples of 2pi.
+// So nfloat = nfloat (with lower k+1 bits cleared) + lower k+1 bits
+//
+//    nfloat (with lower k+1 bits cleared) is a multiple of 2^(k+1)
+//    N * 2^(k+1)
+//    nfloat * pi/2^k = N * 2^(k+1) * pi/2^k + (lower k+1 bits) * pi/2^k
+//    nfloat * pi/2^k = N * 2 * pi + (lower k+1 bits) * pi/2^k
+//    nfloat * pi/2^k = N2pi + M * pi/2^k
+//
+//
+// Sin(x) = Sin((nfloat * pi/2^k) + r)
+//        = Sin(nfloat * pi/2^k) * Cos(r) + Cos(nfloat * pi/2^k) * Sin(r)
+//
+//          Sin(nfloat * pi/2^k) = Sin(N2pi + Mpi/2^k)
+//                               = Sin(N2pi)Cos(Mpi/2^k) + Cos(N2pi)Sin(Mpi/2^k)
+//                               = Sin(Mpi/2^k)
+//
+//          Cos(nfloat * pi/2^k) = Cos(N2pi + Mpi/2^k)
+//                               = Cos(N2pi)Cos(Mpi/2^k) + Sin(N2pi)Sin(Mpi/2^k)
+//                               = Cos(Mpi/2^k)
+//
+// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
+//
+//
+// Step 4
+// ======
+// 0 <= M < 2^(k+1)
+// There are 2^(k+1) Sin entries in a table.
+// There are 2^(k+1) Cos entries in a table.
+//
+// Get Sin(Mpi/2^k) and Cos(Mpi/2^k) by table lookup.
+//
+//
+// Step 5
+// ======
+// Calculate Cos(r) and Sin(r) by polynomial approximation.
+//
+// Cos(r) = 1 + r^2 q1  + r^4 q2 = Series for Cos
+// Sin(r) = r + r^3 p1  + r^5 p2 = Series for Sin
+//
+// and the coefficients q1, q2 and p1, p2 are stored in a table
+//
+//
+// Calculate
+// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
+//
+// as follows
+//
+//    S[m] = Sin(Mpi/2^k) and C[m] = Cos(Mpi/2^k)
+//    rsq = r*r
+//
+//
+//    P = p1 + r^2p2
+//    Q = q1 + r^2q2
+//
+//       rcub = r * rsq
+//       Sin(r) = r + rcub * P
+//              = r + r^3p1  + r^5p2 = Sin(r)
+//
+//       P =  r + rcub * P
+//
+//    Answer = S[m] Cos(r) + C[m] P
+//
+//       Cos(r) = 1 + rsq Q
+//       Cos(r) = 1 + r^2 Q
+//       Cos(r) = 1 + r^2 (q1 + r^2q2)
+//       Cos(r) = 1 + r^2q1 + r^4q2
+//
+//       S[m] Cos(r) = S[m](1 + rsq Q)
+//       S[m] Cos(r) = S[m] + S[m] rsq Q
+//       S[m] Cos(r) = S[m] + s_rsq Q
+//       Q           = S[m] + s_rsq Q
+//
+// Then,
+//
+//    Answer = Q + C[m] P
+
+
+// Registers used
+//==============================================================
+// general input registers:
+// r14 -> r19
+// r32 -> r49
+
+// predicate registers used:
+// p6 -> p14
+
+// floating-point registers used
+// f9 -> f15
+// f32 -> f100
+
+// Assembly macros
+//==============================================================
+
+cisf_Arg                     = f8
+
+cisf_Sin_res                 = f9
+cisf_Cos_res                 = f8
+
+
+cisf_NORM_f8                 = f10
+cisf_W                       = f11
+cisf_int_Nfloat              = f12
+cisf_Nfloat                  = f13
+
+cisf_r                       = f14
+cisf_r_exact                 = f68
+cisf_rsq                     = f15
+cisf_rcub                    = f32
+
+cisf_Inv_Pi_by_16            = f33
+cisf_Pi_by_16_hi             = f34
+cisf_Pi_by_16_lo             = f35
+
+cisf_Inv_Pi_by_64            = f36
+cisf_Pi_by_64_hi             = f37
+cisf_Pi_by_64_lo             = f38
+
+
+cisf_P1                      = f39
+cisf_Q1                      = f40
+cisf_P2                      = f41
+cisf_Q2                      = f42
+cisf_P3                      = f43
+cisf_Q3                      = f44
+cisf_P4                      = f45
+cisf_Q4                      = f46
+
+cisf_P_temp1                 = f47
+cisf_P_temp2                 = f48
+
+cisf_Q_temp1                 = f49
+cisf_Q_temp2                 = f50
+
+cisf_P                       = f51
+
+cisf_SIG_INV_PI_BY_16_2TO61  = f52
+cisf_RSHF_2TO61              = f53
+cisf_RSHF                    = f54
+cisf_2TOM61                  = f55
+cisf_NFLOAT                  = f56
+cisf_W_2TO61_RSH             = f57
+
+cisf_tmp                     = f58
+
+cisf_Sm_sin                  = f59
+cisf_Cm_sin                  = f60
+
+cisf_Sm_cos                  = f61
+cisf_Cm_cos                  = f62
+
+cisf_srsq_sin                = f63
+cisf_srsq_cos                = f64
+
+cisf_Q_sin                   = f65
+cisf_Q_cos                   = f66
+cisf_Q                       = f67
+
+/////////////////////////////////////////////////////////////
+
+cisf_pResSin                 = r33
+cisf_pResCos                 = r34
+
+cisf_exp_limit               = r35
+cisf_r_signexp               = r36
+cisf_AD_beta_table           = r37
+cisf_r_sincos                = r38
+
+cisf_r_exp                   = r39
+cisf_r_17_ones               = r40
+
+cisf_GR_sig_inv_pi_by_16     = r14
+cisf_GR_rshf_2to61           = r15
+cisf_GR_rshf                 = r16
+cisf_GR_exp_2tom61           = r17
+cisf_GR_n                    = r18
+
+cisf_GR_n_sin                = r19
+cisf_GR_m_sin                = r41
+cisf_GR_32m_sin              = r41
+
+cisf_GR_n_cos                = r42
+cisf_GR_m_cos                = r43
+cisf_GR_32m_cos              = r43
+
+cisf_AD_2_sin                = r44
+cisf_AD_2_cos                = r45
+
+cisf_gr_tmp                  = r46
+GR_SAVE_B0                   = r47
+GR_SAVE_GP                   = r48
+rB0_SAVED                    = r49
+GR_SAVE_PFS                  = r50
+GR_SAVE_PR                   = r51
+cisf_AD_1                    = r52
+
+RODATA
+
+.align 16
+// Pi/16 parts
+LOCAL_OBJECT_START(double_cisf_pi)
+   data8 0xC90FDAA22168C234, 0x00003FFC // pi/16 1st part
+   data8 0xC4C6628B80DC1CD1, 0x00003FBC // pi/16 2nd part
+LOCAL_OBJECT_END(double_cisf_pi)
+
+// Coefficients for polynomials
+LOCAL_OBJECT_START(double_cisf_pq_k4)
+   data8 0x3F810FABB668E9A2 // P2
+   data8 0x3FA552E3D6DE75C9 // Q2
+   data8 0xBFC555554447BC7F // P1
+   data8 0xBFDFFFFFC447610A // Q1
+LOCAL_OBJECT_END(double_cisf_pq_k4)
+
+// Sincos table (S[m], C[m])
+LOCAL_OBJECT_START(double_sin_cos_beta_k4)
+    data8 0x0000000000000000 // sin ( 0 Pi / 16 )
+    data8 0x3FF0000000000000 // cos ( 0 Pi / 16 )
+//
+    data8 0x3FC8F8B83C69A60B // sin ( 1 Pi / 16 )
+    data8 0x3FEF6297CFF75CB0 // cos ( 1 Pi / 16 )
+//
+    data8 0x3FD87DE2A6AEA963 // sin ( 2 Pi / 16 )
+    data8 0x3FED906BCF328D46 // cos ( 2 Pi / 16 )
+//
+    data8 0x3FE1C73B39AE68C8 // sin ( 3 Pi / 16 )
+    data8 0x3FEA9B66290EA1A3 // cos ( 3 Pi / 16 )
+//
+    data8 0x3FE6A09E667F3BCD // sin ( 4 Pi / 16 )
+    data8 0x3FE6A09E667F3BCD // cos ( 4 Pi / 16 )
+//
+    data8 0x3FEA9B66290EA1A3 // sin ( 5 Pi / 16 )
+    data8 0x3FE1C73B39AE68C8 // cos ( 5 Pi / 16 )
+//
+    data8 0x3FED906BCF328D46 // sin ( 6 Pi / 16 )
+    data8 0x3FD87DE2A6AEA963 // cos ( 6 Pi / 16 )
+//
+    data8 0x3FEF6297CFF75CB0 // sin ( 7 Pi / 16 )
+    data8 0x3FC8F8B83C69A60B // cos ( 7 Pi / 16 )
+//
+    data8 0x3FF0000000000000 // sin ( 8 Pi / 16 )
+    data8 0x0000000000000000 // cos ( 8 Pi / 16 )
+//
+    data8 0x3FEF6297CFF75CB0 // sin ( 9 Pi / 16 )
+    data8 0xBFC8F8B83C69A60B // cos ( 9 Pi / 16 )
+//
+    data8 0x3FED906BCF328D46 // sin ( 10 Pi / 16 )
+    data8 0xBFD87DE2A6AEA963 // cos ( 10 Pi / 16 )
+//
+    data8 0x3FEA9B66290EA1A3 // sin ( 11 Pi / 16 )
+    data8 0xBFE1C73B39AE68C8 // cos ( 11 Pi / 16 )
+//
+    data8 0x3FE6A09E667F3BCD // sin ( 12 Pi / 16 )
+    data8 0xBFE6A09E667F3BCD // cos ( 12 Pi / 16 )
+//
+    data8 0x3FE1C73B39AE68C8 // sin ( 13 Pi / 16 )
+    data8 0xBFEA9B66290EA1A3 // cos ( 13 Pi / 16 )
+//
+    data8 0x3FD87DE2A6AEA963 // sin ( 14 Pi / 16 )
+    data8 0xBFED906BCF328D46 // cos ( 14 Pi / 16 )
+//
+    data8 0x3FC8F8B83C69A60B // sin ( 15 Pi / 16 )
+    data8 0xBFEF6297CFF75CB0 // cos ( 15 Pi / 16 )
+//
+    data8 0x0000000000000000 // sin ( 16 Pi / 16 )
+    data8 0xBFF0000000000000 // cos ( 16 Pi / 16 )
+//
+    data8 0xBFC8F8B83C69A60B // sin ( 17 Pi / 16 )
+    data8 0xBFEF6297CFF75CB0 // cos ( 17 Pi / 16 )
+//
+    data8 0xBFD87DE2A6AEA963 // sin ( 18 Pi / 16 )
+    data8 0xBFED906BCF328D46 // cos ( 18 Pi / 16 )
+//
+    data8 0xBFE1C73B39AE68C8 // sin ( 19 Pi / 16 )
+    data8 0xBFEA9B66290EA1A3 // cos ( 19 Pi / 16 )
+//
+    data8 0xBFE6A09E667F3BCD // sin ( 20 Pi / 16 )
+    data8 0xBFE6A09E667F3BCD // cos ( 20 Pi / 16 )
+//
+    data8 0xBFEA9B66290EA1A3 // sin ( 21 Pi / 16 )
+    data8 0xBFE1C73B39AE68C8 // cos ( 21 Pi / 16 )
+//
+    data8 0xBFED906BCF328D46 // sin ( 22 Pi / 16 )
+    data8 0xBFD87DE2A6AEA963 // cos ( 22 Pi / 16 )
+//
+    data8 0xBFEF6297CFF75CB0 // sin ( 23 Pi / 16 )
+    data8 0xBFC8F8B83C69A60B // cos ( 23 Pi / 16 )
+//
+    data8 0xBFF0000000000000 // sin ( 24 Pi / 16 )
+    data8 0x0000000000000000 // cos ( 24 Pi / 16 )
+//
+    data8 0xBFEF6297CFF75CB0 // sin ( 25 Pi / 16 )
+    data8 0x3FC8F8B83C69A60B // cos ( 25 Pi / 16 )
+//
+    data8 0xBFED906BCF328D46 // sin ( 26 Pi / 16 )
+    data8 0x3FD87DE2A6AEA963 // cos ( 26 Pi / 16 )
+//
+    data8 0xBFEA9B66290EA1A3 // sin ( 27 Pi / 16 )
+    data8 0x3FE1C73B39AE68C8 // cos ( 27 Pi / 16 )
+//
+    data8 0xBFE6A09E667F3BCD // sin ( 28 Pi / 16 )
+    data8 0x3FE6A09E667F3BCD // cos ( 28 Pi / 16 )
+//
+    data8 0xBFE1C73B39AE68C8 // sin ( 29 Pi / 16 )
+    data8 0x3FEA9B66290EA1A3 // cos ( 29 Pi / 16 )
+//
+    data8 0xBFD87DE2A6AEA963 // sin ( 30 Pi / 16 )
+    data8 0x3FED906BCF328D46 // cos ( 30 Pi / 16 )
+//
+    data8 0xBFC8F8B83C69A60B // sin ( 31 Pi / 16 )
+    data8 0x3FEF6297CFF75CB0 // cos ( 31 Pi / 16 )
+//
+    data8 0x0000000000000000 // sin ( 32 Pi / 16 )
+    data8 0x3FF0000000000000 // cos ( 32 Pi / 16 )
+LOCAL_OBJECT_END(double_sin_cos_beta_k4)
+
+.section .text
+
+GLOBAL_IEEE754_ENTRY(sincosf)
+// cis_GR_sig_inv_pi_by_16 = significand of 16/pi
+{ .mlx
+      alloc         GR_SAVE_PFS              = ar.pfs, 0, 21, 0, 0
+      movl          cisf_GR_sig_inv_pi_by_16 = 0xA2F9836E4E44152A // 16/pi signd
+
+}
+// cis_GR_rshf_2to61 = 1.1000 2^(63+63-2)
+{ .mlx
+      addl          cisf_AD_1           = @ltoff(double_cisf_pi), gp
+      movl          cisf_GR_rshf_2to61  = 0x47b8000000000000 // 1.1 2^(63+63-2)
+};;
+
+{ .mfi
+      ld8           cisf_AD_1           = [cisf_AD_1]
+      fnorm.s1      cisf_NORM_f8        = cisf_Arg
+      cmp.eq        p13, p14            = r0, r0 // p13 set for sincos
+}
+// cis_GR_exp_2tom61 = exponent of scaling factor 2^-61
+{ .mib
+      mov           cisf_GR_exp_2tom61  = 0xffff-61
+      nop.i         0
+      br.cond.sptk  _CISF_COMMON
+};;
+GLOBAL_IEEE754_END(sincosf)
+libm_alias_float_other (__sincos, sincos)
+
+GLOBAL_LIBM_ENTRY(__libm_sincosf)
+{ .mlx
+// cisf_GR_sig_inv_pi_by_16 = significand of 16/pi
+      alloc         GR_SAVE_PFS              = ar.pfs,0,21,0,0
+      movl          cisf_GR_sig_inv_pi_by_16 = 0xA2F9836E4E44152A
+}
+// cisf_GR_rshf_2to61 = 1.1000 2^(63+63-2)
+{ .mlx
+      addl          cisf_AD_1           = @ltoff(double_cisf_pi), gp
+      movl          cisf_GR_rshf_2to61  = 0x47b8000000000000
+};;
+
+// p14 set for __libm_sincos and cis
+{ .mfi
+      ld8           cisf_AD_1           = [cisf_AD_1]
+      fnorm.s1      cisf_NORM_f8        = cisf_Arg
+      cmp.eq        p14, p13            = r0, r0
+}
+// cisf_GR_exp_2tom61 = exponent of scaling factor 2^-61
+{ .mib
+      mov           cisf_GR_exp_2tom61  = 0xffff-61
+      nop.i         0
+      nop.b         0
+};;
+
+_CISF_COMMON:
+//  Form two constants we need
+//  16/pi * 2^-2 * 2^63, scaled by 2^61 since we just loaded the significand
+//  1.1000...000 * 2^(63+63-2) to right shift int(W) into the low significand
+//  fcmp used to set denormal, and invalid on snans
+{ .mfi
+      setf.sig      cisf_SIG_INV_PI_BY_16_2TO61 = cisf_GR_sig_inv_pi_by_16
+      fclass.m      p6,p0                       = cisf_Arg, 0xe7//if x=0,inf,nan
+      addl          cisf_gr_tmp                 = -1, r0
+}
+// cisf_GR_rshf = 1.1000 2^63 for right shift
+{ .mlx
+      setf.d        cisf_RSHF_2TO61     = cisf_GR_rshf_2to61
+      movl          cisf_GR_rshf        = 0x43e8000000000000
+};;
+
+//  Form another constant
+//  2^-61 for scaling Nfloat
+//  0x10017 is register_bias + 24.
+//  So if f8 >= 2^24, go to large args routine
+{ .mmi
+      getf.exp      cisf_r_signexp      = cisf_Arg
+      setf.exp      cisf_2TOM61         = cisf_GR_exp_2tom61
+      mov           cisf_exp_limit      = 0x10017
+};;
+
+// Load the two pieces of pi/16
+// Form another constant
+//  1.1000...000 * 2^63, the right shift constant
+{ .mmb
+      ldfe          cisf_Pi_by_16_hi    = [cisf_AD_1],16
+      setf.d        cisf_RSHF           = cisf_GR_rshf
+(p6)  br.cond.spnt  _CISF_SPECIAL_ARGS
+};;
+
+{ .mmi
+      ldfe          cisf_Pi_by_16_lo    = [cisf_AD_1],16
+      setf.sig      cisf_tmp            = cisf_gr_tmp //constant for inexact set
+      nop.i         0
+};;
+
+// Start loading P, Q coefficients
+{ .mmi
+      ldfpd         cisf_P2,cisf_Q2     = [cisf_AD_1],16
+      nop.m         0
+      dep.z         cisf_r_exp          = cisf_r_signexp, 0, 17
+};;
+
+// p10 is true if we must call routines to handle larger arguments
+// p10 is true if f8 exp is >= 0x10017
+{ .mmb
+      ldfpd         cisf_P1,cisf_Q1     = [cisf_AD_1], 16
+      cmp.ge        p10, p0             = cisf_r_exp, cisf_exp_limit
+(p10) br.cond.spnt  _CISF_LARGE_ARGS    // go to |x| >= 2^24 path
+};;
+
+// cisf_W          = x * cisf_Inv_Pi_by_16
+// Multiply x by scaled 16/pi and add large const to shift integer part of W to
+//   rightmost bits of significand
+{ .mfi
+      nop.m  0
+      fma.s1 cisf_W_2TO61_RSH = cisf_NORM_f8,cisf_SIG_INV_PI_BY_16_2TO61,cisf_RSHF_2TO61
+      nop.i  0
+};;
+
+// cisf_NFLOAT = Round_Int_Nearest(cisf_W)
+{ .mfi
+      nop.m         0
+      fms.s1        cisf_NFLOAT         = cisf_W_2TO61_RSH,cisf_2TOM61,cisf_RSHF
+      nop.i         0
+};;
+
+// N = (int)cisf_int_Nfloat
+{ .mfi
+      getf.sig      cisf_GR_n           = cisf_W_2TO61_RSH
+      nop.f         0
+      nop.i         0
+};;
+
+// Add 2^(k-1) (which is in cisf_r_sincos) to N
+// cisf_r = -cisf_Nfloat * cisf_Pi_by_16_hi + x
+// cisf_r = cisf_r -cisf_Nfloat * cisf_Pi_by_16_lo
+{ .mfi
+      add     cisf_GR_n_cos = 0x8, cisf_GR_n
+      fnma.s1 cisf_r        = cisf_NFLOAT, cisf_Pi_by_16_hi, cisf_NORM_f8
+      nop.i   0
+};;
+
+//Get M (least k+1 bits of N)
+{ .mmi
+      and           cisf_GR_m_sin       = 0x1f,cisf_GR_n
+      and           cisf_GR_m_cos       = 0x1f,cisf_GR_n_cos
+      nop.i         0
+};;
+
+{ .mmi
+      shladd        cisf_AD_2_cos       = cisf_GR_m_cos,4, cisf_AD_1
+      shladd        cisf_AD_2_sin       = cisf_GR_m_sin,4, cisf_AD_1
+      nop.i         0
+};;
+
+// den. input to set uflow
+{ .mmf
+      ldfpd         cisf_Sm_sin, cisf_Cm_sin = [cisf_AD_2_sin]
+      ldfpd         cisf_Sm_cos, cisf_Cm_cos = [cisf_AD_2_cos]
+      fclass.m.unc  p10,p0                   = cisf_Arg,0x0b
+};;
+
+{ .mfi
+      nop.m         0
+      fma.s1        cisf_rsq            = cisf_r, cisf_r,   f0  // get r^2
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fmpy.s0       cisf_tmp            = cisf_tmp,cisf_tmp // inexact flag
+      nop.i         0
+};;
+
+{ .mmf
+      nop.m         0
+      nop.m         0
+      fnma.s1       cisf_r_exact        = cisf_NFLOAT, cisf_Pi_by_16_lo, cisf_r
+};;
+
+{ .mfi
+      nop.m         0
+      fma.s1        cisf_P              = cisf_rsq, cisf_P2, cisf_P1
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        cisf_Q              = cisf_rsq, cisf_Q2, cisf_Q1
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fmpy.s1       cisf_rcub           = cisf_r_exact, cisf_rsq // get r^3
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fmpy.s1       cisf_srsq_sin       = cisf_Sm_sin,cisf_rsq
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fmpy.s1       cisf_srsq_cos       = cisf_Sm_cos,cisf_rsq
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fma.s1        cisf_P              = cisf_rcub,cisf_P,cisf_r_exact
+      nop.i         0
+};;
+
+{ .mfi
+      nop.m         0
+      fma.s1        cisf_Q_sin          = cisf_srsq_sin,cisf_Q, cisf_Sm_sin
+      nop.i         0
+}
+{ .mfi
+      nop.m         0
+      fma.s1        cisf_Q_cos          = cisf_srsq_cos,cisf_Q, cisf_Sm_cos
+      nop.i         0
+};;
+
+// If den. arg, force underflow to be set
+{ .mfi
+      nop.m         0
+(p10) fmpy.s.s0     cisf_tmp            = cisf_Arg,cisf_Arg
+      nop.i         0
+};;
+
+//Final sin
+{ .mfi
+      nop.m         0
+      fma.s.s0      cisf_Sin_res        = cisf_Cm_sin, cisf_P, cisf_Q_sin
+      nop.i         0
+}
+//Final cos
+{ .mfb
+      nop.m         0
+      fma.s.s0      cisf_Cos_res    = cisf_Cm_cos, cisf_P, cisf_Q_cos
+(p14) br.cond.sptk  _CISF_RETURN //com. exit for __libm_sincos and cis main path
+};;
+
+{ .mmb
+      stfs          [cisf_pResSin]      = cisf_Sin_res
+      stfs          [cisf_pResCos]      = cisf_Cos_res
+      br.ret.sptk   b0 // common exit for sincos main path
+};;
+
+_CISF_SPECIAL_ARGS:
+// sinf(+/-0) = +/-0
+// sinf(Inf)  = NaN
+// sinf(NaN)  = NaN
+{ .mfi
+      nop.m         999
+      fma.s.s0      cisf_Sin_res        = cisf_Arg, f0, f0 // sinf(+/-0,NaN,Inf)
+      nop.i         999
+};;
+
+// cosf(+/-0) = 1.0
+// cosf(Inf)  = NaN
+// cosf(NaN)  = NaN
+{ .mfb
+      nop.m         999
+      fma.s.s0      cisf_Cos_res        = cisf_Arg, f0, f1 // cosf(+/-0,NaN,Inf)
+(p14) br.cond.sptk  _CISF_RETURN //spec exit for __libm_sincos and cis main path
+};;
+
+{ .mmb
+      stfs          [cisf_pResSin]      = cisf_Sin_res
+      stfs          [cisf_pResCos]      = cisf_Cos_res
+      br.ret.sptk   b0 // special exit for sincos main path
+};;
+
+ // exit for sincos
+ // NOTE! r8 and r9 used only because of compiler issue
+ // connected with float point complex function arguments pass
+ // After fix of this issue this operations can be deleted
+_CISF_RETURN:
+{ .mmb
+      getf.s        r8                  = cisf_Cos_res
+      getf.s        r9                  = cisf_Sin_res
+      br.ret.sptk   b0 // exit for sincos
+};;
+GLOBAL_LIBM_END(__libm_sincosf)
+
+////  |x| > 2^24 path  ///////
+.proc _CISF_LARGE_ARGS
+_CISF_LARGE_ARGS:
+.prologue
+{ .mfi
+      nop.m         0
+      nop.f         0
+.save ar.pfs, GR_SAVE_PFS
+      mov           GR_SAVE_PFS         = ar.pfs
+};;
+
+{ .mfi
+      mov           GR_SAVE_GP          = gp
+      nop.f         0
+.save b0, GR_SAVE_B0
+      mov           GR_SAVE_B0          = b0
+};;
+
+.body
+// Call of huge arguments sincos
+{ .mib
+      nop.m         0
+      mov           GR_SAVE_PR          = pr
+      br.call.sptk  b0                  = __libm_sincos_large
+};;
+
+{ .mfi
+      mov           gp                  = GR_SAVE_GP
+      nop.f         0
+      mov           pr                  = GR_SAVE_PR, 0x1fffe
+}
+;;
+
+{ .mfi
+      nop.m         0
+      nop.f         0
+      mov           b0                  = GR_SAVE_B0
+}
+;;
+
+{ .mfi
+      nop.m         0
+      fma.s.s0      cisf_Cos_res        = cisf_Cos_res, f1, f0
+      mov           ar.pfs              = GR_SAVE_PFS
+}
+// exit for |x| > 2^24 path (__libm_sincos and cis)
+{ .mfb
+      nop.m         0
+      fma.s.s0      cisf_Sin_res        = cisf_Sin_res, f1, f0
+(p14) br.cond.sptk  _CISF_RETURN
+};;
+
+{ .mmb
+      stfs          [cisf_pResSin]      = cisf_Sin_res
+      stfs          [cisf_pResCos]      = cisf_Cos_res
+      br.ret.sptk   b0 // exit for sincos |x| > 2^24 path
+};;
+
+.endp _CISF_LARGE_ARGS
+
+.type   __libm_sincos_large#,@function
+.global __libm_sincos_large#
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_sincosl.S
@@ -0,0 +1,2525 @@
+.file "libm_sincosl.s"
+
+
+// Copyright (c) 2000 - 2004, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 05/13/02 Initial version of sincosl (based on libm's sinl and cosl)
+// 02/10/03 Reordered header: .section, .global, .proc, .align;
+//          used data8 for long double table values
+// 10/13/03 Corrected .file name
+// 02/11/04 cisl is moved to the separate file.
+// 10/26/04 Avoided using r14-31 as scratch so not clobbered by dynamic loader
+//
+//*********************************************************************
+//
+// Function:   Combined sincosl routine with 3 different API's
+//
+// API's
+//==============================================================
+// 1) void sincosl(long double, long double*s, long double*c)
+// 2) __libm_sincosl - internal LIBM function, that accepts
+//    argument in f8 and returns cosine through f8, sine through f9
+//
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8 (Input x and cosl return value),
+//                              f9 (sinl returned)
+//                              f32-f121
+//
+//    General Purpose Registers:
+//      r32-r61
+//
+//    Predicate Registers:      p6-p15
+//
+//*********************************************************************
+//
+//  IEEE Special Conditions:
+//
+//    Denormal  fault raised on denormal inputs
+//    Overflow exceptions do not occur
+//    Underflow exceptions raised when appropriate for sincosl
+//    (No specialized error handling for this routine)
+//    Inexact raised when appropriate by algorithm
+//
+//    sincosl(SNaN) = QNaN, QNaN
+//    sincosl(QNaN) = QNaN, QNaN
+//    sincosl(inf)  = QNaN, QNaN
+//    sincosl(+/-0) = +/-0, 1
+//
+//*********************************************************************
+//
+//  Mathematical Description
+//  ========================
+//
+//  The computation of FSIN and FCOS performed in parallel.
+//
+//  Arg = N pi/2 + alpha, |alpha| <= pi/4.
+//
+//  cosl( Arg ) = sinl( (N+1) pi/2 + alpha ),
+//
+//  therefore, the code for computing sine will produce cosine as long
+//  as 1 is added to N immediately after the argument reduction
+//  process.
+//
+//  Let M = N if sine
+//      N+1 if cosine.
+//
+//  Now, given
+//
+//  Arg = M pi/2  + alpha, |alpha| <= pi/4,
+//
+//  let I = M mod 4, or I be the two lsb of M when M is represented
+//  as 2's complement. I = [i_0 i_1]. Then
+//
+//  sinl( Arg ) = (-1)^i_0  sinl( alpha ) if i_1 = 0,
+//             = (-1)^i_0  cosl( alpha )     if i_1 = 1.
+//
+//  For example:
+//       if M = -1, I = 11
+//         sin ((-pi/2 + alpha) = (-1) cos (alpha)
+//       if M = 0, I = 00
+//         sin (alpha) = sin (alpha)
+//       if M = 1, I = 01
+//         sin (pi/2 + alpha) = cos (alpha)
+//       if M = 2, I = 10
+//         sin (pi + alpha) = (-1) sin (alpha)
+//       if M = 3, I = 11
+//         sin ((3/2)pi + alpha) = (-1) cos (alpha)
+//
+//  The value of alpha is obtained by argument reduction and
+//  represented by two working precision numbers r and c where
+//
+//  alpha =  r  +  c     accurately.
+//
+//  The reduction method is described in a previous write up.
+//  The argument reduction scheme identifies 4 cases. For Cases 2
+//  and 4, because |alpha| is small, sinl(r+c) and cosl(r+c) can be
+//  computed very easily by 2 or 3 terms of the Taylor series
+//  expansion as follows:
+//
+//  Case 2:
+//  -------
+//
+//  sinl(r + c) = r + c - r^3/6 accurately
+//  cosl(r + c) = 1 - 2^(-67) accurately
+//
+//  Case 4:
+//  -------
+//
+//  sinl(r + c) = r + c - r^3/6 + r^5/120 accurately
+//  cosl(r + c) = 1 - r^2/2 + r^4/24    accurately
+//
+//  The only cases left are Cases 1 and 3 of the argument reduction
+//  procedure. These two cases will be merged since after the
+//  argument is reduced in either cases, we have the reduced argument
+//  represented as r + c and that the magnitude |r + c| is not small
+//  enough to allow the usage of a very short approximation.
+//
+//  The required calculation is either
+//
+//  sinl(r + c)  =  sinl(r)  +  correction,  or
+//  cosl(r + c)  =  cosl(r)  +  correction.
+//
+//  Specifically,
+//
+//  sinl(r + c) = sinl(r) + c sin'(r) + O(c^2)
+//       = sinl(r) + c cos (r) + O(c^2)
+//       = sinl(r) + c(1 - r^2/2)  accurately.
+//  Similarly,
+//
+//  cosl(r + c) = cosl(r) - c sinl(r) + O(c^2)
+//       = cosl(r) - c(r - r^3/6)  accurately.
+//
+//  We therefore concentrate on accurately calculating sinl(r) and
+//  cosl(r) for a working-precision number r, |r| <= pi/4 to within
+//  0.1% or so.
+//
+//  The greatest challenge of this task is that the second terms of
+//  the Taylor series
+//
+//  r - r^3/3! + r^r/5! - ...
+//
+//  and
+//
+//  1 - r^2/2! + r^4/4! - ...
+//
+//  are not very small when |r| is close to pi/4 and the rounding
+//  errors will be a concern if simple polynomial accumulation is
+//  used. When |r| < 2^-3, however, the second terms will be small
+//  enough (6 bits or so of right shift) that a normal Horner
+//  recurrence suffices. Hence there are two cases that we consider
+//  in the accurate computation of sinl(r) and cosl(r), |r| <= pi/4.
+//
+//  Case small_r: |r| < 2^(-3)
+//  --------------------------
+//
+//  Since Arg = M pi/4 + r + c accurately, and M mod 4 is [i_0 i_1],
+//  we have
+//
+//  sinl(Arg) = (-1)^i_0 * sinl(r + c)  if i_1 = 0
+//     = (-1)^i_0 * cosl(r + c)   if i_1 = 1
+//
+//  can be accurately approximated by
+//
+//  sinl(Arg) = (-1)^i_0 * [sinl(r) + c]  if i_1 = 0
+//           = (-1)^i_0 * [cosl(r) - c*r] if i_1 = 1
+//
+//  because |r| is small and thus the second terms in the correction
+//  are unnecessary.
+//
+//  Finally, sinl(r) and cosl(r) are approximated by polynomials of
+//  moderate lengths.
+//
+//  sinl(r) =  r + S_1 r^3 + S_2 r^5 + ... + S_5 r^11
+//  cosl(r) =  1 + C_1 r^2 + C_2 r^4 + ... + C_5 r^10
+//
+//  We can make use of predicates to selectively calculate
+//  sinl(r) or cosl(r) based on i_1.
+//
+//  Case normal_r: 2^(-3) <= |r| <= pi/4
+//  ------------------------------------
+//
+//  This case is more likely than the previous one if one considers
+//  r to be uniformly distributed in [-pi/4 pi/4]. Again,
+//
+//  sinl(Arg) = (-1)^i_0 * sinl(r + c)  if i_1 = 0
+//           = (-1)^i_0 * cosl(r + c)   if i_1 = 1.
+//
+//  Because |r| is now larger, we need one extra term in the
+//  correction. sinl(Arg) can be accurately approximated by
+//
+//  sinl(Arg) = (-1)^i_0 * [sinl(r) + c(1-r^2/2)]      if i_1 = 0
+//           = (-1)^i_0 * [cosl(r) - c*r*(1 - r^2/6)]    i_1 = 1.
+//
+//  Finally, sinl(r) and cosl(r) are approximated by polynomials of
+//  moderate lengths.
+//
+//  sinl(r) =  r + PP_1_hi r^3 + PP_1_lo r^3 +
+//                PP_2 r^5 + ... + PP_8 r^17
+//
+//  cosl(r) =  1 + QQ_1 r^2 + QQ_2 r^4 + ... + QQ_8 r^16
+//
+//  where PP_1_hi is only about 16 bits long and QQ_1 is -1/2.
+//  The crux in accurate computation is to calculate
+//
+//  r + PP_1_hi r^3   or  1 + QQ_1 r^2
+//
+//  accurately as two pieces: U_hi and U_lo. The way to achieve this
+//  is to obtain r_hi as a 10 sig. bit number that approximates r to
+//  roughly 8 bits or so of accuracy. (One convenient way is
+//
+//  r_hi := frcpa( frcpa( r ) ).)
+//
+//  This way,
+//
+//  r + PP_1_hi r^3 =  r + PP_1_hi r_hi^3 +
+//                          PP_1_hi (r^3 - r_hi^3)
+//            =  [r + PP_1_hi r_hi^3]  +
+//         [PP_1_hi (r - r_hi)
+//            (r^2 + r_hi r + r_hi^2) ]
+//            =  U_hi  +  U_lo
+//
+//  Since r_hi is only 10 bit long and PP_1_hi is only 16 bit long,
+//  PP_1_hi * r_hi^3 is only at most 46 bit long and thus computed
+//  exactly. Furthermore, r and PP_1_hi r_hi^3 are of opposite sign
+//  and that there is no more than 8 bit shift off between r and
+//  PP_1_hi * r_hi^3. Hence the sum, U_hi, is representable and thus
+//  calculated without any error. Finally, the fact that
+//
+//  |U_lo| <= 2^(-8) |U_hi|
+//
+//  says that U_hi + U_lo is approximating r + PP_1_hi r^3 to roughly
+//  8 extra bits of accuracy.
+//
+//  Similarly,
+//
+//  1 + QQ_1 r^2  =  [1 + QQ_1 r_hi^2]  +
+//                      [QQ_1 (r - r_hi)(r + r_hi)]
+//          =  U_hi  +  U_lo.
+//
+//  Summarizing, we calculate r_hi = frcpa( frcpa( r ) ).
+//
+//  If i_1 = 0, then
+//
+//    U_hi := r + PP_1_hi * r_hi^3
+//    U_lo := PP_1_hi * (r - r_hi) * (r^2 + r*r_hi + r_hi^2)
+//    poly := PP_1_lo r^3 + PP_2 r^5 + ... + PP_8 r^17
+//    correction := c * ( 1 + C_1 r^2 )
+//
+//  Else ...i_1 = 1
+//
+//    U_hi := 1 + QQ_1 * r_hi * r_hi
+//    U_lo := QQ_1 * (r - r_hi) * (r + r_hi)
+//    poly := QQ_2 * r^4 + QQ_3 * r^6 + ... + QQ_8 r^16
+//    correction := -c * r * (1 + S_1 * r^2)
+//
+//  End
+//
+//  Finally,
+//
+//  V := poly + ( U_lo + correction )
+//
+//                 /    U_hi  +  V         if i_0 = 0
+//  result := |
+//                 \  (-U_hi) -  V         if i_0 = 1
+//
+//  It is important that in the last step, negation of U_hi is
+//  performed prior to the subtraction which is to be performed in
+//  the user-set rounding mode.
+//
+//
+//  Algorithmic Description
+//  =======================
+//
+//  The argument reduction algorithm shares the same code between FSIN and FCOS.
+//  The argument reduction description given
+//  previously is repeated below.
+//
+//
+//  Step 0. Initialization.
+//
+//  Step 1. Check for exceptional and special cases.
+//
+//   * If Arg is +-0, +-inf, NaN, NaT, go to Step 10 for special
+//     handling.
+//   * If |Arg| < 2^24, go to Step 2 for reduction of moderate
+//     arguments. This is the most likely case.
+//   * If |Arg| < 2^63, go to Step 8 for pre-reduction of large
+//     arguments.
+//   * If |Arg| >= 2^63, go to Step 10 for special handling.
+//
+//  Step 2. Reduction of moderate arguments.
+//
+//  If |Arg| < pi/4   ...quick branch
+//     N_fix := N_inc (integer)
+//     r     := Arg
+//     c     := 0.0
+//     Branch to Step 4, Case_1_complete
+//  Else    ...cf. argument reduction
+//     N     := Arg * two_by_PI (fp)
+//     N_fix := fcvt.fx( N )  (int)
+//     N     := fcvt.xf( N_fix )
+//     N_fix := N_fix + N_inc
+//     s     := Arg - N * P_1 (first piece of pi/2)
+//     w     := -N * P_2  (second piece of pi/2)
+//
+//     If |s| >= 2^(-33)
+//        go to Step 3, Case_1_reduce
+//     Else
+//        go to Step 7, Case_2_reduce
+//     Endif
+//  Endif
+//
+//  Step 3. Case_1_reduce.
+//
+//  r := s + w
+//  c := (s - r) + w  ...observe order
+//
+//  Step 4. Case_1_complete
+//
+//  ...At this point, the reduced argument alpha is
+//  ...accurately represented as r + c.
+//  If |r| < 2^(-3), go to Step 6, small_r.
+//
+//  Step 5. Normal_r.
+//
+//  Let [i_0 i_1] by the 2 lsb of N_fix.
+//  FR_rsq  := r * r
+//  r_hi := frcpa( frcpa( r ) )
+//  r_lo := r - r_hi
+//
+//  If i_1 = 0, then
+//    poly := r*FR_rsq*(PP_1_lo + FR_rsq*(PP_2 + ... FR_rsq*PP_8))
+//    U_hi := r + PP_1_hi*r_hi*r_hi*r_hi  ...any order
+//    U_lo := PP_1_hi*r_lo*(r*r + r*r_hi + r_hi*r_hi)
+//    correction := c + c*C_1*FR_rsq    ...any order
+//  Else
+//    poly := FR_rsq*FR_rsq*(QQ_2 + FR_rsq*(QQ_3 + ... + FR_rsq*QQ_8))
+//    U_hi := 1 + QQ_1 * r_hi * r_hi    ...any order
+//    U_lo := QQ_1 * r_lo * (r + r_hi)
+//    correction := -c*(r + S_1*FR_rsq*r) ...any order
+//  Endif
+//
+//  V := poly + (U_lo + correction) ...observe order
+//
+//  result := (i_0 == 0?   1.0 : -1.0)
+//
+//  Last instruction in user-set rounding mode
+//
+//  result := (i_0 == 0?   result*U_hi + V :
+//                        result*U_hi - V)
+//
+//  Return
+//
+//  Step 6. Small_r.
+//
+//  ...Use flush to zero mode without causing exception
+//    Let [i_0 i_1] be the two lsb of N_fix.
+//
+//  FR_rsq := r * r
+//
+//  If i_1 = 0 then
+//     z := FR_rsq*FR_rsq; z := FR_rsq*z *r
+//     poly_lo := S_3 + FR_rsq*(S_4 + FR_rsq*S_5)
+//     poly_hi := r*FR_rsq*(S_1 + FR_rsq*S_2)
+//     correction := c
+//     result := r
+//  Else
+//     z := FR_rsq*FR_rsq; z := FR_rsq*z
+//     poly_lo := C_3 + FR_rsq*(C_4 + FR_rsq*C_5)
+//     poly_hi := FR_rsq*(C_1 + FR_rsq*C_2)
+//     correction := -c*r
+//     result := 1
+//  Endif
+//
+//  poly := poly_hi + (z * poly_lo + correction)
+//
+//  If i_0 = 1, result := -result
+//
+//  Last operation. Perform in user-set rounding mode
+//
+//  result := (i_0 == 0?     result + poly :
+//                          result - poly )
+//  Return
+//
+//  Step 7. Case_2_reduce.
+//
+//  ...Refer to the write up for argument reduction for
+//  ...rationale. The reduction algorithm below is taken from
+//  ...argument reduction description and integrated this.
+//
+//  w := N*P_3
+//  U_1 := N*P_2 + w    ...FMA
+//  U_2 := (N*P_2 - U_1) + w  ...2 FMA
+//  ...U_1 + U_2 is  N*(P_2+P_3) accurately
+//
+//  r := s - U_1
+//  c := ( (s - r) - U_1 ) - U_2
+//
+//  ...The mathematical sum r + c approximates the reduced
+//  ...argument accurately. Note that although compared to
+//  ...Case 1, this case requires much more work to reduce
+//  ...the argument, the subsequent calculation needed for
+//  ...any of the trigonometric function is very little because
+//  ...|alpha| < 1.01*2^(-33) and thus two terms of the
+//  ...Taylor series expansion suffices.
+//
+//  If i_1 = 0 then
+//     poly := c + S_1 * r * r * r  ...any order
+//     result := r
+//  Else
+//     poly := -2^(-67)
+//     result := 1.0
+//  Endif
+//
+//  If i_0 = 1, result := -result
+//
+//  Last operation. Perform in user-set rounding mode
+//
+//  result := (i_0 == 0?     result + poly :
+//                           result - poly )
+//
+//  Return
+//
+//
+//  Step 8. Pre-reduction of large arguments.
+//
+//  ...Again, the following reduction procedure was described
+//  ...in the separate write up for argument reduction, which
+//  ...is tightly integrated here.
+
+//  N_0 := Arg * Inv_P_0
+//  N_0_fix := fcvt.fx( N_0 )
+//  N_0 := fcvt.xf( N_0_fix)
+
+//  Arg' := Arg - N_0 * P_0
+//  w := N_0 * d_1
+//  N := Arg' * two_by_PI
+//  N_fix := fcvt.fx( N )
+//  N := fcvt.xf( N_fix )
+//  N_fix := N_fix + N_inc
+//
+//  s := Arg' - N * P_1
+//  w := w - N * P_2
+//
+//  If |s| >= 2^(-14)
+//     go to Step 3
+//  Else
+//     go to Step 9
+//  Endif
+//
+//  Step 9. Case_4_reduce.
+//
+//    ...first obtain N_0*d_1 and -N*P_2 accurately
+//   U_hi := N_0 * d_1    V_hi := -N*P_2
+//   U_lo := N_0 * d_1 - U_hi V_lo := -N*P_2 - U_hi ...FMAs
+//
+//   ...compute the contribution from N_0*d_1 and -N*P_3
+//   w := -N*P_3
+//   w := w + N_0*d_2
+//   t := U_lo + V_lo + w   ...any order
+//
+//   ...at this point, the mathematical value
+//   ...s + U_hi + V_hi  + t approximates the true reduced argument
+//   ...accurately. Just need to compute this accurately.
+//
+//   ...Calculate U_hi + V_hi accurately:
+//   A := U_hi + V_hi
+//   if |U_hi| >= |V_hi| then
+//      a := (U_hi - A) + V_hi
+//   else
+//      a := (V_hi - A) + U_hi
+//   endif
+//   ...order in computing "a" must be observed. This branch is
+//   ...best implemented by predicates.
+//   ...A + a  is U_hi + V_hi accurately. Moreover, "a" is
+//   ...much smaller than A: |a| <= (1/2)ulp(A).
+//
+//   ...Just need to calculate   s + A + a + t
+//   C_hi := s + A    t := t + a
+//   C_lo := (s - C_hi) + A
+//   C_lo := C_lo + t
+//
+//   ...Final steps for reduction
+//   r := C_hi + C_lo
+//   c := (C_hi - r) + C_lo
+//
+//   ...At this point, we have r and c
+//   ...And all we need is a couple of terms of the corresponding
+//   ...Taylor series.
+//
+//   If i_1 = 0
+//      poly := c + r*FR_rsq*(S_1 + FR_rsq*S_2)
+//      result := r
+//   Else
+//      poly := FR_rsq*(C_1 + FR_rsq*C_2)
+//      result := 1
+//   Endif
+//
+//   If i_0 = 1, result := -result
+//
+//   Last operation. Perform in user-set rounding mode
+//
+//   result := (i_0 == 0?     result + poly :
+//                            result - poly )
+//   Return
+//
+//   Large Arguments: For arguments above 2**63, a Payne-Hanek
+//   style argument reduction is used and pi_by_2 reduce is called.
+//
+
+
+RODATA
+.align 64
+
+LOCAL_OBJECT_START(FSINCOSL_CONSTANTS)
+
+sincosl_table_p:
+//data4 0x4E44152A, 0xA2F9836E, 0x00003FFE,0x00000000 // Inv_pi_by_2
+//data4 0xCE81B9F1, 0xC84D32B0, 0x00004016,0x00000000 // P_0
+//data4 0x2168C235, 0xC90FDAA2, 0x00003FFF,0x00000000 // P_1
+//data4 0xFC8F8CBB, 0xECE675D1, 0x0000BFBD,0x00000000 // P_2
+//data4 0xACC19C60, 0xB7ED8FBB, 0x0000BF7C,0x00000000 // P_3
+//data4 0xDBD171A1, 0x8D848E89, 0x0000BFBF,0x00000000 // d_1
+//data4 0x18A66F8E, 0xD5394C36, 0x0000BF7C,0x00000000 // d_2
+data8 0xA2F9836E4E44152A, 0x00003FFE // Inv_pi_by_2
+data8 0xC84D32B0CE81B9F1, 0x00004016 // P_0
+data8 0xC90FDAA22168C235, 0x00003FFF // P_1
+data8 0xECE675D1FC8F8CBB, 0x0000BFBD // P_2
+data8 0xB7ED8FBBACC19C60, 0x0000BF7C // P_3
+data8 0x8D848E89DBD171A1, 0x0000BFBF // d_1
+data8 0xD5394C3618A66F8E, 0x0000BF7C // d_2
+LOCAL_OBJECT_END(FSINCOSL_CONSTANTS)
+
+LOCAL_OBJECT_START(sincosl_table_d)
+//data4 0x2168C234, 0xC90FDAA2, 0x00003FFE,0x00000000 // pi_by_4
+//data4 0x6EC6B45A, 0xA397E504, 0x00003FE7,0x00000000 // Inv_P_0
+data8 0xC90FDAA22168C234, 0x00003FFE // pi_by_4
+data8 0xA397E5046EC6B45A, 0x00003FE7 // Inv_P_0
+data4 0x3E000000, 0xBE000000         // 2^-3 and -2^-3
+data4 0x2F000000, 0xAF000000         // 2^-33 and -2^-33
+data4 0x9E000000, 0x00000000         // -2^-67
+data4 0x00000000, 0x00000000         // pad
+LOCAL_OBJECT_END(sincosl_table_d)
+
+LOCAL_OBJECT_START(sincosl_table_pp)
+//data4 0xA21C0BC9, 0xCC8ABEBC, 0x00003FCE,0x00000000 // PP_8
+//data4 0x720221DA, 0xD7468A05, 0x0000BFD6,0x00000000 // PP_7
+//data4 0x640AD517, 0xB092382F, 0x00003FDE,0x00000000 // PP_6
+//data4 0xD1EB75A4, 0xD7322B47, 0x0000BFE5,0x00000000 // PP_5
+//data4 0xFFFFFFFE, 0xFFFFFFFF, 0x0000BFFD,0x00000000 // C_1
+//data4 0x00000000, 0xAAAA0000, 0x0000BFFC,0x00000000 // PP_1_hi
+//data4 0xBAF69EEA, 0xB8EF1D2A, 0x00003FEC,0x00000000 // PP_4
+//data4 0x0D03BB69, 0xD00D00D0, 0x0000BFF2,0x00000000 // PP_3
+//data4 0x88888962, 0x88888888, 0x00003FF8,0x00000000 // PP_2
+//data4 0xAAAB0000, 0xAAAAAAAA, 0x0000BFEC,0x00000000 // PP_1_lo
+data8 0xCC8ABEBCA21C0BC9, 0x00003FCE // PP_8
+data8 0xD7468A05720221DA, 0x0000BFD6 // PP_7
+data8 0xB092382F640AD517, 0x00003FDE // PP_6
+data8 0xD7322B47D1EB75A4, 0x0000BFE5 // PP_5
+data8 0xFFFFFFFFFFFFFFFE, 0x0000BFFD // C_1
+data8 0xAAAA000000000000, 0x0000BFFC // PP_1_hi
+data8 0xB8EF1D2ABAF69EEA, 0x00003FEC // PP_4
+data8 0xD00D00D00D03BB69, 0x0000BFF2 // PP_3
+data8 0x8888888888888962, 0x00003FF8 // PP_2
+data8 0xAAAAAAAAAAAB0000, 0x0000BFEC // PP_1_lo
+LOCAL_OBJECT_END(sincosl_table_pp)
+
+LOCAL_OBJECT_START(sincosl_table_qq)
+//data4 0xC2B0FE52, 0xD56232EF, 0x00003FD2 // QQ_8
+//data4 0x2B48DCA6, 0xC9C99ABA, 0x0000BFDA // QQ_7
+//data4 0x9C716658, 0x8F76C650, 0x00003FE2 // QQ_6
+//data4 0xFDA8D0FC, 0x93F27DBA, 0x0000BFE9 // QQ_5
+//data4 0xAAAAAAAA, 0xAAAAAAAA, 0x0000BFFC // S_1
+//data4 0x00000000, 0x80000000, 0x0000BFFE,0x00000000 // QQ_1
+//data4 0x0C6E5041, 0xD00D00D0, 0x00003FEF,0x00000000 // QQ_4
+//data4 0x0B607F60, 0xB60B60B6, 0x0000BFF5,0x00000000 // QQ_3
+//data4 0xAAAAAA9B, 0xAAAAAAAA, 0x00003FFA,0x00000000 // QQ_2
+data8 0xD56232EFC2B0FE52, 0x00003FD2 // QQ_8
+data8 0xC9C99ABA2B48DCA6, 0x0000BFDA // QQ_7
+data8 0x8F76C6509C716658, 0x00003FE2 // QQ_6
+data8 0x93F27DBAFDA8D0FC, 0x0000BFE9 // QQ_5
+data8 0xAAAAAAAAAAAAAAAA, 0x0000BFFC // S_1
+data8 0x8000000000000000, 0x0000BFFE // QQ_1
+data8 0xD00D00D00C6E5041, 0x00003FEF // QQ_4
+data8 0xB60B60B60B607F60, 0x0000BFF5 // QQ_3
+data8 0xAAAAAAAAAAAAAA9B, 0x00003FFA // QQ_2
+LOCAL_OBJECT_END(sincosl_table_qq)
+
+LOCAL_OBJECT_START(sincosl_table_c)
+//data4 0xFFFFFFFE, 0xFFFFFFFF, 0x0000BFFD,0x00000000 // C_1
+//data4 0xAAAA719F, 0xAAAAAAAA, 0x00003FFA,0x00000000 // C_2
+//data4 0x0356F994, 0xB60B60B6, 0x0000BFF5,0x00000000 // C_3
+//data4 0xB2385EA9, 0xD00CFFD5, 0x00003FEF,0x00000000 // C_4
+//data4 0x292A14CD, 0x93E4BD18, 0x0000BFE9,0x00000000 // C_5
+data8 0xFFFFFFFFFFFFFFFE, 0x0000BFFD // C_1
+data8 0xAAAAAAAAAAAA719F, 0x00003FFA // C_2
+data8 0xB60B60B60356F994, 0x0000BFF5 // C_3
+data8 0xD00CFFD5B2385EA9, 0x00003FEF // C_4
+data8 0x93E4BD18292A14CD, 0x0000BFE9 // C_5
+LOCAL_OBJECT_END(sincosl_table_c)
+
+LOCAL_OBJECT_START(sincosl_table_s)
+//data4 0xAAAAAAAA, 0xAAAAAAAA, 0x0000BFFC,0x00000000 // S_1
+//data4 0x888868DB, 0x88888888, 0x00003FF8,0x00000000 // S_2
+//data4 0x055EFD4B, 0xD00D00D0, 0x0000BFF2,0x00000000 // S_3
+//data4 0x839730B9, 0xB8EF1C5D, 0x00003FEC,0x00000000 // S_4
+//data4 0xE5B3F492, 0xD71EA3A4, 0x0000BFE5,0x00000000 // S_5
+data8 0xAAAAAAAAAAAAAAAA, 0x0000BFFC // S_1
+data8 0x88888888888868DB, 0x00003FF8 // S_2
+data8 0xD00D00D0055EFD4B, 0x0000BFF2 // S_3
+data8 0xB8EF1C5D839730B9, 0x00003FEC // S_4
+data8 0xD71EA3A4E5B3F492, 0x0000BFE5 // S_5
+data4 0x38800000, 0xB8800000         // two**-14 and -two**-14
+LOCAL_OBJECT_END(sincosl_table_s)
+
+FR_Input_X        = f8
+FR_Result         = f8
+FR_ResultS        = f9
+FR_ResultC        = f8
+FR_r              = f8
+FR_c              = f9
+
+FR_norm_x         = f9
+FR_inv_pi_2to63   = f10
+FR_rshf_2to64     = f11
+FR_2tom64         = f12
+FR_rshf           = f13
+FR_N_float_signif = f14
+FR_abs_x          = f15
+
+FR_r6             = f32
+FR_r7             = f33
+FR_Pi_by_4        = f34
+FR_Two_to_M14     = f35
+FR_Neg_Two_to_M14 = f36
+FR_Two_to_M33     = f37
+FR_Neg_Two_to_M33 = f38
+FR_Neg_Two_to_M67 = f39
+FR_Inv_pi_by_2    = f40
+FR_N_float        = f41
+FR_N_fix          = f42
+FR_P_1            = f43
+FR_P_2            = f44
+FR_P_3            = f45
+FR_s              = f46
+FR_w              = f47
+FR_Z              = f50
+FR_A              = f51
+FR_a              = f52
+FR_t              = f53
+FR_U_1            = f54
+FR_U_2            = f55
+FR_C_1            = f56
+FR_C_2            = f57
+FR_C_3            = f58
+FR_C_4            = f59
+FR_C_5            = f60
+FR_S_1            = f61
+FR_S_2            = f62
+FR_S_3            = f63
+FR_S_4            = f64
+FR_S_5            = f65
+FR_r_hi           = f68
+FR_r_lo           = f69
+FR_rsq            = f70
+FR_r_cubed        = f71
+FR_C_hi           = f72
+FR_N_0            = f73
+FR_d_1            = f74
+FR_V_hi           = f75
+FR_V_lo           = f76
+FR_U_hi           = f77
+FR_U_lo           = f78
+FR_U_hiabs        = f79
+FR_V_hiabs        = f80
+FR_PP_8           = f81
+FR_QQ_8           = f101
+FR_PP_7           = f82
+FR_QQ_7           = f102
+FR_PP_6           = f83
+FR_QQ_6           = f103
+FR_PP_5           = f84
+FR_QQ_5           = f104
+FR_PP_4           = f85
+FR_QQ_4           = f105
+FR_PP_3           = f86
+FR_QQ_3           = f106
+FR_PP_2           = f87
+FR_QQ_2           = f107
+FR_QQ_1           = f108
+FR_r_hi_sq        = f88
+FR_N_0_fix        = f89
+FR_Inv_P_0        = f90
+FR_d_2            = f93
+FR_P_0            = f95
+FR_C_lo           = f96
+FR_PP_1           = f97
+FR_PP_1_lo        = f98
+FR_ArgPrime       = f99
+FR_inexact        = f100
+
+FR_Neg_Two_to_M3  = f109
+FR_Two_to_M3      = f110
+
+FR_poly_hiS       = f66
+FR_poly_hiC       = f112
+
+FR_poly_loS       = f67
+FR_poly_loC       = f113
+
+FR_polyS          = f92
+FR_polyC          = f114
+
+FR_cS             = FR_c
+FR_cC             = f115
+
+FR_corrS          = f91
+FR_corrC          = f116
+
+FR_U_hiC          = f117
+FR_U_loC          = f118
+
+FR_VS             = f75
+FR_VC             = f119
+
+FR_FirstS         = f120
+FR_FirstC         = f121
+
+FR_U_hiS          = FR_U_hi
+FR_U_loS          = FR_U_lo
+
+FR_Tmp            = f94
+
+
+
+
+sincos_pResSin = r34
+sincos_pResCos = r35
+
+GR_exp_m2_to_m3= r36
+GR_N_Inc       = r37
+GR_Cis         = r38
+GR_signexp_x   = r40
+GR_exp_x       = r40
+GR_exp_mask    = r41
+GR_exp_2_to_63 = r42
+GR_exp_2_to_m3 = r43
+GR_exp_2_to_24 = r44
+
+GR_N_SignS     = r45
+GR_N_SignC     = r46
+GR_N_SinCos    = r47
+
+GR_sig_inv_pi  = r48
+GR_rshf_2to64  = r49
+GR_exp_2tom64  = r50
+GR_rshf        = r51
+GR_ad_p        = r52
+GR_ad_d        = r53
+GR_ad_pp       = r54
+GR_ad_qq       = r55
+GR_ad_c        = r56
+GR_ad_s        = r57
+GR_ad_ce       = r58
+GR_ad_se       = r59
+GR_ad_m14      = r60
+GR_ad_s1       = r61
+
+// For unwind support
+GR_SAVE_B0     = r39
+GR_SAVE_GP     = r40
+GR_SAVE_PFS    = r41
+
+
+.section .text
+
+GLOBAL_IEEE754_ENTRY(sincosl)
+{ .mlx  ///////////////////////////// 1 /////////////////
+      alloc r32 = ar.pfs,3,27,2,0
+      movl GR_sig_inv_pi = 0xa2f9836e4e44152a // significand of 1/pi
+}
+{ .mlx
+      mov GR_N_Inc = 0x0
+      movl GR_rshf_2to64 = 0x47e8000000000000 // 1.1000 2^(63+64)
+};;
+
+{ .mfi ///////////////////////////// 2 /////////////////
+      addl           GR_ad_p   = @ltoff(FSINCOSL_CONSTANTS#), gp
+      fclass.m p6, p0 =  FR_Input_X, 0x1E3 // Test x natval, nan, inf
+      mov GR_exp_2_to_m3 = 0xffff - 3      // Exponent of 2^-3
+}
+{ .mfb
+      mov GR_Cis = 0x0
+      fnorm.s1 FR_norm_x = FR_Input_X      // Normalize x
+    br.cond.sptk _COMMON_SINCOSL
+};;
+GLOBAL_IEEE754_END(sincosl)
+libm_alias_ldouble_other (__sincos, sincos)
+
+GLOBAL_LIBM_ENTRY(__libm_sincosl)
+{ .mlx  ///////////////////////////// 1 /////////////////
+      alloc r32 = ar.pfs,3,27,2,0
+      movl GR_sig_inv_pi = 0xa2f9836e4e44152a // significand of 1/pi
+}
+{ .mlx
+      mov GR_N_Inc = 0x0
+      movl GR_rshf_2to64 = 0x47e8000000000000 // 1.1000 2^(63+64)
+};;
+
+{ .mfi ///////////////////////////// 2 /////////////////
+      addl           GR_ad_p   = @ltoff(FSINCOSL_CONSTANTS#), gp
+      fclass.m p6, p0 =  FR_Input_X, 0x1E3 // Test x natval, nan, inf
+      mov GR_exp_2_to_m3 = 0xffff - 3      // Exponent of 2^-3
+}
+{ .mfb
+      mov GR_Cis = 0x1
+      fnorm.s1 FR_norm_x = FR_Input_X      // Normalize x
+      nop.b 0
+};;
+
+_COMMON_SINCOSL:
+{ .mfi ///////////////////////////// 3 /////////////////
+      setf.sig FR_inv_pi_2to63 = GR_sig_inv_pi // Form 1/pi * 2^63
+      nop.f 0
+      mov GR_exp_2tom64 = 0xffff - 64      // Scaling constant to compute N
+}
+{ .mlx
+      setf.d FR_rshf_2to64 = GR_rshf_2to64    // Form const 1.1000 * 2^(63+64)
+      movl GR_rshf = 0x43e8000000000000       // Form const 1.1000 * 2^63
+};;
+
+{ .mfi ///////////////////////////// 4 /////////////////
+      ld8 GR_ad_p = [GR_ad_p]              // Point to Inv_pi_by_2
+      fclass.m p7, p0 = FR_Input_X, 0x0b   // Test x denormal
+      nop.i 0
+};;
+
+{ .mfi    ///////////////////////////// 5 /////////////////
+      getf.exp GR_signexp_x = FR_Input_X   // Get sign and exponent of x
+      fclass.m p10, p0 = FR_Input_X, 0x007 // Test x zero
+      nop.i 0
+}
+{ .mib
+      mov GR_exp_mask = 0x1ffff            // Exponent mask
+      nop.i 0
+(p6)  br.cond.spnt SINCOSL_SPECIAL         // Branch if x natval, nan, inf
+};;
+
+{ .mfi ///////////////////////////// 6 /////////////////
+      setf.exp FR_2tom64 = GR_exp_2tom64   // Form 2^-64 for scaling N_float
+      nop.f 0
+      add GR_ad_d = 0x70, GR_ad_p          // Point to constant table d
+}
+{ .mib
+      setf.d FR_rshf = GR_rshf         // Form right shift const 1.1000 * 2^63
+      mov  GR_exp_m2_to_m3 = 0x2fffc       // Form -(2^-3)
+(p7)  br.cond.spnt SINCOSL_DENORMAL        // Branch if x denormal
+};;
+
+SINCOSL_COMMON2:
+{ .mfi ///////////////////////////// 7 /////////////////
+      and GR_exp_x = GR_exp_mask, GR_signexp_x // Get exponent of x
+      fclass.nm p8, p0 = FR_Input_X, 0x1FF // Test x unsupported type
+      mov GR_exp_2_to_63 = 0xffff + 63     // Exponent of 2^63
+}
+{ .mib
+      add GR_ad_pp = 0x40, GR_ad_d         // Point to constant table pp
+      mov GR_exp_2_to_24 = 0xffff + 24     // Exponent of 2^24
+(p10) br.cond.spnt SINCOSL_ZERO            // Branch if x zero
+};;
+
+{ .mfi ///////////////////////////// 8 /////////////////
+      ldfe FR_Inv_pi_by_2 = [GR_ad_p], 16  // Load 2/pi
+      fcmp.eq.s0 p15, p0 = FR_Input_X, f0  // Dummy to set denormal
+      add GR_ad_qq = 0xa0, GR_ad_pp        // Point to constant table qq
+}
+{ .mfi
+      ldfe FR_Pi_by_4 = [GR_ad_d], 16      // Load pi/4 for range test
+      nop.f 0
+      cmp.ge p10,p0 = GR_exp_x, GR_exp_2_to_63   // Is |x| >= 2^63
+};;
+
+{ .mfi ///////////////////////////// 9 /////////////////
+      ldfe FR_P_0 = [GR_ad_p], 16          // Load P_0 for pi/4 <= |x| < 2^63
+      fmerge.s FR_abs_x = f1, FR_norm_x    // |x|
+      add GR_ad_c = 0x90, GR_ad_qq         // Point to constant table c
+}
+{ .mfi
+      ldfe FR_Inv_P_0 = [GR_ad_d], 16      // Load 1/P_0 for pi/4 <= |x| < 2^63
+      nop.f 0
+      cmp.ge p7,p0 = GR_exp_x, GR_exp_2_to_24   // Is |x| >= 2^24
+};;
+
+{ .mfi ///////////////////////////// 10 /////////////////
+      ldfe FR_P_1 = [GR_ad_p], 16          // Load P_1 for pi/4 <= |x| < 2^63
+      nop.f 0
+      add GR_ad_s = 0x50, GR_ad_c          // Point to constant table s
+}
+{ .mfi
+      ldfe FR_PP_8 = [GR_ad_pp], 16        // Load PP_8 for 2^-3 < |r| < pi/4
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi ///////////////////////////// 11 /////////////////
+      ldfe FR_P_2 = [GR_ad_p], 16          // Load P_2 for pi/4 <= |x| < 2^63
+      nop.f 0
+      add GR_ad_ce = 0x40, GR_ad_c         // Point to end of constant table c
+}
+{ .mfi
+      ldfe FR_QQ_8 = [GR_ad_qq], 16        // Load QQ_8 for 2^-3 < |r| < pi/4
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi ///////////////////////////// 12 /////////////////
+      ldfe FR_QQ_7 = [GR_ad_qq], 16        // Load QQ_7 for 2^-3 < |r| < pi/4
+      fma.s1  FR_N_float_signif = FR_Input_X, FR_inv_pi_2to63, FR_rshf_2to64
+      add GR_ad_se = 0x40, GR_ad_s         // Point to end of constant table s
+}
+{ .mib
+      ldfe FR_PP_7 = [GR_ad_pp], 16        // Load PP_7 for 2^-3 < |r| < pi/4
+      mov GR_ad_s1 = GR_ad_s               // Save pointer to S_1
+(p10) br.cond.spnt SINCOSL_ARG_TOO_LARGE   // Branch if |x| >= 2^63
+                                           // Use Payne-Hanek Reduction
+};;
+
+{ .mfi ///////////////////////////// 13 /////////////////
+      ldfe FR_P_3 = [GR_ad_p], 16          // Load P_3 for pi/4 <= |x| < 2^63
+      fmerge.se FR_r = FR_norm_x, FR_norm_x // r = x, in case |x| < pi/4
+      add GR_ad_m14 = 0x50, GR_ad_s        // Point to constant table m14
+}
+{ .mfb
+      ldfps FR_Two_to_M3, FR_Neg_Two_to_M3 = [GR_ad_d], 8
+      fma.s1 FR_rsq = FR_norm_x, FR_norm_x, f0 // rsq = x*x, in case |x| < pi/4
+(p7)  br.cond.spnt SINCOSL_LARGER_ARG      // Branch if 2^24 <= |x| < 2^63
+                                           // Use pre-reduction
+};;
+
+{ .mmf ///////////////////////////// 14 /////////////////
+      ldfe FR_PP_6 = [GR_ad_pp], 16       // Load PP_6 for normal path
+      ldfe FR_QQ_6 = [GR_ad_qq], 16       // Load QQ_6 for normal path
+      fmerge.se FR_c = f0, f0             // c = 0 in case |x| < pi/4
+};;
+
+{ .mmf ///////////////////////////// 15 /////////////////
+      ldfe FR_PP_5 = [GR_ad_pp], 16       // Load PP_5 for normal path
+      ldfe FR_QQ_5 = [GR_ad_qq], 16       // Load QQ_5 for normal path
+      nop.f 0
+};;
+
+// Here if 0 < |x| < 2^24
+{ .mfi ///////////////////////////// 17 /////////////////
+      ldfe FR_S_5 = [GR_ad_se], -16       // Load S_5 if i_1=0
+      fcmp.lt.s1  p6, p7 = FR_abs_x, FR_Pi_by_4  // Test |x| < pi/4
+      nop.i 0
+}
+{ .mfi
+      ldfe FR_C_5 = [GR_ad_ce], -16       // Load C_5 if i_1=1
+      fms.s1 FR_N_float = FR_N_float_signif, FR_2tom64, FR_rshf
+      nop.i 0
+};;
+
+{ .mmi ///////////////////////////// 18 /////////////////
+      ldfe FR_S_4 = [GR_ad_se], -16       // Load S_4 if i_1=0
+      ldfe FR_C_4 = [GR_ad_ce], -16       // Load C_4 if i_1=1
+      nop.i 0
+};;
+
+//
+//     N  = Arg * 2/pi
+//     Check if Arg < pi/4
+//
+//
+//     Case 2: Convert integer N_fix back to normalized floating-point value.
+//     Case 1: p8 is only affected  when p6 is set
+//
+//
+//     Grab the integer part of N and call it N_fix
+//
+{ .mfi ///////////////////////////// 19 /////////////////
+(p7)  ldfps FR_Two_to_M33, FR_Neg_Two_to_M33 = [GR_ad_d], 8
+(p6)  fma.s1 FR_r_cubed = FR_r, FR_rsq, f0        // r^3 if |x| < pi/4
+(p6)  mov GR_N_Inc = 0x0                         // N_IncS if |x| < pi/4
+};;
+
+//     If |x| < pi/4, r = x and c = 0
+//     lf |x| < pi/4, is x < 2**(-3).
+//     r = Arg
+//     c = 0
+{ .mmi ///////////////////////////// 20 /////////////////
+(p7)  getf.sig  GR_N_Inc = FR_N_float_signif
+      nop.m 0
+(p6)  cmp.lt.unc p8,p0 = GR_exp_x, GR_exp_2_to_m3   // Is |x| < 2^-3
+};;
+
+//
+//     lf |x| < pi/4, is -2**(-3)< x < 2**(-3) - set p8.
+//     If |x| >= pi/4,
+//     Create the right N for |x| < pi/4 and otherwise
+//     Case 2: Place integer part of N in GP register
+//
+
+{ .mbb ///////////////////////////// 21 /////////////////
+      nop.m 0
+(p8)  br.cond.spnt SINCOSL_SMALL_R_0    // Branch if 0 < |x| < 2^-3
+(p6)  br.cond.spnt SINCOSL_NORMAL_R_0   // Branch if 2^-3 <= |x| < pi/4
+};;
+
+// Here if pi/4 <= |x| < 2^24
+{ .mfi
+      ldfs FR_Neg_Two_to_M67 = [GR_ad_d], 8     // Load -2^-67
+      fnma.s1 FR_s = FR_N_float, FR_P_1, FR_Input_X // s = -N * P_1  + Arg
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_w = FR_N_float, FR_P_2, f0      // w = N * P_2
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fms.s1 FR_r = FR_s, f1, FR_w        // r = s - w, assume |s| >= 2^-33
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fcmp.lt.s1 p7, p6 = FR_s, FR_Two_to_M33
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p7)  fcmp.gt.s1 p7, p6 = FR_s, FR_Neg_Two_to_M33 // p6 if |s| >= 2^-33, else p7
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fms.s1 FR_c = FR_s, f1, FR_r             // c = s - r, for |s| >= 2^-33
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_rsq = FR_r, FR_r, f0           // rsq = r * r, for |s| >= 2^-33
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p7)  fma.s1 FR_w = FR_N_float, FR_P_3, f0
+      nop.i 0
+};;
+
+{ .mmf
+      ldfe FR_C_1 = [GR_ad_pp], 16     // Load C_1 if i_1=0
+      ldfe FR_S_1 = [GR_ad_qq], 16     // Load S_1 if i_1=1
+      frcpa.s1 FR_r_hi, p15 = f1, FR_r  // r_hi = frcpa(r)
+};;
+
+{ .mfi
+      nop.m 0
+(p6)  fcmp.lt.unc.s1 p8, p13 = FR_r, FR_Two_to_M3 // If big s, test r with 2^-3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p7)  fma.s1 FR_U_1 = FR_N_float, FR_P_2, FR_w
+      nop.i 0
+};;
+
+//
+//     For big s: r = s - w: No further reduction is necessary
+//     For small s: w = N * P_3 (change sign) More reduction
+//
+{ .mfi
+    nop.m 0
+(p8)  fcmp.gt.s1 p8, p13 = FR_r, FR_Neg_Two_to_M3 // If big s, p8 if |r| < 2^-3
+    nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_rsq, FR_PP_8, FR_PP_7 // poly = rsq*PP_8+PP_7
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyC = FR_rsq, FR_QQ_8, FR_QQ_7 // poly = rsq*QQ_8+QQ_7
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p7)  fms.s1 FR_r = FR_s, f1, FR_U_1
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p6)  fma.s1 FR_r_cubed = FR_r, FR_rsq, f0  // rcubed = r * rsq
+      nop.i 0
+};;
+
+{ .mfi
+//
+//     For big s: Is |r| < 2**(-3)?
+//     For big s: c = S - r
+//     For small s: U_1 = N * P_2 + w
+//
+//     If p8 is set, prepare to branch to Small_R.
+//     If p9 is set, prepare to branch to Normal_R.
+//     For big s,  r is complete here.
+//
+//
+//     For big s: c = c + w (w has not been negated.)
+//     For small s: r = S - U_1
+//
+      nop.m 0
+(p6)  fms.s1 FR_c = FR_c, f1, FR_w
+      nop.i 0
+}
+{ .mbb
+      nop.m 0
+(p8)  br.cond.spnt  SINCOSL_SMALL_R_1  // Branch if |s|>=2^-33, |r| < 2^-3,
+                                       // and pi/4 <= |x| < 2^24
+(p13) br.cond.sptk  SINCOSL_NORMAL_R_1 // Branch if |s|>=2^-33, |r| >= 2^-3,
+                                       // and pi/4 <= |x| < 2^24
+};;
+
+SINCOSL_S_TINY:
+//
+// Here if |s| < 2^-33, and pi/4 <= |x| < 2^24
+//
+{ .mfi
+       and GR_N_SinCos = 0x1, GR_N_Inc
+       fms.s1 FR_U_2 = FR_N_float, FR_P_2, FR_U_1
+       tbit.z p8,p12       = GR_N_Inc, 0
+};;
+
+
+//
+//     For small s: U_2 = N * P_2 - U_1
+//     S_1 stored constant - grab the one stored with the
+//     coefficients.
+//
+{ .mfi
+      ldfe      FR_S_1 = [GR_ad_s1], 16
+      fma.s1  FR_polyC = f0, f1, FR_Neg_Two_to_M67
+      sub GR_N_SignS =  GR_N_Inc, GR_N_SinCos
+}
+{ .mfi
+      add GR_N_SignC =  GR_N_Inc, GR_N_SinCos
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fms.s1  FR_s = FR_s, f1, FR_r
+(p8)  tbit.z.unc p10,p11   = GR_N_SignC, 1
+}
+{ .mfi
+      nop.m 0
+      fma.s1  FR_rsq = FR_r, FR_r, f0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1  FR_U_2 = FR_U_2, f1, FR_w
+(p8)  tbit.z.unc p8,p9    = GR_N_SignS, 1
+};;
+
+{ .mfi
+      nop.m 0
+      fmerge.se FR_FirstS = FR_r, FR_r
+(p12) tbit.z.unc p14,p15  = GR_N_SignC, 1
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_FirstC = f0, f1, f1
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fms.s1  FR_c = FR_s, f1, FR_U_1
+(p12) tbit.z.unc p12,p13  = GR_N_SignS, 1
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1  FR_r = FR_S_1, FR_r, f0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s0  FR_S_1 = FR_S_1, FR_S_1, f0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fms.s1 FR_c = FR_c, f1, FR_U_2
+      nop.i 0
+};;
+
+.pred.rel "mutex",p9,p15
+{ .mfi
+      nop.m 0
+(p9)  fms.s0 FR_FirstS   = f1, f0, FR_FirstS
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p15) fms.s0 FR_FirstS   = f1, f0, FR_FirstS
+      nop.i 0
+};;
+
+.pred.rel "mutex",p11,p13
+{ .mfi
+      nop.m 0
+(p11) fms.s0 FR_FirstC   = f1, f0, FR_FirstC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p13) fms.s0 FR_FirstC   = f1, f0, FR_FirstC
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_r, FR_rsq, FR_c
+      nop.i 0
+};;
+
+
+.pred.rel "mutex",p8,p9
+{ .mfi
+      nop.m 0
+(p8)  fma.s0 FR_ResultS = FR_FirstS, f1, FR_polyS
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p9)  fms.s0 FR_ResultS = FR_FirstS, f1, FR_polyS
+      nop.i 0
+};;
+
+.pred.rel "mutex",p10,p11
+{ .mfi
+      nop.m 0
+(p10) fma.s0 FR_ResultC = FR_FirstC, f1, FR_polyC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p11) fms.s0 FR_ResultC = FR_FirstC, f1, FR_polyC
+      nop.i 0
+};;
+
+
+
+.pred.rel "mutex",p12,p13
+{ .mfi
+      nop.m 0
+(p12) fma.s0 FR_ResultS = FR_FirstC, f1, FR_polyC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p13) fms.s0 FR_ResultS = FR_FirstC, f1, FR_polyC
+      nop.i 0
+};;
+
+.pred.rel "mutex",p14,p15
+{ .mfi
+      nop.m 0
+(p14) fma.s0 FR_ResultC = FR_FirstS, f1, FR_polyS
+      nop.i 0
+}
+{ .mfb
+      cmp.eq  p10, p0 = 0x1, GR_Cis
+(p15) fms.s0 FR_ResultC = FR_FirstS, f1, FR_polyS
+(p10) br.ret.sptk               b0
+};;
+
+{ .mmb       // exit for sincosl
+      stfe  [sincos_pResSin] =  FR_ResultS
+      stfe  [sincos_pResCos] =  FR_ResultC
+      br.ret.sptk               b0
+};;
+
+
+
+
+
+
+SINCOSL_LARGER_ARG:
+//
+// Here if 2^24 <= |x| < 2^63
+//
+{ .mfi
+      ldfe FR_d_1 = [GR_ad_p], 16          // Load d_1 for |x| >= 2^24 path
+      fma.s1 FR_N_0 = FR_Input_X, FR_Inv_P_0, f0 //     N_0 = Arg * Inv_P_0
+      nop.i 0
+};;
+
+{ .mmi
+      ldfps FR_Two_to_M14, FR_Neg_Two_to_M14 = [GR_ad_m14]
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mfi
+      ldfe FR_d_2 = [GR_ad_p], 16          // Load d_2 for |x| >= 2^24 path
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fcvt.fx.s1 FR_N_0_fix = FR_N_0 // N_0_fix  = integer part of N_0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fcvt.xf FR_N_0 = FR_N_0_fix //     Make N_0 the integer part
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fnma.s1 FR_ArgPrime = FR_N_0, FR_P_0, FR_Input_X // Arg'=-N_0*P_0+Arg
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_w = FR_N_0, FR_d_1, f0 //     w  = N_0 * d_1
+      nop.i 0
+};;
+
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_N_float = FR_ArgPrime, FR_Inv_pi_by_2, f0 //  N = A' * 2/pi
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fcvt.fx.s1 FR_N_fix = FR_N_float //     N_fix is the integer part
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fcvt.xf FR_N_float = FR_N_fix
+      nop.i 0
+};;
+
+{ .mfi
+      getf.sig GR_N_Inc = FR_N_fix // N is the integer part of
+                                 // the reduced-reduced argument
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fnma.s1 FR_s = FR_N_float, FR_P_1, FR_ArgPrime //     s = -N*P_1 + Arg'
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fnma.s1 FR_w = FR_N_float, FR_P_2, FR_w //     w = -N*P_2 + w
+      nop.i 0
+};;
+
+//
+//     For |s|  > 2**(-14) r = S + w (r complete)
+//     Else       U_hi = N_0 * d_1
+//
+{ .mfi
+      nop.m 0
+      fcmp.lt.unc.s1 p9, p8 = FR_s, FR_Two_to_M14
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p9)  fcmp.gt.s1 p9, p8 = FR_s, FR_Neg_Two_to_M14  // p9 if |s| < 2^-14
+      nop.i 0
+};;
+
+//
+//     Either S <= -2**(-14) or S >= 2**(-14)
+//     or -2**(-14) < s < 2**(-14)
+//
+{ .mfi
+      nop.m 0
+(p9)  fma.s1 FR_V_hi = FR_N_float, FR_P_2, f0
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p9)  fma.s1 FR_U_hi = FR_N_0, FR_d_1, f0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p8)  fma.s1 FR_r = FR_s, f1, FR_w
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p9)  fma.s1 FR_w = FR_N_float, FR_P_3, f0
+      nop.i 0
+};;
+
+//
+//    We need abs of both U_hi and V_hi - don't
+//    worry about switched sign of V_hi.
+//
+//    Big s: finish up c = (S - r) + w (c complete)
+//    Case 4: A =  U_hi + V_hi
+//    Note: Worry about switched sign of V_hi, so subtract instead of add.
+//
+{ .mfi
+      nop.m 0
+(p9)  fms.s1 FR_A = FR_U_hi, f1, FR_V_hi
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p9)  fnma.s1 FR_V_lo = FR_N_float, FR_P_2, FR_V_hi
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p9)  fmerge.s FR_V_hiabs = f0, FR_V_hi
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p9)  fms.s1 FR_U_lo = FR_N_0, FR_d_1, FR_U_hi // For small s: U_lo=N_0*d_1-U_hi
+      nop.i 0
+};;
+
+//
+//    For big s: Is |r| < 2**(-3)
+//    For big s: if p12 set, prepare to branch to Small_R.
+//    For big s: If p13 set, prepare to branch to Normal_R.
+//
+{ .mfi
+      nop.m 0
+(p9)  fmerge.s FR_U_hiabs = f0, FR_U_hi
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p8)  fms.s1 FR_c = FR_s, f1, FR_r  //     For big s: c = S - r
+      nop.i 0
+};;
+
+//
+//    For small S: V_hi = N * P_2
+//                 w = N * P_3
+//    Note the product does not include the (-) as in the writeup
+//    so (-) missing for V_hi and w.
+//
+{ .mfi
+      nop.m 0
+(p8)  fcmp.lt.unc.s1 p12, p13 = FR_r, FR_Two_to_M3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p12) fcmp.gt.s1 p12, p13 = FR_r, FR_Neg_Two_to_M3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p8)  fma.s1 FR_c = FR_c, f1, FR_w
+      nop.i 0
+}
+{ .mfb
+      nop.m 0
+(p9)  fms.s1 FR_w = FR_N_0, FR_d_2, FR_w
+(p12) br.cond.spnt SINCOSL_SMALL_R      // Branch if |r| < 2^-3
+                                        // and 2^24 <= |x| < 2^63
+};;
+
+{ .mib
+      nop.m 0
+      nop.i 0
+(p13) br.cond.sptk SINCOSL_NORMAL_R     // Branch if |r| >= 2^-3
+                                        // and 2^24 <= |x| < 2^63
+};;
+
+SINCOSL_LARGER_S_TINY:
+//    Here if |s| < 2^-14, and 2^24 <= |x| < 2^63
+//
+//    Big s: Vector off when |r| < 2**(-3).  Recall that p8 will be true.
+//    The remaining stuff is for Case 4.
+//    Small s: V_lo = N * P_2 + U_hi (U_hi is in place of V_hi in writeup)
+//    Note: the (-) is still missing for V_lo.
+//    Small s: w = w + N_0 * d_2
+//    Note: the (-) is now incorporated in w.
+//
+{ .mfi
+      and GR_N_SinCos = 0x1, GR_N_Inc
+      fcmp.ge.unc.s1 p6, p7 = FR_U_hiabs, FR_V_hiabs
+      tbit.z p8,p12       = GR_N_Inc, 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_t = FR_U_lo, f1, FR_V_lo //     C_hi = S + A
+      nop.i 0
+};;
+
+{ .mfi
+      sub GR_N_SignS =  GR_N_Inc, GR_N_SinCos
+(p6)  fms.s1 FR_a = FR_U_hi, f1, FR_A
+      add GR_N_SignC =  GR_N_Inc, GR_N_SinCos
+}
+{ .mfi
+      nop.m 0
+(p7)  fma.s1 FR_a = FR_V_hi, f1, FR_A
+      nop.i 0
+};;
+
+{ .mmf
+      ldfe FR_C_1 = [GR_ad_c], 16
+      ldfe  FR_S_1 = [GR_ad_s], 16
+      fma.s1 FR_C_hi = FR_s, f1, FR_A
+};;
+
+{ .mmi
+      ldfe FR_C_2 = [GR_ad_c], 64
+      ldfe FR_S_2 = [GR_ad_s], 64
+(p8)  tbit.z.unc p10,p11   = GR_N_SignC, 1
+};;
+
+//
+//    r and c have been computed.
+//    Make sure ftz mode is set - should be automatic when using wre
+//    |r| < 2**(-3)
+//    Get [i_0,i_1] - two lsb of N_fix.
+//
+//    For larger u than v: a = U_hi - A
+//    Else a = V_hi - A (do an add to account for missing (-) on V_hi
+//
+{ .mfi
+      nop.m 0
+      fma.s1 FR_t = FR_t, f1, FR_w //     t = t + w
+(p8)  tbit.z.unc p8,p9    = GR_N_SignS, 1
+}
+{ .mfi
+      nop.m 0
+(p6)  fms.s1 FR_a = FR_a, f1, FR_V_hi
+      nop.i 0
+};;
+
+//
+//     If u > v: a = (U_hi - A)  + V_hi
+//     Else      a = (V_hi - A)  + U_hi
+//     In each case account for negative missing from V_hi.
+//
+{ .mfi
+      nop.m 0
+      fms.s1 FR_C_lo = FR_s, f1, FR_C_hi
+(p12) tbit.z.unc p14,p15  = GR_N_SignC, 1
+}
+{ .mfi
+      nop.m 0
+(p7)  fms.s1 FR_a = FR_U_hi, f1, FR_a
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_C_lo = FR_C_lo, f1, FR_A //     C_lo = (S - C_hi) + A
+(p12) tbit.z.unc p12,p13  = GR_N_SignS, 1
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_t = FR_t, f1, FR_a //     t = t + a
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_r = FR_C_hi, f1, FR_C_lo
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_C_lo = FR_C_lo, f1, FR_t //     C_lo = C_lo + t
+      nop.i 0
+};;
+
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_rsq = FR_r, FR_r, f0
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fms.s1 FR_c = FR_C_hi, f1, FR_r
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_FirstS = f0, f1, FR_r
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_FirstC = f0, f1, f1
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_rsq, FR_S_2, FR_S_1
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyC = FR_rsq, FR_C_2, FR_C_1
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_r_cubed = FR_rsq, FR_r, f0
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_c = FR_c, f1, FR_C_lo
+      nop.i 0
+};;
+
+.pred.rel "mutex",p9,p15
+{ .mfi
+      nop.m 0
+(p9)  fms.s0 FR_FirstS   = f1, f0, FR_FirstS
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p15) fms.s0 FR_FirstS   = f1, f0, FR_FirstS
+      nop.i 0
+};;
+
+.pred.rel "mutex",p11,p13
+{ .mfi
+      nop.m 0
+(p11) fms.s0 FR_FirstC   = f1, f0, FR_FirstC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p13) fms.s0 FR_FirstC   = f1, f0, FR_FirstC
+      nop.i 0
+};;
+
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_r_cubed, FR_polyS, FR_c
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyC = FR_rsq, FR_polyC, f0
+      nop.i 0
+};;
+
+
+
+.pred.rel "mutex",p8,p9
+{ .mfi
+      nop.m 0
+(p8)  fma.s0 FR_ResultS = FR_FirstS, f1, FR_polyS
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p9)  fms.s0 FR_ResultS = FR_FirstS, f1, FR_polyS
+      nop.i 0
+};;
+
+.pred.rel "mutex",p10,p11
+{ .mfi
+      nop.m 0
+(p10) fma.s0 FR_ResultC = FR_FirstC, f1, FR_polyC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p11) fms.s0 FR_ResultC = FR_FirstC, f1, FR_polyC
+      nop.i 0
+};;
+
+
+
+.pred.rel "mutex",p12,p13
+{ .mfi
+      nop.m 0
+(p12) fma.s0 FR_ResultS = FR_FirstC, f1, FR_polyC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p13) fms.s0 FR_ResultS = FR_FirstC, f1, FR_polyC
+      nop.i 0
+};;
+
+.pred.rel "mutex",p14,p15
+{ .mfi
+      nop.m 0
+(p14) fma.s0 FR_ResultC = FR_FirstS, f1, FR_polyS
+      nop.i 0
+}
+{ .mfb
+      cmp.eq  p10, p0 = 0x1, GR_Cis
+(p15) fms.s0 FR_ResultC = FR_FirstS, f1, FR_polyS
+(p10) br.ret.sptk               b0
+};;
+
+
+{ .mmb       // exit for sincosl
+      stfe  [sincos_pResSin] =  FR_ResultS
+      stfe  [sincos_pResCos] =  FR_ResultC
+      br.ret.sptk               b0
+};;
+
+
+
+SINCOSL_SMALL_R:
+//
+// Here if |r| < 2^-3
+//
+// Enter with r, c, and N_Inc computed
+//
+{ .mfi
+      nop.m 0
+      fma.s1 FR_rsq = FR_r, FR_r, f0   // rsq = r * r
+      nop.i 0
+};;
+
+{ .mmi
+      ldfe FR_S_5 = [GR_ad_se], -16    // Load S_5
+      ldfe FR_C_5 = [GR_ad_ce], -16    // Load C_5
+      nop.i 0
+};;
+
+{ .mmi
+      ldfe FR_S_4 = [GR_ad_se], -16    // Load S_4
+      ldfe FR_C_4 = [GR_ad_ce], -16    // Load C_4
+      nop.i 0
+};;
+
+SINCOSL_SMALL_R_0:
+// Entry point for 2^-3 < |x| < pi/4
+SINCOSL_SMALL_R_1:
+// Entry point for pi/4 < |x| < 2^24 and |r| < 2^-3
+{ .mfi
+      ldfe   FR_S_3 = [GR_ad_se], -16    // Load S_3
+      fma.s1 FR_r6  = FR_rsq, FR_rsq, f0 // Z = rsq * rsq
+      tbit.z p7,p11       = GR_N_Inc, 0
+}
+{ .mfi
+      ldfe    FR_C_3 = [GR_ad_ce], -16   // Load C_3
+      nop.f 0
+      and GR_N_SinCos = 0x1, GR_N_Inc
+};;
+
+{ .mfi
+      ldfe   FR_S_2 = [GR_ad_se], -16    // Load S_2
+      fnma.s1 FR_cC = FR_c, FR_r, f0     // c = -c * r
+      sub GR_N_SignS =  GR_N_Inc, GR_N_SinCos
+}
+{ .mfi
+      ldfe   FR_C_2 = [GR_ad_ce], -16    // Load C_2
+      nop.f 0
+      add GR_N_SignC =  GR_N_Inc, GR_N_SinCos
+};;
+
+{ .mmi
+      ldfe FR_S_1 = [GR_ad_se], -16    // Load S_1
+      ldfe FR_C_1 = [GR_ad_ce], -16    // Load C_1
+(p7)  tbit.z.unc p9,p10   = GR_N_SignC, 1
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_r7 = FR_r6, FR_r, f0     // Z = Z * r
+(p7)  tbit.z.unc p7,p8    = GR_N_SignS, 1
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_poly_loS = FR_rsq, FR_S_5, FR_S_4 // poly_lo=rsq*S_5+S_4
+(p11) tbit.z.unc p13,p14  = GR_N_SignC, 1
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_poly_loC = FR_rsq, FR_C_5, FR_C_4 // poly_lo=rsq*C_5+C_4
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_poly_hiS = FR_rsq, FR_S_2, FR_S_1 // poly_hi=rsq*S_2+S_1
+(p11) tbit.z.unc p11,p12  = GR_N_SignS, 1
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_poly_hiC = FR_rsq, FR_C_2, FR_C_1 // poly_hi=rsq*C_2+C_1
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s0 FR_FirstS = FR_r, f1, f0
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s0 FR_FirstC = f1, f1, f0
+      nop.i 0
+};;
+
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_r6 = FR_r6, FR_rsq, f0
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_r7 = FR_r7, FR_rsq, f0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_poly_loS = FR_rsq, FR_poly_loS, FR_S_3 // p_lo=p_lo*rsq+S_3
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_poly_loC = FR_rsq, FR_poly_loC, FR_C_3 // p_lo=p_lo*rsq+C_3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s0 FR_inexact = FR_S_4, FR_S_4, f0     // Dummy op to set inexact
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_poly_hiS = FR_poly_hiS, FR_rsq, f0     // p_hi=p_hi*rsq
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_poly_hiC = FR_poly_hiC, FR_rsq, f0     // p_hi=p_hi*rsq
+      nop.i 0
+};;
+
+.pred.rel "mutex",p8,p14
+{ .mfi
+      nop.m 0
+(p8)  fms.s0 FR_FirstS   = f1, f0, FR_FirstS
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p14) fms.s0 FR_FirstS   = f1, f0, FR_FirstS
+      nop.i 0
+};;
+
+.pred.rel "mutex",p10,p12
+{ .mfi
+      nop.m 0
+(p10) fms.s0 FR_FirstC   = f1, f0, FR_FirstC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p12) fms.s0 FR_FirstC   = f1, f0, FR_FirstC
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_r7, FR_poly_loS, FR_cS        // poly=Z*poly_lo+c
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyC = FR_r6, FR_poly_loC, FR_cC        // poly=Z*poly_lo+c
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_poly_hiS = FR_r, FR_poly_hiS, f0       // p_hi=r*p_hi
+      nop.i 0
+};;
+
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_polyS, f1, FR_poly_hiS
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyC = FR_polyC, f1, FR_poly_hiC
+      nop.i 0
+};;
+
+.pred.rel "mutex",p7,p8
+{ .mfi
+      nop.m 0
+(p7)  fma.s0 FR_ResultS = FR_FirstS, f1, FR_polyS
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p8)  fms.s0 FR_ResultS = FR_FirstS, f1, FR_polyS
+      nop.i 0
+};;
+
+.pred.rel "mutex",p9,p10
+{ .mfi
+      nop.m 0
+(p9)  fma.s0 FR_ResultC = FR_FirstC, f1, FR_polyC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p10) fms.s0 FR_ResultC = FR_FirstC, f1, FR_polyC
+      nop.i 0
+};;
+
+.pred.rel "mutex",p11,p12
+{ .mfi
+      nop.m 0
+(p11) fma.s0 FR_ResultS = FR_FirstC, f1, FR_polyC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p12) fms.s0 FR_ResultS = FR_FirstC, f1, FR_polyC
+      nop.i 0
+};;
+
+.pred.rel "mutex",p13,p14
+{ .mfi
+      nop.m 0
+(p13) fma.s0 FR_ResultC = FR_FirstS, f1, FR_polyS
+      nop.i 0
+}
+{ .mfb
+      cmp.eq  p15, p0 = 0x1, GR_Cis
+(p14) fms.s0 FR_ResultC = FR_FirstS, f1, FR_polyS
+(p15) br.ret.sptk               b0
+};;
+
+
+{ .mmb       // exit for sincosl
+      stfe  [sincos_pResSin] =  FR_ResultS
+      stfe  [sincos_pResCos] =  FR_ResultC
+      br.ret.sptk               b0
+};;
+
+
+
+
+
+
+SINCOSL_NORMAL_R:
+//
+// Here if 2^-3 <= |r| < pi/4
+// THIS IS THE MAIN PATH
+//
+// Enter with r, c, and N_Inc having been computed
+//
+{ .mfi
+      ldfe FR_PP_6 = [GR_ad_pp], 16    // Load PP_6
+      fma.s1 FR_rsq = FR_r, FR_r, f0   // rsq = r * r
+      nop.i 0
+}
+{ .mfi
+      ldfe FR_QQ_6 = [GR_ad_qq], 16    // Load QQ_6
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mmi
+      ldfe FR_PP_5 = [GR_ad_pp], 16    // Load PP_5
+      ldfe FR_QQ_5 = [GR_ad_qq], 16    // Load QQ_5
+      nop.i 0
+};;
+
+
+
+SINCOSL_NORMAL_R_0:
+// Entry for 2^-3 < |x| < pi/4
+.pred.rel "mutex",p9,p10
+{ .mmf
+      ldfe FR_C_1 = [GR_ad_pp], 16     // Load C_1
+      ldfe FR_S_1 = [GR_ad_qq], 16     // Load S_1
+      frcpa.s1 FR_r_hi, p6 = f1, FR_r  // r_hi = frcpa(r)
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_rsq, FR_PP_8, FR_PP_7 // poly = rsq*PP_8+PP_7
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyC = FR_rsq, FR_QQ_8, FR_QQ_7 // poly = rsq*QQ_8+QQ_7
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_r_cubed = FR_r, FR_rsq, f0  // rcubed = r * rsq
+      nop.i 0
+};;
+
+
+SINCOSL_NORMAL_R_1:
+// Entry for pi/4 <= |x| < 2^24
+.pred.rel "mutex",p9,p10
+{ .mmf
+      ldfe FR_PP_1 = [GR_ad_pp], 16             // Load PP_1_hi
+      ldfe FR_QQ_1 = [GR_ad_qq], 16             // Load QQ_1
+      frcpa.s1 FR_r_hi, p6 = f1, FR_r_hi        // r_hi = frpca(frcpa(r))
+};;
+
+{ .mfi
+      ldfe FR_PP_4 = [GR_ad_pp], 16             // Load PP_4
+      fma.s1 FR_polyS = FR_rsq, FR_polyS, FR_PP_6 // poly = rsq*poly+PP_6
+      and GR_N_SinCos = 0x1, GR_N_Inc
+}
+{ .mfi
+      ldfe FR_QQ_4 = [GR_ad_qq], 16             // Load QQ_4
+      fma.s1 FR_polyC = FR_rsq, FR_polyC, FR_QQ_6 // poly = rsq*poly+QQ_6
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_corrS = FR_C_1, FR_rsq, f0       // corr = C_1 * rsq
+      sub GR_N_SignS =  GR_N_Inc, GR_N_SinCos
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_corrC = FR_S_1, FR_r_cubed, FR_r // corr = S_1 * r^3 + r
+      add GR_N_SignC =  GR_N_Inc, GR_N_SinCos
+};;
+
+{ .mfi
+      ldfe FR_PP_3 = [GR_ad_pp], 16             // Load PP_3
+      fma.s1 FR_r_hi_sq = FR_r_hi, FR_r_hi, f0  // r_hi_sq = r_hi * r_hi
+      tbit.z p7,p11       = GR_N_Inc, 0
+}
+{ .mfi
+      ldfe FR_QQ_3 = [GR_ad_qq], 16             // Load QQ_3
+      fms.s1 FR_r_lo = FR_r, f1, FR_r_hi        // r_lo = r - r_hi
+      nop.i 0
+};;
+
+{ .mfi
+      ldfe FR_PP_2 = [GR_ad_pp], 16             // Load PP_2
+      fma.s1 FR_polyS = FR_rsq, FR_polyS, FR_PP_5 // poly = rsq*poly+PP_5
+(p7)  tbit.z.unc p9,p10   = GR_N_SignC, 1
+}
+{ .mfi
+      ldfe FR_QQ_2 = [GR_ad_qq], 16             // Load QQ_2
+      fma.s1 FR_polyC = FR_rsq, FR_polyC, FR_QQ_5 // poly = rsq*poly+QQ_5
+      nop.i 0
+};;
+
+{ .mfi
+      ldfe FR_PP_1_lo = [GR_ad_pp], 16          // Load PP_1_lo
+      fma.s1 FR_corrS = FR_corrS, FR_c, FR_c      // corr = corr * c + c
+(p7)  tbit.z.unc p7,p8    = GR_N_SignS, 1
+}
+{ .mfi
+      nop.m 0
+      fnma.s1 FR_corrC = FR_corrC, FR_c, f0       // corr = -corr * c
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_U_loS = FR_r, FR_r_hi, FR_r_hi_sq // U_lo = r*r_hi+r_hi_sq
+(p11) tbit.z.unc p13,p14  = GR_N_SignC, 1
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_U_loC = FR_r_hi, f1, FR_r        // U_lo = r_hi + r
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_U_hiS = FR_r_hi, FR_r_hi_sq, f0  // U_hi = r_hi*r_hi_sq
+(p11) tbit.z.unc p11,p12  = GR_N_SignS, 1
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_U_hiC = FR_QQ_1, FR_r_hi_sq, f1  // U_hi = QQ_1*r_hi_sq+1
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_rsq, FR_polyS, FR_PP_4 // poly = poly*rsq+PP_4
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyC = FR_rsq, FR_polyC, FR_QQ_4 // poly = poly*rsq+QQ_4
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_U_loS = FR_r, FR_r, FR_U_loS      // U_lo = r * r + U_lo
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_U_loC = FR_r_lo, FR_U_loC, f0     // U_lo = r_lo * U_lo
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_U_hiS = FR_PP_1, FR_U_hiS, f0     // U_hi = PP_1 * U_hi
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_rsq, FR_polyS, FR_PP_3 // poly = poly*rsq+PP_3
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyC = FR_rsq, FR_polyC, FR_QQ_3 // poly = poly*rsq+QQ_3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_U_loS = FR_r_lo, FR_U_loS, f0     // U_lo = r_lo * U_lo
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_U_loC = FR_QQ_1,FR_U_loC, f0      // U_lo = QQ_1 * U_lo
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_U_hiS = FR_r, f1, FR_U_hiS        // U_hi = r + U_hi
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_rsq, FR_polyS, FR_PP_2 // poly = poly*rsq+PP_2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyC = FR_rsq, FR_polyC, FR_QQ_2 // poly = poly*rsq+QQ_2
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_U_loS = FR_PP_1, FR_U_loS, f0     // U_lo = PP_1 * U_lo
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_rsq, FR_polyS, FR_PP_1_lo // poly =poly*rsq+PP1lo
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyC = FR_rsq, FR_polyC, f0      // poly = poly*rsq
+      nop.i 0
+};;
+
+
+.pred.rel "mutex",p8,p14
+{ .mfi
+      nop.m 0
+(p8)  fms.s0 FR_U_hiS   = f1, f0, FR_U_hiS
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p14) fms.s0 FR_U_hiS   = f1, f0, FR_U_hiS
+      nop.i 0
+};;
+
+.pred.rel "mutex",p10,p12
+{ .mfi
+      nop.m 0
+(p10) fms.s0 FR_U_hiC   = f1, f0, FR_U_hiC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p12) fms.s0 FR_U_hiC   = f1, f0, FR_U_hiC
+      nop.i 0
+};;
+
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_VS = FR_U_loS, f1, FR_corrS        // V = U_lo + corr
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_VC = FR_U_loC, f1, FR_corrC        // V = U_lo + corr
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s0 FR_inexact = FR_PP_5, FR_PP_4, f0  // Dummy op to set inexact
+      nop.i 0
+};;
+
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyS = FR_r_cubed, FR_polyS, f0  // poly = poly*r^3
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_polyC = FR_rsq, FR_polyC, f0      // poly = poly*rsq
+      nop.i 0
+};;
+
+
+{ .mfi
+      nop.m 0
+      fma.s1 FR_VS = FR_polyS, f1, FR_VS           // V = poly + V
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1 FR_VC = FR_polyC, f1, FR_VC           // V = poly + V
+      nop.i 0
+};;
+
+
+
+.pred.rel "mutex",p7,p8
+{ .mfi
+      nop.m 0
+(p7)  fma.s0 FR_ResultS = FR_U_hiS, f1, FR_VS
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p8)  fms.s0 FR_ResultS = FR_U_hiS, f1, FR_VS
+      nop.i 0
+};;
+
+.pred.rel "mutex",p9,p10
+{ .mfi
+      nop.m 0
+(p9)  fma.s0 FR_ResultC = FR_U_hiC, f1, FR_VC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p10) fms.s0 FR_ResultC = FR_U_hiC, f1, FR_VC
+      nop.i 0
+};;
+
+
+
+.pred.rel "mutex",p11,p12
+{ .mfi
+      nop.m 0
+(p11) fma.s0 FR_ResultS = FR_U_hiC, f1, FR_VC
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p12) fms.s0 FR_ResultS = FR_U_hiC, f1, FR_VC
+      nop.i 0
+};;
+
+.pred.rel "mutex",p13,p14
+{ .mfi
+      nop.m 0
+(p13) fma.s0 FR_ResultC = FR_U_hiS, f1, FR_VS
+      nop.i 0
+}
+{ .mfb
+      cmp.eq  p15, p0 = 0x1, GR_Cis
+(p14) fms.s0 FR_ResultC = FR_U_hiS, f1, FR_VS
+(p15) br.ret.sptk               b0
+};;
+
+{ .mmb       // exit for sincosl
+      stfe  [sincos_pResSin] =  FR_ResultS
+      stfe  [sincos_pResCos] =  FR_ResultC
+      br.ret.sptk               b0
+};;
+
+
+
+
+
+SINCOSL_ZERO:
+
+{ .mfi
+      nop.m 0
+      fmerge.s FR_ResultS = FR_Input_X, FR_Input_X // If sin, result = input
+      nop.i 0
+}
+{ .mfb
+      cmp.eq  p15, p0 = 0x1, GR_Cis
+      fma.s0 FR_ResultC = f1, f1, f0    // If cos, result=1.0
+(p15) br.ret.sptk               b0
+};;
+
+{ .mmb       // exit for sincosl
+      stfe  [sincos_pResSin] =  FR_ResultS
+      stfe  [sincos_pResCos] =  FR_ResultC
+      br.ret.sptk               b0
+};;
+
+
+SINCOSL_DENORMAL:
+{ .mmb
+      getf.exp GR_signexp_x = FR_norm_x   // Get sign and exponent of x
+      nop.m 999
+      br.cond.sptk  SINCOSL_COMMON2        // Return to common code
+}
+;;
+
+
+SINCOSL_SPECIAL:
+//
+//    Path for Arg = +/- QNaN, SNaN, Inf
+//    Invalid can be raised. SNaNs
+//    become QNaNs
+//
+{ .mfi
+      cmp.eq  p15, p0 = 0x1, GR_Cis
+      fmpy.s0 FR_ResultS = FR_Input_X, f0
+      nop.i 0
+}
+{ .mfb
+      nop.m 0
+      fmpy.s0 FR_ResultC = FR_Input_X, f0
+(p15) br.ret.sptk               b0
+};;
+
+{ .mmb       // exit for sincosl
+      stfe  [sincos_pResSin] =  FR_ResultS
+      stfe  [sincos_pResCos] =  FR_ResultC
+      br.ret.sptk               b0
+};;
+
+GLOBAL_LIBM_END(__libm_sincosl)
+
+
+// *******************************************************************
+// *******************************************************************
+// *******************************************************************
+//
+//     Special Code to handle very large argument case.
+//     Call int __libm_pi_by_2_reduce(x,r,c) for |arguments| >= 2**63
+//     The interface is custom:
+//       On input:
+//         (Arg or x) is in f8
+//       On output:
+//         r is in f8
+//         c is in f9
+//         N is in r8
+//     Be sure to allocate at least 2 GP registers as output registers for
+//     __libm_pi_by_2_reduce.  This routine uses r62-63. These are used as
+//     scratch registers within the __libm_pi_by_2_reduce routine (for speed).
+//
+//     We know also that __libm_pi_by_2_reduce preserves f10-15, f71-127.  We
+//     use this to eliminate save/restore of key fp registers in this calling
+//     function.
+//
+// *******************************************************************
+// *******************************************************************
+// *******************************************************************
+
+LOCAL_LIBM_ENTRY(__libm_callout)
+SINCOSL_ARG_TOO_LARGE:
+.prologue
+{ .mfi
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+};;
+
+{ .mmi
+        setf.exp FR_Two_to_M3 = GR_exp_2_to_m3  // Form 2^-3
+        mov GR_SAVE_GP=gp                       // Save gp
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+
+.body
+//
+//     Call argument reduction with x in f8
+//     Returns with N in r8, r in f8, c in f9
+//     Assumes f71-127 are preserved across the call
+//
+{ .mib
+        setf.exp FR_Neg_Two_to_M3 = GR_exp_m2_to_m3 // Form -(2^-3)
+        nop.i 0
+        br.call.sptk b0=__libm_pi_by_2_reduce#
+};;
+
+{ .mfi
+        mov   GR_N_Inc = r8
+        fcmp.lt.unc.s1  p6, p0 = FR_r, FR_Two_to_M3
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+
+{ .mfi
+        mov   gp = GR_SAVE_GP                  // Restore gp
+(p6)    fcmp.gt.unc.s1  p6, p0 = FR_r, FR_Neg_Two_to_M3
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+};;
+
+{ .mbb
+  nop.m 0
+(p6)    br.cond.spnt SINCOSL_SMALL_R     // Branch if |r|< 2^-3 for |x| >= 2^63
+        br.cond.sptk SINCOSL_NORMAL_R    // Branch if |r|>=2^-3 for |x| >= 2^63
+};;
+
+LOCAL_LIBM_END(__libm_callout)
+
+.type   __libm_pi_by_2_reduce#,@function
+.global __libm_pi_by_2_reduce#
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_support.h
@@ -0,0 +1,1015 @@
+/* file: libm_support.h */
+
+
+/*
+// Copyright (c) 2000 - 2004, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+
+// History: 02/02/2000 Initial version
+//          2/28/2000 added tags for logb and nextafter
+//          3/22/2000 Changes to support _LIB_VERSIONIMF variable
+//                    and filled some enum gaps. Added support for C99.
+//          5/31/2000 added prototypes for __libm_frexp_4l/8l
+//          8/10/2000 Changed declaration of _LIB_VERSIONIMF to work for library
+//                    builds and other application builds (precompiler directives).
+//          8/11/2000 Added pointers-to-matherr-functions declarations to allow
+//                    for user-defined matherr functions in the dll build.
+//         12/07/2000 Added scalbn error_types values.
+//          5/01/2001 Added error_types values for C99 nearest integer
+//                    functions.
+//          6/07/2001 Added error_types values for fdim.
+//          6/18/2001 Added include of complex_support.h.
+//          8/03/2001 Added error_types values for nexttoward, scalbln.
+//          8/23/2001 Corrected tag numbers from 186 and higher.
+//          8/27/2001 Added check for long int and long long int definitions.
+//         12/10/2001 Added error_types for erfc.
+//         12/27/2001 Added error_types for degree argument functions.
+//         01/02/2002 Added error_types for tand, cotd.
+//         01/04/2002 Delete include of complex_support.h
+//         01/23/2002 Deleted prototypes for __libm_frexp*.  Added check for
+//                    multiple int, long int, and long long int definitions.
+//         05/20/2002 Added error_types for cot.
+//         06/27/2002 Added error_types for sinhcosh.
+//         12/05/2002 Added error_types for annuity and compound
+//         04/10/2003 Added error_types for tgammal/tgamma/tgammaf
+//         05/16/2003 FP-treatment macros copied here from IA32 libm_support.h
+//         06/02/2003 Added pad into struct fp80 (12/16 bytes).
+//         08/01/2003 Added struct ker80 and macros for multiprecision addition,
+//                    subtraction, multiplication, division, square root.
+//         08/07/2003 History section updated.
+//         09/03/2003 ALIGN(n) macro added.
+//         10/01/2003 LDOUBLE_ALIGN and fp80 corrected on linux to 16 bytes.
+//         11/24/2004 Added ifdef around definitions of INT32/64
+//         12/15/2004 Added error_types for exp10, nextafter, nexttoward
+//                    underflow.  Moved error codes into libm_error_codes.h.
+//
+*/
+
+#ifndef __LIBM_SUPPORT_H_INCLUDED__
+#define __LIBM_SUPPORT_H_INCLUDED__
+
+#include <math-svid-compat.h>
+
+#ifndef _LIBC
+#if !(defined(_WIN32) || defined(_WIN64))
+# pragma const_seg(".rodata") /* place constant data in text (code) section */
+#endif
+
+#if defined(__ICC) || defined(__ICL) || defined(__ECC) || defined(__ECL)
+# pragma warning( disable : 1682 )	/* #1682: ixplicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem) */
+# pragma warning( disable : 1683 )	/* #1683: explicit conversion of a 64-bit integral type to a smaller integral type (potential portability problem) */
+#endif
+#endif
+
+/* macros to form a double value in hex representation (unsigned int type) */
+
+#define DOUBLE_HEX(hi,lo) 0x##lo,0x##hi /*LITTLE_ENDIAN*/
+
+#include "libm_cpu_defs.h"
+
+#if !(defined (IA64))
+#  include "libm_dll.h"
+#  include "libm_dispatch.h"
+#endif
+
+#include "libm_error_codes.h"
+
+struct exceptionf
+{
+  int type;
+  char *name;
+  float arg1, arg2, retval;
+};
+
+# ifdef __cplusplus
+struct __exception
+{
+  int type;
+  char *name;
+  double arg1, arg2, retval;
+};
+# else
+
+#  ifndef _LIBC
+struct exception
+{
+  int type;
+  char *name;
+  double arg1, arg2, retval;
+};
+#  endif
+# endif
+
+struct exceptionl
+{
+  int type;
+  char *name;
+  long double arg1, arg2, retval;
+};
+
+#if (defined (_MS_) && defined (IA64))
+#define   MATHERR_F   _matherrf
+#define   MATHERR_D   _matherr
+#else
+#define MATHERR_F   matherrf
+#define MATHERR_D   matherr
+#endif
+
+# ifdef __cplusplus
+#define EXC_DECL_D  __exception
+#else
+// exception is a reserved name in C++
+#define EXC_DECL_D  exception
+#endif
+
+extern int MATHERR_F(struct exceptionf*);
+extern int matherrl(struct exceptionl*);
+
+/* memory format definitions (LITTLE_ENDIAN only) */
+
+#if !(defined(SIZE_INT_32) || defined(SIZE_INT_64))
+# error "You need to define SIZE_INT_32 or SIZE_INT_64"
+#endif
+
+#if (defined(SIZE_INT_32) && defined(SIZE_INT_64))
+#error multiple integer size definitions; define SIZE_INT_32 or SIZE_INT_64
+#endif
+
+#if !(defined(SIZE_LONG_32) || defined(SIZE_LONG_64))
+# error "You need to define SIZE_LONG_32 or SIZE_LONG_64"
+#endif
+
+#if (defined(SIZE_LONG_32) && defined(SIZE_LONG_64))
+#error multiple integer size definitions; define SIZE_LONG_32 or SIZE_LONG_64
+#endif
+
+#if !defined(__USE_EXTERNAL_FPMEMTYP_H__)
+
+#define BIAS_32  0x007F
+#define BIAS_64  0x03FF
+#define BIAS_80  0x3FFF
+
+#define MAXEXP_32  0x00FE
+#define MAXEXP_64  0x07FE
+#define MAXEXP_80  0x7FFE
+
+#define EXPINF_32  0x00FF
+#define EXPINF_64  0x07FF
+#define EXPINF_80  0x7FFF
+
+struct fp32 { /*// sign:1 exponent:8 significand:23 (implied leading 1)*/
+#if defined(SIZE_INT_32)
+    unsigned significand:23;
+    unsigned exponent:8;
+    unsigned sign:1;
+#elif defined(SIZE_INT_64)
+    unsigned significand:23;
+    unsigned exponent:8;
+    unsigned sign:1;
+#endif
+};
+
+struct fp64 { /*/ sign:1 exponent:11 significand:52 (implied leading 1)*/
+#if defined(SIZE_INT_32)
+    unsigned lo_significand:32;
+    unsigned hi_significand:20;
+    unsigned exponent:11;
+    unsigned sign:1;
+#elif defined(SIZE_INT_64)
+    unsigned significand:52;
+    unsigned exponent:11;
+    unsigned sign:1;
+#endif
+};
+
+struct fp80 { /*/ sign:1 exponent:15 significand:64 (NO implied bits) */
+#if defined(SIZE_INT_32)
+    unsigned         lo_significand;
+    unsigned         hi_significand;
+    unsigned         exponent:15;
+    unsigned         sign:1;
+#elif defined(SIZE_INT_64)
+    unsigned         significand;
+    unsigned         exponent:15;
+    unsigned         sign:1;
+#endif
+    unsigned         pad:16;
+#if !(defined(__unix__) && defined(__i386__))
+    unsigned         padwin:32;
+#endif
+};
+
+#endif /*__USE_EXTERNAL_FPMEMTYP_H__*/
+
+#if !(defined(opensource))
+typedef          __int32  INT32;
+typedef   signed __int32 SINT32;
+typedef unsigned __int32 UINT32;
+
+typedef          __int64  INT64;
+typedef   signed __int64 SINT64;
+typedef unsigned __int64 UINT64;
+#else
+typedef          int  INT32;
+typedef   signed int SINT32;
+typedef unsigned int UINT32;
+
+typedef          long long  INT64;
+typedef   signed long long SINT64;
+typedef unsigned long long UINT64;
+#endif
+
+#if (defined(_WIN32) || defined(_WIN64))        /* Windows */
+# define I64CONST(bits) 0x##bits##i64
+# define U64CONST(bits) 0x##bits##ui64
+#elif (defined(__linux__) && defined(_M_IA64))  /* Linux,64 */
+# define I64CONST(bits) 0x##bits##L
+# define U64CONST(bits) 0x##bits##uL
+#else                                           /* Linux,32 */
+# define I64CONST(bits) 0x##bits##LL
+# define U64CONST(bits) 0x##bits##uLL
+#endif
+
+struct ker80 {
+    union {
+        long double ldhi;
+        struct fp80 fphi;
+    };
+    union {
+        long double ldlo;
+        struct fp80 fplo;
+    };
+    int ex;
+};
+
+/* Addition: x+y                                            */
+/* The result is sum rhi+rlo                                */
+/* Temporary variables: t1                                  */
+/* All variables are in long double precision               */
+/* Correct if no overflow (algorithm by D.Knuth)           */
+#define __LIBM_ADDL1_K80( rhi,rlo,x,y, t1 )                 \
+    rhi = x   + y;                                          \
+    rlo = rhi - x;                                          \
+    t1  = rhi - rlo;                                        \
+    rlo = y   - rlo;                                        \
+    t1  = x   - t1;                                         \
+    rlo = rlo + t1;
+
+/* Addition: (xhi+xlo) + (yhi+ylo)                          */
+/* The result is sum rhi+rlo                                */
+/* Temporary variables: t1                                  */
+/* All variables are in long double precision               */
+/* Correct if no overflow (algorithm by T.J.Dekker)         */
+#define __LIBM_ADDL2_K80( rhi,rlo,xhi,xlo,yhi,ylo, t1 )     \
+    rlo = xhi+yhi;                                          \
+    if ( VALUE_GT_80(FP80(xhi),FP80(yhi)) ) {               \
+        t1=xhi-rlo;t1=t1+yhi;t1=t1+ylo;t1=t1+xlo;           \
+    } else {                                                \
+        t1=yhi-rlo;t1=t1+xhi;t1=t1+xlo;t1=t1+ylo;           \
+    }                                                       \
+    rhi=rlo+t1;                                             \
+    rlo=rlo-rhi;rlo=rlo+t1;
+
+/* Addition: r=x+y                                          */
+/* Variables r,x,y are pointers to struct ker80,            */
+/* all other variables are in long double precision         */
+/* Temporary variables: t1                                  */
+/* Correct if x and y belong to interval [2^-8000;2^8000],  */
+/* or when one or both of them are zero                     */
+#if   defined(SIZE_INT_32)
+#define __LIBM_ADDL_K80(r,x,y, t1)                          \
+    if ( ((y)->ex+(y)->fphi.exponent-134 <                  \
+          (x)->ex+(x)->fphi.exponent)       &&              \
+         ((x)->ex+(x)->fphi.exponent <                      \
+          (y)->ex+(y)->fphi.exponent+134)   &&              \
+         !SIGNIFICAND_ZERO_80(&((x)->fphi)) &&              \
+         !SIGNIFICAND_ZERO_80(&((y)->fphi)) )               \
+    {                                                       \
+        /* y/2^134 < x < y*2^134,               */          \
+        /* and x,y are nonzero finite numbers   */          \
+        if ( (x)->ex != (y)->ex ) {                         \
+            /* adjust x->ex to y->ex */                     \
+            /* t1 = 2^(x->ex - y->ex) */                    \
+            FP80(t1)->sign = 0;                             \
+            FP80(t1)->exponent = BIAS_80 + (x)->ex-(y)->ex; \
+            /*  exponent is correct because             */  \
+            /*  |x->ex - y->ex| =                       */  \
+            /*  = |  (x->ex + x->fphi.exponent) -       */  \
+            /*      -(y->ex + y->fphi.exponent) +       */  \
+            /*              + y->fphi.exponent  -       */  \
+            /*              - x->fphi.exponent     | <  */  \
+            /*  < |  (x->ex+x->fphi.exponent) -         */  \
+            /*      -(y->ex+y->fphi.exponent)      | +  */  \
+            /*   +|  y->fphi.exponent -                 */  \
+            /*      -x->fphi.exponent              | <  */  \
+            /*  < 134 + 16000                           */  \
+            FP80(t1)->hi_significand = 0x80000000;          \
+            FP80(t1)->lo_significand = 0x00000000;          \
+            (x)->ex = (y)->ex;                              \
+            (x)->ldhi *= t1;                                \
+            (x)->ldlo *= t1;                                \
+        }                                                   \
+        /* r==x+y */                                        \
+        (r)->ex = (y)->ex;                                  \
+        __LIBM_ADDL2_K80( (r)->ldhi,(r)->ldlo,              \
+            (x)->ldhi,(x)->ldlo, (y)->ldhi,(y)->ldlo, t1 ); \
+    } else if ( SIGNIFICAND_ZERO_80(&((x)->fphi)) ||        \
+             ((y)->ex+(y)->fphi.exponent-BIAS_80 - 134 >=   \
+              (x)->ex+(x)->fphi.exponent-BIAS_80) )         \
+    {                                                       \
+        /* |x|<<|y| */                                      \
+        *(r) = *(y);                                        \
+    } else {                                                \
+        /* |y|<<|x| */                                      \
+        *(r) = *(x);                                        \
+    }
+#elif defined(SIZE_INT_64)
+#define __LIBM_ADDL_K80(r,x,y, t1)                          \
+    if ( ((y)->ex+(y)->fphi.exponent-134 <                  \
+          (x)->ex+(x)->fphi.exponent)       &&              \
+         ((x)->ex+(x)->fphi.exponent <                      \
+          (y)->ex+(y)->fphi.exponent+134)   &&              \
+         !SIGNIFICAND_ZERO_80(&((x)->fphi)) &&              \
+         !SIGNIFICAND_ZERO_80(&((y)->fphi)) )               \
+    {                                                       \
+        /* y/2^134 < x < y*2^134,               */          \
+        /* and x,y are nonzero finite numbers   */          \
+        if ( (x)->ex != (y)->ex ) {                         \
+            /* adjust x->ex to y->ex */                     \
+            /* t1 = 2^(x->ex - y->ex) */                    \
+            FP80(t1)->sign = 0;                             \
+            FP80(t1)->exponent = BIAS_80 + (x)->ex-(y)->ex; \
+            /*  exponent is correct because             */  \
+            /*  |x->ex - y->ex| =                       */  \
+            /*  = |  (x->ex + x->fphi.exponent) -       */  \
+            /*      -(y->ex + y->fphi.exponent) +       */  \
+            /*              + y->fphi.exponent  -       */  \
+            /*              - x->fphi.exponent     | <  */  \
+            /*  < |  (x->ex+x->fphi.exponent) -         */  \
+            /*      -(y->ex+y->fphi.exponent)      | +  */  \
+            /*   +|  y->fphi.exponent -                 */  \
+            /*      -x->fphi.exponent              | <  */  \
+            /*  < 134 + 16000                           */  \
+            FP80(t1)->significand = 0x8000000000000000;     \
+            (x)->ex = (y)->ex;                              \
+            (x)->ldhi *= t1;                                \
+            (x)->ldlo *= t1;                                \
+        }                                                   \
+        /* r==x+y */                                        \
+        (r)->ex = (y)->ex;                                  \
+        __LIBM_ADDL2_K80( (r)->ldhi,(r)->ldlo,              \
+            (x)->ldhi,(x)->ldlo, (y)->ldhi,(y)->ldlo, t1 ); \
+    } else if ( SIGNIFICAND_ZERO_80(&((x)->fphi)) ||        \
+             ((y)->ex+(y)->fphi.exponent-BIAS_80 - 134 >=   \
+              (x)->ex+(x)->fphi.exponent-BIAS_80) )         \
+    {                                                       \
+        /* |x|<<|y| */                                      \
+        *(r) = *(y);                                        \
+    } else {                                                \
+        /* |y|<<|x| */                                      \
+        *(r) = *(x);                                        \
+    }
+#endif
+
+/* Addition: r=x+y                                          */
+/* Variables r,x,y are pointers to struct ker80,            */
+/* all other variables are in long double precision         */
+/* Temporary variables: t1                                  */
+/* Correct for any finite x and y                           */
+#define __LIBM_ADDL_NORM_K80(r,x,y, t1)                     \
+    if ( ((x)->fphi.exponent-BIAS_80<-8000) ||              \
+         ((x)->fphi.exponent-BIAS_80>+8000) ||              \
+         ((y)->fphi.exponent-BIAS_80<-8000) ||              \
+         ((y)->fphi.exponent-BIAS_80>+8000) )               \
+    {                                                       \
+        __libm_normalizel_k80(x);                           \
+        __libm_normalizel_k80(y);                           \
+    }                                                       \
+    __LIBM_ADDL_K80(r,x,y, t1)
+
+/* Subtraction: x-y                                         */
+/* The result is sum rhi+rlo                                */
+/* Temporary variables: t1                                  */
+/* All variables are in long double precision               */
+/* Correct if no overflow (algorithm by D.Knuth)           */
+#define __LIBM_SUBL1_K80( rhi, rlo, x, y, t1 )              \
+    rhi = x   - y;                                          \
+    rlo = rhi - x;                                          \
+    t1  = rhi - rlo;                                        \
+    rlo = y   + rlo;                                        \
+    t1  = x   - t1;                                         \
+    rlo = t1  - rlo;
+
+/* Subtraction: (xhi+xlo) - (yhi+ylo)                       */
+/* The result is sum rhi+rlo                                */
+/* Temporary variables: t1                                  */
+/* All variables are in long double precision               */
+/* Correct if no overflow (algorithm by T.J.Dekker)         */
+#define __LIBM_SUBL2_K80( rhi,rlo,xhi,xlo,yhi,ylo, t1 )     \
+    rlo = xhi-yhi;                                          \
+    if ( VALUE_GT_80(FP80(xhi),FP80(yhi)) ) {               \
+        t1=xhi-rlo;t1=t1-yhi;t1=t1-ylo;t1=t1+xlo;           \
+    } else {                                                \
+        t1=yhi+rlo;t1=xhi-t1;t1=t1+xlo;t1=t1-ylo;           \
+    }                                                       \
+    rhi=rlo+t1;                                             \
+    rlo=rlo-rhi;rlo=rlo+t1;
+
+/* Subtraction: r=x-y                                       */
+/* Variables r,x,y are pointers to struct ker80,            */
+/* all other variables are in long double precision         */
+/* Temporary variables: t1                                  */
+/* Correct if x and y belong to interval [2^-8000;2^8000],  */
+/* or when one or both of them are zero                     */
+#if   defined(SIZE_INT_32)
+#define __LIBM_SUBL_K80(r,x,y, t1)                          \
+    if ( ((y)->ex+(y)->fphi.exponent-134 <                  \
+          (x)->ex+(x)->fphi.exponent)       &&              \
+         ((x)->ex+(x)->fphi.exponent <                      \
+          (y)->ex+(y)->fphi.exponent+134)   &&              \
+         !SIGNIFICAND_ZERO_80(&((x)->fphi)) &&              \
+         !SIGNIFICAND_ZERO_80(&((y)->fphi)) )               \
+    {                                                       \
+        /* y/2^134 < x < y*2^134,               */          \
+        /* and x,y are nonzero finite numbers   */          \
+        if ( (x)->ex != (y)->ex ) {                         \
+            /* adjust x->ex to y->ex */                     \
+            /* t1 = 2^(x->ex - y->ex) */                    \
+            FP80(t1)->sign = 0;                             \
+            FP80(t1)->exponent = BIAS_80 + (x)->ex-(y)->ex; \
+            /*  exponent is correct because             */  \
+            /*  |x->ex - y->ex| =                       */  \
+            /*  = |  (x->ex + x->fphi.exponent) -       */  \
+            /*      -(y->ex + y->fphi.exponent) +       */  \
+            /*              + y->fphi.exponent  -       */  \
+            /*              - x->fphi.exponent     | <  */  \
+            /*  < |  (x->ex+x->fphi.exponent) -         */  \
+            /*      -(y->ex+y->fphi.exponent)      | +  */  \
+            /*   +|  y->fphi.exponent -                 */  \
+            /*      -x->fphi.exponent              | <  */  \
+            /*  < 134 + 16000                           */  \
+            FP80(t1)->hi_significand = 0x80000000;          \
+            FP80(t1)->lo_significand = 0x00000000;          \
+            (x)->ex = (y)->ex;                              \
+            (x)->ldhi *= t1;                                \
+            (x)->ldlo *= t1;                                \
+        }                                                   \
+        /* r==x+y */                                        \
+        (r)->ex = (y)->ex;                                  \
+        __LIBM_SUBL2_K80( (r)->ldhi,(r)->ldlo,              \
+            (x)->ldhi,(x)->ldlo, (y)->ldhi,(y)->ldlo, t1 ); \
+    } else if ( SIGNIFICAND_ZERO_80(&((x)->fphi)) ||        \
+             ((y)->ex+(y)->fphi.exponent-BIAS_80 - 134 >=   \
+              (x)->ex+(x)->fphi.exponent-BIAS_80) )         \
+    {                                                       \
+        /* |x|<<|y| */                                      \
+        (r)->ex   =   (y)->ex;                              \
+        (r)->ldhi = -((y)->ldhi);                           \
+        (r)->ldlo = -((y)->ldlo);                           \
+    } else {                                                \
+        /* |y|<<|x| */                                      \
+        *(r) = *(x);                                        \
+    }
+#elif defined(SIZE_INT_64)
+#define __LIBM_SUBL_K80(r,x,y, t1)                          \
+    if ( ((y)->ex+(y)->fphi.exponent-134 <                  \
+          (x)->ex+(x)->fphi.exponent)       &&              \
+         ((x)->ex+(x)->fphi.exponent <                      \
+          (y)->ex+(y)->fphi.exponent+134)   &&              \
+         !SIGNIFICAND_ZERO_80(&((x)->fphi)) &&              \
+         !SIGNIFICAND_ZERO_80(&((y)->fphi)) )               \
+    {                                                       \
+        /* y/2^134 < x < y*2^134,               */          \
+        /* and x,y are nonzero finite numbers   */          \
+        if ( (x)->ex != (y)->ex ) {                         \
+            /* adjust x->ex to y->ex */                     \
+            /* t1 = 2^(x->ex - y->ex) */                    \
+            FP80(t1)->sign = 0;                             \
+            FP80(t1)->exponent = BIAS_80 + (x)->ex-(y)->ex; \
+            /*  exponent is correct because             */  \
+            /*  |x->ex - y->ex| =                       */  \
+            /*  = |  (x->ex + x->fphi.exponent) -       */  \
+            /*      -(y->ex + y->fphi.exponent) +       */  \
+            /*              + y->fphi.exponent  -       */  \
+            /*              - x->fphi.exponent     | <  */  \
+            /*  < |  (x->ex+x->fphi.exponent) -         */  \
+            /*      -(y->ex+y->fphi.exponent)      | +  */  \
+            /*   +|  y->fphi.exponent -                 */  \
+            /*      -x->fphi.exponent              | <  */  \
+            /*  < 134 + 16000                           */  \
+            FP80(t1)->significand = 0x8000000000000000;     \
+            (x)->ex = (y)->ex;                              \
+            (x)->ldhi *= t1;                                \
+            (x)->ldlo *= t1;                                \
+        }                                                   \
+        /* r==x+y */                                        \
+        (r)->ex = (y)->ex;                                  \
+        __LIBM_SUBL2_K80( (r)->ldhi,(r)->ldlo,              \
+            (x)->ldhi,(x)->ldlo, (y)->ldhi,(y)->ldlo, t1 ); \
+    } else if ( SIGNIFICAND_ZERO_80(&((x)->fphi)) ||        \
+             ((y)->ex+(y)->fphi.exponent-BIAS_80 - 134 >=   \
+              (x)->ex+(x)->fphi.exponent-BIAS_80) )         \
+    {                                                       \
+        /* |x|<<|y| */                                      \
+        (r)->ex   =   (y)->ex;                              \
+        (r)->ldhi = -((y)->ldhi);                           \
+        (r)->ldlo = -((y)->ldlo);                           \
+    } else {                                                \
+        /* |y|<<|x| */                                      \
+        *(r) = *(x);                                        \
+    }
+#endif
+
+/* Subtraction: r=x+y                                       */
+/* Variables r,x,y are pointers to struct ker80,            */
+/* all other variables are in long double precision         */
+/* Temporary variables: t1                                  */
+/* Correct for any finite x and y                           */
+#define __LIBM_SUBL_NORM_K80(r,x,y, t1)                     \
+    if ( ((x)->fphi.exponent-BIAS_80<-8000) ||              \
+         ((x)->fphi.exponent-BIAS_80>+8000) ||              \
+         ((y)->fphi.exponent-BIAS_80<-8000) ||              \
+         ((y)->fphi.exponent-BIAS_80>+8000) )               \
+    {                                                       \
+        __libm_normalizel_k80(x);                           \
+        __libm_normalizel_k80(y);                           \
+    }                                                       \
+    __LIBM_SUBL_K80(r,x,y, t1)
+
+/* Multiplication: x*y                                      */
+/* The result is sum rhi+rlo                                */
+/* Here t32 is the constant 2^32+1                          */
+/* Temporary variables: t1,t2,t3,t4,t5,t6                   */
+/* All variables are in long double precision               */
+/* Correct if no over/underflow (algorithm by T.J.Dekker)   */
+#define __LIBM_MULL1_K80(rhi,rlo,x,y,                       \
+                                     t32,t1,t2,t3,t4,t5,t6) \
+    t1=(x)*(t32); t3=x-t1; t3=t3+t1; t4=x-t3;               \
+    t1=(y)*(t32); t5=y-t1; t5=t5+t1; t6=y-t5;               \
+    t1=(t3)*(t5);                                           \
+    t2=(t3)*(t6)+(t4)*(t5);                                 \
+    rhi=t1+t2;                                              \
+    rlo=t1-rhi; rlo=rlo+t2; rlo=rlo+(t4*t6);
+
+/* Multiplication: (xhi+xlo)*(yhi+ylo)                      */
+/* The result is sum rhi+rlo                                */
+/* Here t32 is the constant 2^32+1                          */
+/* Temporary variables: t1,t2,t3,t4,t5,t6,t7,t8             */
+/* All variables are in long double precision               */
+/* Correct if no over/underflow (algorithm by T.J.Dekker)   */
+#define __LIBM_MULL2_K80(rhi,rlo,xhi,xlo,yhi,ylo,           \
+                               t32,t1,t2,t3,t4,t5,t6,t7,t8) \
+    __LIBM_MULL1_K80(t7,t8,xhi,yhi, t32,t1,t2,t3,t4,t5,t6)  \
+    t1=(xhi)*(ylo)+(xlo)*(yhi); t1=t1+t8;                   \
+    rhi=t7+t1;                                              \
+    rlo=t7-rhi; rlo=rlo+t1;
+
+/* Multiplication: r=x*y                                    */
+/* Variables r,x,y are pointers to struct ker80,            */
+/* all other variables are in long double precision         */
+/* Here t32 is the constant 2^32+1                          */
+/* Temporary variables: t1,t2,t3,t4,t5,t6,t7,t8             */
+/* Correct if x and y belong to interval [2^-8000;2^8000]   */
+#define __LIBM_MULL_K80(r,x,y, t32,t1,t2,t3,t4,t5,t6,t7,t8) \
+    (r)->ex = (x)->ex + (y)->ex;                            \
+    __LIBM_MULL2_K80((r)->ldhi,(r)->ldlo,                   \
+        (x)->ldhi,(x)->ldlo,(y)->ldhi,(y)->ldlo,            \
+        t32,t1,t2,t3,t4,t5,t6,t7,t8)
+
+/* Multiplication: r=x*y                                    */
+/* Variables r,x,y are pointers to struct ker80,            */
+/* all other variables are in long double precision         */
+/* Here t32 is the constant 2^32+1                          */
+/* Temporary variables: t1,t2,t3,t4,t5,t6,t7,t8             */
+/* Correct for any finite x and y                           */
+#define __LIBM_MULL_NORM_K80(r,x,y,                         \
+                               t32,t1,t2,t3,t4,t5,t6,t7,t8) \
+    if ( ((x)->fphi.exponent-BIAS_80<-8000) ||              \
+         ((x)->fphi.exponent-BIAS_80>+8000) ||              \
+         ((y)->fphi.exponent-BIAS_80<-8000) ||              \
+         ((y)->fphi.exponent-BIAS_80>+8000) )               \
+    {                                                       \
+        __libm_normalizel_k80(x);                           \
+        __libm_normalizel_k80(y);                           \
+    }                                                       \
+    __LIBM_MULL_K80(r,x,y, t32,t1,t2,t3,t4,t5,t6,t7,t8)
+
+/* Division: (xhi+xlo)/(yhi+ylo)                            */
+/* The result is sum rhi+rlo                                */
+/* Here t32 is the constant 2^32+1                          */
+/* Temporary variables: t1,t2,t3,t4,t5,t6,t7,t8,t9          */
+/* All variables are in long double precision               */
+/* Correct if no over/underflow (algorithm by T.J.Dekker)   */
+#define __LIBM_DIVL2_K80(rhi,rlo,xhi,xlo,yhi,ylo,           \
+                            t32,t1,t2,t3,t4,t5,t6,t7,t8,t9) \
+    t7=(xhi)/(yhi);                                         \
+    __LIBM_MULL1_K80(t8,t9,t7,yhi, t32,t1,t2,t3,t4,t5,t6)   \
+    t1=xhi-t8; t1=t1-t9; t1=t1+xlo; t1=t1-(t7)*(ylo);       \
+    t1=(t1)/(yhi);                                          \
+    rhi=t7+t1;                                              \
+    rlo=t7-rhi; rlo=rlo+t1;
+
+/* Division: r=x/y                                          */
+/* Variables r,x,y are pointers to struct ker80,            */
+/* all other variables are in long double precision         */
+/* Here t32 is the constant 2^32+1                          */
+/* Temporary variables: t1,t2,t3,t4,t5,t6,t7,t8,t9          */
+/* Correct if x and y belong to interval [2^-8000;2^8000]   */
+#define __LIBM_DIVL_K80(r,x,y,                              \
+                            t32,t1,t2,t3,t4,t5,t6,t7,t8,t9) \
+    (r)->ex = (x)->ex - (y)->ex;                            \
+    __LIBM_DIVL2_K80( (r)->ldhi,(r)->ldlo,                  \
+        (x)->ldhi,(x)->ldlo,(y)->ldhi,(y)->ldlo,            \
+        t32,t1,t2,t3,t4,t5,t6,t7,t8,t9)
+
+/* Division: r=x/y                                          */
+/* Variables r,x,y are pointers to struct ker80,            */
+/* all other variables are in long double precision         */
+/* Here t32 is the constant 2^32+1                          */
+/* Temporary variables: t1,t2,t3,t4,t5,t6,t7,t8             */
+/* Correct for any finite x and y                           */
+#define __LIBM_DIVL_NORM_K80(r,x,y,                         \
+                            t32,t1,t2,t3,t4,t5,t6,t7,t8,t9) \
+    if ( ((x)->fphi.exponent-BIAS_80<-8000) ||              \
+         ((x)->fphi.exponent-BIAS_80>+8000) ||              \
+         ((y)->fphi.exponent-BIAS_80<-8000) ||              \
+         ((y)->fphi.exponent-BIAS_80>+8000) )               \
+    {                                                       \
+        __libm_normalizel_k80(x);                           \
+        __libm_normalizel_k80(y);                           \
+    }                                                       \
+    __LIBM_DIVL_K80(r,x,y, t32,t1,t2,t3,t4,t5,t6,t7,t8,t9)
+
+/* Square root: sqrt(xhi+xlo)                               */
+/* The result is sum rhi+rlo                                */
+/* Here t32 is the constant 2^32+1                          */
+/*      half is the constant 0.5                            */
+/* Temporary variables: t1,t2,t3,t4,t5,t6,t7,t8,t9          */
+/* All variables are in long double precision               */
+/* Correct for positive xhi+xlo (algorithm by T.J.Dekker)   */
+#define __LIBM_SQRTL2_NORM_K80(rhi,rlo,xhi,xlo,             \
+                       t32,half,t1,t2,t3,t4,t5,t6,t7,t8,t9) \
+    t7=sqrtl(xhi);                                          \
+    __LIBM_MULL1_K80(t8,t9,t7,t7, t32,t1,t2,t3,t4,t5,t6)    \
+    t1=xhi-t8; t1=t1-t9; t1=t1+xlo; t1=(t1)*(half);         \
+    t1=(t1)/(t7);                                           \
+    rhi=t7+t1;                                              \
+    rlo=t7-rhi; rlo=rlo+t1;
+
+/* Square root: r=sqrt(x)                                   */
+/* Variables r,x,y are pointers to struct ker80,            */
+/* all other variables are in long double precision         */
+/* Here t32 is the constant 2^32+1                          */
+/*      half is the constant 0.5                            */
+/* Temporary variables: t1,t2,t3,t4,t5,t6,t7,t8,t9          */
+/* Correct if x belongs to interval [2^-16000;2^16000]      */
+#define __LIBM_SQRTL_K80(r,x,                               \
+                       t32,half,t1,t2,t3,t4,t5,t6,t7,t8,t9) \
+    if ( ((x)->ex & 1) == 1 ) {                             \
+        (x)->ex    = (x)->ex + 1;                           \
+        (x)->ldhi *= half;                                  \
+        (x)->ldlo *= half;                                  \
+    }                                                       \
+    (r)->ex = (x)->ex >> 1;                                 \
+    __LIBM_SQRTL2_NORM_K80( (r)->ldhi,(r)->ldlo,            \
+        (x)->ldhi,(x)->ldlo,                                \
+        t32,half,t1,t2,t3,t4,t5,t6,t7,t8,t9)
+
+/* Square root: r=sqrt(x)                                   */
+/* Variables r,x,y are pointers to struct ker80,            */
+/* all other variables are in long double precision         */
+/* Here t32 is the constant 2^32+1                          */
+/*      half is the constant 0.5                            */
+/* Temporary variables: t1,t2,t3,t4,t5,t6,t7,t8,t9          */
+/* Correct for any positive x                               */
+#define __LIBM_SQRTL_NORM_K80(r,x,                          \
+                       t32,half,t1,t2,t3,t4,t5,t6,t7,t8,t9) \
+    if ( ((x)->fphi.exponent-BIAS_80<-16000) ||             \
+         ((x)->fphi.exponent-BIAS_80>+16000) )              \
+    {                                                       \
+        __libm_normalizel_k80(x);                           \
+    }                                                       \
+    __LIBM_SQRTL_K80(r,x, t32,half,t1,t2,t3,t4,t5,t6,t7,t8,t9)
+
+
+#ifdef __INTEL_COMPILER
+#define ALIGN(n) __declspec(align(n))
+#else /* __INTEL_COMPILER */
+#define ALIGN(n)
+#endif /* __INTEL_COMPILER */
+
+/* macros to form a long double value in hex representation (unsigned short type) */
+
+#if (defined(__unix__) && defined(__i386__))
+# define LDOUBLE_ALIGN 12	/* IA32 Linux: 12-byte alignment */
+#else	/*__linux__ & IA32*/
+# define LDOUBLE_ALIGN 16	/* EFI2/IA32 Win or IPF Win/Linux: 16-byte alignment */
+#endif	/*__linux__ & IA32*/
+
+#if (LDOUBLE_ALIGN == 16)
+#define _XPD_ ,0x0000,0x0000,0x0000
+#else /*12*/
+#define _XPD_ ,0x0000
+#endif
+
+#define LDOUBLE_HEX(w4,w3,w2,w1,w0) 0x##w0,0x##w1,0x##w2,0x##w3,0x##w4 _XPD_ /*LITTLE_ENDIAN*/
+
+/* macros to sign-expand low 'num' bits of 'val' to native integer */
+
+#if defined(SIZE_INT_32)
+# define SIGN_EXPAND(val,num)  ((int)(val) << (32-(num))) >> (32-(num)) /* sign expand of 'num' LSBs */
+#elif defined(SIZE_INT_64)
+# define SIGN_EXPAND(val,num)  ((int)(val) << (64-(num))) >> (64-(num)) /* sign expand of 'num' LSBs */
+#endif
+
+/* macros to form pointers to FP number on-the-fly */
+
+#define FP32(f)  ((struct fp32 *)&f)
+#define FP64(d)  ((struct fp64 *)&d)
+#define FP80(ld) ((struct fp80 *)&ld)
+
+/* macros to extract signed low and high doubleword of long double */
+
+#if defined(SIZE_INT_32)
+# define HI_DWORD_80(ld) ((((FP80(ld)->sign << 15) | FP80(ld)->exponent) << 16) | \
+                          ((FP80(ld)->hi_significand >> 16) & 0xFFFF))
+# define LO_DWORD_80(ld) SIGN_EXPAND(FP80(ld)->lo_significand, 32)
+#elif defined(SIZE_INT_64)
+# define HI_DWORD_80(ld) ((((FP80(ld)->sign << 15) | FP80(ld)->exponent) << 16) | \
+                          ((FP80(ld)->significand >> 48) & 0xFFFF))
+# define LO_DWORD_80(ld) SIGN_EXPAND(FP80(ld)->significand, 32)
+#endif
+
+/* macros to extract hi bits of significand.
+ * note that explicit high bit do not count (returns as is)
+ */
+
+#if defined(SIZE_INT_32)
+# define HI_SIGNIFICAND_80(X,NBITS) ((X)->hi_significand >> (31 - (NBITS)))
+#elif defined(SIZE_INT_64)
+# define HI_SIGNIFICAND_80(X,NBITS) ((X)->significand >> (63 - (NBITS)))
+#endif
+
+/* macros to check, whether a significand bits are all zero, or some of them are non-zero.
+ * note that SIGNIFICAND_ZERO_80 tests high bit also, but SIGNIFICAND_NONZERO_80 does not
+ */
+
+#define SIGNIFICAND_ZERO_32(X)     ((X)->significand == 0)
+#define SIGNIFICAND_NONZERO_32(X)  ((X)->significand != 0)
+
+#if defined(SIZE_INT_32)
+# define SIGNIFICAND_ZERO_64(X)    (((X)->hi_significand == 0) && ((X)->lo_significand == 0))
+# define SIGNIFICAND_NONZERO_64(X) (((X)->hi_significand != 0) || ((X)->lo_significand != 0))
+#elif defined(SIZE_INT_64)
+# define SIGNIFICAND_ZERO_64(X)    ((X)->significand == 0)
+# define SIGNIFICAND_NONZERO_64(X) ((X)->significand != 0)
+#endif
+
+#if defined(SIZE_INT_32)
+# define SIGNIFICAND_ZERO_80(X)    (((X)->hi_significand == 0x00000000) && ((X)->lo_significand == 0))
+# define SIGNIFICAND_NONZERO_80(X) (((X)->hi_significand != 0x80000000) || ((X)->lo_significand != 0))
+#elif defined(SIZE_INT_64)
+# define SIGNIFICAND_ZERO_80(X)    ((X)->significand == 0x0000000000000000)
+# define SIGNIFICAND_NONZERO_80(X) ((X)->significand != 0x8000000000000000)
+#endif
+
+/* macros to compare long double with constant value, represented as hex */
+
+#define SIGNIFICAND_EQ_HEX_32(X,BITS) ((X)->significand == 0x ## BITS)
+#define SIGNIFICAND_GT_HEX_32(X,BITS) ((X)->significand >  0x ## BITS)
+#define SIGNIFICAND_GE_HEX_32(X,BITS) ((X)->significand >= 0x ## BITS)
+#define SIGNIFICAND_LT_HEX_32(X,BITS) ((X)->significand <  0x ## BITS)
+#define SIGNIFICAND_LE_HEX_32(X,BITS) ((X)->significand <= 0x ## BITS)
+
+#if defined(SIZE_INT_32)
+# define SIGNIFICAND_EQ_HEX_64(X,HI,LO) \
+    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand == 0x ## LO))
+# define SIGNIFICAND_GT_HEX_64(X,HI,LO) (((X)->hi_significand > 0x ## HI) || \
+    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand >  0x ## LO)))
+# define SIGNIFICAND_GE_HEX_64(X,HI,LO) (((X)->hi_significand > 0x ## HI) || \
+    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand >= 0x ## LO)))
+# define SIGNIFICAND_LT_HEX_64(X,HI,LO) (((X)->hi_significand < 0x ## HI) || \
+    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand <  0x ## LO)))
+# define SIGNIFICAND_LE_HEX_64(X,HI,LO) (((X)->hi_significand < 0x ## HI) || \
+    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand <= 0x ## LO)))
+#elif defined(SIZE_INT_64)
+# define SIGNIFICAND_EQ_HEX_64(X,HI,LO) ((X)->significand == 0x ## HI ## LO)
+# define SIGNIFICAND_GT_HEX_64(X,HI,LO) ((X)->significand >  0x ## HI ## LO)
+# define SIGNIFICAND_GE_HEX_64(X,HI,LO) ((X)->significand >= 0x ## HI ## LO)
+# define SIGNIFICAND_LT_HEX_64(X,HI,LO) ((X)->significand <  0x ## HI ## LO)
+# define SIGNIFICAND_LE_HEX_64(X,HI,LO) ((X)->significand <= 0x ## HI ## LO)
+#endif
+
+#if defined(SIZE_INT_32)
+# define SIGNIFICAND_EQ_HEX_80(X,HI,LO) \
+    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand == 0x ## LO))
+# define SIGNIFICAND_GT_HEX_80(X,HI,LO) (((X)->hi_significand > 0x ## HI) || \
+    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand >  0x ## LO)))
+# define SIGNIFICAND_GE_HEX_80(X,HI,LO) (((X)->hi_significand > 0x ## HI) || \
+    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand >= 0x ## LO)))
+# define SIGNIFICAND_LT_HEX_80(X,HI,LO) (((X)->hi_significand < 0x ## HI) || \
+    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand <  0x ## LO)))
+# define SIGNIFICAND_LE_HEX_80(X,HI,LO) (((X)->hi_significand < 0x ## HI) || \
+    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand <= 0x ## LO)))
+#elif defined(SIZE_INT_64)
+# define SIGNIFICAND_EQ_HEX_80(X,HI,LO) ((X)->significand == 0x ## HI ## LO)
+# define SIGNIFICAND_GT_HEX_80(X,HI,LO) ((X)->significand >  0x ## HI ## LO)
+# define SIGNIFICAND_GE_HEX_80(X,HI,LO) ((X)->significand >= 0x ## HI ## LO)
+# define SIGNIFICAND_LT_HEX_80(X,HI,LO) ((X)->significand <  0x ## HI ## LO)
+# define SIGNIFICAND_LE_HEX_80(X,HI,LO) ((X)->significand <= 0x ## HI ## LO)
+#endif
+
+#define VALUE_EQ_HEX_32(X,EXP,BITS) \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_EQ_HEX_32(X, BITS)))
+#define VALUE_GT_HEX_32(X,EXP,BITS) (((X)->exponent > (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_GT_HEX_32(X, BITS))))
+#define VALUE_GE_HEX_32(X,EXP,BITS) (((X)->exponent > (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_GE_HEX_32(X, BITS))))
+#define VALUE_LT_HEX_32(X,EXP,BITS) (((X)->exponent < (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_LT_HEX_32(X, BITS))))
+#define VALUE_LE_HEX_32(X,EXP,BITS) (((X)->exponent < (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_LE_HEX_32(X, BITS))))
+
+#define VALUE_EQ_HEX_64(X,EXP,HI,LO) \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_EQ_HEX_64(X, HI, LO)))
+#define VALUE_GT_HEX_64(X,EXP,HI,LO) (((X)->exponent > (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_GT_HEX_64(X, HI, LO))))
+#define VALUE_GE_HEX_64(X,EXP,HI,LO) (((X)->exponent > (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_GE_HEX_64(X, HI, LO))))
+#define VALUE_LT_HEX_64(X,EXP,HI,LO) (((X)->exponent < (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_LT_HEX_64(X, HI, LO))))
+#define VALUE_LE_HEX_64(X,EXP,HI,LO) (((X)->exponent < (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_LE_HEX_64(X, HI, LO))))
+
+#define VALUE_EQ_HEX_80(X,EXP,HI,LO) \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_EQ_HEX_80(X, HI, LO)))
+#define VALUE_GT_HEX_80(X,EXP,HI,LO) (((X)->exponent > (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_GT_HEX_80(X, HI, LO))))
+#define VALUE_GE_HEX_80(X,EXP,HI,LO) (((X)->exponent > (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_GE_HEX_80(X, HI, LO))))
+#define VALUE_LT_HEX_80(X,EXP,HI,LO) (((X)->exponent < (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_LT_HEX_80(X, HI, LO))))
+#define VALUE_LE_HEX_80(X,EXP,HI,LO) (((X)->exponent < (EXP)) || \
+   (((X)->exponent == (EXP)) && (SIGNIFICAND_LE_HEX_80(X, HI, LO))))
+
+/* macros to compare two long doubles */
+
+#define SIGNIFICAND_EQ_32(X,Y) ((X)->significand == (Y)->significand)
+#define SIGNIFICAND_GT_32(X,Y) ((X)->significand > (Y)->significand)
+#define SIGNIFICAND_GE_32(X,Y) ((X)->significand >= (Y)->significand)
+#define SIGNIFICAND_LT_32(X,Y) ((X)->significand < (Y)->significand)
+#define SIGNIFICAND_LE_32(X,Y) ((X)->significand <= (Y)->significand)
+
+#if defined(SIZE_INT_32)
+# define SIGNIFICAND_EQ_64(X,Y) \
+  (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand == (Y)->lo_significand))
+# define SIGNIFICAND_GT_64(X,Y) (((X)->hi_significand > (Y)->hi_significand) || \
+  (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand >  (Y)->lo_significand)))
+# define SIGNIFICAND_GE_64(X,Y) (((X)->hi_significand > (Y)->hi_significand) || \
+  (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand >= (Y)->lo_significand)))
+# define SIGNIFICAND_LT_64(X,Y) (((X)->hi_significand < (Y)->hi_significand) || \
+  (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand <  (Y)->lo_significand)))
+# define SIGNIFICAND_LE_64(X,Y) (((X)->hi_significand < (Y)->hi_significand) || \
+  (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand <= (Y)->lo_significand)))
+#elif defined(SIZE_INT_64)
+# define SIGNIFICAND_EQ_64(X,Y) ((X)->significand == (Y)->significand)
+# define SIGNIFICAND_GT_64(X,Y) ((X)->significand >  (Y)->significand)
+# define SIGNIFICAND_GE_64(X,Y) ((X)->significand >= (Y)->significand)
+# define SIGNIFICAND_LT_64(X,Y) ((X)->significand <  (Y)->significand)
+# define SIGNIFICAND_LE_64(X,Y) ((X)->significand <= (Y)->significand)
+#endif
+
+#if defined(SIZE_INT_32)
+# define SIGNIFICAND_EQ_80(X,Y) \
+    (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand == (Y)->lo_significand))
+# define SIGNIFICAND_GT_80(X,Y) (((X)->hi_significand > (Y)->hi_significand) || \
+    (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand >  (Y)->lo_significand)))
+# define SIGNIFICAND_GE_80(X,Y) (((X)->hi_significand > (Y)->hi_significand) || \
+    (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand >= (Y)->lo_significand)))
+# define SIGNIFICAND_LT_80(X,Y) (((X)->hi_significand < (Y)->hi_significand) || \
+    (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand <  (Y)->lo_significand)))
+# define SIGNIFICAND_LE_80(X,Y) (((X)->hi_significand < (Y)->hi_significand) || \
+    (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand <= (Y)->lo_significand)))
+#elif defined(SIZE_INT_64)
+# define SIGNIFICAND_EQ_80(X,Y) ((X)->significand == (Y)->significand)
+# define SIGNIFICAND_GT_80(X,Y) ((X)->significand >  (Y)->significand)
+# define SIGNIFICAND_GE_80(X,Y) ((X)->significand >= (Y)->significand)
+# define SIGNIFICAND_LT_80(X,Y) ((X)->significand <  (Y)->significand)
+# define SIGNIFICAND_LE_80(X,Y) ((X)->significand <= (Y)->significand)
+#endif
+
+#define VALUE_EQ_32(X,Y) \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_EQ_32(X, Y)))
+#define VALUE_GT_32(X,Y) (((X)->exponent > (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_GT_32(X, Y))))
+#define VALUE_GE_32(X,Y) (((X)->exponent > (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_GE_32(X, Y))))
+#define VALUE_LT_32(X,Y) (((X)->exponent < (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_LT_32(X, Y))))
+#define VALUE_LE_32(X,Y) (((X)->exponent < (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_LE_32(X, Y))))
+
+#define VALUE_EQ_64(X,Y) \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_EQ_64(X, Y)))
+#define VALUE_GT_64(X,Y) (((X)->exponent > (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_GT_64(X, Y))))
+#define VALUE_GE_64(X,Y) (((X)->exponent > (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_GE_64(X, Y))))
+#define VALUE_LT_64(X,Y) (((X)->exponent < (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_LT_64(X, Y))))
+#define VALUE_LE_64(X,Y) (((X)->exponent < (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_LE_64(X, Y))))
+
+#define VALUE_EQ_80(X,Y) \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_EQ_80(X, Y)))
+#define VALUE_GT_80(X,Y) (((X)->exponent > (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_GT_80(X, Y))))
+#define VALUE_GE_80(X,Y) (((X)->exponent > (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_GE_80(X, Y))))
+#define VALUE_LT_80(X,Y) (((X)->exponent < (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_LT_80(X, Y))))
+#define VALUE_LE_80(X,Y) (((X)->exponent < (Y)->exponent) || \
+   (((X)->exponent == (Y)->exponent) && (SIGNIFICAND_LE_80(X, Y))))
+
+/* add/subtract 1 ulp macros */
+
+#if defined(SIZE_INT_32)
+# define ADD_ULP_80(X) \
+    if ((++(X)->lo_significand == 0) && \
+        (++(X)->hi_significand == (((X)->exponent == 0) ? 0x80000000 : 0))) \
+    { \
+        (X)->hi_significand |= 0x80000000; \
+        ++(X)->exponent; \
+    }
+# define SUB_ULP_80(X) \
+    if (--(X)->lo_significand == 0xFFFFFFFF) { \
+        --(X)->hi_significand; \
+        if (((X)->exponent != 0) && \
+            ((X)->hi_significand == 0x7FFFFFFF) && \
+            (--(X)->exponent != 0)) \
+        { \
+            (X)->hi_significand |= 0x80000000; \
+        } \
+    }
+#elif defined(SIZE_INT_64)
+# define ADD_ULP_80(X) \
+    if (++(X)->significand == (((X)->exponent == 0) ? 0x8000000000000000 : 0))) { \
+        (X)->significand |= 0x8000000000000000; \
+        ++(X)->exponent; \
+    }
+# define SUB_ULP_80(X) \
+    { \
+        --(X)->significand; \
+        if (((X)->exponent != 0) && \
+            ((X)->significand == 0x7FFFFFFFFFFFFFFF) && \
+            (--(X)->exponent != 0)) \
+        { \
+            (X)->significand |= 0x8000000000000000; \
+        } \
+    }
+#endif
+
+
+/* */
+
+#define VOLATILE_32 /*volatile*/
+#define VOLATILE_64 /*volatile*/
+#define VOLATILE_80 /*volatile*/
+
+#define QUAD_TYPE _Quad
+
+#endif    /*__LIBM_SUPPORT_H_INCLUDED__*/
--- /dev/null
+++ a/sysdeps/ia64/fpu/libm_tan.S
@@ -0,0 +1,3330 @@
+.file "libm_tan.s"
+
+// Copyright (C) 2000, 2001, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://developer.intel.com/opensource.
+//
+// *********************************************************************
+//
+// History:
+// 02/02/00 Initial Version
+// 4/04/00  Unwind support added
+// 12/28/00 Fixed false invalid flags
+//
+// *********************************************************************
+//
+// Function:   tan(x) = tangent(x), for double precision x values
+//
+// *********************************************************************
+//
+// Accuracy:       Very accurate for double-precision values
+//
+// *********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8 (Input and Return Value)
+//                              f9-f15
+//                              f32-f112
+//
+//    General Purpose Registers:
+//      r32-r48
+//      r49-r50 (Used to pass arguments to pi_by_2 reduce routine)
+//
+//    Predicate Registers:      p6-p15
+//
+// *********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    Denormal  fault raised on denormal inputs
+//    Overflow exceptions do not occur
+//    Underflow exceptions raised when appropriate for tan
+//    (No specialized error handling for this routine)
+//    Inexact raised when appropriate by algorithm
+//
+//    tan(SNaN) = QNaN
+//    tan(QNaN) = QNaN
+//    tan(inf) = QNaN
+//    tan(+/-0) = +/-0
+//
+// *********************************************************************
+//
+// Mathematical Description
+//
+// We consider the computation of FPTAN of Arg. Now, given
+//
+//      Arg = N pi/2  + alpha,          |alpha| <= pi/4,
+//
+// basic mathematical relationship shows that
+//
+//      tan( Arg ) =  tan( alpha )     if N is even;
+//                 = -cot( alpha )      otherwise.
+//
+// The value of alpha is obtained by argument reduction and
+// represented by two working precision numbers r and c where
+//
+//      alpha =  r  +  c     accurately.
+//
+// The reduction method is described in a previous write up.
+// The argument reduction scheme identifies 4 cases. For Cases 2
+// and 4, because |alpha| is small, tan(r+c) and -cot(r+c) can be
+// computed very easily by 2 or 3 terms of the Taylor series
+// expansion as follows:
+//
+// Case 2:
+// -------
+//
+//      tan(r + c) = r + c + r^3/3          ...accurately
+//        -cot(r + c) = -1/(r+c) + r/3          ...accurately
+//
+// Case 4:
+// -------
+//
+//      tan(r + c) = r + c + r^3/3 + 2r^5/15     ...accurately
+//        -cot(r + c) = -1/(r+c) + r/3 + r^3/45     ...accurately
+//
+//
+// The only cases left are Cases 1 and 3 of the argument reduction
+// procedure. These two cases will be merged since after the
+// argument is reduced in either cases, we have the reduced argument
+// represented as r + c and that the magnitude |r + c| is not small
+// enough to allow the usage of a very short approximation.
+//
+// The greatest challenge of this task is that the second terms of
+// the Taylor series for tan(r) and -cot(r)
+//
+//      r + r^3/3 + 2 r^5/15 + ...
+//
+// and
+//
+//      -1/r + r/3 + r^3/45 + ...
+//
+// are not very small when |r| is close to pi/4 and the rounding
+// errors will be a concern if simple polynomial accumulation is
+// used. When |r| < 2^(-2), however, the second terms will be small
+// enough (5 bits or so of right shift) that a normal Horner
+// recurrence suffices. Hence there are two cases that we consider
+// in the accurate computation of tan(r) and cot(r), |r| <= pi/4.
+//
+// Case small_r: |r| < 2^(-2)
+// --------------------------
+//
+// Since Arg = N pi/4 + r + c accurately, we have
+//
+//      tan(Arg) =  tan(r+c)            for N even,
+//            = -cot(r+c)          otherwise.
+//
+// Here for this case, both tan(r) and -cot(r) can be approximated
+// by simple polynomials:
+//
+//      tan(r) =    r + P1_1 r^3 + P1_2 r^5 + ... + P1_9 r^19
+//        -cot(r) = -1/r + Q1_1 r   + Q1_2 r^3 + ... + Q1_7 r^13
+//
+// accurately. Since |r| is relatively small, tan(r+c) and
+// -cot(r+c) can be accurately approximated by replacing r with
+// r+c only in the first two terms of the corresponding polynomials.
+//
+// Note that P1_1 (and Q1_1 for that matter) approximates 1/3 to
+// almost 64 sig. bits, thus
+//
+//      P1_1 (r+c)^3 =  P1_1 r^3 + c * r^2     accurately.
+//
+// Hence,
+//
+//      tan(r+c) =    r + P1_1 r^3 + P1_2 r^5 + ... + P1_9 r^19
+//                     + c*(1 + r^2)
+//
+//        -cot(r+c) = -1/(r+c) + Q1_1 r   + Q1_2 r^3 + ... + Q1_7 r^13
+//               + Q1_1*c
+//
+//
+// Case normal_r: 2^(-2) <= |r| <= pi/4
+// ------------------------------------
+//
+// This case is more likely than the previous one if one considers
+// r to be uniformly distributed in [-pi/4 pi/4].
+//
+// The required calculation is either
+//
+//      tan(r + c)  =  tan(r)  +  correction,  or
+//        -cot(r + c)  = -cot(r)  +  correction.
+//
+// Specifically,
+//
+//      tan(r + c) =  tan(r) + c tan'(r)  + O(c^2)
+//              =  tan(r) + c sec^2(r) + O(c^2)
+//              =  tan(r) + c SEC_sq     ...accurately
+//                as long as SEC_sq approximates sec^2(r)
+//                to, say, 5 bits or so.
+//
+// Similarly,
+//
+//        -cot(r + c) = -cot(r) - c cot'(r)  + O(c^2)
+//              = -cot(r) + c csc^2(r) + O(c^2)
+//              = -cot(r) + c CSC_sq     ...accurately
+//                as long as CSC_sq approximates csc^2(r)
+//                to, say, 5 bits or so.
+//
+// We therefore concentrate on accurately calculating tan(r) and
+// cot(r) for a working-precision number r, |r| <= pi/4 to within
+// 0.1% or so.
+//
+// We will employ a table-driven approach. Let
+//
+//      r = sgn_r * 2^k * 1.b_1 b_2 ... b_5 ... b_63
+//        = sgn_r * ( B + x )
+//
+// where
+//
+//      B = 2^k * 1.b_1 b_2 ... b_5 1
+//         x = |r| - B
+//
+// Now,
+//                   tan(B)  +   tan(x)
+//      tan( B + x ) =  ------------------------
+//                   1 -  tan(B)*tan(x)
+//
+//               /                         \
+//               |   tan(B)  +   tan(x)          |
+
+//      = tan(B) +  | ------------------------ - tan(B) |
+//               |     1 -  tan(B)*tan(x)          |
+//               \                         /
+//
+//                 sec^2(B) * tan(x)
+//      = tan(B) + ------------------------
+//                 1 -  tan(B)*tan(x)
+//
+//                (1/[sin(B)*cos(B)]) * tan(x)
+//      = tan(B) + --------------------------------
+//                      cot(B)  -  tan(x)
+//
+//
+// Clearly, the values of tan(B), cot(B) and 1/(sin(B)*cos(B)) are
+// calculated beforehand and stored in a table. Since
+//
+//      |x| <= 2^k * 2^(-6)  <= 2^(-7)  (because k = -1, -2)
+//
+// a very short polynomial will be sufficient to approximate tan(x)
+// accurately. The details involved in computing the last expression
+// will be given in the next section on algorithm description.
+//
+//
+// Now, we turn to the case where cot( B + x ) is needed.
+//
+//
+//                   1 - tan(B)*tan(x)
+//      cot( B + x ) =  ------------------------
+//                   tan(B)  +  tan(x)
+//
+//               /                           \
+//               |   1 - tan(B)*tan(x)              |
+
+//      = cot(B) +  | ----------------------- - cot(B) |
+//               |     tan(B)  +  tan(x)            |
+//               \                           /
+//
+//               [tan(B) + cot(B)] * tan(x)
+//      = cot(B) - ----------------------------
+//                   tan(B)  +  tan(x)
+//
+//                (1/[sin(B)*cos(B)]) * tan(x)
+//      = cot(B) - --------------------------------
+//                      tan(B)  +  tan(x)
+//
+//
+// Note that the values of tan(B), cot(B) and 1/(sin(B)*cos(B)) that
+// are needed are the same set of values needed in the previous
+// case.
+//
+// Finally, we can put all the ingredients together as follows:
+//
+//      Arg = N * pi/2 +  r + c          ...accurately
+//
+//      tan(Arg) =  tan(r) + correction    if N is even;
+//            = -cot(r) + correction    otherwise.
+//
+// For Cases 2 and 4,
+//
+//     Case 2:
+//     tan(Arg) =  tan(r + c) = r + c + r^3/3           N even
+//              = -cot(r + c) = -1/(r+c) + r/3           N odd
+//     Case 4:
+//     tan(Arg) =  tan(r + c) = r + c + r^3/3 + 2r^5/15  N even
+//              = -cot(r + c) = -1/(r+c) + r/3 + r^3/45  N odd
+//
+//
+// For Cases 1 and 3,
+//
+//     Case small_r: |r| < 2^(-2)
+//
+//      tan(Arg) =  r + P1_1 r^3 + P1_2 r^5 + ... + P1_9 r^19
+//                     + c*(1 + r^2)               N even
+//
+//                  = -1/(r+c) + Q1_1 r   + Q1_2 r^3 + ... + Q1_7 r^13
+//               + Q1_1*c                    N odd
+//
+//     Case normal_r: 2^(-2) <= |r| <= pi/4
+//
+//      tan(Arg) =  tan(r) + c * sec^2(r)     N even
+//               = -cot(r) + c * csc^2(r)     otherwise
+//
+//     For N even,
+//
+//      tan(Arg) = tan(r) + c*sec^2(r)
+//               = tan( sgn_r * (B+x) ) + c * sec^2(|r|)
+//                  = sgn_r * ( tan(B+x)  + sgn_r*c*sec^2(|r|) )
+//                  = sgn_r * ( tan(B+x)  + sgn_r*c*sec^2(B) )
+//
+// since B approximates |r| to 2^(-6) in relative accuracy.
+//
+//                 /            (1/[sin(B)*cos(B)]) * tan(x)
+//    tan(Arg) = sgn_r * | tan(B) + --------------------------------
+//                 \                     cot(B)  -  tan(x)
+//                                        \
+//                       + CORR  |
+
+//                                     /
+// where
+//
+//    CORR = sgn_r*c*tan(B)*SC_inv(B);  SC_inv(B) = 1/(sin(B)*cos(B)).
+//
+// For N odd,
+//
+//      tan(Arg) = -cot(r) + c*csc^2(r)
+//               = -cot( sgn_r * (B+x) ) + c * csc^2(|r|)
+//                  = sgn_r * ( -cot(B+x)  + sgn_r*c*csc^2(|r|) )
+//                  = sgn_r * ( -cot(B+x)  + sgn_r*c*csc^2(B) )
+//
+// since B approximates |r| to 2^(-6) in relative accuracy.
+//
+//                 /            (1/[sin(B)*cos(B)]) * tan(x)
+//    tan(Arg) = sgn_r * | -cot(B) + --------------------------------
+//                 \                     tan(B)  +  tan(x)
+//                                        \
+//                       + CORR  |
+
+//                                     /
+// where
+//
+//    CORR = sgn_r*c*cot(B)*SC_inv(B);  SC_inv(B) = 1/(sin(B)*cos(B)).
+//
+//
+// The actual algorithm prescribes how all the mathematical formulas
+// are calculated.
+//
+//
+// 2. Algorithmic Description
+// ==========================
+//
+// 2.1 Computation for Cases 2 and 4.
+// ----------------------------------
+//
+// For Case 2, we use two-term polynomials.
+//
+//    For N even,
+//
+//    rsq := r * r
+//    Result := c + r * rsq * P1_1
+//    Result := r + Result          ...in user-defined rounding
+//
+//    For N odd,
+//    S_hi  := -frcpa(r)               ...8 bits
+//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...16 bits
+//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...32 bits
+//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...64 bits
+//    S_lo  := S_hi*( (1 + S_hi*r) + S_hi*c )
+//    ...S_hi + S_lo is -1/(r+c) to extra precision
+//    S_lo  := S_lo + Q1_1*r
+//
+//    Result := S_hi + S_lo     ...in user-defined rounding
+//
+// For Case 4, we use three-term polynomials
+//
+//    For N even,
+//
+//    rsq := r * r
+//    Result := c + r * rsq * (P1_1 + rsq * P1_2)
+//    Result := r + Result          ...in user-defined rounding
+//
+//    For N odd,
+//    S_hi  := -frcpa(r)               ...8 bits
+//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...16 bits
+//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...32 bits
+//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...64 bits
+//    S_lo  := S_hi*( (1 + S_hi*r) + S_hi*c )
+//    ...S_hi + S_lo is -1/(r+c) to extra precision
+//    rsq   := r * r
+//    P      := Q1_1 + rsq*Q1_2
+//    S_lo  := S_lo + r*P
+//
+//    Result := S_hi + S_lo     ...in user-defined rounding
+//
+//
+// Note that the coefficients P1_1, P1_2, Q1_1, and Q1_2 are
+// the same as those used in the small_r case of Cases 1 and 3
+// below.
+//
+//
+// 2.2 Computation for Cases 1 and 3.
+// ----------------------------------
+// This is further divided into the case of small_r,
+// where |r| < 2^(-2), and the case of normal_r, where |r| lies between
+// 2^(-2) and pi/4.
+//
+// Algorithm for the case of small_r
+// ---------------------------------
+//
+// For N even,
+//      rsq   := r * r
+//      Poly1 := rsq*(P1_1 + rsq*(P1_2 + rsq*P1_3))
+//      r_to_the_8    := rsq * rsq
+//      r_to_the_8    := r_to_the_8 * r_to_the_8
+//      Poly2 := P1_4 + rsq*(P1_5 + rsq*(P1_6 + ... rsq*P1_9))
+//      CORR  := c * ( 1 + rsq )
+//      Poly  := Poly1 + r_to_the_8*Poly2
+//      Result := r*Poly + CORR
+//      Result := r + Result     ...in user-defined rounding
+//      ...note that Poly1 and r_to_the_8 can be computed in parallel
+//      ...with Poly2 (Poly1 is intentionally set to be much
+//      ...shorter than Poly2 so that r_to_the_8 and CORR can be hidden)
+//
+// For N odd,
+//      S_hi  := -frcpa(r)               ...8 bits
+//      S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...16 bits
+//      S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...32 bits
+//      S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...64 bits
+//      S_lo  := S_hi*( (1 + S_hi*r) + S_hi*c )
+//      ...S_hi + S_lo is -1/(r+c) to extra precision
+//      S_lo  := S_lo + Q1_1*c
+//
+//      ...S_hi and S_lo are computed in parallel with
+//      ...the following
+//      rsq := r*r
+//      P   := Q1_1 + rsq*(Q1_2 + rsq*(Q1_3 + ... + rsq*Q1_7))
+//
+//      Result :=  r*P + S_lo
+//      Result :=  S_hi  +  Result      ...in user-defined rounding
+//
+//
+// Algorithm for the case of normal_r
+// ----------------------------------
+//
+// Here, we first consider the computation of tan( r + c ). As
+// presented in the previous section,
+//
+//      tan( r + c )  =  tan(r) + c * sec^2(r)
+//                 =  sgn_r * [ tan(B+x) + CORR ]
+//      CORR = sgn_r * c * tan(B) * 1/[sin(B)*cos(B)]
+//
+// because sec^2(r) = sec^(|r|), and B approximate |r| to 6.5 bits.
+//
+//      tan( r + c ) =
+//           /           (1/[sin(B)*cos(B)]) * tan(x)
+//      sgn_r * | tan(B) + --------------------------------  +
+//           \                     cot(B)  -  tan(x)
+//                                \
+//                          CORR  |
+
+//                                /
+//
+// The values of tan(B), cot(B) and 1/(sin(B)*cos(B)) are
+// calculated beforehand and stored in a table. Specifically,
+// the table values are
+//
+//      tan(B)                as  T_hi  +  T_lo;
+//      cot(B)             as  C_hi  +  C_lo;
+//      1/[sin(B)*cos(B)]  as  SC_inv
+//
+// T_hi, C_hi are in  double-precision  memory format;
+// T_lo, C_lo are in  single-precision  memory format;
+// SC_inv     is  in extended-precision memory format.
+//
+// The value of tan(x) will be approximated by a short polynomial of
+// the form
+//
+//      tan(x)  as  x  +  x * P, where
+//           P  =   x^2 * (P2_1 + x^2 * (P2_2 + x^2 * P2_3))
+//
+// Because |x| <= 2^(-7), cot(B) - x approximates cot(B) - tan(x)
+// to a relative accuracy better than 2^(-20). Thus, a good
+// initial guess of 1/( cot(B) - tan(x) ) to initiate the iterative
+// division is:
+//
+//      1/(cot(B) - tan(x))      is approximately
+//      1/(cot(B) -   x)         is
+//      tan(B)/(1 - x*tan(B))    is approximately
+//      T_hi / ( 1 - T_hi * x )  is approximately
+//
+//      T_hi * [ 1 + (Thi * x) + (T_hi * x)^2 ]
+//
+// The calculation of tan(r+c) therefore proceed as follows:
+//
+//      Tx     := T_hi * x
+//      xsq     := x * x
+//
+//      V_hi     := T_hi*(1 + Tx*(1 + Tx))
+//      P     := xsq * (P1_1 + xsq*(P1_2 + xsq*P1_3))
+//      ...V_hi serves as an initial guess of 1/(cot(B) - tan(x))
+//         ...good to about 20 bits of accuracy
+//
+//      tanx     := x + x*P
+//      D     := C_hi - tanx
+//      ...D is a double precision denominator: cot(B) - tan(x)
+//
+//      V_hi     := V_hi + V_hi*(1 - V_hi*D)
+//      ....V_hi approximates 1/(cot(B)-tan(x)) to 40 bits
+//
+//      V_lo     := V_hi * ( [ (1 - V_hi*C_hi) + V_hi*tanx ]
+//                           - V_hi*C_lo )   ...observe all order
+//         ...V_hi + V_lo approximates 1/(cot(B) - tan(x))
+//      ...to extra accuracy
+//
+//      ...               SC_inv(B) * (x + x*P)
+//      ...   tan(B) +      ------------------------- + CORR
+//         ...                cot(B) - (x + x*P)
+//      ...
+//      ... = tan(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
+//      ...
+//
+//      Sx     := SC_inv * x
+//      CORR     := sgn_r * c * SC_inv * T_hi
+//
+//      ...put the ingredients together to compute
+//      ...               SC_inv(B) * (x + x*P)
+//      ...   tan(B) +      ------------------------- + CORR
+//         ...                cot(B) - (x + x*P)
+//      ...
+//      ... = tan(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
+//      ...
+//      ... = T_hi + T_lo + CORR +
+//      ...    Sx * V_hi + Sx * V_lo + Sx * P *(V_hi + V_lo)
+//
+//      CORR := CORR + T_lo
+//      tail := V_lo + P*(V_hi + V_lo)
+//         tail := Sx * tail  +  CORR
+//      tail := Sx * V_hi  +  tail
+//         T_hi := sgn_r * T_hi
+//
+//         ...T_hi + sgn_r*tail  now approximate
+//      ...sgn_r*(tan(B+x) + CORR) accurately
+//
+//      Result :=  T_hi + sgn_r*tail  ...in user-defined
+//                           ...rounding control
+//      ...It is crucial that independent paths be fully
+//      ...exploited for performance's sake.
+//
+//
+// Next, we consider the computation of -cot( r + c ). As
+// presented in the previous section,
+//
+//        -cot( r + c )  =  -cot(r) + c * csc^2(r)
+//                 =  sgn_r * [ -cot(B+x) + CORR ]
+//      CORR = sgn_r * c * cot(B) * 1/[sin(B)*cos(B)]
+//
+// because csc^2(r) = csc^(|r|), and B approximate |r| to 6.5 bits.
+//
+//        -cot( r + c ) =
+//           /             (1/[sin(B)*cos(B)]) * tan(x)
+//      sgn_r * | -cot(B) + --------------------------------  +
+//           \                     tan(B)  +  tan(x)
+//                                \
+//                          CORR  |
+
+//                                /
+//
+// The values of tan(B), cot(B) and 1/(sin(B)*cos(B)) are
+// calculated beforehand and stored in a table. Specifically,
+// the table values are
+//
+//      tan(B)                as  T_hi  +  T_lo;
+//      cot(B)             as  C_hi  +  C_lo;
+//      1/[sin(B)*cos(B)]  as  SC_inv
+//
+// T_hi, C_hi are in  double-precision  memory format;
+// T_lo, C_lo are in  single-precision  memory format;
+// SC_inv     is  in extended-precision memory format.
+//
+// The value of tan(x) will be approximated by a short polynomial of
+// the form
+//
+//      tan(x)  as  x  +  x * P, where
+//           P  =   x^2 * (P2_1 + x^2 * (P2_2 + x^2 * P2_3))
+//
+// Because |x| <= 2^(-7), tan(B) + x approximates tan(B) + tan(x)
+// to a relative accuracy better than 2^(-18). Thus, a good
+// initial guess of 1/( tan(B) + tan(x) ) to initiate the iterative
+// division is:
+//
+//      1/(tan(B) + tan(x))      is approximately
+//      1/(tan(B) +   x)         is
+//      cot(B)/(1 + x*cot(B))    is approximately
+//      C_hi / ( 1 + C_hi * x )  is approximately
+//
+//      C_hi * [ 1 - (C_hi * x) + (C_hi * x)^2 ]
+//
+// The calculation of -cot(r+c) therefore proceed as follows:
+//
+//      Cx     := C_hi * x
+//      xsq     := x * x
+//
+//      V_hi     := C_hi*(1 - Cx*(1 - Cx))
+//      P     := xsq * (P1_1 + xsq*(P1_2 + xsq*P1_3))
+//      ...V_hi serves as an initial guess of 1/(tan(B) + tan(x))
+//         ...good to about 18 bits of accuracy
+//
+//      tanx     := x + x*P
+//      D     := T_hi + tanx
+//      ...D is a double precision denominator: tan(B) + tan(x)
+//
+//      V_hi     := V_hi + V_hi*(1 - V_hi*D)
+//      ....V_hi approximates 1/(tan(B)+tan(x)) to 40 bits
+//
+//      V_lo     := V_hi * ( [ (1 - V_hi*T_hi) - V_hi*tanx ]
+//                           - V_hi*T_lo )   ...observe all order
+//         ...V_hi + V_lo approximates 1/(tan(B) + tan(x))
+//      ...to extra accuracy
+//
+//      ...               SC_inv(B) * (x + x*P)
+//      ...  -cot(B) +      ------------------------- + CORR
+//         ...                tan(B) + (x + x*P)
+//      ...
+//      ... =-cot(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
+//      ...
+//
+//      Sx     := SC_inv * x
+//      CORR     := sgn_r * c * SC_inv * C_hi
+//
+//      ...put the ingredients together to compute
+//      ...               SC_inv(B) * (x + x*P)
+//      ...  -cot(B) +      ------------------------- + CORR
+//         ...                tan(B) + (x + x*P)
+//      ...
+//      ... =-cot(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
+//      ...
+//      ... =-C_hi - C_lo + CORR +
+//      ...    Sx * V_hi + Sx * V_lo + Sx * P *(V_hi + V_lo)
+//
+//      CORR := CORR - C_lo
+//      tail := V_lo + P*(V_hi + V_lo)
+//         tail := Sx * tail  +  CORR
+//      tail := Sx * V_hi  +  tail
+//         C_hi := -sgn_r * C_hi
+//
+//         ...C_hi + sgn_r*tail now approximates
+//      ...sgn_r*(-cot(B+x) + CORR) accurately
+//
+//      Result :=  C_hi + sgn_r*tail   in user-defined rounding control
+//      ...It is crucial that independent paths be fully
+//      ...exploited for performance's sake.
+//
+// 3. Implementation Notes
+// =======================
+//
+//   Table entries T_hi, T_lo; C_hi, C_lo; SC_inv
+//
+//   Recall that 2^(-2) <= |r| <= pi/4;
+//
+//      r = sgn_r * 2^k * 1.b_1 b_2 ... b_63
+//
+//   and
+//
+//        B = 2^k * 1.b_1 b_2 b_3 b_4 b_5 1
+//
+//   Thus, for k = -2, possible values of B are
+//
+//          B = 2^(-2) * ( 1 + index/32  +  1/64 ),
+//      index ranges from 0 to 31
+//
+//   For k = -1, however, since |r| <= pi/4 = 0.78...
+//   possible values of B are
+//
+//        B = 2^(-1) * ( 1 + index/32  +  1/64 )
+//      index ranges from 0 to 19.
+//
+//
+
+#include "libm_support.h"
+
+#ifdef _LIBC
+.rodata
+#else
+.data
+#endif
+
+.align 128
+
+TAN_BASE_CONSTANTS:
+.type TAN_BASE_CONSTANTS, @object
+data4    0x4B800000, 0xCB800000, 0x38800000, 0xB8800000 // two**24, -two**24
+                                                        // two**-14, -two**-14
+data4    0x4E44152A, 0xA2F9836E, 0x00003FFE, 0x00000000 // two_by_pi
+data4    0xCE81B9F1, 0xC84D32B0, 0x00004016, 0x00000000 // P_0
+data4    0x2168C235, 0xC90FDAA2, 0x00003FFF, 0x00000000 // P_1
+data4    0xFC8F8CBB, 0xECE675D1, 0x0000BFBD, 0x00000000 // P_2
+data4    0xACC19C60, 0xB7ED8FBB, 0x0000BF7C, 0x00000000 // P_3
+data4    0x5F000000, 0xDF000000, 0x00000000, 0x00000000 // two_to_63, -two_to_63
+data4    0x6EC6B45A, 0xA397E504, 0x00003FE7, 0x00000000 // Inv_P_0
+data4    0xDBD171A1, 0x8D848E89, 0x0000BFBF, 0x00000000 // d_1
+data4    0x18A66F8E, 0xD5394C36, 0x0000BF7C, 0x00000000 // d_2
+data4    0x2168C234, 0xC90FDAA2, 0x00003FFE, 0x00000000 // PI_BY_4
+data4    0x2168C234, 0xC90FDAA2, 0x0000BFFE, 0x00000000 // MPI_BY_4
+data4    0x3E800000, 0xBE800000, 0x00000000, 0x00000000 // two**-2, -two**-2
+data4    0x2F000000, 0xAF000000, 0x00000000, 0x00000000 // two**-33, -two**-33
+data4    0xAAAAAABD, 0xAAAAAAAA, 0x00003FFD, 0x00000000 // P1_1
+data4    0x88882E6A, 0x88888888, 0x00003FFC, 0x00000000 // P1_2
+data4    0x0F0177B6, 0xDD0DD0DD, 0x00003FFA, 0x00000000 // P1_3
+data4    0x646B8C6D, 0xB327A440, 0x00003FF9, 0x00000000 // P1_4
+data4    0x1D5F7D20, 0x91371B25, 0x00003FF8, 0x00000000 // P1_5
+data4    0x61C67914, 0xEB69A5F1, 0x00003FF6, 0x00000000 // P1_6
+data4    0x019318D2, 0xBEDD37BE, 0x00003FF5, 0x00000000 // P1_7
+data4    0x3C794015, 0x9979B146, 0x00003FF4, 0x00000000 // P1_8
+data4    0x8C6EB58A, 0x8EBD21A3, 0x00003FF3, 0x00000000 // P1_9
+data4    0xAAAAAAB4, 0xAAAAAAAA, 0x00003FFD, 0x00000000 // Q1_1
+data4    0x0B5FC93E, 0xB60B60B6, 0x00003FF9, 0x00000000 // Q1_2
+data4    0x0C9BBFBF, 0x8AB355E0, 0x00003FF6, 0x00000000 // Q1_3
+data4    0xCBEE3D4C, 0xDDEBBC89, 0x00003FF2, 0x00000000 // Q1_4
+data4    0x5F80BBB6, 0xB3548A68, 0x00003FEF, 0x00000000 // Q1_5
+data4    0x4CED5BF1, 0x91362560, 0x00003FEC, 0x00000000 // Q1_6
+data4    0x8EE92A83, 0xF189D95A, 0x00003FE8, 0x00000000 // Q1_7
+data4    0xAAAB362F, 0xAAAAAAAA, 0x00003FFD, 0x00000000 // P2_1
+data4    0xE97A6097, 0x88888886, 0x00003FFC, 0x00000000 // P2_2
+data4    0x25E716A1, 0xDD108EE0, 0x00003FFA, 0x00000000 // P2_3
+//
+//  Entries T_hi   double-precision memory format
+//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
+//  Entries T_lo  single-precision memory format
+//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
+//
+data4    0x62400794, 0x3FD09BC3, 0x23A05C32, 0x00000000
+data4    0xDFFBC074, 0x3FD124A9, 0x240078B2, 0x00000000
+data4    0x5BD4920F, 0x3FD1AE23, 0x23826B8E, 0x00000000
+data4    0x15E2701D, 0x3FD23835, 0x22D31154, 0x00000000
+data4    0x63739C2D, 0x3FD2C2E4, 0x2265C9E2, 0x00000000
+data4    0xAFEEA48B, 0x3FD34E36, 0x245C05EB, 0x00000000
+data4    0x7DBB35D1, 0x3FD3DA31, 0x24749F2D, 0x00000000
+data4    0x67321619, 0x3FD466DA, 0x2462CECE, 0x00000000
+data4    0x1F94A4D5, 0x3FD4F437, 0x246D0DF1, 0x00000000
+data4    0x740C3E6D, 0x3FD5824D, 0x240A85B5, 0x00000000
+data4    0x4CB1E73D, 0x3FD61123, 0x23F96E33, 0x00000000
+data4    0xAD9EA64B, 0x3FD6A0BE, 0x247C5393, 0x00000000
+data4    0xB804FD01, 0x3FD73125, 0x241F3B29, 0x00000000
+data4    0xAB53EE83, 0x3FD7C25E, 0x2479989B, 0x00000000
+data4    0xE6640EED, 0x3FD8546F, 0x23B343BC, 0x00000000
+data4    0xE8AF1892, 0x3FD8E75F, 0x241454D1, 0x00000000
+data4    0x53928BDA, 0x3FD97B35, 0x238613D9, 0x00000000
+data4    0xEB9DE4DE, 0x3FDA0FF6, 0x22859FA7, 0x00000000
+data4    0x99ECF92D, 0x3FDAA5AB, 0x237A6D06, 0x00000000
+data4    0x6D8F1796, 0x3FDB3C5A, 0x23952F6C, 0x00000000
+data4    0x9CFB8BE4, 0x3FDBD40A, 0x2280FC95, 0x00000000
+data4    0x87943100, 0x3FDC6CC3, 0x245D2EC0, 0x00000000
+data4    0xB736C500, 0x3FDD068C, 0x23C4AD7D, 0x00000000
+data4    0xE1DDBC31, 0x3FDDA16D, 0x23D076E6, 0x00000000
+data4    0xEB515A93, 0x3FDE3D6E, 0x244809A6, 0x00000000
+data4    0xE6E9E5F1, 0x3FDEDA97, 0x220856C8, 0x00000000
+data4    0x1963CE69, 0x3FDF78F1, 0x244BE993, 0x00000000
+data4    0x7D635BCE, 0x3FE00C41, 0x23D21799, 0x00000000
+data4    0x1C302CD3, 0x3FE05CAB, 0x248A1B1D, 0x00000000
+data4    0xDB6A1FA0, 0x3FE0ADB9, 0x23D53E33, 0x00000000
+data4    0x4A20BA81, 0x3FE0FF72, 0x24DB9ED5, 0x00000000
+data4    0x153FA6F5, 0x3FE151D9, 0x24E9E451, 0x00000000
+//
+//  Entries T_hi   double-precision memory format
+//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
+//  Entries T_lo  single-precision memory format
+//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
+//
+data4    0xBA1BE39E, 0x3FE1CEC4, 0x24B60F9E, 0x00000000
+data4    0x5ABD9B2D, 0x3FE277E4, 0x248C2474, 0x00000000
+data4    0x0272B110, 0x3FE32418, 0x247B8311, 0x00000000
+data4    0x890E2DF0, 0x3FE3D38B, 0x24C55751, 0x00000000
+data4    0x46236871, 0x3FE4866D, 0x24E5BC34, 0x00000000
+data4    0x45E044B0, 0x3FE53CEE, 0x24001BA4, 0x00000000
+data4    0x82EC06E4, 0x3FE5F742, 0x24B973DC, 0x00000000
+data4    0x25DF43F9, 0x3FE6B5A1, 0x24895440, 0x00000000
+data4    0xCAFD348C, 0x3FE77844, 0x240021CA, 0x00000000
+data4    0xCEED6B92, 0x3FE83F6B, 0x24C45372, 0x00000000
+data4    0xA34F3665, 0x3FE90B58, 0x240DAD33, 0x00000000
+data4    0x2C1E56B4, 0x3FE9DC52, 0x24F846CE, 0x00000000
+data4    0x27041578, 0x3FEAB2A4, 0x2323FB6E, 0x00000000
+data4    0x9DD8C373, 0x3FEB8E9F, 0x24B3090B, 0x00000000
+data4    0x65C9AA7B, 0x3FEC709B, 0x2449F611, 0x00000000
+data4    0xACCF8435, 0x3FED58F4, 0x23616A7E, 0x00000000
+data4    0x97635082, 0x3FEE480F, 0x24C2FEAE, 0x00000000
+data4    0xF0ACC544, 0x3FEF3E57, 0x242CE964, 0x00000000
+data4    0xF7E06E4B, 0x3FF01E20, 0x2480D3EE, 0x00000000
+data4    0x8A798A69, 0x3FF0A125, 0x24DB8967, 0x00000000
+//
+//  Entries C_hi   double-precision memory format
+//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
+//  Entries C_lo  single-precision memory format
+//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
+//
+data4    0xE63EFBD0, 0x400ED3E2, 0x259D94D4, 0x00000000
+data4    0xC515DAB5, 0x400DDDB4, 0x245F0537, 0x00000000
+data4    0xBE19A79F, 0x400CF57A, 0x25D4EA9F, 0x00000000
+data4    0xD15298ED, 0x400C1A06, 0x24AE40A0, 0x00000000
+data4    0x164B2708, 0x400B4A4C, 0x25A5AAB6, 0x00000000
+data4    0x5285B068, 0x400A855A, 0x25524F18, 0x00000000
+data4    0x3FFA549F, 0x4009CA5A, 0x24C999C0, 0x00000000
+data4    0x646AF623, 0x4009188A, 0x254FD801, 0x00000000
+data4    0x6084D0E7, 0x40086F3C, 0x2560F5FD, 0x00000000
+data4    0xA29A76EE, 0x4007CDD2, 0x255B9D19, 0x00000000
+data4    0x6C8ECA95, 0x400733BE, 0x25CB021B, 0x00000000
+data4    0x1F8DDC52, 0x4006A07E, 0x24AB4722, 0x00000000
+data4    0xC298AD58, 0x4006139B, 0x252764E2, 0x00000000
+data4    0xBAD7164B, 0x40058CAB, 0x24DAF5DB, 0x00000000
+data4    0xAE31A5D3, 0x40050B4B, 0x25EA20F4, 0x00000000
+data4    0x89F85A8A, 0x40048F21, 0x2583A3E8, 0x00000000
+data4    0xA862380D, 0x400417DA, 0x25DCC4CC, 0x00000000
+data4    0x1088FCFE, 0x4003A52B, 0x2430A492, 0x00000000
+data4    0xCD3527D5, 0x400336CC, 0x255F77CF, 0x00000000
+data4    0x5760766D, 0x4002CC7F, 0x25DA0BDA, 0x00000000
+data4    0x11CE02E3, 0x40026607, 0x256FF4A2, 0x00000000
+data4    0xD37BBE04, 0x4002032C, 0x25208AED, 0x00000000
+data4    0x7F050775, 0x4001A3BD, 0x24B72DD6, 0x00000000
+data4    0xA554848A, 0x40014789, 0x24AB4DAA, 0x00000000
+data4    0x323E81B7, 0x4000EE65, 0x2584C440, 0x00000000
+data4    0x21CF1293, 0x40009827, 0x25C9428D, 0x00000000
+data4    0x3D415EEB, 0x400044A9, 0x25DC8482, 0x00000000
+data4    0xBD72C577, 0x3FFFE78F, 0x257F5070, 0x00000000
+data4    0x75EFD28E, 0x3FFF4AC3, 0x23EBBF7A, 0x00000000
+data4    0x60B52DDE, 0x3FFEB2AF, 0x22EECA07, 0x00000000
+data4    0x35204180, 0x3FFE1F19, 0x24191079, 0x00000000
+data4    0x54F7E60A, 0x3FFD8FCA, 0x248D3058, 0x00000000
+//
+//  Entries C_hi   double-precision memory format
+//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
+//  Entries C_lo  single-precision memory format
+//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
+//
+data4    0x79F6FADE, 0x3FFCC06A, 0x239C7886, 0x00000000
+data4    0x891662A6, 0x3FFBB91F, 0x250BD191, 0x00000000
+data4    0x529F155D, 0x3FFABFB6, 0x256CC3E6, 0x00000000
+data4    0x2E964AE9, 0x3FF9D300, 0x250843E3, 0x00000000
+data4    0x89DCB383, 0x3FF8F1EF, 0x2277C87E, 0x00000000
+data4    0x7C87DBD6, 0x3FF81B93, 0x256DA6CF, 0x00000000
+data4    0x1042EDE4, 0x3FF74F14, 0x2573D28A, 0x00000000
+data4    0x1784B360, 0x3FF68BAF, 0x242E489A, 0x00000000
+data4    0x7C923C4C, 0x3FF5D0B5, 0x2532D940, 0x00000000
+data4    0xF418EF20, 0x3FF51D88, 0x253C7DD6, 0x00000000
+data4    0x02F88DAE, 0x3FF4719A, 0x23DB59BF, 0x00000000
+data4    0x49DA0788, 0x3FF3CC66, 0x252B4756, 0x00000000
+data4    0x0B980DB8, 0x3FF32D77, 0x23FE585F, 0x00000000
+data4    0xE56C987A, 0x3FF2945F, 0x25378A63, 0x00000000
+data4    0xB16523F6, 0x3FF200BD, 0x247BB2E0, 0x00000000
+data4    0x8CE27778, 0x3FF17235, 0x24446538, 0x00000000
+data4    0xFDEFE692, 0x3FF0E873, 0x2514638F, 0x00000000
+data4    0x33154062, 0x3FF0632C, 0x24A7FC27, 0x00000000
+data4    0xB3EF115F, 0x3FEFC42E, 0x248FD0FE, 0x00000000
+data4    0x135D26F6, 0x3FEEC9E8, 0x2385C719, 0x00000000
+//
+//  Entries SC_inv in Swapped IEEE format (extended)
+//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
+//
+data4    0x1BF30C9E, 0x839D6D4A, 0x00004001, 0x00000000
+data4    0x554B0EB0, 0x80092804, 0x00004001, 0x00000000
+data4    0xA1CF0DE9, 0xF959F94C, 0x00004000, 0x00000000
+data4    0x77378677, 0xF3086BA0, 0x00004000, 0x00000000
+data4    0xCCD4723C, 0xED154515, 0x00004000, 0x00000000
+data4    0x1C27CF25, 0xE7790944, 0x00004000, 0x00000000
+data4    0x8DDACB88, 0xE22D037D, 0x00004000, 0x00000000
+data4    0x89C73522, 0xDD2B2D8A, 0x00004000, 0x00000000
+data4    0xBB2C1171, 0xD86E1A23, 0x00004000, 0x00000000
+data4    0xDFF5E0F9, 0xD3F0E288, 0x00004000, 0x00000000
+data4    0x283BEBD5, 0xCFAF16B1, 0x00004000, 0x00000000
+data4    0x0D88DD53, 0xCBA4AFAA, 0x00004000, 0x00000000
+data4    0xCA67C43D, 0xC7CE03CC, 0x00004000, 0x00000000
+data4    0x0CA0DDB0, 0xC427BC82, 0x00004000, 0x00000000
+data4    0xF13D8CAB, 0xC0AECD57, 0x00004000, 0x00000000
+data4    0x71ECE6B1, 0xBD606C38, 0x00004000, 0x00000000
+data4    0xA44C4929, 0xBA3A0A96, 0x00004000, 0x00000000
+data4    0xE5CCCEC1, 0xB7394F6F, 0x00004000, 0x00000000
+data4    0x9637D8BC, 0xB45C1203, 0x00004000, 0x00000000
+data4    0x92CB051B, 0xB1A05528, 0x00004000, 0x00000000
+data4    0x6BA2FFD0, 0xAF04432B, 0x00004000, 0x00000000
+data4    0x7221235F, 0xAC862A23, 0x00004000, 0x00000000
+data4    0x5F00A9D1, 0xAA2478AF, 0x00004000, 0x00000000
+data4    0x81E082BF, 0xA7DDBB0C, 0x00004000, 0x00000000
+data4    0x45684FEE, 0xA5B0987D, 0x00004000, 0x00000000
+data4    0x627A8F53, 0xA39BD0F5, 0x00004000, 0x00000000
+data4    0x6EC5C8B0, 0xA19E3B03, 0x00004000, 0x00000000
+data4    0x91CD7C66, 0x9FB6C1F0, 0x00004000, 0x00000000
+data4    0x1FA3DF8A, 0x9DE46410, 0x00004000, 0x00000000
+data4    0xA8F6B888, 0x9C263139, 0x00004000, 0x00000000
+data4    0xC27B0450, 0x9A7B4968, 0x00004000, 0x00000000
+data4    0x5EE614EE, 0x98E2DB7E, 0x00004000, 0x00000000
+//
+//  Entries SC_inv in Swapped IEEE format (extended)
+//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
+//
+data4    0x13B2B5BA, 0x969F335C, 0x00004000, 0x00000000
+data4    0xD4C0F548, 0x93D446D9, 0x00004000, 0x00000000
+data4    0x61B798AF, 0x9147094F, 0x00004000, 0x00000000
+data4    0x758787AC, 0x8EF317CC, 0x00004000, 0x00000000
+data4    0xB99EEFDB, 0x8CD498B3, 0x00004000, 0x00000000
+data4    0xDFF8BC37, 0x8AE82A7D, 0x00004000, 0x00000000
+data4    0xE3C55D42, 0x892AD546, 0x00004000, 0x00000000
+data4    0xD15573C1, 0x8799FEA9, 0x00004000, 0x00000000
+data4    0x435A4B4C, 0x86335F88, 0x00004000, 0x00000000
+data4    0x3E93A87B, 0x84F4FB6E, 0x00004000, 0x00000000
+data4    0x80A382FB, 0x83DD1952, 0x00004000, 0x00000000
+data4    0xA4CB8C9E, 0x82EA3D7F, 0x00004000, 0x00000000
+data4    0x6861D0A8, 0x821B247C, 0x00004000, 0x00000000
+data4    0x63E8D244, 0x816EBED1, 0x00004000, 0x00000000
+data4    0x27E4CFC6, 0x80E42D91, 0x00004000, 0x00000000
+data4    0x28E64AFD, 0x807ABF8D, 0x00004000, 0x00000000
+data4    0x863B4FD8, 0x8031EF26, 0x00004000, 0x00000000
+data4    0xAE8C11FD, 0x800960AD, 0x00004000, 0x00000000
+data4    0x5FDBEC21, 0x8000E147, 0x00004000, 0x00000000
+data4    0xA07791FA, 0x80186650, 0x00004000, 0x00000000
+
+Arg                 = f8
+Result              = f8
+fp_tmp              = f9
+U_2                 = f10
+rsq                =  f11
+C_hi                = f12
+C_lo                = f13
+T_hi                = f14
+T_lo                = f15
+
+N_0                 = f32
+d_1                 = f33
+MPI_BY_4            = f34
+tail                = f35
+tanx                = f36
+Cx                  = f37
+Sx                  = f38
+sgn_r               = f39
+CORR                = f40
+P                   = f41
+D                   = f42
+ArgPrime            = f43
+P_0                 = f44
+
+P2_1                = f45
+P2_2                = f46
+P2_3                = f47
+
+P1_1                = f45
+P1_2                = f46
+P1_3                = f47
+
+P1_4                = f48
+P1_5                = f49
+P1_6                = f50
+P1_7                = f51
+P1_8                = f52
+P1_9                = f53
+
+TWO_TO_63           = f54
+NEGTWO_TO_63        = f55
+x                   = f56
+xsq                 = f57
+Tx                  = f58
+Tx1                 = f59
+Set                 = f60
+poly1               = f61
+poly2               = f62
+Poly                = f63
+Poly1               = f64
+Poly2               = f65
+r_to_the_8          = f66
+B                   = f67
+SC_inv              = f68
+Pos_r               = f69
+N_0_fix             = f70
+PI_BY_4             = f71
+NEGTWO_TO_NEG2      = f72
+TWO_TO_24           = f73
+TWO_TO_NEG14        = f74
+TWO_TO_NEG33        = f75
+NEGTWO_TO_24        = f76
+NEGTWO_TO_NEG14     = f76
+NEGTWO_TO_NEG33     = f77
+two_by_PI           = f78
+N                   = f79
+N_fix               = f80
+P_1                 = f81
+P_2                 = f82
+P_3                 = f83
+s_val               = f84
+w                   = f85
+c                   = f86
+r                   = f87
+Z                   = f88
+A                   = f89
+a                   = f90
+t                   = f91
+U_1                 = f92
+d_2                 = f93
+TWO_TO_NEG2         = f94
+Q1_1                = f95
+Q1_2                = f96
+Q1_3                = f97
+Q1_4                = f98
+Q1_5                = f99
+Q1_6                = f100
+Q1_7                = f101
+Q1_8                = f102
+S_hi                = f103
+S_lo                = f104
+V_hi                = f105
+V_lo                = f106
+U_hi                = f107
+U_lo                = f108
+U_hiabs             = f109
+V_hiabs             = f110
+V                   = f111
+Inv_P_0             = f112
+
+GR_SAVE_B0     = r33
+GR_SAVE_GP     = r34
+GR_SAVE_PFS    = r35
+
+delta1         = r36
+table_ptr1     = r37
+table_ptr2     = r38
+i_0            = r39
+i_1            = r40
+N_fix_gr       = r41
+N_inc          = r42
+exp_Arg        = r43
+exp_r          = r44
+sig_r          = r45
+lookup         = r46
+table_offset   = r47
+Create_B       = r48
+gr_tmp         = r49
+
+GR_Parameter_X = r49
+GR_Parameter_r = r50
+
+
+
+.global __libm_tan
+.section .text
+.proc __libm_tan
+
+
+__libm_tan:
+
+{ .mfi
+alloc r32 = ar.pfs, 0,17,2,0
+(p0)   fclass.m.unc  p6,p0 = Arg, 0x1E7
+      addl gr_tmp = -1,r0
+}
+;;
+
+{ .mfi
+       nop.m 999
+(p0)   fclass.nm.unc  p7,p0 = Arg, 0x1FF
+       nop.i 999
+}
+;;
+
+{ .mfi
+(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
+       nop.f 999
+       nop.i 999
+}
+;;
+
+{ .mmi
+      ld8 table_ptr1 = [table_ptr1]
+      setf.sig fp_tmp = gr_tmp   // Make a constant so fmpy produces inexact
+      nop.i 999
+}
+;;
+
+//
+//     Check for NatVals, Infs , NaNs, and Zeros
+//     Check for everything - if false, then must be pseudo-zero
+//     or pseudo-nan.
+//     Local table pointer
+//
+
+{ .mbb
+(p0)   add table_ptr2 = 96, table_ptr1
+(p6)   br.cond.spnt __libm_TAN_SPECIAL
+(p7)   br.cond.spnt __libm_TAN_SPECIAL ;;
+}
+//
+//     Point to Inv_P_0
+//     Branch out to deal with unsupporteds and special values.
+//
+
+{ .mmf
+(p0)   ldfs TWO_TO_24 = [table_ptr1],4
+(p0)   ldfs TWO_TO_63 = [table_ptr2],4
+//
+//     Load -2**24, load -2**63.
+//
+(p0)   fcmp.eq.s0 p0, p6 = Arg, f1 ;;
+}
+
+{ .mfi
+(p0)   ldfs NEGTWO_TO_63 = [table_ptr2],12
+(p0)   fnorm.s1     Arg = Arg
+	nop.i 999
+}
+//
+//     Load 2**24, Load 2**63.
+//
+
+{ .mmi
+(p0)   ldfs NEGTWO_TO_24 = [table_ptr1],12 ;;
+//
+//     Do fcmp to generate Denormal exception
+//     - can't do FNORM (will generate Underflow when U is unmasked!)
+//     Normalize input argument.
+//
+(p0)   ldfe two_by_PI = [table_ptr1],16
+	nop.i 999
+}
+
+{ .mmi
+(p0)   ldfe Inv_P_0 = [table_ptr2],16 ;;
+(p0)   ldfe d_1 = [table_ptr2],16
+	nop.i 999
+}
+//
+//     Decide about the paths to take:
+//     PR_1 and PR_3 set if -2**24 < Arg < 2**24 - CASE 1 OR 2
+//     OTHERWISE - CASE 3 OR 4
+//     Load inverse of P_0 .
+//     Set PR_6 if Arg <= -2**63
+//     Are there any Infs, NaNs, or zeros?
+//
+
+{ .mmi
+(p0)   ldfe P_0 = [table_ptr1],16 ;;
+(p0)   ldfe d_2 = [table_ptr2],16
+	nop.i 999
+}
+//
+//     Set PR_8 if Arg <= -2**24
+//     Set PR_6 if Arg >=  2**63
+//
+
+{ .mmi
+(p0)   ldfe P_1 = [table_ptr1],16 ;;
+(p0)   ldfe PI_BY_4 = [table_ptr2],16
+	nop.i 999
+}
+//
+//     Set PR_8 if Arg >= 2**24
+//
+
+{ .mmi
+(p0)   ldfe P_2 = [table_ptr1],16 ;;
+(p0)   ldfe   MPI_BY_4 = [table_ptr2],16
+	nop.i 999
+}
+//
+//     Load  P_2 and PI_BY_4
+//
+
+{ .mfi
+(p0)   ldfe   P_3 = [table_ptr1],16
+	nop.f 999
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p0)   fcmp.le.unc.s1 p6,p7 = Arg,NEGTWO_TO_63
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p0)   fcmp.le.unc.s1 p8,p9 = Arg,NEGTWO_TO_24
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p7)   fcmp.ge.s1 p6,p0 = Arg,TWO_TO_63
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p9)   fcmp.ge.s1 p8,p0 = Arg,TWO_TO_24
+	nop.i 999 ;;
+}
+
+{ .mib
+	nop.m 999
+	nop.i 999
+//
+//     Load  P_3 and -PI_BY_4
+//
+(p6)   br.cond.spnt TAN_ARG_TOO_LARGE ;;
+}
+
+{ .mib
+	nop.m 999
+	nop.i 999
+//
+//     Load 2**(-2).
+//     Load -2**(-2).
+//     Branch out if we have a special argument.
+//     Branch out if the magnitude of the input argument is too large
+//     - do this branch before the next.
+//
+(p8)   br.cond.spnt TAN_LARGER_ARG ;;
+}
+//
+//     Branch to Cases 3 or 4 if Arg <= -2**24 or Arg >= 2**24
+//
+
+{ .mfi
+(p0)   ldfs TWO_TO_NEG2 = [table_ptr2],4
+//     ARGUMENT REDUCTION CODE - CASE 1 and 2
+//     Load 2**(-2).
+//     Load -2**(-2).
+(p0)   fmpy.s1 N = Arg,two_by_PI
+	nop.i 999 ;;
+}
+
+{ .mfi
+(p0)   ldfs NEGTWO_TO_NEG2 = [table_ptr2],12
+//
+//     N = Arg * 2/pi
+//
+(p0)   fcmp.lt.unc.s1 p8,p9= Arg,PI_BY_4
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     if Arg < pi/4,  set PR_8.
+//
+(p8)   fcmp.gt.s1 p8,p9= Arg,MPI_BY_4
+	nop.i 999 ;;
+}
+//
+//     Case 1: Is |r| < 2**(-2).
+//     Arg is the same as r in this case.
+//     r = Arg
+//     c = 0
+//
+
+{ .mfi
+(p8)   mov N_fix_gr = r0
+//
+//     if Arg > -pi/4, reset PR_8.
+//     Select the case when |Arg| < pi/4 - set PR[8] = true.
+//     Else Select the case when |Arg| >= pi/4 - set PR[9] = true.
+//
+(p0)   fcvt.fx.s1 N_fix = N
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Grab the integer part of N .
+//
+(p8)   mov r = Arg
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p8)   mov c = f0
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p8)   fcmp.lt.unc.s1 p10, p11 = Arg, TWO_TO_NEG2
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p10)  fcmp.gt.s1 p10,p0 = Arg, NEGTWO_TO_NEG2
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Case 2: Place integer part of N in GP register.
+//
+(p9)   fcvt.xf N = N_fix
+	nop.i 999 ;;
+}
+
+{ .mib
+(p9)   getf.sig N_fix_gr = N_fix
+	nop.i 999
+//
+//     Case 2: Convert integer N_fix back to normalized floating-point value.
+//
+(p10)  br.cond.spnt TAN_SMALL_R ;;
+}
+
+{ .mib
+	nop.m 999
+	nop.i 999
+(p8)   br.cond.sptk TAN_NORMAL_R ;;
+}
+//
+//     Case 1: PR_3 is only affected  when PR_1 is set.
+//
+
+{ .mmi
+(p9)   ldfs TWO_TO_NEG33 = [table_ptr2], 4 ;;
+//
+//     Case 2: Load 2**(-33).
+//
+(p9)   ldfs NEGTWO_TO_NEG33 = [table_ptr2], 4
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Case 2: Load -2**(-33).
+//
+(p9)   fnma.s1 s_val = N, P_1, Arg
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p9)   fmpy.s1 w = N, P_2
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Case 2: w = N * P_2
+//     Case 2: s_val = -N * P_1  + Arg
+//
+(p0)   fcmp.lt.unc.s1 p9,p8 = s_val, TWO_TO_NEG33
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Decide between case_1 and case_2 reduce:
+//
+(p9)   fcmp.gt.s1 p9, p8 = s_val, NEGTWO_TO_NEG33
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Case 1_reduce:  s <= -2**(-33) or s >= 2**(-33)
+//     Case 2_reduce: -2**(-33) < s < 2**(-33)
+//
+(p8)   fsub.s1 r = s_val, w
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p9)   fmpy.s1 w = N, P_3
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p9)   fma.s1  U_1 = N, P_2, w
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Case 1_reduce: Is |r| < 2**(-2), if so set PR_10
+//     else set PR_11.
+//
+(p8)   fsub.s1 c = s_val, r
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Case 1_reduce: r = s + w (change sign)
+//     Case 2_reduce: w = N * P_3 (change sign)
+//
+(p8)   fcmp.lt.unc.s1 p10, p11 = r, TWO_TO_NEG2
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p10)  fcmp.gt.s1 p10, p11 = r, NEGTWO_TO_NEG2
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p9)   fsub.s1 r = s_val, U_1
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Case 1_reduce: c is complete here.
+//     c = c + w (w has not been negated.)
+//     Case 2_reduce: r is complete here - continue to calculate c .
+//     r = s - U_1
+//
+(p9)   fms.s1 U_2 = N, P_2, U_1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Case 1_reduce: c = s - r
+//     Case 2_reduce: U_1 = N * P_2 + w
+//
+(p8)   fsub.s1 c = c, w
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p9)   fsub.s1 s_val = s_val, r
+	nop.i 999
+}
+
+{ .mfb
+	nop.m 999
+//
+//     Case 2_reduce:
+//     U_2 = N * P_2 - U_1
+//     Not needed until later.
+//
+(p9)   fadd.s1 U_2 = U_2, w
+//
+//     Case 2_reduce:
+//     s = s - r
+//     U_2 = U_2 + w
+//
+(p10)  br.cond.spnt TAN_SMALL_R ;;
+}
+
+{ .mib
+	nop.m 999
+	nop.i 999
+(p11)  br.cond.sptk TAN_NORMAL_R ;;
+}
+
+{ .mii
+	nop.m 999
+//
+//     Case 2_reduce:
+//     c = c - U_2
+//     c is complete here
+//     Argument reduction ends here.
+//
+(p9)   extr.u i_1 = N_fix_gr, 0, 1 ;;
+(p9)   cmp.eq.unc p11, p12 = 0x0000,i_1 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Is i_1  even or odd?
+//     if i_1 == 0, set p11, else set p12.
+//
+(p11)  fmpy.s1 rsq = r, Z
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12)  frcpa.s1 S_hi,p0 = f1, r
+	nop.i 999
+}
+
+//
+//     Case 1: Branch to SMALL_R or NORMAL_R.
+//     Case 1 is done now.
+//
+
+{ .mfi
+(p9)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
+(p9)   fsub.s1 c = s_val, U_1
+	nop.i 999 ;;
+}
+;;
+
+{ .mmi
+(p9)  ld8 table_ptr1 = [table_ptr1]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+{ .mmi
+(p9)   add table_ptr1 = 224, table_ptr1 ;;
+(p9)   ldfe P1_1 = [table_ptr1],144
+	nop.i 999 ;;
+}
+//
+//     Get [i_1] -  lsb of N_fix_gr .
+//     Load P1_1 and point to Q1_1 .
+//
+
+{ .mfi
+(p9)   ldfe Q1_1 = [table_ptr1] , 0
+//
+//     N even: rsq = r * Z
+//     N odd:  S_hi = frcpa(r)
+//
+(p12)  fmerge.ns S_hi = S_hi, S_hi
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//     Case 2_reduce:
+//     c = s - U_1
+//
+(p9)   fsub.s1 c = c, U_2
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12)  fma.s1  poly1 = S_hi, r, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     N odd:  Change sign of S_hi
+//
+(p11)  fmpy.s1 rsq = rsq, P1_1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12)  fma.s1 S_hi = S_hi, poly1, S_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     N even: rsq = rsq * P1_1
+//     N odd:  poly1 =  1.0 +  S_hi * r    16 bits partial  account for necessary
+//
+(p11)  fma.s1 Result = r, rsq, c
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     N even: Result = c  + r * rsq
+//     N odd:  S_hi  = S_hi + S_hi*poly1  16 bits account for necessary
+//
+(p12)  fma.s1 poly1 = S_hi, r, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     N even: Result = Result + r
+//     N odd:  poly1  = 1.0 + S_hi * r        32 bits partial
+//
+(p11)  fadd.s0 Result = r, Result
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12)  fma.s1  S_hi = S_hi, poly1, S_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     N even: Result1 = Result + r
+//     N odd:   S_hi  = S_hi * poly1 + S_hi   32 bits
+//
+(p12)  fma.s1 poly1 = S_hi, r, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     N odd:  poly1  =  S_hi * r + 1.0       64 bits partial
+//
+(p12)  fma.s1 S_hi = S_hi, poly1, S_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     N odd:  poly1  =  S_hi * poly + 1.0    64 bits
+//
+(p12)  fma.s1 poly1 = S_hi, r, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     N odd:  poly1  =  S_hi * r + 1.0
+//
+(p12)  fma.s1 poly1 = S_hi, c, poly1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     N odd:  poly1  =  S_hi * c + poly1
+//
+(p12)  fmpy.s1 S_lo = S_hi, poly1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//     N odd:  S_lo  =  S_hi *  poly1
+//
+(p12)  fma.s1 S_lo = Q1_1, r, S_lo
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//     N odd:  Result =  S_hi + S_lo
+//
+(p0)   fmpy.s0 fp_tmp = fp_tmp, fp_tmp  // Dummy mult to set inexact
+	nop.i 999 ;;
+}
+
+{ .mfb
+	nop.m 999
+//
+//     N odd:  S_lo  =  S_lo + Q1_1 * r
+//
+(p12)  fadd.s0 Result = S_hi, S_lo
+(p0)   br.ret.sptk b0 ;;
+}
+
+
+TAN_LARGER_ARG:
+
+{ .mmf
+(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
+      nop.m 999
+(p0)  fmpy.s1 N_0 = Arg, Inv_P_0
+}
+;;
+
+//
+// ARGUMENT REDUCTION CODE - CASE 3 and 4
+//
+//
+//    Adjust table_ptr1 to beginning of table.
+//    N_0 = Arg * Inv_P_0
+//
+
+
+{ .mmi
+(p0)  ld8 table_ptr1 = [table_ptr1]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+
+{ .mmi
+(p0)  add table_ptr1 = 8, table_ptr1 ;;
+//
+//    Point to  2*-14
+//
+(p0)  ldfs TWO_TO_NEG14 = [table_ptr1], 4
+	nop.i 999 ;;
+}
+//
+//    Load 2**(-14).
+//
+
+{ .mmi
+(p0)  ldfs NEGTWO_TO_NEG14 = [table_ptr1], 180 ;;
+//
+//    N_0_fix  = integer part of N_0 .
+//    Adjust table_ptr1 to beginning of table.
+//
+(p0)  ldfs TWO_TO_NEG2 = [table_ptr1], 4
+	nop.i 999 ;;
+}
+//
+//    Make N_0 the integer part.
+//
+
+{ .mfi
+(p0)  ldfs NEGTWO_TO_NEG2 = [table_ptr1]
+//
+//    Load -2**(-14).
+//
+(p0)  fcvt.fx.s1 N_0_fix = N_0
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p0)  fcvt.xf N_0 = N_0_fix
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p0)  fnma.s1 ArgPrime = N_0, P_0, Arg
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p0)  fmpy.s1 w = N_0, d_1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    ArgPrime = -N_0 * P_0 + Arg
+//    w  = N_0 * d_1
+//
+(p0)  fmpy.s1 N = ArgPrime, two_by_PI
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N = ArgPrime * 2/pi
+//
+(p0)  fcvt.fx.s1 N_fix = N
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N_fix is the integer part.
+//
+(p0)  fcvt.xf N = N_fix
+	nop.i 999 ;;
+}
+
+{ .mfi
+(p0)  getf.sig N_fix_gr = N_fix
+	nop.f 999
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N is the integer part of the reduced-reduced argument.
+//    Put the integer in a GP register.
+//
+(p0)  fnma.s1 s_val = N, P_1, ArgPrime
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p0)  fnma.s1 w = N, P_2, w
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    s_val = -N*P_1 + ArgPrime
+//    w = -N*P_2 + w
+//
+(p0)  fcmp.lt.unc.s1 p11, p10 = s_val, TWO_TO_NEG14
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p11) fcmp.gt.s1 p11, p10 = s_val, NEGTWO_TO_NEG14
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 3: r = s_val + w (Z complete)
+//    Case 4: U_hi = N_0 * d_1
+//
+(p10) fmpy.s1 V_hi = N, P_2
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p11) fmpy.s1 U_hi = N_0, d_1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 3: r = s_val + w (Z complete)
+//    Case 4: U_hi = N_0 * d_1
+//
+(p11) fmpy.s1 V_hi = N, P_2
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p11) fmpy.s1 U_hi = N_0, d_1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Decide between case 3 and 4:
+//    Case 3:  s <= -2**(-14) or s >= 2**(-14)
+//    Case 4: -2**(-14) < s < 2**(-14)
+//
+(p10) fadd.s1 r = s_val, w
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p11) fmpy.s1 w = N, P_3
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 4: We need abs of both U_hi and V_hi - dont
+//    worry about switched sign of V_hi .
+//
+(p11) fsub.s1 A = U_hi, V_hi
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 4: A =  U_hi + V_hi
+//    Note: Worry about switched sign of V_hi, so subtract instead of add.
+//
+(p11) fnma.s1 V_lo = N, P_2, V_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p11) fms.s1 U_lo = N_0, d_1, U_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p11) fabs V_hiabs = V_hi
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 4: V_hi = N * P_2
+//            w = N * P_3
+//    Note the product does not include the (-) as in the writeup
+//    so (-) missing for V_hi and w .
+(p10) fadd.s1 r = s_val, w
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 3: c = s_val - r
+//    Case 4: U_lo = N_0 * d_1 - U_hi
+//
+(p11) fabs U_hiabs = U_hi
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p11) fmpy.s1 w = N, P_3
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 4: Set P_12 if U_hiabs >= V_hiabs
+//
+(p11) fadd.s1 C_hi = s_val, A
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 4: C_hi = s_val + A
+//
+(p11) fadd.s1 t = U_lo, V_lo
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 3: Is |r| < 2**(-2), if so set PR_7
+//    else set PR_8.
+//    Case 3: If PR_7 is set, prepare to branch to Small_R.
+//    Case 3: If PR_8 is set, prepare to branch to Normal_R.
+//
+(p10) fsub.s1 c = s_val, r
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 3: c = (s - r) + w (c complete)
+//
+(p11) fcmp.ge.unc.s1 p12, p13 = U_hiabs, V_hiabs
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p11) fms.s1 w = N_0, d_2, w
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 4: V_hi = N * P_2
+//            w = N * P_3
+//    Note the product does not include the (-) as in the writeup
+//    so (-) missing for V_hi and w .
+//
+(p10) fcmp.lt.unc.s1 p14, p15 = r, TWO_TO_NEG2
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p14) fcmp.gt.s1 p14, p15 = r, NEGTWO_TO_NEG2
+	nop.i 999 ;;
+}
+
+{ .mfb
+	nop.m 999
+//
+//    Case 4: V_lo = -N * P_2 - V_hi (U_hi is in place of V_hi in writeup)
+//    Note: the (-) is still missing for V_hi .
+//    Case 4: w = w + N_0 * d_2
+//    Note: the (-) is now incorporated in w .
+//
+(p10) fadd.s1 c = c, w
+//
+//    Case 4: t = U_lo + V_lo
+//    Note: remember V_lo should be (-), subtract instead of add. NO
+//
+(p14) br.cond.spnt TAN_SMALL_R ;;
+}
+
+{ .mib
+	nop.m 999
+	nop.i 999
+(p15) br.cond.spnt TAN_NORMAL_R ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 3: Vector off when |r| < 2**(-2).  Recall that PR_3 will be true.
+//    The remaining stuff is for Case 4.
+//
+(p12) fsub.s1 a = U_hi, A
+(p11) extr.u i_1 = N_fix_gr, 0, 1 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 4: C_lo = s_val - C_hi
+//
+(p11) fadd.s1 t = t, w
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p13) fadd.s1 a = V_hi, A
+	nop.i 999 ;;
+}
+
+//
+//    Case 4: a = U_hi - A
+//            a = V_hi - A (do an add to account for missing (-) on V_hi
+//
+
+{ .mfi
+(p11)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
+(p11) fsub.s1 C_lo = s_val, C_hi
+	nop.i 999
+}
+;;
+
+{ .mmi
+(p11) ld8 table_ptr1 = [table_ptr1]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+//
+//    Case 4: a = (U_hi - A)  + V_hi
+//            a = (V_hi - A)  + U_hi
+//    In each case account for negative missing form V_hi .
+//
+//
+//    Case 4: C_lo = (s_val - C_hi) + A
+//
+
+{ .mmi
+(p11) add table_ptr1 = 224, table_ptr1 ;;
+(p11) ldfe P1_1 = [table_ptr1], 16
+	nop.i 999 ;;
+}
+
+{ .mfi
+(p11) ldfe P1_2 = [table_ptr1], 128
+//
+//    Case 4: w = U_lo + V_lo  + w
+//
+(p12) fsub.s1 a = a, V_hi
+	nop.i 999 ;;
+}
+//
+//    Case 4: r = C_hi + C_lo
+//
+
+{ .mfi
+(p11) ldfe Q1_1 = [table_ptr1], 16
+(p11) fadd.s1 C_lo = C_lo, A
+	nop.i 999 ;;
+}
+//
+//    Case 4: c = C_hi - r
+//    Get [i_1] - lsb of N_fix_gr.
+//
+
+{ .mfi
+(p11) ldfe Q1_2 = [table_ptr1], 16
+	nop.f 999
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p13) fsub.s1 a = U_hi, a
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p11) fadd.s1 t = t, a
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 4: t = t + a
+//
+(p11) fadd.s1 C_lo = C_lo, t
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 4: C_lo = C_lo + t
+//
+(p11) fadd.s1 r = C_hi, C_lo
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p11) fsub.s1 c = C_hi, r
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    Case 4: c = c + C_lo  finished.
+//    Is i_1  even or odd?
+//    if i_1 == 0, set PR_4, else set PR_5.
+//
+// r and c have been computed.
+// We known whether this is the sine or cosine routine.
+// Make sure ftz mode is set - should be automatic when using wre
+(p0)  fmpy.s1 rsq = r, r
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p11) fadd.s1 c = c , C_lo
+(p11) cmp.eq.unc p11, p12 =  0x0000, i_1 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) frcpa.s1 S_hi, p0 = f1, r
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd: Change sign of S_hi
+//
+(p11) fma.s1 Result = rsq, P1_2, P1_1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 P = rsq, Q1_2, Q1_1
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd:  Result  =  S_hi + S_lo      (User supplied rounding mode for C1)
+//
+(p0)   fmpy.s0 fp_tmp = fp_tmp, fp_tmp  // Dummy mult to set inexact
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: rsq = r * r
+//    N odd:  S_hi = frcpa(r)
+//
+(p12) fmerge.ns S_hi = S_hi, S_hi
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: rsq = rsq * P1_2 + P1_1
+//    N odd:  poly1 =  1.0 +  S_hi * r    16 bits partial  account for necessary
+//
+(p11) fmpy.s1 Result = rsq, Result
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 poly1 = S_hi, r,f1
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: Result =  Result * rsq
+//    N odd:  S_hi  = S_hi + S_hi*poly1  16 bits account for necessary
+//
+(p11) fma.s1 Result = r, Result, c
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 S_hi = S_hi, poly1, S_hi
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd:   S_hi  = S_hi * poly1 + S_hi   32 bits
+//
+(p11) fadd.s0 Result= r, Result
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 poly1 =  S_hi, r, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: Result = Result * r + c
+//    N odd:  poly1  = 1.0 + S_hi * r        32 bits partial
+//
+(p12) fma.s1 S_hi = S_hi, poly1, S_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 poly1 = S_hi, r, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: Result1 = Result + r  (Rounding mode S0)
+//    N odd:  poly1  =  S_hi * r + 1.0       64 bits partial
+//
+(p12) fma.s1 S_hi = S_hi, poly1, S_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd:  poly1  =  S_hi * poly + S_hi    64 bits
+//
+(p12) fma.s1 poly1 = S_hi, r, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd:  poly1  =  S_hi * r + 1.0
+//
+(p12) fma.s1 poly1 = S_hi, c, poly1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd:  poly1  =  S_hi * c + poly1
+//
+(p12) fmpy.s1 S_lo = S_hi, poly1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd:  S_lo  =  S_hi *  poly1
+//
+(p12) fma.s1 S_lo = P, r, S_lo
+	nop.i 999 ;;
+}
+
+{ .mfb
+	nop.m 999
+//
+//    N odd:  S_lo  =  S_lo + r * P
+//
+(p12) fadd.s0 Result = S_hi, S_lo
+(p0)   br.ret.sptk b0 ;;
+}
+
+
+TAN_SMALL_R:
+
+{ .mii
+	nop.m 999
+(p0)  extr.u i_1 = N_fix_gr, 0, 1 ;;
+(p0)  cmp.eq.unc p11, p12 = 0x0000, i_1
+}
+
+{ .mfi
+	nop.m 999
+(p0)  fmpy.s1 rsq = r, r
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) frcpa.s1 S_hi, p0 = f1, r
+	nop.i 999
+}
+
+{ .mfi
+(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
+        nop.f 999
+        nop.i 999
+}
+;;
+
+{ .mmi
+(p0)  ld8 table_ptr1 = [table_ptr1]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+// *****************************************************************
+// *****************************************************************
+// *****************************************************************
+
+{ .mmi
+(p0)  add table_ptr1 = 224, table_ptr1 ;;
+(p0)  ldfe P1_1 = [table_ptr1], 16
+	nop.i 999 ;;
+}
+//    r and c have been computed.
+//    We known whether this is the sine or cosine routine.
+//    Make sure ftz mode is set - should be automatic when using wre
+//    |r| < 2**(-2)
+
+{ .mfi
+(p0)  ldfe P1_2 = [table_ptr1], 16
+(p11) fmpy.s1 r_to_the_8 = rsq, rsq
+	nop.i 999 ;;
+}
+//
+//    Set table_ptr1 to beginning of constant table.
+//    Get [i_1] - lsb of N_fix_gr.
+//
+
+{ .mfi
+(p0)  ldfe P1_3 = [table_ptr1], 96
+//
+//    N even: rsq = r * r
+//    N odd:  S_hi = frcpa(r)
+//
+(p12) fmerge.ns S_hi = S_hi, S_hi
+	nop.i 999 ;;
+}
+//
+//    Is i_1  even or odd?
+//    if i_1 == 0, set PR_11.
+//    if i_1 != 0, set PR_12.
+//
+
+{ .mfi
+(p11) ldfe P1_9 = [table_ptr1], -16
+//
+//    N even: Poly2 = P1_7 + Poly2 * rsq
+//    N odd:  poly2 = Q1_5 + poly2 * rsq
+//
+(p11) fadd.s1 CORR = rsq, f1
+	nop.i 999 ;;
+}
+
+{ .mmi
+(p11) ldfe P1_8 = [table_ptr1], -16 ;;
+//
+//    N even: Poly1 = P1_2 + P1_3 * rsq
+//    N odd:  poly1 =  1.0 +  S_hi * r
+//    16 bits partial  account for necessary (-1)
+//
+(p11) ldfe P1_7 = [table_ptr1], -16
+	nop.i 999 ;;
+}
+//
+//    N even: Poly1 = P1_1 + Poly1 * rsq
+//    N odd:  S_hi  =  S_hi + S_hi * poly1)     16 bits account for necessary
+//
+
+{ .mfi
+(p11) ldfe P1_6 = [table_ptr1], -16
+//
+//    N even: Poly2 = P1_5 + Poly2 * rsq
+//    N odd:  poly2 = Q1_3 + poly2 * rsq
+//
+(p11) fmpy.s1 r_to_the_8 = r_to_the_8, r_to_the_8
+	nop.i 999 ;;
+}
+//
+//    N even: Poly1 =  Poly1 * rsq
+//    N odd:  poly1  = 1.0 + S_hi * r         32 bits partial
+//
+
+{ .mfi
+(p11) ldfe P1_5 = [table_ptr1], -16
+(p12) fma.s1 poly1 =  S_hi, r, f1
+	nop.i 999 ;;
+}
+//
+//    N even: CORR =  CORR * c
+//    N odd:  S_hi  =  S_hi * poly1 + S_hi    32 bits
+//
+
+//
+//    N even: Poly2 = P1_6 + Poly2 * rsq
+//    N odd:  poly2 = Q1_4 + poly2 * rsq
+//
+{ .mmf
+(p0)  addl           table_ptr2   = @ltoff(TAN_BASE_CONSTANTS), gp
+(p11) ldfe P1_4 = [table_ptr1], -16
+(p11) fmpy.s1 CORR =  CORR, c
+}
+;;
+
+
+{ .mmi
+(p0)  ld8 table_ptr2 = [table_ptr2]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+
+{ .mii
+(p0)  add table_ptr2 = 464, table_ptr2
+	nop.i 999 ;;
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p11) fma.s1 Poly1 = P1_3, rsq, P1_2
+	nop.i 999 ;;
+}
+
+{ .mfi
+(p0)  ldfe Q1_7 = [table_ptr2], -16
+(p12) fma.s1 S_hi = S_hi, poly1, S_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+(p0)  ldfe Q1_6 = [table_ptr2], -16
+(p11) fma.s1 Poly2 = P1_9, rsq, P1_8
+	nop.i 999 ;;
+}
+
+{ .mmi
+(p0)  ldfe Q1_5 = [table_ptr2], -16 ;;
+(p12) ldfe Q1_4 = [table_ptr2], -16
+	nop.i 999 ;;
+}
+
+{ .mfi
+(p12) ldfe Q1_3 = [table_ptr2], -16
+//
+//    N even: Poly2 = P1_8 + P1_9 * rsq
+//    N odd:  poly2 = Q1_6 + Q1_7 * rsq
+//
+(p11) fma.s1 Poly1 = Poly1, rsq, P1_1
+	nop.i 999 ;;
+}
+
+{ .mfi
+(p12) ldfe Q1_2 = [table_ptr2], -16
+(p12) fma.s1 poly1 = S_hi, r, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+(p12) ldfe Q1_1 = [table_ptr2], -16
+(p11) fma.s1 Poly2 = Poly2, rsq, P1_7
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: CORR =  rsq + 1
+//    N even: r_to_the_8 =  rsq * rsq
+//
+(p11) fmpy.s1 Poly1 = Poly1, rsq
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 S_hi = S_hi, poly1, S_hi
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 poly2 = Q1_7, rsq, Q1_6
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p11) fma.s1 Poly2 = Poly2, rsq, P1_6
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 poly1 = S_hi, r, f1
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 poly2 = poly2, rsq, Q1_5
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p11) fma.s1 Poly2= Poly2, rsq, P1_5
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 S_hi =  S_hi, poly1, S_hi
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 poly2 = poly2, rsq, Q1_4
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: r_to_the_8 = r_to_the_8 * r_to_the_8
+//    N odd:  poly1  =  S_hi * r + 1.0       64 bits partial
+//
+(p11) fma.s1 Poly2 = Poly2, rsq, P1_4
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: Result = CORR + Poly * r
+//    N odd:  P = Q1_1 + poly2 * rsq
+//
+(p12) fma.s1 poly1 = S_hi, r, f1
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 poly2 = poly2, rsq, Q1_3
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: Poly2 = P1_4 + Poly2 * rsq
+//    N odd:  poly2 = Q1_2 + poly2 * rsq
+//
+(p11) fma.s1 Poly = Poly2, r_to_the_8, Poly1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 poly1 = S_hi, c, poly1
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 poly2 = poly2, rsq, Q1_2
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: Poly = Poly1 + Poly2 * r_to_the_8
+//    N odd:  S_hi =  S_hi * poly1 + S_hi    64 bits
+//
+(p11) fma.s1 Result = Poly, r, CORR
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: Result =  r + Result  (User supplied rounding mode)
+//    N odd:  poly1  =  S_hi * c + poly1
+//
+(p12) fmpy.s1 S_lo = S_hi, poly1
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fma.s1 P = poly2, rsq, Q1_1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd:  poly1  =  S_hi * r + 1.0
+//
+(p11) fadd.s0 Result = Result, r
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd:  S_lo  =  S_hi *  poly1
+//
+(p12) fma.s1 S_lo = Q1_1, c, S_lo
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd:  Result = Result + S_hi  (user supplied rounding mode)
+//
+(p0)   fmpy.s0 fp_tmp = fp_tmp, fp_tmp  // Dummy mult to set inexact
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd:  S_lo  =  Q1_1 * c + S_lo
+//
+(p12) fma.s1 Result = P, r, S_lo
+	nop.i 999 ;;
+}
+
+{ .mfb
+	nop.m 999
+//
+//    N odd:  Result =  S_lo + r * P
+//
+(p12) fadd.s0 Result = Result, S_hi
+(p0)   br.ret.sptk b0 ;;
+}
+
+
+TAN_NORMAL_R:
+
+{ .mfi
+(p0)  getf.sig sig_r = r
+// *******************************************************************
+// *******************************************************************
+// *******************************************************************
+//
+//    r and c have been computed.
+//    Make sure ftz mode is set - should be automatic when using wre
+//
+//
+//    Get [i_1] -  lsb of N_fix_gr alone.
+//
+(p0)  fmerge.s  Pos_r = f1, r
+(p0)  extr.u i_1 = N_fix_gr, 0, 1 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p0)  fmerge.s  sgn_r =  r, f1
+(p0)  cmp.eq.unc p11, p12 = 0x0000, i_1 ;;
+}
+
+{ .mfi
+	nop.m 999
+	nop.f 999
+(p0)  extr.u lookup = sig_r, 58, 5
+}
+
+{ .mlx
+	nop.m 999
+(p0)  movl Create_B = 0x8200000000000000 ;;
+}
+
+{ .mfi
+(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
+	nop.f 999
+(p0)  dep Create_B = lookup, Create_B, 58, 5
+}
+;;
+
+//
+//    Get [i_1] -  lsb of N_fix_gr alone.
+//    Pos_r = abs (r)
+//
+
+
+{ .mmi
+      ld8 table_ptr1 = [table_ptr1]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+
+{ .mmi
+	nop.m 999
+(p0)  setf.sig B = Create_B
+//
+//    Set table_ptr1 and table_ptr2 to base address of
+//    constant table.
+//
+(p0)  add table_ptr1 = 480, table_ptr1 ;;
+}
+
+{ .mmb
+	nop.m 999
+//
+//    Is i_1 or i_0  == 0 ?
+//    Create the constant  1 00000 1000000000000000000000...
+//
+(p0)  ldfe P2_1 = [table_ptr1], 16
+	nop.b 999
+}
+
+{ .mmi
+	nop.m 999 ;;
+(p0)  getf.exp exp_r = Pos_r
+	nop.i 999
+}
+//
+//    Get r's exponent
+//    Get r's significand
+//
+
+{ .mmi
+(p0)  ldfe P2_2 = [table_ptr1], 16 ;;
+//
+//    Get the 5 bits or r for the lookup.   1.xxxxx ....
+//    from sig_r.
+//    Grab  lsb of exp of B
+//
+(p0)  ldfe P2_3 = [table_ptr1], 16
+	nop.i 999 ;;
+}
+
+{ .mii
+	nop.m 999
+(p0)  andcm table_offset = 0x0001, exp_r ;;
+(p0)  shl table_offset = table_offset, 9 ;;
+}
+
+{ .mii
+	nop.m 999
+//
+//    Deposit   0 00000 1000000000000000000000... on
+//              1 xxxxx yyyyyyyyyyyyyyyyyyyyyy...,
+//    getting rid of the ys.
+//    Is  B = 2** -2 or  B= 2** -1? If 2**-1, then
+//    we want an offset of 512 for table addressing.
+//
+(p0)  shladd table_offset = lookup, 4, table_offset ;;
+//
+//    B =  ........ 1xxxxx 1000000000000000000...
+//
+(p0)  add table_ptr1 = table_ptr1, table_offset ;;
+}
+
+{ .mmb
+	nop.m 999
+//
+//   B =  ........ 1xxxxx 1000000000000000000...
+//   Convert B so it has the same exponent as Pos_r
+//
+(p0)  ldfd T_hi = [table_ptr1], 8
+	nop.b 999 ;;
+}
+
+//
+//    x = |r| - B
+//    Load T_hi.
+//    Load C_hi.
+//
+
+{ .mmf
+(p0)  addl           table_ptr2   = @ltoff(TAN_BASE_CONSTANTS), gp
+(p0)  ldfs T_lo = [table_ptr1]
+(p0)  fmerge.se B = Pos_r, B
+}
+;;
+
+{ .mmi
+      ld8 table_ptr2 = [table_ptr2]
+      nop.m 999
+      nop.i 999
+}
+;;
+
+{ .mii
+(p0)  add table_ptr2 = 1360, table_ptr2
+	nop.i 999 ;;
+(p0)  add table_ptr2 = table_ptr2, table_offset ;;
+}
+
+{ .mfi
+(p0)  ldfd C_hi = [table_ptr2], 8
+(p0)  fsub.s1 x = Pos_r, B
+	nop.i 999 ;;
+}
+
+{ .mii
+(p0)  ldfs C_lo = [table_ptr2],255
+	nop.i 999 ;;
+//
+//    xsq = x * x
+//    N even: Tx = T_hi * x
+//    Load T_lo.
+//    Load C_lo - increment pointer to get SC_inv
+//    - cant get all the way, do an add later.
+//
+(p0)  add table_ptr2 = 569, table_ptr2 ;;
+}
+//
+//    N even: Tx1 = Tx + 1
+//    N odd:  Cx1 = 1 - Cx
+//
+
+{ .mfi
+(p0)  ldfe SC_inv = [table_ptr2], 0
+	nop.f 999
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p0)  fmpy.s1 xsq = x, x
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p11) fmpy.s1 Tx = T_hi, x
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fmpy.s1 Cx = C_hi, x
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd: Cx = C_hi * x
+//
+(p0)  fma.s1 P = P2_3, xsq, P2_2
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even and odd: P = P2_3 + P2_2 * xsq
+//
+(p11) fadd.s1 Tx1 = Tx, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: D = C_hi - tanx
+//    N odd: D = T_hi + tanx
+//
+(p11) fmpy.s1 CORR = SC_inv, T_hi
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p0)  fmpy.s1 Sx = SC_inv, x
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fmpy.s1 CORR = SC_inv, C_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fsub.s1 V_hi = f1, Cx
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p0)  fma.s1 P = P, xsq, P2_1
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even and odd: P = P2_1 + P * xsq
+//
+(p11) fma.s1 V_hi = Tx, Tx1, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: Result  = sgn_r * tail + T_hi (user rounding mode for C1)
+//    N odd:  Result  = sgn_r * tail + C_hi (user rounding mode for C1)
+//
+(p0)   fmpy.s0 fp_tmp = fp_tmp, fp_tmp  // Dummy mult to set inexact
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p0)  fmpy.s1 CORR = CORR, c
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fnma.s1 V_hi = Cx,V_hi,f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: V_hi = Tx * Tx1 + 1
+//    N odd: Cx1 = 1 - Cx * Cx1
+//
+(p0)  fmpy.s1 P = P, xsq
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even and odd: P = P * xsq
+//
+(p11) fmpy.s1 V_hi = V_hi, T_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even and odd: tail = P * tail + V_lo
+//
+(p11) fmpy.s1 T_hi = sgn_r, T_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p0)  fmpy.s1 CORR = CORR, sgn_r
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+(p12) fmpy.s1 V_hi = V_hi,C_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: V_hi = T_hi * V_hi
+//    N odd: V_hi  = C_hi * V_hi
+//
+(p0)  fma.s1 tanx = P, x, x
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fnmpy.s1 C_hi = sgn_r, C_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: V_lo = 1 - V_hi + C_hi
+//    N odd: V_lo = 1 - V_hi + T_hi
+//
+(p11) fadd.s1 CORR = CORR, T_lo
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fsub.s1 CORR = CORR, C_lo
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even and odd: tanx = x + x * P
+//    N even and odd: Sx = SC_inv * x
+//
+(p11) fsub.s1 D = C_hi, tanx
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fadd.s1 D = T_hi, tanx
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N odd: CORR = SC_inv * C_hi
+//    N even: CORR = SC_inv * T_hi
+//
+(p0)  fnma.s1 D = V_hi, D, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even and odd: D = 1 - V_hi * D
+//    N even and odd: CORR = CORR * c
+//
+(p0)  fma.s1 V_hi = V_hi, D, V_hi
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even and odd: V_hi = V_hi + V_hi * D
+//    N even and odd: CORR = sgn_r * CORR
+//
+(p11) fnma.s1 V_lo = V_hi, C_hi, f1
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fnma.s1 V_lo = V_hi, T_hi, f1
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: CORR = COOR + T_lo
+//    N odd: CORR = CORR - C_lo
+//
+(p11) fma.s1 V_lo = tanx, V_hi, V_lo
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fnma.s1 V_lo = tanx, V_hi, V_lo
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: V_lo = V_lo + V_hi * tanx
+//    N odd: V_lo = V_lo - V_hi * tanx
+//
+(p11) fnma.s1 V_lo = C_lo, V_hi, V_lo
+	nop.i 999
+}
+
+{ .mfi
+	nop.m 999
+(p12) fnma.s1 V_lo = T_lo, V_hi, V_lo
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N  even: V_lo = V_lo - V_hi * C_lo
+//    N  odd: V_lo = V_lo - V_hi * T_lo
+//
+(p0)  fmpy.s1 V_lo = V_hi, V_lo
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even and odd: V_lo = V_lo * V_hi
+//
+(p0)  fadd.s1 tail = V_hi, V_lo
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even and odd: tail = V_hi + V_lo
+//
+(p0)  fma.s1 tail = tail, P, V_lo
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even: T_hi = sgn_r * T_hi
+//    N odd : C_hi = -sgn_r * C_hi
+//
+(p0)  fma.s1 tail = tail, Sx, CORR
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even and odd: tail = Sx * tail + CORR
+//
+(p0)  fma.s1 tail = V_hi, Sx, tail
+	nop.i 999 ;;
+}
+
+{ .mfi
+	nop.m 999
+//
+//    N even an odd: tail = Sx * V_hi + tail
+//
+(p11) fma.s0 Result = sgn_r, tail, T_hi
+	nop.i 999
+}
+
+{ .mfb
+	nop.m 999
+(p12) fma.s0 Result = sgn_r, tail, C_hi
+(p0)   br.ret.sptk b0 ;;
+}
+
+.endp __libm_tan
+ASM_SIZE_DIRECTIVE(__libm_tan)
+
+
+
+// *******************************************************************
+// *******************************************************************
+// *******************************************************************
+//
+//     Special Code to handle very large argument case.
+//     Call int pi_by_2_reduce(&x,&r)
+//     for |arguments| >= 2**63
+//     (Arg or x) is in f8
+//     Address to save r and c as double
+
+//                 (1)                    (2)                 (3) (call)         (4)
+//            sp -> +               psp -> +            psp -> +           sp ->  +
+//                  |                      |                   |                  |
+//                  |                r50 ->| <- r50      f0  ->|           r50 -> | -> c
+//                  |                      |                   |                  |
+//         sp-32 -> | <- r50          f0 ->|             f0  ->| <- r50    r49 -> | -> r
+//                  |                      |                   |                  |
+//                  |               r49  ->| <- r49     Arg  ->| <- r49           | -> x
+//                  |                      |                   |                  |
+//         sp -64 ->|             sp -64 ->|          sp -64 ->|                  |
+//
+//            save pfs           save b0                                     restore gp
+//            save gp                                                        restore b0
+//                                                                           restore pfs
+
+
+
+.proc __libm_callout
+__libm_callout:
+TAN_ARG_TOO_LARGE:
+.prologue
+// (1)
+{ .mfi
+        add   GR_Parameter_r =-32,sp                        // Parameter: r address
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+
+// (2)
+{ .mmi
+        stfe [GR_Parameter_r ] = f0,16                      // Clear Parameter r on stack
+        add  GR_Parameter_X = 16,sp                        // Parameter x address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+
+// (3)
+.body
+{ .mib
+        stfe [GR_Parameter_r ] = f0,-16                     // Clear Parameter c on stack
+        nop.i 0
+        nop.b 0
+}
+{ .mib
+        stfe [GR_Parameter_X] = Arg                        // Store Parameter x on stack
+        nop.i 0
+(p0)    br.call.sptk b0=__libm_pi_by_2_reduce#
+}
+;;
+
+
+// (4)
+{ .mmi
+        mov   gp = GR_SAVE_GP                  // Restore gp
+(p0)    mov   N_fix_gr = r8
+        nop.i 999
+}
+;;
+
+{ .mmi
+(p0)    ldfe  Arg        =[GR_Parameter_X],16
+(p0)    ldfs  TWO_TO_NEG2 = [table_ptr2],4
+        nop.i 999
+}
+;;
+
+
+{ .mmb
+(p0)    ldfe  r =[GR_Parameter_r ],16
+(p0)    ldfs  NEGTWO_TO_NEG2 = [table_ptr2],4
+        nop.b 999 ;;
+}
+
+{ .mfi
+(p0)    ldfe  c =[GR_Parameter_r ]
+        nop.f 999
+        nop.i 999 ;;
+}
+
+{ .mfi
+        nop.m 999
+//
+//     Is |r| < 2**(-2)
+//
+(p0)   fcmp.lt.unc.s1  p6, p0 = r, TWO_TO_NEG2
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+}
+;;
+
+{ .mfi
+       nop.m 999
+(p6)   fcmp.gt.unc.s1  p6, p0 = r, NEGTWO_TO_NEG2
+       mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+}
+;;
+
+{ .mbb
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+(p6)   br.cond.spnt TAN_SMALL_R
+(p0)   br.cond.sptk TAN_NORMAL_R
+}
+;;
+.endp __libm_callout
+ASM_SIZE_DIRECTIVE(__libm_callout)
+
+
+.proc __libm_TAN_SPECIAL
+__libm_TAN_SPECIAL:
+
+//
+//     Code for NaNs, Unsupporteds, Infs, or +/- zero ?
+//     Invalid raised for Infs and SNaNs.
+//
+
+{ .mfb
+	nop.m 999
+(p0)   fmpy.s0 Arg = Arg, f0
+(p0)   br.ret.sptk b0
+}
+.endp __libm_TAN_SPECIAL
+ASM_SIZE_DIRECTIVE(__libm_TAN_SPECIAL)
+
+
+.type __libm_pi_by_2_reduce#,@function
+.global __libm_pi_by_2_reduce#
--- /dev/null
+++ a/sysdeps/ia64/fpu/math_err.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/math_ldbl.h
@@ -0,0 +1,122 @@
+/* Manipulation of the bit representation of 'long double' quantities.
+   Copyright (C) 2000-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _MATH_LDBL_H_
+#define _MATH_LDBL_H_ 1
+
+#include <stdint.h>
+#include <endian.h>
+
+/* A union which permits us to convert between a long double and
+   three 32 bit ints.  */
+
+#if __FLOAT_WORD_ORDER == __BIG_ENDIAN
+
+typedef union
+{
+  long double value;
+  struct
+  {
+    unsigned int empty0:32;
+    int sign_exponent:16;
+    unsigned int empty1:16;
+    uint32_t msw;
+    uint32_t lsw;
+  } parts;
+} ieee_long_double_shape_type;
+
+#endif
+
+#if __FLOAT_WORD_ORDER == __LITTLE_ENDIAN
+
+typedef union
+{
+  long double value;
+  struct
+  {
+    uint32_t lsw;
+    uint32_t msw;
+    int sign_exponent:16;
+    unsigned int empty1:16;
+    unsigned int empty0:32;
+  } parts;
+} ieee_long_double_shape_type;
+
+#endif
+
+/* Get three 32 bit ints from a double.  */
+
+#define GET_LDOUBLE_WORDS(exp,ix0,ix1,d)			\
+do {								\
+  ieee_long_double_shape_type ew_u;				\
+  ew_u.value = (d);						\
+  (exp) = ew_u.parts.sign_exponent;				\
+  (ix0) = ew_u.parts.msw;					\
+  (ix1) = ew_u.parts.lsw;					\
+} while (0)
+
+/* Set a double from two 32 bit ints.  */
+
+#define SET_LDOUBLE_WORDS(d,exp,ix0,ix1)			\
+do {								\
+  ieee_long_double_shape_type iw_u;				\
+  iw_u.parts.sign_exponent = (exp);				\
+  iw_u.parts.msw = (ix0);					\
+  iw_u.parts.lsw = (ix1);					\
+  (d) = iw_u.value;						\
+} while (0)
+
+/* Get the more significant 32 bits of a long double mantissa.  */
+
+#define GET_LDOUBLE_MSW(v,d)					\
+do {								\
+  ieee_long_double_shape_type sh_u;				\
+  sh_u.value = (d);						\
+  (v) = sh_u.parts.msw;						\
+} while (0)
+
+/* Set the more significant 32 bits of a long double mantissa from an int.  */
+
+#define SET_LDOUBLE_MSW(d,v)					\
+do {								\
+  ieee_long_double_shape_type sh_u;				\
+  sh_u.value = (d);						\
+  sh_u.parts.msw = (v);						\
+  (d) = sh_u.value;						\
+} while (0)
+
+/* Get int from the exponent of a long double.  */
+
+#define GET_LDOUBLE_EXP(exp,d)					\
+do {								\
+  ieee_long_double_shape_type ge_u;				\
+  ge_u.value = (d);						\
+  (exp) = ge_u.parts.sign_exponent;				\
+} while (0)
+
+/* Set exponent of a long double from an int.  */
+
+#define SET_LDOUBLE_EXP(d,exp)					\
+do {								\
+  ieee_long_double_shape_type se_u;				\
+  se_u.value = (d);						\
+  se_u.parts.sign_exponent = (exp);				\
+  (d) = se_u.value;						\
+} while (0)
+
+#endif /* math_ldbl.h */
--- /dev/null
+++ a/sysdeps/ia64/fpu/mpa.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/mpatan.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/mpatan2.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/mpsqrt.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/mptan.c
@@ -0,0 +1 @@
+/* Not needed.  */
--- /dev/null
+++ a/sysdeps/ia64/fpu/printf_fphex.c
@@ -0,0 +1,76 @@
+/* Print floating point number in hexadecimal notation according to ISO C99.
+   Copyright (C) 2000-2024 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef LONG_DOUBLE_DENORM_BIAS
+# define LONG_DOUBLE_DENORM_BIAS (IEEE854_LONG_DOUBLE_BIAS - 1)
+#endif
+
+#define PRINT_FPHEX_LONG_DOUBLE \
+do {									      \
+      /* The "strange" 80 bit format on ia64 has an explicit		      \
+	 leading digit in the 64 bit mantissa.  */			      \
+      unsigned long long int num;					      \
+      union ieee854_long_double u;					      \
+      u.d = fpnum.ldbl;							      \
+									      \
+      num = (((unsigned long long int) u.ieee.mantissa0) << 32		      \
+	     | u.ieee.mantissa1);					      \
+									      \
+      zero_mantissa = num == 0;						      \
+									      \
+      numstr = _itoa_word (num, numbuf + sizeof numbuf, 16,		      \
+			   info->spec == 'A');				      \
+									      \
+      /* Fill with zeroes.  */						      \
+      while (numstr > numbuf + (sizeof numbuf - 64 / 4))		      \
+	*--numstr = '0';						      \
+									      \
+      /* We use a full nibble for the leading digit.  */		      \
+      leading = *numstr++;						      \
+									      \
+      /* We have 3 bits from the mantissa in the leading nibble.	      \
+	 Therefore we are here using `IEEE854_LONG_DOUBLE_BIAS + 3'.  */      \
+      exponent = u.ieee.exponent;					      \
+									      \
+      if (exponent == 0)						      \
+	{								      \
+	  if (zero_mantissa)						      \
+	    expnegative = 0;						      \
+	  else								      \
+	    {								      \
+	      /* This is a denormalized number.  */			      \
+	      expnegative = 1;						      \
+	      /* This is a hook for the m68k long double format, where the    \
+		 exponent bias is the same for normalized and denormalized    \
+		 numbers.  */						      \
+	      exponent = LONG_DOUBLE_DENORM_BIAS + 3;			      \
+	    }								      \
+	}								      \
+      else if (exponent >= IEEE854_LONG_DOUBLE_BIAS + 3)		      \
+	{								      \
+	  expnegative = 0;						      \
+	  exponent -= IEEE854_LONG_DOUBLE_BIAS + 3;			      \
+	}								      \
+      else								      \
+	{								      \
+	  expnegative = 1;						      \
+	  exponent = -(exponent - (IEEE854_LONG_DOUBLE_BIAS + 3));	      \
+	}								      \
+} while (0)
+
+#include <stdio-common/printf_fphex.c>
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_asinh.S
@@ -0,0 +1,1137 @@
+.file "asinh.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// ==============================================================
+// History
+// ==============================================================
+// 04/02/01 Initial version
+// 04/19/01 Improved speed of the paths #1,2,3,4,5
+// 10/18/01 Improved accuracy
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+// 05/21/03 Improved performance, fixed to handle unorms
+// 03/31/05 Reformatted delimiters between data tables
+//
+// API
+// ==============================================================
+// double asinh(double)
+//
+// Overview of operation
+// ==============================================================
+//
+// There are 7 paths:
+// 1. x = 0.0
+//    Return asinh(x) = 0.0
+//
+// 2. 0.0 <|x| < 2^(-3)
+//    Return asinh(x) = POL13(x),
+//         where POL13(x) = (x^2*C13 + ...)*x^2 + C5)*x^2 + C3)*x^3 + x
+//
+// 3. 2^(-3) <= |x| < 2^63
+//    Return asinh(x) = sign(x)*(log(|x| + sqrt(x^2 + 1.0)))
+//    To compute x + sqrt(x^2 + 1.0) modified Newton Raphson method is used
+//      (3 iterations)
+//    Algorithm description for log function see below.
+//
+// 4. 2^63 <= |x| < +INF
+//    Return asinh(x) = sign(x)*log(2*|x|)
+//    Algorithm description for log function see below.
+//
+// 5. x = INF
+//    Return asinh(x) = INF
+//
+// 6. x = [S,Q]NaN
+//    Return asinh(x) = QNaN
+//
+// 7. x = denormal
+//    Return asinh(x) = x correctly rounded
+//
+//==============================================================
+// Algorithm Description for log(x) function
+// Below we are using the fact that inequality x - 1.0 > 2^(-6) is always
+//   true for this asinh implementation
+//
+// Consider  x = 2^N 1.f1 f2 f3 f4...f63
+// Log(x) = log(frcpa(x) x/frcpa(x))
+//        = log(1/frcpa(x)) + log(frcpa(x) x)
+//        = -log(frcpa(x)) + log(frcpa(x) x)
+//
+// frcpa(x)       = 2^-N frcpa((1.f1 f2 ... f63)
+//
+// -log(frcpa(x)) = -log(C)
+//                = -log(2^-N) - log(frcpa(1.f1 f2 ... f63))
+//
+// -log(frcpa(x)) = -log(C)
+//                = +Nlog2 - log(frcpa(1.f1 f2 ... f63))
+//
+// -log(frcpa(x)) = -log(C)
+//                = +Nlog2 + log(frcpa(1.f1 f2 ... f63))
+//
+// Log(x) = log(1/frcpa(x)) + log(frcpa(x) x)
+//
+// Log(x) =  +Nlog2 + log(1./frcpa(1.f1 f2 ... f63)) + log(frcpa(x) x)
+// Log(x) =  +Nlog2 - log(/frcpa(1.f1 f2 ... f63))   + log(frcpa(x) x)
+// Log(x) =  +Nlog2 + T                              + log(frcpa(x) x)
+//
+// Log(x) =  +Nlog2 + T                     + log(C x)
+//
+// Cx = 1 + r
+//
+// Log(x) =  +Nlog2 + T  + log(1+r)
+// Log(x) =  +Nlog2 + T  + Series( r - r^2/2 + r^3/3 - r^4/4 ....)
+//
+// 1.f1 f2 ... f8 has 256 entries.
+// They are 1 + k/2^8, k = 0 ... 255
+// These 256 values are the table entries.
+//
+// Implementation
+//==============================================================
+// C = frcpa(x)
+// r = C * x - 1
+//
+// Form rseries = r + P1*r^2 + P2*r^3 + P3*r^4 + P4*r^5 + P5*r^6
+//
+// x = f * 2*n where f is 1.f_1f_2f_3....f_63
+// Nfloat = float(n)  where n is the true unbiased exponent
+// pre-index = f_1f_2....f_8
+// index = pre_index * 16
+// get the dxt table entry at index + offset = T
+//
+// result = (T + Nfloat * log(2)) + rseries
+//
+// The T table is calculated as follows
+// Form x_k = 1 + k/2^8 where k goes from 0... 255
+//      y_k = frcpa(x_k)
+//      log(1/y_k)  in quad and round to double-extended
+//
+//
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input
+// f9 -> f15,  f32 -> f68
+
+// General registers used:
+// r14 -> r27
+
+// Predicate registers used:
+// p6 -> p14
+
+// p6 to filter out case when x = [Q,S]NaN or INF or zero
+// p7 to filter out case when x < 0.0
+// p8 to select path #2
+// p9 used in the frcpa from path #3
+// p11 to filter out case when x >= 0
+// p12 to filter out case when x = unorm
+// p13 to select path #4
+// Assembly macros
+//==============================================================
+log_GR_exp_17_ones    = r14
+log_GR_signexp_f8     = r15
+log_table_address2    = r16
+log_GR_exp_16_ones    = r17
+log_GR_exp_f8         = r18
+log_GR_true_exp_f8    = r19
+log_GR_significand_f8 = r20
+log_GR_index          = r21
+log_GR_comp2          = r22
+asinh_GR_f8           = r23
+asinh_GR_comp         = r24
+asinh_GR_f8           = r25
+log_table_address3    = r26
+NR_table_address      = r27
+
+//==============================================================
+log_y            = f9
+NR1              = f10
+NR2              = f11
+log_y_rs         = f12
+log_y_rs_iter    = f13
+log_y_rs_iter1   = f14
+fNormX           = f15
+asinh_w_sq       = f32
+log_C13          = f33
+log_C11          = f34
+log_P3           = f35
+log_P2           = f36
+log_P1           = f37
+log_P5           = f38
+log_P4           = f39
+log_C3           = f40
+log_C5           = f41
+log_C7           = f42
+log2             = f43
+asinh_f8         = f44
+log_C            = f45
+log_arg          = f46
+log_C9           = f47
+asinh_w_four     = f48
+log_int_Nfloat   = f49
+log_r            = f50
+log_rsq          = f51
+log_rp_p4        = f52
+log_rp_p32       = f53
+log_rcube        = f54
+log_rp_p10       = f55
+log_rp_p2        = f56
+log_Nfloat       = f57
+log_T            = f58
+log_r2P_r        = f59
+log_T_plus_Nlog2 = f60
+asinh_w_3        = f61
+asinh_w_5        = f62
+asinh_w_cube     = f63
+asinh_w_7        = f64
+log_arg_early    = f65
+asinh_w_9        = f66
+asinh_w_13       = f67
+asinh_w_seven    = f68
+
+// Data tables
+//==============================================================
+
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(log_table_1)
+data8 0xBFC5555DA7212371 // P5
+data8 0x3FC999A19EEF5826 // P4
+data8 0xBFCFFFFFFFFEF009 // P3
+data8 0x3FD555555554ECB2 // P2
+data8 0xBFE0000000000000 // P1 = -0.5
+data8 0x0000000000000000 // pad
+data8 0xb17217f7d1cf79ac, 0x00003ffe  // log2
+LOCAL_OBJECT_END(log_table_1)
+
+LOCAL_OBJECT_START(log_table_2)
+data8 0x3FE0000000000000 // 0.5
+data8 0x4008000000000000 // 3.0
+//
+data8 0x8824BE4D74BC4F00, 0x00003FF9 // C13
+data8 0xB725A2CD9556CC57, 0x0000BFF9 // C11
+data8 0xF8E339127FBFF49D, 0x00003FF9 // C9
+data8 0xB6DB6D7DCE17CB78, 0x0000BFFA // C7
+data8 0x999999998802CCEF, 0x00003FFB // C5
+data8 0xAAAAAAAAAAA8DC40, 0x0000BFFC // C3
+LOCAL_OBJECT_END(log_table_2)
+
+
+LOCAL_OBJECT_START(log_table_3)
+data8 0x80200aaeac44ef38 , 0x00003ff6 //   log(1/frcpa(1+  0/2^-8))
+//
+data8 0xc09090a2c35aa070 , 0x00003ff7 //   log(1/frcpa(1+  1/2^-8))
+data8 0xa0c94fcb41977c75 , 0x00003ff8 //   log(1/frcpa(1+  2/2^-8))
+data8 0xe18b9c263af83301 , 0x00003ff8 //   log(1/frcpa(1+  3/2^-8))
+data8 0x8d35c8d6399c30ea , 0x00003ff9 //   log(1/frcpa(1+  4/2^-8))
+data8 0xadd4d2ecd601cbb8 , 0x00003ff9 //   log(1/frcpa(1+  5/2^-8))
+//
+data8 0xce95403a192f9f01 , 0x00003ff9 //   log(1/frcpa(1+  6/2^-8))
+data8 0xeb59392cbcc01096 , 0x00003ff9 //   log(1/frcpa(1+  7/2^-8))
+data8 0x862c7d0cefd54c5d , 0x00003ffa //   log(1/frcpa(1+  8/2^-8))
+data8 0x94aa63c65e70d499 , 0x00003ffa //   log(1/frcpa(1+  9/2^-8))
+data8 0xa54a696d4b62b382 , 0x00003ffa //   log(1/frcpa(1+ 10/2^-8))
+//
+data8 0xb3e4a796a5dac208 , 0x00003ffa //   log(1/frcpa(1+ 11/2^-8))
+data8 0xc28c45b1878340a9 , 0x00003ffa //   log(1/frcpa(1+ 12/2^-8))
+data8 0xd35c55f39d7a6235 , 0x00003ffa //   log(1/frcpa(1+ 13/2^-8))
+data8 0xe220f037b954f1f5 , 0x00003ffa //   log(1/frcpa(1+ 14/2^-8))
+data8 0xf0f3389b036834f3 , 0x00003ffa //   log(1/frcpa(1+ 15/2^-8))
+//
+data8 0xffd3488d5c980465 , 0x00003ffa //   log(1/frcpa(1+ 16/2^-8))
+data8 0x87609ce2ed300490 , 0x00003ffb //   log(1/frcpa(1+ 17/2^-8))
+data8 0x8ede9321e8c85927 , 0x00003ffb //   log(1/frcpa(1+ 18/2^-8))
+data8 0x96639427f2f8e2f4 , 0x00003ffb //   log(1/frcpa(1+ 19/2^-8))
+data8 0x9defad3e8f73217b , 0x00003ffb //   log(1/frcpa(1+ 20/2^-8))
+//
+data8 0xa582ebd50097029c , 0x00003ffb //   log(1/frcpa(1+ 21/2^-8))
+data8 0xac06dbe75ab80fee , 0x00003ffb //   log(1/frcpa(1+ 22/2^-8))
+data8 0xb3a78449b2d3ccca , 0x00003ffb //   log(1/frcpa(1+ 23/2^-8))
+data8 0xbb4f79635ab46bb2 , 0x00003ffb //   log(1/frcpa(1+ 24/2^-8))
+data8 0xc2fec93a83523f3f , 0x00003ffb //   log(1/frcpa(1+ 25/2^-8))
+//
+data8 0xc99af2eaca4c4571 , 0x00003ffb //   log(1/frcpa(1+ 26/2^-8))
+data8 0xd1581106472fa653 , 0x00003ffb //   log(1/frcpa(1+ 27/2^-8))
+data8 0xd8002560d4355f2e , 0x00003ffb //   log(1/frcpa(1+ 28/2^-8))
+data8 0xdfcb43b4fe508632 , 0x00003ffb //   log(1/frcpa(1+ 29/2^-8))
+data8 0xe67f6dff709d4119 , 0x00003ffb //   log(1/frcpa(1+ 30/2^-8))
+//
+data8 0xed393b1c22351280 , 0x00003ffb //   log(1/frcpa(1+ 31/2^-8))
+data8 0xf5192bff087bcc35 , 0x00003ffb //   log(1/frcpa(1+ 32/2^-8))
+data8 0xfbdf4ff6dfef2fa3 , 0x00003ffb //   log(1/frcpa(1+ 33/2^-8))
+data8 0x81559a97f92f9cc7 , 0x00003ffc //   log(1/frcpa(1+ 34/2^-8))
+data8 0x84be72bce90266e8 , 0x00003ffc //   log(1/frcpa(1+ 35/2^-8))
+//
+data8 0x88bc74113f23def2 , 0x00003ffc //   log(1/frcpa(1+ 36/2^-8))
+data8 0x8c2ba3edf6799d11 , 0x00003ffc //   log(1/frcpa(1+ 37/2^-8))
+data8 0x8f9dc92f92ea08b1 , 0x00003ffc //   log(1/frcpa(1+ 38/2^-8))
+data8 0x9312e8f36efab5a7 , 0x00003ffc //   log(1/frcpa(1+ 39/2^-8))
+data8 0x968b08643409ceb6 , 0x00003ffc //   log(1/frcpa(1+ 40/2^-8))
+//
+data8 0x9a062cba08a1708c , 0x00003ffc //   log(1/frcpa(1+ 41/2^-8))
+data8 0x9d845b3abf95485c , 0x00003ffc //   log(1/frcpa(1+ 42/2^-8))
+data8 0xa06fd841bc001bb4 , 0x00003ffc //   log(1/frcpa(1+ 43/2^-8))
+data8 0xa3f3a74652fbe0db , 0x00003ffc //   log(1/frcpa(1+ 44/2^-8))
+data8 0xa77a8fb2336f20f5 , 0x00003ffc //   log(1/frcpa(1+ 45/2^-8))
+//
+data8 0xab0497015d28b0a0 , 0x00003ffc //   log(1/frcpa(1+ 46/2^-8))
+data8 0xae91c2be6ba6a615 , 0x00003ffc //   log(1/frcpa(1+ 47/2^-8))
+data8 0xb189d1b99aebb20b , 0x00003ffc //   log(1/frcpa(1+ 48/2^-8))
+data8 0xb51cced5de9c1b2c , 0x00003ffc //   log(1/frcpa(1+ 49/2^-8))
+data8 0xb819bee9e720d42f , 0x00003ffc //   log(1/frcpa(1+ 50/2^-8))
+//
+data8 0xbbb2a0947b093a5d , 0x00003ffc //   log(1/frcpa(1+ 51/2^-8))
+data8 0xbf4ec1505811684a , 0x00003ffc //   log(1/frcpa(1+ 52/2^-8))
+data8 0xc2535bacfa8975ff , 0x00003ffc //   log(1/frcpa(1+ 53/2^-8))
+data8 0xc55a3eafad187eb8 , 0x00003ffc //   log(1/frcpa(1+ 54/2^-8))
+data8 0xc8ff2484b2c0da74 , 0x00003ffc //   log(1/frcpa(1+ 55/2^-8))
+//
+data8 0xcc0b1a008d53ab76 , 0x00003ffc //   log(1/frcpa(1+ 56/2^-8))
+data8 0xcfb6203844b3209b , 0x00003ffc //   log(1/frcpa(1+ 57/2^-8))
+data8 0xd2c73949a47a19f5 , 0x00003ffc //   log(1/frcpa(1+ 58/2^-8))
+data8 0xd5daae18b49d6695 , 0x00003ffc //   log(1/frcpa(1+ 59/2^-8))
+data8 0xd8f08248cf7e8019 , 0x00003ffc //   log(1/frcpa(1+ 60/2^-8))
+//
+data8 0xdca7749f1b3e540e , 0x00003ffc //   log(1/frcpa(1+ 61/2^-8))
+data8 0xdfc28e033aaaf7c7 , 0x00003ffc //   log(1/frcpa(1+ 62/2^-8))
+data8 0xe2e012a5f91d2f55 , 0x00003ffc //   log(1/frcpa(1+ 63/2^-8))
+data8 0xe600064ed9e292a8 , 0x00003ffc //   log(1/frcpa(1+ 64/2^-8))
+data8 0xe9226cce42b39f60 , 0x00003ffc //   log(1/frcpa(1+ 65/2^-8))
+//
+data8 0xec4749fd97a28360 , 0x00003ffc //   log(1/frcpa(1+ 66/2^-8))
+data8 0xef6ea1bf57780495 , 0x00003ffc //   log(1/frcpa(1+ 67/2^-8))
+data8 0xf29877ff38809091 , 0x00003ffc //   log(1/frcpa(1+ 68/2^-8))
+data8 0xf5c4d0b245cb89be , 0x00003ffc //   log(1/frcpa(1+ 69/2^-8))
+data8 0xf8f3afd6fcdef3aa , 0x00003ffc //   log(1/frcpa(1+ 70/2^-8))
+//
+data8 0xfc2519756be1abc7 , 0x00003ffc //   log(1/frcpa(1+ 71/2^-8))
+data8 0xff59119f503e6832 , 0x00003ffc //   log(1/frcpa(1+ 72/2^-8))
+data8 0x8147ce381ae0e146 , 0x00003ffd //   log(1/frcpa(1+ 73/2^-8))
+data8 0x82e45f06cb1ad0f2 , 0x00003ffd //   log(1/frcpa(1+ 74/2^-8))
+data8 0x842f5c7c573cbaa2 , 0x00003ffd //   log(1/frcpa(1+ 75/2^-8))
+//
+data8 0x85ce471968c8893a , 0x00003ffd //   log(1/frcpa(1+ 76/2^-8))
+data8 0x876e8305bc04066d , 0x00003ffd //   log(1/frcpa(1+ 77/2^-8))
+data8 0x891012678031fbb3 , 0x00003ffd //   log(1/frcpa(1+ 78/2^-8))
+data8 0x8a5f1493d766a05f , 0x00003ffd //   log(1/frcpa(1+ 79/2^-8))
+data8 0x8c030c778c56fa00 , 0x00003ffd //   log(1/frcpa(1+ 80/2^-8))
+//
+data8 0x8da85df17e31d9ae , 0x00003ffd //   log(1/frcpa(1+ 81/2^-8))
+data8 0x8efa663e7921687e , 0x00003ffd //   log(1/frcpa(1+ 82/2^-8))
+data8 0x90a22b6875c6a1f8 , 0x00003ffd //   log(1/frcpa(1+ 83/2^-8))
+data8 0x91f62cc8f5d24837 , 0x00003ffd //   log(1/frcpa(1+ 84/2^-8))
+data8 0x93a06cfc3857d980 , 0x00003ffd //   log(1/frcpa(1+ 85/2^-8))
+//
+data8 0x94f66d5e6fd01ced , 0x00003ffd //   log(1/frcpa(1+ 86/2^-8))
+data8 0x96a330156e6772f2 , 0x00003ffd //   log(1/frcpa(1+ 87/2^-8))
+data8 0x97fb3582754ea25b , 0x00003ffd //   log(1/frcpa(1+ 88/2^-8))
+data8 0x99aa8259aad1bbf2 , 0x00003ffd //   log(1/frcpa(1+ 89/2^-8))
+data8 0x9b0492f6227ae4a8 , 0x00003ffd //   log(1/frcpa(1+ 90/2^-8))
+//
+data8 0x9c5f8e199bf3a7a5 , 0x00003ffd //   log(1/frcpa(1+ 91/2^-8))
+data8 0x9e1293b9998c1daa , 0x00003ffd //   log(1/frcpa(1+ 92/2^-8))
+data8 0x9f6fa31e0b41f308 , 0x00003ffd //   log(1/frcpa(1+ 93/2^-8))
+data8 0xa0cda11eaf46390e , 0x00003ffd //   log(1/frcpa(1+ 94/2^-8))
+data8 0xa22c8f029cfa45aa , 0x00003ffd //   log(1/frcpa(1+ 95/2^-8))
+//
+data8 0xa3e48badb7856b34 , 0x00003ffd //   log(1/frcpa(1+ 96/2^-8))
+data8 0xa5459a0aa95849f9 , 0x00003ffd //   log(1/frcpa(1+ 97/2^-8))
+data8 0xa6a79c84480cfebd , 0x00003ffd //   log(1/frcpa(1+ 98/2^-8))
+data8 0xa80a946d0fcb3eb2 , 0x00003ffd //   log(1/frcpa(1+ 99/2^-8))
+data8 0xa96e831a3ea7b314 , 0x00003ffd //   log(1/frcpa(1+100/2^-8))
+//
+data8 0xaad369e3dc544e3b , 0x00003ffd //   log(1/frcpa(1+101/2^-8))
+data8 0xac92e9588952c815 , 0x00003ffd //   log(1/frcpa(1+102/2^-8))
+data8 0xadfa035aa1ed8fdc , 0x00003ffd //   log(1/frcpa(1+103/2^-8))
+data8 0xaf6219eae1ad6e34 , 0x00003ffd //   log(1/frcpa(1+104/2^-8))
+data8 0xb0cb2e6d8160f753 , 0x00003ffd //   log(1/frcpa(1+105/2^-8))
+//
+data8 0xb2354249ad950f72 , 0x00003ffd //   log(1/frcpa(1+106/2^-8))
+data8 0xb3a056e98ef4a3b4 , 0x00003ffd //   log(1/frcpa(1+107/2^-8))
+data8 0xb50c6dba52c6292a , 0x00003ffd //   log(1/frcpa(1+108/2^-8))
+data8 0xb679882c33876165 , 0x00003ffd //   log(1/frcpa(1+109/2^-8))
+data8 0xb78c07429785cedc , 0x00003ffd //   log(1/frcpa(1+110/2^-8))
+//
+data8 0xb8faeb8dc4a77d24 , 0x00003ffd //   log(1/frcpa(1+111/2^-8))
+data8 0xba6ad77eb36ae0d6 , 0x00003ffd //   log(1/frcpa(1+112/2^-8))
+data8 0xbbdbcc915e9bee50 , 0x00003ffd //   log(1/frcpa(1+113/2^-8))
+data8 0xbd4dcc44f8cf12ef , 0x00003ffd //   log(1/frcpa(1+114/2^-8))
+data8 0xbec0d81bf5b531fa , 0x00003ffd //   log(1/frcpa(1+115/2^-8))
+//
+data8 0xc034f19c139186f4 , 0x00003ffd //   log(1/frcpa(1+116/2^-8))
+data8 0xc14cb69f7c5e55ab , 0x00003ffd //   log(1/frcpa(1+117/2^-8))
+data8 0xc2c2abbb6e5fd56f , 0x00003ffd //   log(1/frcpa(1+118/2^-8))
+data8 0xc439b2c193e6771e , 0x00003ffd //   log(1/frcpa(1+119/2^-8))
+data8 0xc553acb9d5c67733 , 0x00003ffd //   log(1/frcpa(1+120/2^-8))
+//
+data8 0xc6cc96e441272441 , 0x00003ffd //   log(1/frcpa(1+121/2^-8))
+data8 0xc8469753eca88c30 , 0x00003ffd //   log(1/frcpa(1+122/2^-8))
+data8 0xc962cf3ce072b05c , 0x00003ffd //   log(1/frcpa(1+123/2^-8))
+data8 0xcadeba8771f694aa , 0x00003ffd //   log(1/frcpa(1+124/2^-8))
+data8 0xcc5bc08d1f72da94 , 0x00003ffd //   log(1/frcpa(1+125/2^-8))
+//
+data8 0xcd7a3f99ea035c29 , 0x00003ffd //   log(1/frcpa(1+126/2^-8))
+data8 0xcef93860c8a53c35 , 0x00003ffd //   log(1/frcpa(1+127/2^-8))
+data8 0xd0192f68a7ed23df , 0x00003ffd //   log(1/frcpa(1+128/2^-8))
+data8 0xd19a201127d3c645 , 0x00003ffd //   log(1/frcpa(1+129/2^-8))
+data8 0xd2bb92f4061c172c , 0x00003ffd //   log(1/frcpa(1+130/2^-8))
+//
+data8 0xd43e80b2ee8cc8fc , 0x00003ffd //   log(1/frcpa(1+131/2^-8))
+data8 0xd56173601fc4ade4 , 0x00003ffd //   log(1/frcpa(1+132/2^-8))
+data8 0xd6e6637efb54086f , 0x00003ffd //   log(1/frcpa(1+133/2^-8))
+data8 0xd80ad9f58f3c8193 , 0x00003ffd //   log(1/frcpa(1+134/2^-8))
+data8 0xd991d1d31aca41f8 , 0x00003ffd //   log(1/frcpa(1+135/2^-8))
+//
+data8 0xdab7d02231484a93 , 0x00003ffd //   log(1/frcpa(1+136/2^-8))
+data8 0xdc40d532cde49a54 , 0x00003ffd //   log(1/frcpa(1+137/2^-8))
+data8 0xdd685f79ed8b265e , 0x00003ffd //   log(1/frcpa(1+138/2^-8))
+data8 0xde9094bbc0e17b1d , 0x00003ffd //   log(1/frcpa(1+139/2^-8))
+data8 0xe01c91b78440c425 , 0x00003ffd //   log(1/frcpa(1+140/2^-8))
+//
+data8 0xe14658f26997e729 , 0x00003ffd //   log(1/frcpa(1+141/2^-8))
+data8 0xe270cdc2391e0d23 , 0x00003ffd //   log(1/frcpa(1+142/2^-8))
+data8 0xe3ffce3a2aa64922 , 0x00003ffd //   log(1/frcpa(1+143/2^-8))
+data8 0xe52bdb274ed82887 , 0x00003ffd //   log(1/frcpa(1+144/2^-8))
+data8 0xe6589852e75d7df6 , 0x00003ffd //   log(1/frcpa(1+145/2^-8))
+//
+data8 0xe786068c79937a7d , 0x00003ffd //   log(1/frcpa(1+146/2^-8))
+data8 0xe91903adad100911 , 0x00003ffd //   log(1/frcpa(1+147/2^-8))
+data8 0xea481236f7d35bb0 , 0x00003ffd //   log(1/frcpa(1+148/2^-8))
+data8 0xeb77d48c692e6b14 , 0x00003ffd //   log(1/frcpa(1+149/2^-8))
+data8 0xeca84b83d7297b87 , 0x00003ffd //   log(1/frcpa(1+150/2^-8))
+//
+data8 0xedd977f4962aa158 , 0x00003ffd //   log(1/frcpa(1+151/2^-8))
+data8 0xef7179a22f257754 , 0x00003ffd //   log(1/frcpa(1+152/2^-8))
+data8 0xf0a450d139366ca7 , 0x00003ffd //   log(1/frcpa(1+153/2^-8))
+data8 0xf1d7e0524ff9ffdb , 0x00003ffd //   log(1/frcpa(1+154/2^-8))
+data8 0xf30c29036a8b6cae , 0x00003ffd //   log(1/frcpa(1+155/2^-8))
+//
+data8 0xf4412bc411ea8d92 , 0x00003ffd //   log(1/frcpa(1+156/2^-8))
+data8 0xf576e97564c8619d , 0x00003ffd //   log(1/frcpa(1+157/2^-8))
+data8 0xf6ad62fa1b5f172f , 0x00003ffd //   log(1/frcpa(1+158/2^-8))
+data8 0xf7e499368b55c542 , 0x00003ffd //   log(1/frcpa(1+159/2^-8))
+data8 0xf91c8d10abaffe22 , 0x00003ffd //   log(1/frcpa(1+160/2^-8))
+//
+data8 0xfa553f7018c966f3 , 0x00003ffd //   log(1/frcpa(1+161/2^-8))
+data8 0xfb8eb13e185d802c , 0x00003ffd //   log(1/frcpa(1+162/2^-8))
+data8 0xfcc8e3659d9bcbed , 0x00003ffd //   log(1/frcpa(1+163/2^-8))
+data8 0xfe03d6d34d487fd2 , 0x00003ffd //   log(1/frcpa(1+164/2^-8))
+data8 0xff3f8c7581e9f0ae , 0x00003ffd //   log(1/frcpa(1+165/2^-8))
+//
+data8 0x803e029e280173ae , 0x00003ffe //   log(1/frcpa(1+166/2^-8))
+data8 0x80dca10cc52d0757 , 0x00003ffe //   log(1/frcpa(1+167/2^-8))
+data8 0x817ba200632755a1 , 0x00003ffe //   log(1/frcpa(1+168/2^-8))
+data8 0x821b05f3b01d6774 , 0x00003ffe //   log(1/frcpa(1+169/2^-8))
+data8 0x82bacd623ff19d06 , 0x00003ffe //   log(1/frcpa(1+170/2^-8))
+//
+data8 0x835af8c88e7a8f47 , 0x00003ffe //   log(1/frcpa(1+171/2^-8))
+data8 0x83c5f8299e2b4091 , 0x00003ffe //   log(1/frcpa(1+172/2^-8))
+data8 0x8466cb43f3d87300 , 0x00003ffe //   log(1/frcpa(1+173/2^-8))
+data8 0x850803a67c80ca4b , 0x00003ffe //   log(1/frcpa(1+174/2^-8))
+data8 0x85a9a1d11a23b461 , 0x00003ffe //   log(1/frcpa(1+175/2^-8))
+//
+data8 0x864ba644a18e6e05 , 0x00003ffe //   log(1/frcpa(1+176/2^-8))
+data8 0x86ee1182dcc432f7 , 0x00003ffe //   log(1/frcpa(1+177/2^-8))
+data8 0x875a925d7e48c316 , 0x00003ffe //   log(1/frcpa(1+178/2^-8))
+data8 0x87fdaa109d23aef7 , 0x00003ffe //   log(1/frcpa(1+179/2^-8))
+data8 0x88a129ed4becfaf2 , 0x00003ffe //   log(1/frcpa(1+180/2^-8))
+//
+data8 0x89451278ecd7f9cf , 0x00003ffe //   log(1/frcpa(1+181/2^-8))
+data8 0x89b29295f8432617 , 0x00003ffe //   log(1/frcpa(1+182/2^-8))
+data8 0x8a572ac5a5496882 , 0x00003ffe //   log(1/frcpa(1+183/2^-8))
+data8 0x8afc2d0ce3b2dadf , 0x00003ffe //   log(1/frcpa(1+184/2^-8))
+data8 0x8b6a69c608cfd3af , 0x00003ffe //   log(1/frcpa(1+185/2^-8))
+//
+data8 0x8c101e106e899a83 , 0x00003ffe //   log(1/frcpa(1+186/2^-8))
+data8 0x8cb63de258f9d626 , 0x00003ffe //   log(1/frcpa(1+187/2^-8))
+data8 0x8d2539c5bd19e2b1 , 0x00003ffe //   log(1/frcpa(1+188/2^-8))
+data8 0x8dcc0e064b29e6f1 , 0x00003ffe //   log(1/frcpa(1+189/2^-8))
+data8 0x8e734f45d88357ae , 0x00003ffe //   log(1/frcpa(1+190/2^-8))
+//
+data8 0x8ee30cef034a20db , 0x00003ffe //   log(1/frcpa(1+191/2^-8))
+data8 0x8f8b0515686d1d06 , 0x00003ffe //   log(1/frcpa(1+192/2^-8))
+data8 0x90336bba039bf32f , 0x00003ffe //   log(1/frcpa(1+193/2^-8))
+data8 0x90a3edd23d1c9d58 , 0x00003ffe //   log(1/frcpa(1+194/2^-8))
+data8 0x914d0de2f5d61b32 , 0x00003ffe //   log(1/frcpa(1+195/2^-8))
+//
+data8 0x91be0c20d28173b5 , 0x00003ffe //   log(1/frcpa(1+196/2^-8))
+data8 0x9267e737c06cd34a , 0x00003ffe //   log(1/frcpa(1+197/2^-8))
+data8 0x92d962ae6abb1237 , 0x00003ffe //   log(1/frcpa(1+198/2^-8))
+data8 0x9383fa6afbe2074c , 0x00003ffe //   log(1/frcpa(1+199/2^-8))
+data8 0x942f0421651c1c4e , 0x00003ffe //   log(1/frcpa(1+200/2^-8))
+//
+data8 0x94a14a3845bb985e , 0x00003ffe //   log(1/frcpa(1+201/2^-8))
+data8 0x954d133857f861e7 , 0x00003ffe //   log(1/frcpa(1+202/2^-8))
+data8 0x95bfd96468e604c4 , 0x00003ffe //   log(1/frcpa(1+203/2^-8))
+data8 0x9632d31cafafa858 , 0x00003ffe //   log(1/frcpa(1+204/2^-8))
+data8 0x96dfaabd86fa1647 , 0x00003ffe //   log(1/frcpa(1+205/2^-8))
+//
+data8 0x9753261fcbb2a594 , 0x00003ffe //   log(1/frcpa(1+206/2^-8))
+data8 0x9800c11b426b996d , 0x00003ffe //   log(1/frcpa(1+207/2^-8))
+data8 0x9874bf4d45ae663c , 0x00003ffe //   log(1/frcpa(1+208/2^-8))
+data8 0x99231f5ee9a74f79 , 0x00003ffe //   log(1/frcpa(1+209/2^-8))
+data8 0x9997a18a56bcad28 , 0x00003ffe //   log(1/frcpa(1+210/2^-8))
+//
+data8 0x9a46c873a3267e79 , 0x00003ffe //   log(1/frcpa(1+211/2^-8))
+data8 0x9abbcfc621eb6cb6 , 0x00003ffe //   log(1/frcpa(1+212/2^-8))
+data8 0x9b310cb0d354c990 , 0x00003ffe //   log(1/frcpa(1+213/2^-8))
+data8 0x9be14cf9e1b3515c , 0x00003ffe //   log(1/frcpa(1+214/2^-8))
+data8 0x9c5710b8cbb73a43 , 0x00003ffe //   log(1/frcpa(1+215/2^-8))
+//
+data8 0x9ccd0abd301f399c , 0x00003ffe //   log(1/frcpa(1+216/2^-8))
+data8 0x9d7e67f3bdce8888 , 0x00003ffe //   log(1/frcpa(1+217/2^-8))
+data8 0x9df4ea81a99daa01 , 0x00003ffe //   log(1/frcpa(1+218/2^-8))
+data8 0x9e6ba405a54514ba , 0x00003ffe //   log(1/frcpa(1+219/2^-8))
+data8 0x9f1e21c8c7bb62b3 , 0x00003ffe //   log(1/frcpa(1+220/2^-8))
+//
+data8 0x9f956593f6b6355c , 0x00003ffe //   log(1/frcpa(1+221/2^-8))
+data8 0xa00ce1092e5498c3 , 0x00003ffe //   log(1/frcpa(1+222/2^-8))
+data8 0xa0c08309c4b912c1 , 0x00003ffe //   log(1/frcpa(1+223/2^-8))
+data8 0xa1388a8c6faa2afa , 0x00003ffe //   log(1/frcpa(1+224/2^-8))
+data8 0xa1b0ca7095b5f985 , 0x00003ffe //   log(1/frcpa(1+225/2^-8))
+//
+data8 0xa22942eb47534a00 , 0x00003ffe //   log(1/frcpa(1+226/2^-8))
+data8 0xa2de62326449d0a3 , 0x00003ffe //   log(1/frcpa(1+227/2^-8))
+data8 0xa357690f88bfe345 , 0x00003ffe //   log(1/frcpa(1+228/2^-8))
+data8 0xa3d0a93f45169a4b , 0x00003ffe //   log(1/frcpa(1+229/2^-8))
+data8 0xa44a22f7ffe65f30 , 0x00003ffe //   log(1/frcpa(1+230/2^-8))
+//
+data8 0xa500c5e5b4c1aa36 , 0x00003ffe //   log(1/frcpa(1+231/2^-8))
+data8 0xa57ad064eb2ebbc2 , 0x00003ffe //   log(1/frcpa(1+232/2^-8))
+data8 0xa5f5152dedf4384e , 0x00003ffe //   log(1/frcpa(1+233/2^-8))
+data8 0xa66f9478856233ec , 0x00003ffe //   log(1/frcpa(1+234/2^-8))
+data8 0xa6ea4e7cca02c32e , 0x00003ffe //   log(1/frcpa(1+235/2^-8))
+//
+data8 0xa765437325341ccf , 0x00003ffe //   log(1/frcpa(1+236/2^-8))
+data8 0xa81e21e6c75b4020 , 0x00003ffe //   log(1/frcpa(1+237/2^-8))
+data8 0xa899ab333fe2b9ca , 0x00003ffe //   log(1/frcpa(1+238/2^-8))
+data8 0xa9157039c51ebe71 , 0x00003ffe //   log(1/frcpa(1+239/2^-8))
+data8 0xa991713433c2b999 , 0x00003ffe //   log(1/frcpa(1+240/2^-8))
+//
+data8 0xaa0dae5cbcc048b3 , 0x00003ffe //   log(1/frcpa(1+241/2^-8))
+data8 0xaa8a27ede5eb13ad , 0x00003ffe //   log(1/frcpa(1+242/2^-8))
+data8 0xab06de228a9e3499 , 0x00003ffe //   log(1/frcpa(1+243/2^-8))
+data8 0xab83d135dc633301 , 0x00003ffe //   log(1/frcpa(1+244/2^-8))
+data8 0xac3fb076adc7fe7a , 0x00003ffe //   log(1/frcpa(1+245/2^-8))
+//
+data8 0xacbd3cbbe47988f1 , 0x00003ffe //   log(1/frcpa(1+246/2^-8))
+data8 0xad3b06b1a5dc57c3 , 0x00003ffe //   log(1/frcpa(1+247/2^-8))
+data8 0xadb90e94af887717 , 0x00003ffe //   log(1/frcpa(1+248/2^-8))
+data8 0xae3754a218f7c816 , 0x00003ffe //   log(1/frcpa(1+249/2^-8))
+data8 0xaeb5d9175437afa2 , 0x00003ffe //   log(1/frcpa(1+250/2^-8))
+//
+data8 0xaf349c322e9c7cee , 0x00003ffe //   log(1/frcpa(1+251/2^-8))
+data8 0xafb39e30d1768d1c , 0x00003ffe //   log(1/frcpa(1+252/2^-8))
+data8 0xb032df51c2c93116 , 0x00003ffe //   log(1/frcpa(1+253/2^-8))
+data8 0xb0b25fd3e6035ad9 , 0x00003ffe //   log(1/frcpa(1+254/2^-8))
+data8 0xb1321ff67cba178c , 0x00003ffe //   log(1/frcpa(1+255/2^-8))
+LOCAL_OBJECT_END(log_table_3)
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(asinh)
+
+{ .mfi
+      getf.exp   asinh_GR_f8 = f8        // Must recompute later if x unorm
+      fclass.m   p12,p0 = f8, 0x0b       // Test x unorm
+      mov        log_GR_exp_17_ones = 0x1ffff
+}
+{ .mfi
+      addl       NR_table_address = @ltoff(log_table_1), gp
+      fma.s1     log_y = f8, f8, f1      // y = x^2 + 1
+      mov        asinh_GR_comp = 0xfffc
+}
+;;
+
+{ .mfi
+      mov        log_GR_exp_16_ones = 0xffff //BIAS
+      fclass.m   p6,p0 = f8, 0xe7        // Test for x = NaN and inf and zero
+      mov        log_GR_comp2 = 0x1003e
+}
+{ .mfi
+      ld8        NR_table_address = [NR_table_address]
+      fma.s1     asinh_w_sq = f8,f8,f0   // x^2
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fcmp.lt.s1 p7,p11 = f8,f0          // if x<0
+      nop.i      0
+}
+{ .mfb
+      nop.m      0
+      fnorm.s1   fNormX = f8             // Normalize x
+(p12) br.cond.spnt ASINH_UNORM           // Branch if x=unorm
+}
+;;
+
+ASINH_COMMON:
+// Return here if x=unorm and not denorm
+{ .mfi
+      //to get second table address
+      adds       log_table_address2 = 0x40, NR_table_address
+      fma.s1     log_arg = f8,f1,f8
+      nop.i      0
+}
+{ .mfb
+      nop.m      0
+(p6)  fma.d.s0   f8 = f8,f1,f8           // quietize nan result if x=nan
+(p6)  br.ret.spnt b0                     // Exit for x=nan and inf and zero
+}
+;;
+
+{ .mfi
+      ldfpd      NR1,NR2 = [log_table_address2],16
+      frsqrta.s1 log_y_rs,p0 = log_y     // z=1/sqrt(y)
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfe       log_C13 = [log_table_address2],16
+      nop.f      0
+      and        asinh_GR_f8 = asinh_GR_f8,log_GR_exp_17_ones
+}
+;;
+
+{ .mib
+      ldfe       log_C11 = [log_table_address2],16
+      cmp.le     p13,p0 = log_GR_comp2,asinh_GR_f8
+(p13) br.cond.spnt LOG_COMMON1           // Branch if path 4, |x| >= 2^63
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter = log_y_rs,log_y,f0  // y*z
+      nop.i      0
+}
+;;
+
+.pred.rel "mutex",p7,p11
+{ .mfi
+      nop.m      0
+(p11) mov        asinh_f8 = fNormX
+      nop.i      0
+}
+{ .mfb
+      cmp.gt     p8,p0 = asinh_GR_comp,asinh_GR_f8
+(p7)  fnma.s1    asinh_f8 = fNormX,f1,f0
+(p8)  br.cond.spnt ASINH_NEAR_ZERO       // Branch if path 2, 0 < |x| < 2^-3
+}
+;;
+
+// Here if main path, 2^-3 <= |x| < 2^63
+///////////////////////////////// The first iteration /////////////////////////
+{ .mfi
+      ldfpd      log_P5,log_P4 = [NR_table_address],16
+      fnma.s1    log_y_rs_iter = log_y_rs_iter,log_y_rs,NR2     // 3-(y*z)*z
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs,NR1,f0               // 0.5*z
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfpd      log_P3,log_P2 = [NR_table_address],16
+      // (0.5*z)*(3-(y*z)*z)
+      fma.s1     log_y_rs_iter = log_y_rs_iter1,log_y_rs_iter,f0
+      nop.i      0
+}
+;;
+
+/////////////////////////// The second iteration /////////////////////////////
+{ .mfi
+      ldfd       log_P1 = [NR_table_address],16
+      fma.s1     log_y_rs = log_y_rs_iter,log_y,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fnma.s1    log_y_rs = log_y_rs,log_y_rs_iter,NR2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs_iter,NR1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfe       log2 = [NR_table_address],16
+      // (0.5*z)*(3-(y*z)*z)
+      fma.s1     log_y_rs_iter = log_y_rs_iter1,log_y_rs,f0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      // (0.5*z)*(3-(y*z)*z)
+      fma.s1     log_arg_early = log_y_rs_iter1,log_y_rs,f0
+      nop.i      0
+}
+;;
+
+////////////////////////////////// The third iteration ////////////////////////
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs = log_y_rs_iter,log_y,f0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs_iter,NR1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_arg_early = log_arg_early,log_y,asinh_f8
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fnma.s1    log_y_rs = log_y_rs,log_y_rs_iter,NR2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs_iter1,log_y,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      frcpa.s1   log_C,p0 = f1,log_arg_early
+      nop.i      0
+}
+;;
+
+{ .mfi
+      getf.exp   log_GR_signexp_f8 = log_arg_early
+      nop.f      0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      getf.sig   log_GR_significand_f8 = log_arg_early
+      // (0.5*z)*(3-(y*z)*z)*y + |x|
+      fma.s1     log_arg = log_y_rs_iter1,log_y_rs,asinh_f8
+      //to get third table address
+      adds       log_table_address3 = 0x70, NR_table_address
+}
+;;
+
+///////////////////////////////// The end NR iterations /////////////////////
+{ .mfi
+      nop.m      0
+      nop.f      0
+      //significant bit destruction
+      and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones
+}
+;;
+
+{ .mfi
+      //BIAS subtraction
+      sub        log_GR_true_exp_f8 = log_GR_exp_f8, log_GR_exp_16_ones
+(p7)  fnma.s1    log2 = log2,f1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      setf.sig   log_int_Nfloat = log_GR_true_exp_f8
+      fms.s1     log_r = log_C,log_arg,f1  // C = frcpa(x); r = C * x - 1
+      extr.u     log_GR_index = log_GR_significand_f8,55,8 //Extract 8 bits
+}
+;;
+
+{ .mmi
+      //pre-index*16 + index
+      shladd     log_table_address3 = log_GR_index,4,log_table_address3
+;;
+      ldfe       log_T = [log_table_address3]
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rsq = log_r, log_r, f0          //r^2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p4 = log_P5, log_r, log_P4   //P5*r + P4
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p32 = log_P3, log_r, log_P2  //P3*r + P2
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //convert N to the floating-point format
+      fcvt.xf    log_Nfloat = log_int_Nfloat
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rcube = log_rsq, log_r, f0      //r^3
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p10 = log_rsq, log_P1, log_r //P1*r^2 + r
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //(P5*r + P4)*r^2 + P3*r + P2
+      fma.s1     log_rp_p2 = log_rp_p4, log_rsq, log_rp_p32
+      nop.i      0
+}
+;;
+
+.pred.rel "mutex",p7,p11
+{ .mfi
+      nop.m      0
+(p11) fma.s1     log_T_plus_Nlog2 = log_Nfloat,log2,log_T  //N*log2 + T if x>0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+(p7)  fms.s1     log_T_plus_Nlog2 = log_Nfloat,log2,log_T  //N*log2 - T if x<0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //((P5*r + P4)*r^2 + P3*r + P2)*w^3 + P1*r^2 + r
+      fma.s1     log_r2P_r = log_rp_p2, log_rcube, log_rp_p10
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //  N*log2 + T + ((P5*r + P4)*r^2 + P3*r + P2)*r^3 + P1*r^2 + r
+(p11) fadd.d.s0  f8 = log_T_plus_Nlog2,log_r2P_r
+      nop.i      0
+}
+{ .mfb
+      nop.m      0
+      // -N*log2 - T - ((P5*r + P4)*r^2 + P3*r + P2)*r^3 + P1*r^2 + r
+(p7)  fsub.d.s0  f8 = log_T_plus_Nlog2,log_r2P_r
+      br.ret.sptk b0           // Exit main path, path 3: 2^-3 <= |x| < 2^63
+}
+;;
+
+// Here if path 4, |x| >= 2^63
+LOG_COMMON1:
+{ .mfi
+      ldfpd      log_P5,log_P4 = [NR_table_address],16
+      nop.f      0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfpd      log_P3,log_P2 = [NR_table_address],16
+      frcpa.s1   log_C,p0 = f1,log_arg
+      nop.i      0
+}
+;;
+
+{ .mmi
+      getf.exp   log_GR_signexp_f8 = log_arg
+      ldfd       log_P1 = [NR_table_address],16
+      nop.i      0
+}
+;;
+
+{ .mmi
+      getf.sig   log_GR_significand_f8 = log_arg
+      ldfe       log2 = [NR_table_address],16
+      nop.i      0
+}
+;;
+
+{ .mfi
+      adds       log_table_address3 = 0x70, NR_table_address
+      nop.f      0
+      //significant bit destruction
+      and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones
+}
+;;
+
+{ .mmf
+      nop.m      0
+      //BIAS subtraction
+      sub        log_GR_true_exp_f8 = log_GR_exp_f8, log_GR_exp_16_ones
+      fms.s1     log_r = log_C,log_arg,f1  //C = frcpa(x); r = C * x - 1
+}
+;;
+
+{ .mfi
+      setf.sig   log_int_Nfloat = log_GR_true_exp_f8
+      nop.f      0
+      extr.u     log_GR_index = log_GR_significand_f8,55,8 //Extract 8 bits
+}
+;;
+
+{ .mmi
+      //pre-index*16 + index
+      shladd     log_table_address3 = log_GR_index,4,log_table_address3
+;;
+      ldfe       log_T = [log_table_address3]
+      nop.i      0
+
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rsq = log_r, log_r, f0          //r^2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p4 = log_P5, log_r, log_P4   //P5*r + P4
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p32 = log_P3, log_r, log_P2  //P3*r + P2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+(p7)  fnma.s1    log2 = log2,f1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rcube = log_rsq, log_r, f0      //r^3
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p10 = log_rsq, log_P1, log_r //P1*r^2 + r
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //convert N to the floating-point format
+      fcvt.xf    log_Nfloat = log_int_Nfloat
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      //(P5*r + P4)*r^2 + P3*r + P2
+      fma.s1     log_rp_p2 = log_rp_p4, log_rsq, log_rp_p32
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+(p7)  fnma.s1    log_T = log_T,f1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_T_plus_Nlog2 = log_Nfloat,log2,log_T    //N*log2 + T
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      //((P5*r + P4)*r^2 + P3*r + P2)*w^3 + P1*r^2 + r
+      fma.s1     log_r2P_r = log_rp_p2, log_rcube, log_rp_p10
+      nop.i      0
+}
+;;
+
+.pred.rel "mutex",p7,p11
+{ .mfi
+      nop.m      0
+      //  N*log2 + T + ((P5*r + P4)*r^2 + P3*r + P2)*r^3 + P1*r^2 + r
+(p11) fadd.d.s0  f8 = log_T_plus_Nlog2,log_r2P_r
+      nop.i      0
+}
+{ .mfb
+      nop.m      0
+      // -N*log2 - T - ((P5*r + P4)*r^2 + P3*r + P2)*r^3 + P1*r^2 + r
+(p7)  fsub.d.s0  f8 = log_T_plus_Nlog2,log_r2P_r
+      br.ret.sptk b0              // Exit path 4, |x| >= 2^63
+}
+;;
+
+// Here is path 2, 0 < |x| < 2^-3
+ASINH_NEAR_ZERO:
+{ .mfi
+      ldfe       log_C9 = [log_table_address2],16
+      fma.s1     asinh_w_cube = asinh_w_sq,fNormX,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfe       log_C7 = [log_table_address2],16
+      fma.s1     asinh_w_four = asinh_w_sq,asinh_w_sq,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfe       log_C5 = [log_table_address2],16
+      nop.f      0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfe       log_C3 = [log_table_address2],16
+      nop.f      0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     asinh_w_13 = log_C13,asinh_w_sq,log_C11
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     asinh_w_9 = log_C9,asinh_w_sq,log_C7
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     asinh_w_3 = log_C5,asinh_w_sq,log_C3
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     asinh_w_seven = asinh_w_four,asinh_w_cube,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     asinh_w_7 = asinh_w_13,asinh_w_four,asinh_w_9
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     asinh_w_5 = asinh_w_3,asinh_w_cube,fNormX
+      nop.i      0
+}
+;;
+
+{ .mfb
+      nop.m      0
+      fma.d.s0   f8 = asinh_w_7,asinh_w_seven,asinh_w_5
+      br.ret.sptk b0                   // Exit path 2 (0.0 <|x| < 2^(-3))
+}
+;;
+
+ASINH_UNORM:
+// Here if x=unorm
+{ .mfi
+      getf.exp   asinh_GR_f8 = fNormX  // Recompute if x unorm
+      fclass.m   p0,p13 = fNormX, 0x0b // Test x denorm
+      nop.i      0
+}
+;;
+
+{ .mfb
+      nop.m      0
+      fcmp.eq.s0 p14,p0 = f8, f0       // Dummy to set denormal flag
+(p13) br.cond.sptk ASINH_COMMON        // Continue if x unorm and not denorm
+}
+;;
+
+.pred.rel "mutex",p7,p11
+{ .mfi
+      nop.m      0
+(p7)  fma.d.s0   f8 = f8,f8,f8         // Result x+x^2 if x=-denorm
+      nop.i      0
+}
+{ .mfb
+      nop.m      0
+(p11) fnma.d.s0  f8 = f8,f8,f8         // Result x-x^2 if x=+denorm
+      br.ret.spnt b0                   // Exit if denorm
+}
+;;
+
+GLOBAL_LIBM_END(asinh)
+libm_alias_double_other (asinh, asinh)
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_asinhf.S
@@ -0,0 +1,937 @@
+.file "asinhf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// ==============================================================
+// History
+// ==============================================================
+// 04/02/01 Initial version
+// 04/19/01 Improved speed of the paths #1,2,3,4,5
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align
+// 05/21/03 Improved performance, fixed to handle unorms
+//
+// API
+// ==============================================================
+// float asinhf(float)
+//
+// Overview of operation
+// ==============================================================
+//
+// There are 7 paths:
+// 1. x = 0.0
+//    Return asinhf(x) = 0.0
+// 2. 0.0 <|x| < 2^(-5)
+//    Return asinhf(x) = Pol5(x), where Pol5(x) = ((x^2)*C1 + C0)*x^3 + x
+
+// 3. 2^(-5) <= |x| < 2^51
+//    Return asinhf(x) = sign(x)*(log(|x| + sqrt(x^2 + 1.0)))
+//    To compute x + sqrt(x^2 + 1.0) modified Newton Raphson method is used
+//    (2 iterations)
+//    Algorithm description for log function see below.
+//
+// 4. 2^51 <= |x| < +INF
+//    Return asinhf(x) = sign(x)*log(2*|x|)
+//    Algorithm description for log function see below.
+//
+// 5. x = INF
+//    Return asinhf(x) = INF
+//
+// 6. x = [S,Q]NaN
+//    Return asinhf(x) = QNaN
+//
+// 7. x = denormal
+//    Return asinhf(x) = x
+//
+//==============================================================
+// Algorithm Description for log(x) function
+// Below we are using the fact that inequality x - 1.0 > 2^(-6) is always
+// true for this asinh implementation
+//
+// Consider  x = 2^N 1.f1 f2 f3 f4...f63
+// Log(x) = log(frcpa(x) x/frcpa(x))
+//        = log(1/frcpa(x)) + log(frcpa(x) x)
+//        = -log(frcpa(x)) + log(frcpa(x) x)
+//
+// frcpa(x)       = 2^-N frcpa((1.f1 f2 ... f63)
+//
+// -log(frcpa(x)) = -log(C)
+//                = -log(2^-N) - log(frcpa(1.f1 f2 ... f63))
+//
+// -log(frcpa(x)) = -log(C)
+//                = +Nlog2 - log(frcpa(1.f1 f2 ... f63))
+//
+// -log(frcpa(x)) = -log(C)
+//                = +Nlog2 + log(frcpa(1.f1 f2 ... f63))
+//
+// Log(x) = log(1/frcpa(x)) + log(frcpa(x) x)
+//
+// Log(x) =  +Nlog2 + log(1./frcpa(1.f1 f2 ... f63)) + log(frcpa(x) x)
+// Log(x) =  +Nlog2 - log(/frcpa(1.f1 f2 ... f63))   + log(frcpa(x) x)
+// Log(x) =  +Nlog2 + T                              + log(frcpa(x) x)
+//
+// Log(x) =  +Nlog2 + T                     + log(C x)
+//
+// Cx = 1 + r
+//
+// Log(x) =  +Nlog2 + T  + log(1+r)
+// Log(x) =  +Nlog2 + T  + Series( r - r^2/2 + r^3/3 - r^4/4 ....)
+//
+// 1.f1 f2 ... f8 has 256 entries.
+// They are 1 + k/2^8, k = 0 ... 255
+// These 256 values are the table entries.
+//
+// Implementation
+//==============================================================
+// C = frcpa(x)
+// r = C * x - 1
+//
+// Form rseries = r + P1*r^2 + P2*r^3 + P3*r^4
+//
+// x = f * 2*n where f is 1.f_1f_2f_3....f_63
+// Nfloat = float(n)  where n is the true unbiased exponent
+// pre-index = f_1f_2....f_8
+// index = pre_index * 8
+// get the dxt table entry at index + offset = T
+//
+// result = (T + Nfloat * log(2)) + rseries
+//
+// The T table is calculated as follows
+// Form x_k = 1 + k/2^8 where k goes from 0... 255
+//      y_k = frcpa(x_k)
+//      log(1/y_k)  in quad and round to double-extended
+//
+//
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input
+// f9 -> f15,  f32 -> f55
+
+// General registers used:
+// r14 -> r27
+
+// Predicate registers used:
+// p6 -> p14
+
+// p6 to filter out case when x = [Q,S]NaN or INF or zero
+// p7 to filter out case when x < 0.0
+// p8 to select path #2
+
+// p11 to filter out case when x >= 0
+// p12 to filter out case when x = + denormal
+// p13 to select path #4
+// p14 to filtef out case when x = - denormal
+// Assembly macros
+//==============================================================
+log_GR_exp_17_ones    = r14
+log_GR_signexp_f8     = r15
+log_table_address2    = r16
+log_GR_exp_16_ones    = r17
+log_GR_exp_f8         = r18
+log_GR_true_exp_f8    = r19
+log_GR_significand_f8 = r20
+log_GR_index          = r21
+log_GR_comp2          = r22
+asinh_GR_f8           = r23
+asinh_GR_comp         = r24
+asinh_GR_f8           = r25
+log_table_address3    = r26
+NR_table_address      = r27
+
+//==============================================================
+log_y            = f9
+NR1              = f10
+NR2              = f11
+log_y_rs         = f12
+log_y_rs_iter    = f13
+log_y_rs_iter1   = f14
+fNormX           = f15
+asinh_w_sq       = f32
+log_arg_early    = f33
+log_y_rs_iter2   = f34
+log_P3           = f35
+log_P2           = f36
+log_P1           = f37
+log2             = f38
+log_C0           = f39
+log_C1           = f40
+asinh_f8         = f41
+log_C            = f42
+log_arg          = f43
+asinh_w_cube     = f44
+log_int_Nfloat   = f45
+log_r            = f46
+log_rsq          = f47
+asinh_w_1        = f48
+log_rp_p32       = f49
+log_rcube        = f50
+log_rp_p10       = f51
+log_rp_p2        = f52
+log_Nfloat       = f53
+log_T            = f54
+log_T_plus_Nlog2 = f55
+
+// Data tables
+//==============================================================
+
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(log_table_1)
+
+data8 0xbfd0001008f39d59 // p3
+data8 0x3fd5556073e0c45a // p2
+data8 0xbfdffffffffaea15 // p1
+data8 0x3fe62e42fefa39ef // log(2)
+LOCAL_OBJECT_END(log_table_1)
+
+LOCAL_OBJECT_START(log_table_2)
+data8 0x3FE0000000000000 // 0.5
+data8 0x4008000000000000 // 3.0
+data8 0x9979C79685A5EB16, 0x00003FFB // C1 3FFB9979C79685A5EB16
+data8 0xAAAAA96F80786D62, 0x0000BFFC // C0 BFFCAAAAA96F80786D62
+LOCAL_OBJECT_END(log_table_2)
+
+LOCAL_OBJECT_START(log_table_3)
+data8 0x3F60040155D5889E    //log(1/frcpa(1+   0/256)
+data8 0x3F78121214586B54    //log(1/frcpa(1+   1/256)
+data8 0x3F841929F96832F0    //log(1/frcpa(1+   2/256)
+data8 0x3F8C317384C75F06    //log(1/frcpa(1+   3/256)
+data8 0x3F91A6B91AC73386    //log(1/frcpa(1+   4/256)
+data8 0x3F95BA9A5D9AC039    //log(1/frcpa(1+   5/256)
+data8 0x3F99D2A8074325F4    //log(1/frcpa(1+   6/256)
+data8 0x3F9D6B2725979802    //log(1/frcpa(1+   7/256)
+data8 0x3FA0C58FA19DFAAA    //log(1/frcpa(1+   8/256)
+data8 0x3FA2954C78CBCE1B    //log(1/frcpa(1+   9/256)
+data8 0x3FA4A94D2DA96C56    //log(1/frcpa(1+  10/256)
+data8 0x3FA67C94F2D4BB58    //log(1/frcpa(1+  11/256)
+data8 0x3FA85188B630F068    //log(1/frcpa(1+  12/256)
+data8 0x3FAA6B8ABE73AF4C    //log(1/frcpa(1+  13/256)
+data8 0x3FAC441E06F72A9E    //log(1/frcpa(1+  14/256)
+data8 0x3FAE1E6713606D07    //log(1/frcpa(1+  15/256)
+data8 0x3FAFFA6911AB9301    //log(1/frcpa(1+  16/256)
+data8 0x3FB0EC139C5DA601    //log(1/frcpa(1+  17/256)
+data8 0x3FB1DBD2643D190B    //log(1/frcpa(1+  18/256)
+data8 0x3FB2CC7284FE5F1C    //log(1/frcpa(1+  19/256)
+data8 0x3FB3BDF5A7D1EE64    //log(1/frcpa(1+  20/256)
+data8 0x3FB4B05D7AA012E0    //log(1/frcpa(1+  21/256)
+data8 0x3FB580DB7CEB5702    //log(1/frcpa(1+  22/256)
+data8 0x3FB674F089365A7A    //log(1/frcpa(1+  23/256)
+data8 0x3FB769EF2C6B568D    //log(1/frcpa(1+  24/256)
+data8 0x3FB85FD927506A48    //log(1/frcpa(1+  25/256)
+data8 0x3FB9335E5D594989    //log(1/frcpa(1+  26/256)
+data8 0x3FBA2B0220C8E5F5    //log(1/frcpa(1+  27/256)
+data8 0x3FBB0004AC1A86AC    //log(1/frcpa(1+  28/256)
+data8 0x3FBBF968769FCA11    //log(1/frcpa(1+  29/256)
+data8 0x3FBCCFEDBFEE13A8    //log(1/frcpa(1+  30/256)
+data8 0x3FBDA727638446A2    //log(1/frcpa(1+  31/256)
+data8 0x3FBEA3257FE10F7A    //log(1/frcpa(1+  32/256)
+data8 0x3FBF7BE9FEDBFDE6    //log(1/frcpa(1+  33/256)
+data8 0x3FC02AB352FF25F4    //log(1/frcpa(1+  34/256)
+data8 0x3FC097CE579D204D    //log(1/frcpa(1+  35/256)
+data8 0x3FC1178E8227E47C    //log(1/frcpa(1+  36/256)
+data8 0x3FC185747DBECF34    //log(1/frcpa(1+  37/256)
+data8 0x3FC1F3B925F25D41    //log(1/frcpa(1+  38/256)
+data8 0x3FC2625D1E6DDF57    //log(1/frcpa(1+  39/256)
+data8 0x3FC2D1610C86813A    //log(1/frcpa(1+  40/256)
+data8 0x3FC340C59741142E    //log(1/frcpa(1+  41/256)
+data8 0x3FC3B08B6757F2A9    //log(1/frcpa(1+  42/256)
+data8 0x3FC40DFB08378003    //log(1/frcpa(1+  43/256)
+data8 0x3FC47E74E8CA5F7C    //log(1/frcpa(1+  44/256)
+data8 0x3FC4EF51F6466DE4    //log(1/frcpa(1+  45/256)
+data8 0x3FC56092E02BA516    //log(1/frcpa(1+  46/256)
+data8 0x3FC5D23857CD74D5    //log(1/frcpa(1+  47/256)
+data8 0x3FC6313A37335D76    //log(1/frcpa(1+  48/256)
+data8 0x3FC6A399DABBD383    //log(1/frcpa(1+  49/256)
+data8 0x3FC70337DD3CE41B    //log(1/frcpa(1+  50/256)
+data8 0x3FC77654128F6127    //log(1/frcpa(1+  51/256)
+data8 0x3FC7E9D82A0B022D    //log(1/frcpa(1+  52/256)
+data8 0x3FC84A6B759F512F    //log(1/frcpa(1+  53/256)
+data8 0x3FC8AB47D5F5A310    //log(1/frcpa(1+  54/256)
+data8 0x3FC91FE49096581B    //log(1/frcpa(1+  55/256)
+data8 0x3FC981634011AA75    //log(1/frcpa(1+  56/256)
+data8 0x3FC9F6C407089664    //log(1/frcpa(1+  57/256)
+data8 0x3FCA58E729348F43    //log(1/frcpa(1+  58/256)
+data8 0x3FCABB55C31693AD    //log(1/frcpa(1+  59/256)
+data8 0x3FCB1E104919EFD0    //log(1/frcpa(1+  60/256)
+data8 0x3FCB94EE93E367CB    //log(1/frcpa(1+  61/256)
+data8 0x3FCBF851C067555F    //log(1/frcpa(1+  62/256)
+data8 0x3FCC5C0254BF23A6    //log(1/frcpa(1+  63/256)
+data8 0x3FCCC000C9DB3C52    //log(1/frcpa(1+  64/256)
+data8 0x3FCD244D99C85674    //log(1/frcpa(1+  65/256)
+data8 0x3FCD88E93FB2F450    //log(1/frcpa(1+  66/256)
+data8 0x3FCDEDD437EAEF01    //log(1/frcpa(1+  67/256)
+data8 0x3FCE530EFFE71012    //log(1/frcpa(1+  68/256)
+data8 0x3FCEB89A1648B971    //log(1/frcpa(1+  69/256)
+data8 0x3FCF1E75FADF9BDE    //log(1/frcpa(1+  70/256)
+data8 0x3FCF84A32EAD7C35    //log(1/frcpa(1+  71/256)
+data8 0x3FCFEB2233EA07CD    //log(1/frcpa(1+  72/256)
+data8 0x3FD028F9C7035C1C    //log(1/frcpa(1+  73/256)
+data8 0x3FD05C8BE0D9635A    //log(1/frcpa(1+  74/256)
+data8 0x3FD085EB8F8AE797    //log(1/frcpa(1+  75/256)
+data8 0x3FD0B9C8E32D1911    //log(1/frcpa(1+  76/256)
+data8 0x3FD0EDD060B78081    //log(1/frcpa(1+  77/256)
+data8 0x3FD122024CF0063F    //log(1/frcpa(1+  78/256)
+data8 0x3FD14BE2927AECD4    //log(1/frcpa(1+  79/256)
+data8 0x3FD180618EF18ADF    //log(1/frcpa(1+  80/256)
+data8 0x3FD1B50BBE2FC63B    //log(1/frcpa(1+  81/256)
+data8 0x3FD1DF4CC7CF242D    //log(1/frcpa(1+  82/256)
+data8 0x3FD214456D0EB8D4    //log(1/frcpa(1+  83/256)
+data8 0x3FD23EC5991EBA49    //log(1/frcpa(1+  84/256)
+data8 0x3FD2740D9F870AFB    //log(1/frcpa(1+  85/256)
+data8 0x3FD29ECDABCDFA04    //log(1/frcpa(1+  86/256)
+data8 0x3FD2D46602ADCCEE    //log(1/frcpa(1+  87/256)
+data8 0x3FD2FF66B04EA9D4    //log(1/frcpa(1+  88/256)
+data8 0x3FD335504B355A37    //log(1/frcpa(1+  89/256)
+data8 0x3FD360925EC44F5D    //log(1/frcpa(1+  90/256)
+data8 0x3FD38BF1C3337E75    //log(1/frcpa(1+  91/256)
+data8 0x3FD3C25277333184    //log(1/frcpa(1+  92/256)
+data8 0x3FD3EDF463C1683E    //log(1/frcpa(1+  93/256)
+data8 0x3FD419B423D5E8C7    //log(1/frcpa(1+  94/256)
+data8 0x3FD44591E0539F49    //log(1/frcpa(1+  95/256)
+data8 0x3FD47C9175B6F0AD    //log(1/frcpa(1+  96/256)
+data8 0x3FD4A8B341552B09    //log(1/frcpa(1+  97/256)
+data8 0x3FD4D4F3908901A0    //log(1/frcpa(1+  98/256)
+data8 0x3FD501528DA1F968    //log(1/frcpa(1+  99/256)
+data8 0x3FD52DD06347D4F6    //log(1/frcpa(1+ 100/256)
+data8 0x3FD55A6D3C7B8A8A    //log(1/frcpa(1+ 101/256)
+data8 0x3FD5925D2B112A59    //log(1/frcpa(1+ 102/256)
+data8 0x3FD5BF406B543DB2    //log(1/frcpa(1+ 103/256)
+data8 0x3FD5EC433D5C35AE    //log(1/frcpa(1+ 104/256)
+data8 0x3FD61965CDB02C1F    //log(1/frcpa(1+ 105/256)
+data8 0x3FD646A84935B2A2    //log(1/frcpa(1+ 106/256)
+data8 0x3FD6740ADD31DE94    //log(1/frcpa(1+ 107/256)
+data8 0x3FD6A18DB74A58C5    //log(1/frcpa(1+ 108/256)
+data8 0x3FD6CF31058670EC    //log(1/frcpa(1+ 109/256)
+data8 0x3FD6F180E852F0BA    //log(1/frcpa(1+ 110/256)
+data8 0x3FD71F5D71B894F0    //log(1/frcpa(1+ 111/256)
+data8 0x3FD74D5AEFD66D5C    //log(1/frcpa(1+ 112/256)
+data8 0x3FD77B79922BD37E    //log(1/frcpa(1+ 113/256)
+data8 0x3FD7A9B9889F19E2    //log(1/frcpa(1+ 114/256)
+data8 0x3FD7D81B037EB6A6    //log(1/frcpa(1+ 115/256)
+data8 0x3FD8069E33827231    //log(1/frcpa(1+ 116/256)
+data8 0x3FD82996D3EF8BCB    //log(1/frcpa(1+ 117/256)
+data8 0x3FD85855776DCBFB    //log(1/frcpa(1+ 118/256)
+data8 0x3FD8873658327CCF    //log(1/frcpa(1+ 119/256)
+data8 0x3FD8AA75973AB8CF    //log(1/frcpa(1+ 120/256)
+data8 0x3FD8D992DC8824E5    //log(1/frcpa(1+ 121/256)
+data8 0x3FD908D2EA7D9512    //log(1/frcpa(1+ 122/256)
+data8 0x3FD92C59E79C0E56    //log(1/frcpa(1+ 123/256)
+data8 0x3FD95BD750EE3ED3    //log(1/frcpa(1+ 124/256)
+data8 0x3FD98B7811A3EE5B    //log(1/frcpa(1+ 125/256)
+data8 0x3FD9AF47F33D406C    //log(1/frcpa(1+ 126/256)
+data8 0x3FD9DF270C1914A8    //log(1/frcpa(1+ 127/256)
+data8 0x3FDA0325ED14FDA4    //log(1/frcpa(1+ 128/256)
+data8 0x3FDA33440224FA79    //log(1/frcpa(1+ 129/256)
+data8 0x3FDA57725E80C383    //log(1/frcpa(1+ 130/256)
+data8 0x3FDA87D0165DD199    //log(1/frcpa(1+ 131/256)
+data8 0x3FDAAC2E6C03F896    //log(1/frcpa(1+ 132/256)
+data8 0x3FDADCCC6FDF6A81    //log(1/frcpa(1+ 133/256)
+data8 0x3FDB015B3EB1E790    //log(1/frcpa(1+ 134/256)
+data8 0x3FDB323A3A635948    //log(1/frcpa(1+ 135/256)
+data8 0x3FDB56FA04462909    //log(1/frcpa(1+ 136/256)
+data8 0x3FDB881AA659BC93    //log(1/frcpa(1+ 137/256)
+data8 0x3FDBAD0BEF3DB165    //log(1/frcpa(1+ 138/256)
+data8 0x3FDBD21297781C2F    //log(1/frcpa(1+ 139/256)
+data8 0x3FDC039236F08819    //log(1/frcpa(1+ 140/256)
+data8 0x3FDC28CB1E4D32FD    //log(1/frcpa(1+ 141/256)
+data8 0x3FDC4E19B84723C2    //log(1/frcpa(1+ 142/256)
+data8 0x3FDC7FF9C74554C9    //log(1/frcpa(1+ 143/256)
+data8 0x3FDCA57B64E9DB05    //log(1/frcpa(1+ 144/256)
+data8 0x3FDCCB130A5CEBB0    //log(1/frcpa(1+ 145/256)
+data8 0x3FDCF0C0D18F326F    //log(1/frcpa(1+ 146/256)
+data8 0x3FDD232075B5A201    //log(1/frcpa(1+ 147/256)
+data8 0x3FDD490246DEFA6B    //log(1/frcpa(1+ 148/256)
+data8 0x3FDD6EFA918D25CD    //log(1/frcpa(1+ 149/256)
+data8 0x3FDD9509707AE52F    //log(1/frcpa(1+ 150/256)
+data8 0x3FDDBB2EFE92C554    //log(1/frcpa(1+ 151/256)
+data8 0x3FDDEE2F3445E4AF    //log(1/frcpa(1+ 152/256)
+data8 0x3FDE148A1A2726CE    //log(1/frcpa(1+ 153/256)
+data8 0x3FDE3AFC0A49FF40    //log(1/frcpa(1+ 154/256)
+data8 0x3FDE6185206D516E    //log(1/frcpa(1+ 155/256)
+data8 0x3FDE882578823D52    //log(1/frcpa(1+ 156/256)
+data8 0x3FDEAEDD2EAC990C    //log(1/frcpa(1+ 157/256)
+data8 0x3FDED5AC5F436BE3    //log(1/frcpa(1+ 158/256)
+data8 0x3FDEFC9326D16AB9    //log(1/frcpa(1+ 159/256)
+data8 0x3FDF2391A2157600    //log(1/frcpa(1+ 160/256)
+data8 0x3FDF4AA7EE03192D    //log(1/frcpa(1+ 161/256)
+data8 0x3FDF71D627C30BB0    //log(1/frcpa(1+ 162/256)
+data8 0x3FDF991C6CB3B379    //log(1/frcpa(1+ 163/256)
+data8 0x3FDFC07ADA69A910    //log(1/frcpa(1+ 164/256)
+data8 0x3FDFE7F18EB03D3E    //log(1/frcpa(1+ 165/256)
+data8 0x3FE007C053C5002E    //log(1/frcpa(1+ 166/256)
+data8 0x3FE01B942198A5A1    //log(1/frcpa(1+ 167/256)
+data8 0x3FE02F74400C64EB    //log(1/frcpa(1+ 168/256)
+data8 0x3FE04360BE7603AD    //log(1/frcpa(1+ 169/256)
+data8 0x3FE05759AC47FE34    //log(1/frcpa(1+ 170/256)
+data8 0x3FE06B5F1911CF52    //log(1/frcpa(1+ 171/256)
+data8 0x3FE078BF0533C568    //log(1/frcpa(1+ 172/256)
+data8 0x3FE08CD9687E7B0E    //log(1/frcpa(1+ 173/256)
+data8 0x3FE0A10074CF9019    //log(1/frcpa(1+ 174/256)
+data8 0x3FE0B5343A234477    //log(1/frcpa(1+ 175/256)
+data8 0x3FE0C974C89431CE    //log(1/frcpa(1+ 176/256)
+data8 0x3FE0DDC2305B9886    //log(1/frcpa(1+ 177/256)
+data8 0x3FE0EB524BAFC918    //log(1/frcpa(1+ 178/256)
+data8 0x3FE0FFB54213A476    //log(1/frcpa(1+ 179/256)
+data8 0x3FE114253DA97D9F    //log(1/frcpa(1+ 180/256)
+data8 0x3FE128A24F1D9AFF    //log(1/frcpa(1+ 181/256)
+data8 0x3FE1365252BF0865    //log(1/frcpa(1+ 182/256)
+data8 0x3FE14AE558B4A92D    //log(1/frcpa(1+ 183/256)
+data8 0x3FE15F85A19C765B    //log(1/frcpa(1+ 184/256)
+data8 0x3FE16D4D38C119FA    //log(1/frcpa(1+ 185/256)
+data8 0x3FE18203C20DD133    //log(1/frcpa(1+ 186/256)
+data8 0x3FE196C7BC4B1F3B    //log(1/frcpa(1+ 187/256)
+data8 0x3FE1A4A738B7A33C    //log(1/frcpa(1+ 188/256)
+data8 0x3FE1B981C0C9653D    //log(1/frcpa(1+ 189/256)
+data8 0x3FE1CE69E8BB106B    //log(1/frcpa(1+ 190/256)
+data8 0x3FE1DC619DE06944    //log(1/frcpa(1+ 191/256)
+data8 0x3FE1F160A2AD0DA4    //log(1/frcpa(1+ 192/256)
+data8 0x3FE2066D7740737E    //log(1/frcpa(1+ 193/256)
+data8 0x3FE2147DBA47A394    //log(1/frcpa(1+ 194/256)
+data8 0x3FE229A1BC5EBAC3    //log(1/frcpa(1+ 195/256)
+data8 0x3FE237C1841A502E    //log(1/frcpa(1+ 196/256)
+data8 0x3FE24CFCE6F80D9A    //log(1/frcpa(1+ 197/256)
+data8 0x3FE25B2C55CD5762    //log(1/frcpa(1+ 198/256)
+data8 0x3FE2707F4D5F7C41    //log(1/frcpa(1+ 199/256)
+data8 0x3FE285E0842CA384    //log(1/frcpa(1+ 200/256)
+data8 0x3FE294294708B773    //log(1/frcpa(1+ 201/256)
+data8 0x3FE2A9A2670AFF0C    //log(1/frcpa(1+ 202/256)
+data8 0x3FE2B7FB2C8D1CC1    //log(1/frcpa(1+ 203/256)
+data8 0x3FE2C65A6395F5F5    //log(1/frcpa(1+ 204/256)
+data8 0x3FE2DBF557B0DF43    //log(1/frcpa(1+ 205/256)
+data8 0x3FE2EA64C3F97655    //log(1/frcpa(1+ 206/256)
+data8 0x3FE3001823684D73    //log(1/frcpa(1+ 207/256)
+data8 0x3FE30E97E9A8B5CD    //log(1/frcpa(1+ 208/256)
+data8 0x3FE32463EBDD34EA    //log(1/frcpa(1+ 209/256)
+data8 0x3FE332F4314AD796    //log(1/frcpa(1+ 210/256)
+data8 0x3FE348D90E7464D0    //log(1/frcpa(1+ 211/256)
+data8 0x3FE35779F8C43D6E    //log(1/frcpa(1+ 212/256)
+data8 0x3FE36621961A6A99    //log(1/frcpa(1+ 213/256)
+data8 0x3FE37C299F3C366A    //log(1/frcpa(1+ 214/256)
+data8 0x3FE38AE2171976E7    //log(1/frcpa(1+ 215/256)
+data8 0x3FE399A157A603E7    //log(1/frcpa(1+ 216/256)
+data8 0x3FE3AFCCFE77B9D1    //log(1/frcpa(1+ 217/256)
+data8 0x3FE3BE9D503533B5    //log(1/frcpa(1+ 218/256)
+data8 0x3FE3CD7480B4A8A3    //log(1/frcpa(1+ 219/256)
+data8 0x3FE3E3C43918F76C    //log(1/frcpa(1+ 220/256)
+data8 0x3FE3F2ACB27ED6C7    //log(1/frcpa(1+ 221/256)
+data8 0x3FE4019C2125CA93    //log(1/frcpa(1+ 222/256)
+data8 0x3FE4181061389722    //log(1/frcpa(1+ 223/256)
+data8 0x3FE42711518DF545    //log(1/frcpa(1+ 224/256)
+data8 0x3FE436194E12B6BF    //log(1/frcpa(1+ 225/256)
+data8 0x3FE445285D68EA69    //log(1/frcpa(1+ 226/256)
+data8 0x3FE45BCC464C893A    //log(1/frcpa(1+ 227/256)
+data8 0x3FE46AED21F117FC    //log(1/frcpa(1+ 228/256)
+data8 0x3FE47A1527E8A2D3    //log(1/frcpa(1+ 229/256)
+data8 0x3FE489445EFFFCCC    //log(1/frcpa(1+ 230/256)
+data8 0x3FE4A018BCB69835    //log(1/frcpa(1+ 231/256)
+data8 0x3FE4AF5A0C9D65D7    //log(1/frcpa(1+ 232/256)
+data8 0x3FE4BEA2A5BDBE87    //log(1/frcpa(1+ 233/256)
+data8 0x3FE4CDF28F10AC46    //log(1/frcpa(1+ 234/256)
+data8 0x3FE4DD49CF994058    //log(1/frcpa(1+ 235/256)
+data8 0x3FE4ECA86E64A684    //log(1/frcpa(1+ 236/256)
+data8 0x3FE503C43CD8EB68    //log(1/frcpa(1+ 237/256)
+data8 0x3FE513356667FC57    //log(1/frcpa(1+ 238/256)
+data8 0x3FE522AE0738A3D8    //log(1/frcpa(1+ 239/256)
+data8 0x3FE5322E26867857    //log(1/frcpa(1+ 240/256)
+data8 0x3FE541B5CB979809    //log(1/frcpa(1+ 241/256)
+data8 0x3FE55144FDBCBD62    //log(1/frcpa(1+ 242/256)
+data8 0x3FE560DBC45153C7    //log(1/frcpa(1+ 243/256)
+data8 0x3FE5707A26BB8C66    //log(1/frcpa(1+ 244/256)
+data8 0x3FE587F60ED5B900    //log(1/frcpa(1+ 245/256)
+data8 0x3FE597A7977C8F31    //log(1/frcpa(1+ 246/256)
+data8 0x3FE5A760D634BB8B    //log(1/frcpa(1+ 247/256)
+data8 0x3FE5B721D295F10F    //log(1/frcpa(1+ 248/256)
+data8 0x3FE5C6EA94431EF9    //log(1/frcpa(1+ 249/256)
+data8 0x3FE5D6BB22EA86F6    //log(1/frcpa(1+ 250/256)
+data8 0x3FE5E6938645D390    //log(1/frcpa(1+ 251/256)
+data8 0x3FE5F673C61A2ED2    //log(1/frcpa(1+ 252/256)
+data8 0x3FE6065BEA385926    //log(1/frcpa(1+ 253/256)
+data8 0x3FE6164BFA7CC06B    //log(1/frcpa(1+ 254/256)
+data8 0x3FE62643FECF9743    //log(1/frcpa(1+ 255/256)
+LOCAL_OBJECT_END(log_table_3)
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(asinhf)
+
+{ .mfi
+      getf.exp   asinh_GR_f8 = f8        // Must recompute later if x unorm
+      fclass.m   p12,p0 = f8, 0x0b       // Test x unorm
+      mov        log_GR_exp_17_ones = 0x1ffff
+}
+{ .mfi
+      addl       NR_table_address = @ltoff(log_table_1), gp
+      fma.s1     log_y = f8, f8, f1      // y = x^2 + 1
+      mov        asinh_GR_comp = 0xfffa
+}
+;;
+
+{ .mfi
+      mov        log_GR_exp_16_ones = 0xffff //BIAS
+      fclass.m   p6,p0 = f8, 0xe7        // Test for x = NaN and inf and zero
+      mov        log_GR_comp2 = 0x10032
+}
+{ .mfi
+      ld8        NR_table_address = [NR_table_address]
+      fma.s1     asinh_w_sq = f8,f8,f0   // x^2
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fcmp.lt.s1 p7,p11 = f8,f0          // if x<0
+      nop.i      0
+}
+{ .mfb
+      nop.m      0
+      fnorm.s1   fNormX = f8             // Normalize x
+(p12) br.cond.spnt ASINH_UNORM           // Branch if x=unorm
+}
+;;
+
+ASINH_COMMON:
+// Return here if x=unorm and not denorm
+{ .mfi
+      //to get second table address
+      adds       log_table_address2 = 0x20, NR_table_address
+      fma.s1     log_arg = f8,f1,f8
+}
+{ .mfb
+      nop.m      0
+(p6)  fma.s.s0   f8 = f8,f1,f8           // quietize nan result if x=nan
+(p6)  br.ret.spnt b0                     // Exit for x=nan and inf and zero
+}
+;;
+
+{ .mfi
+      ldfpd      NR1,NR2 = [log_table_address2],16
+      frsqrta.s1 log_y_rs,p0 = log_y     // z=1/sqrt(y)
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfe       log_C1 = [log_table_address2],16
+      nop.f      0
+      and        asinh_GR_f8 = asinh_GR_f8,log_GR_exp_17_ones
+}
+;;
+
+{ .mib
+      ldfe       log_C0 = [log_table_address2],16
+      cmp.le     p13,p0 = log_GR_comp2,asinh_GR_f8
+(p13) br.cond.spnt LOG_COMMON1           // Branch if path 4: |x| >= 2^51
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter = log_y_rs,log_y,f0  // y*z
+      nop.i      0
+}
+;;
+
+.pred.rel "mutex",p7,p11
+{ .mfi
+      nop.m      0
+(p11) mov        asinh_f8 = fNormX
+      nop.i      0
+}
+{ .mfb
+      cmp.gt     p8,p0 = asinh_GR_comp,asinh_GR_f8
+(p7)  fnma.s1    asinh_f8 = fNormX,f1,f0
+(p8)  br.cond.spnt ASINH_NEAR_ZERO       // Branch if path 2: 0 < |x| < 2^-5
+}
+;;
+
+// Here if main path, 2^-5 <= |x| < 2^51
+///////////////////////////////// The first iteration /////////////////////////
+{ .mfi
+      ldfpd      log_P3,log_P2 = [NR_table_address],16
+      fnma.s1    log_y_rs_iter2 = log_y_rs_iter,log_y_rs,NR2    // 3-(y*z)*z
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs,NR1,f0               // 0.5*z
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfpd      log_P1,log2 = [NR_table_address],16
+      // (0.5*z)*(3-(y*z)*z)
+      fma.s1     log_y_rs_iter = log_y_rs_iter1,log_y_rs_iter2,f0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      // (0.5*z)*(3-(y*z)*z)
+      fma.s1     log_arg_early = log_y_rs_iter1,log_y_rs_iter2,f0
+      nop.i      0
+}
+;;
+
+////////////////////////////////// The second iteration ////////////////////////
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs = log_y_rs_iter,log_y,f0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs_iter,NR1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_arg_early = log_arg_early,log_y,asinh_f8
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fnma.s1    log_y_rs = log_y_rs,log_y_rs_iter,NR2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_y_rs_iter1 = log_y_rs_iter1,log_y,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      frcpa.s1   log_C,p0 = f1,log_arg_early
+      nop.i      0
+}
+;;
+
+{ .mfi
+      getf.exp   log_GR_signexp_f8 = log_arg_early
+      nop.f      0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      getf.sig   log_GR_significand_f8 = log_arg_early
+      // (0.5*z)*(3-(y*z)*z)*y + |x|
+      fma.s1     log_arg = log_y_rs_iter1,log_y_rs,asinh_f8
+      //to get third table address
+      adds       log_table_address3 = 0x30, NR_table_address
+}
+;;
+
+/////////////////////////////////////////// The end NR iterations /////////////
+
+{ .mfi
+      nop.m      0
+      nop.f      0
+      //significant bit destruction
+      and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones
+}
+;;
+
+{ .mfi
+      //BIAS subtraction
+      sub        log_GR_true_exp_f8 = log_GR_exp_f8, log_GR_exp_16_ones
+(p7)  fnma.s1    log2 = log2,f1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      setf.sig   log_int_Nfloat = log_GR_true_exp_f8
+      fms.s1     log_r = log_C,log_arg,f1  //C = frcpa(x); r = C * x - 1
+      extr.u     log_GR_index = log_GR_significand_f8,55,8 //Extract 8 bits
+}
+;;
+
+{ .mmi
+      //pre-index*16 + index
+      shladd     log_table_address3 = log_GR_index,3,log_table_address3
+;;
+      ldfd       log_T = [log_table_address3]
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rsq = log_r, log_r, f0          //r^2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p32 = log_P3, log_r, log_P2  //P3*r + P2
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p10 = log_P1, log_r, f1
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //convert N to the floating-point format
+      fcvt.xf    log_Nfloat = log_int_Nfloat
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p2 = log_rp_p32, log_rsq, log_rp_p10
+      nop.i      0
+}
+;;
+
+.pred.rel "mutex",p7,p11
+{ .mfi
+      nop.m      0
+(p11) fma.s1     log_T_plus_Nlog2 = log_Nfloat,log2,log_T  //N*log2 + T if x>0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+(p7)  fms.s1     log_T_plus_Nlog2 = log_Nfloat,log2,log_T  //N*log2 - T if x<0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+(p11) fma.s.s0   f8 = log_rp_p2,log_r,log_T_plus_Nlog2
+      nop.i      0
+}
+{ .mfb
+      nop.m      0
+(p7)  fnma.s.s0  f8 = log_rp_p2,log_r,log_T_plus_Nlog2
+      br.ret.sptk b0          // Exit main path, path 3: 2^-5 <= |x| < 2^51
+}
+;;
+
+
+// Here if path 4, |x| >= 2^51
+LOG_COMMON1:
+{ .mfi
+      ldfpd      log_P3,log_P2 = [NR_table_address],16
+      nop.f      0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      ldfpd      log_P1,log2 = [NR_table_address],16
+      frcpa.s1   log_C,p0 = f1,log_arg
+      nop.i      0
+}
+;;
+
+{ .mfi
+      getf.exp   log_GR_signexp_f8 = log_arg
+      nop.f      0
+      //to get third table address
+      adds       log_table_address3 = 0x30, NR_table_address
+}
+;;
+
+{ .mfi
+      getf.sig   log_GR_significand_f8 = log_arg
+      nop.f      0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      nop.f      0
+      //to destroy the most bit in the significant area
+      and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones
+}
+;;
+
+{ .mmf
+      nop.m      0
+      //BIAS subtraction
+      sub        log_GR_true_exp_f8 = log_GR_exp_f8, log_GR_exp_16_ones
+      fms.s1     log_r = log_C,log_arg,f1  //C = frcpa(x); r = C * x - 1
+}
+;;
+
+{ .mfi
+      setf.sig   log_int_Nfloat = log_GR_true_exp_f8
+      nop.f      0
+      extr.u     log_GR_index = log_GR_significand_f8,55,8 //Extract 8 bits
+}
+;;
+
+{ .mmi
+      //pre-index*16 + index
+      shladd     log_table_address3 = log_GR_index,3,log_table_address3
+;;
+      ldfd       log_T = [log_table_address3]
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rsq = log_r, log_r, f0          //r^2
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p32 = log_P3, log_r, log_P2  //P3*r + P2
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p10 = log_P1, log_r, f1
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+(p7)  fnma.s1    log2 = log2,f1,f0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+      //convert N to the floating-point format
+      fcvt.xf    log_Nfloat = log_int_Nfloat
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     log_rp_p2 = log_rp_p32, log_rsq, log_rp_p10
+      nop.i      0
+}
+;;
+
+.pred.rel "mutex",p7,p11
+{ .mfi
+      nop.m      0
+(p11) fma.s1     log_T_plus_Nlog2 = log_Nfloat,log2,log_T  //N*log2 + T if x>0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+(p7)  fms.s1     log_T_plus_Nlog2 = log_Nfloat,log2,log_T  //N*log2 - T if x<0
+      nop.i      0
+}
+;;
+
+{ .mfi
+      nop.m      0
+(p11) fma.s.s0   f8 = log_rp_p2,log_r,log_T_plus_Nlog2
+      nop.i      0
+}
+{ .mfb
+      nop.m      0
+(p7)  fnma.s.s0  f8 = log_rp_p2,log_r,log_T_plus_Nlog2
+      br.ret.sptk b0           // Exit path 4, |x| >= 2^51
+}
+;;
+
+// Here if path 2, 0 < |x| < 2^-5
+ASINH_NEAR_ZERO:
+{ .mfi
+      nop.m      0
+      fma.s1     asinh_w_1 = asinh_w_sq,log_C1,log_C0
+      nop.i      0
+}
+{ .mfi
+      nop.m      0
+      fma.s1     asinh_w_cube = asinh_w_sq,fNormX,f0
+      nop.i      0
+}
+;;
+
+{ .mfb
+      nop.m      0
+      fma.s.s0   f8 = asinh_w_1,asinh_w_cube,fNormX
+      br.ret.sptk b0          // Exit path 2, 0 < |x| < 2^-5
+}
+;;
+
+ASINH_UNORM:
+// Here if x=unorm
+{ .mfi
+      getf.exp   asinh_GR_f8 = fNormX  // Recompute if x unorm
+      fclass.m   p0,p13 = fNormX, 0x0b // Test x denorm
+      nop.i      0
+}
+;;
+
+{ .mfb
+      nop.m      0
+      fcmp.eq.s0 p14,p0 = f8, f0       // Dummy to set denormal flag
+(p13) br.cond.sptk ASINH_COMMON        // Continue if x unorm and not denorm
+}
+;;
+
+.pred.rel "mutex",p7,p11
+{ .mfi
+      nop.m      0
+(p7)  fma.s.s0   f8 = f8,f8,f8         // Result x+x^2 if x=-denorm
+      nop.i      0
+}
+{ .mfb
+      nop.m      0
+(p11) fnma.s.s0  f8 = f8,f8,f8         // Result x-x^2 if x=+denorm
+      br.ret.spnt b0                   // Exit if denorm
+}
+;;
+
+GLOBAL_LIBM_END(asinhf)
+libm_alias_float_other (asinh, asinh)
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_asinhl.S
@@ -0,0 +1,1344 @@
+.file "asinhl.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 09/04/01 Initial version
+// 09/13/01 Performance improved, symmetry problems fixed
+// 10/10/01 Performance improved, split issues removed
+// 12/11/01 Changed huges_logp to not be global
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align;
+//          used data8 for long double table values
+//
+//*********************************************************************
+//
+// API
+//==============================================================
+// long double asinhl(long double);
+//
+// Overview of operation
+//==============================================================
+//
+// There are 6 paths:
+// 1. x = 0, [S,Q]Nan or +/-INF
+//    Return asinhl(x) = x + x;
+//
+// 2. x = + denormal
+//    Return asinhl(x) = x - x^2;
+//
+// 3. x = - denormal
+//    Return asinhl(x) = x + x^2;
+//
+// 4. 'Near 0': max denormal < |x| < 1/128
+//    Return asinhl(x) = sign(x)*(x+x^3*(c3+x^2*(c5+x^2*(c7+x^2*(c9)))));
+//
+// 5. 'Huges': |x| > 2^63
+//    Return asinhl(x) = sign(x)*(logl(2*x));
+//
+// 6. 'Main path': 1/128 < |x| < 2^63
+//    b_hi + b_lo = x + sqrt(x^2 + 1);
+//    asinhl(x) = sign(x)*(log_special(b_hi, b_lo));
+//
+// Algorithm description
+//==============================================================
+//
+// Main path algorithm
+// ( thanks to Peter Markstein for the idea of sqrt(x^2+1) computation! )
+// *************************************************************************
+//
+// There are 3 parts of x+sqrt(x^2+1) computation:
+//
+//  1) p2 = (p2_hi+p2_lo) = x^2+1 obtaining
+//     ------------------------------------
+//     p2_hi = x2_hi + 1, where x2_hi = x * x;
+//     p2_lo = x2_lo + p1_lo, where
+//                            x2_lo = FMS(x*x-x2_hi),
+//                            p1_lo = (1 - p2_hi) + x2_hi;
+//
+//  2) g = (g_hi+g_lo) = sqrt(p2) = sqrt(p2_hi+p2_lo)
+//     ----------------------------------------------
+//     r = invsqrt(p2_hi) (8-bit reciprocal square root approximation);
+//     g = p2_hi * r (first 8 bit-approximation of sqrt);
+//
+//     h = 0.5 * r;
+//     e = 0.5 - g * h;
+//     g = g * e + g (second 16 bit-approximation of sqrt);
+//
+//     h = h * e + h;
+//     e = 0.5 - g * h;
+//     g = g * e + g (third 32 bit-approximation of sqrt);
+//
+//     h = h * e + h;
+//     e = 0.5 - g * h;
+//     g_hi = g * e + g (fourth 64 bit-approximation of sqrt);
+//
+//     Remainder computation:
+//     h = h * e + h;
+//     d = (p2_hi - g_hi * g_hi) + p2_lo;
+//     g_lo = d * h;
+//
+//  3) b = (b_hi + b_lo) = x + g, where g = (g_hi + g_lo) = sqrt(x^2+1)
+//     -------------------------------------------------------------------
+//     b_hi = (g_hi + x) + gl;
+//     b_lo = (g_hi - b_hi) + x + gl;
+//
+//  Now we pass b presented as sum b_hi + b_lo to special version
+//  of logl function which accept a pair of arguments as
+//  'mutiprecision' value.
+//
+//  Special log algorithm overview
+//  ================================
+//   Here we use a table lookup method. The basic idea is that in
+//   order to compute logl(Arg) = logl (Arg-1) for an argument Arg in [1,2),
+//   we construct a value G such that G*Arg is close to 1 and that
+//   logl(1/G) is obtainable easily from a table of values calculated
+//   beforehand. Thus
+//
+//      logl(Arg) = logl(1/G) + logl((G*Arg - 1))
+//
+//   Because |G*Arg - 1| is small, the second term on the right hand
+//   side can be approximated by a short polynomial. We elaborate
+//   this method in four steps.
+//
+//   Step 0: Initialization
+//
+//   We need to calculate logl( X ). Obtain N, S_hi such that
+//
+//      X = 2^N * ( S_hi + S_lo )   exactly
+//
+//   where S_hi in [1,2) and S_lo is a correction to S_hi in the sense
+//   that |S_lo| <= ulp(S_hi).
+//
+//   For the special version of logl: S_lo = b_lo
+//   !-----------------------------------------------!
+//
+//   Step 1: Argument Reduction
+//
+//   Based on S_hi, obtain G_1, G_2, G_3 from a table and calculate
+//
+//      G := G_1 * G_2 * G_3
+//      r := (G * S_hi - 1) + G * S_lo
+//
+//   These G_j's have the property that the product is exactly
+//   representable and that |r| < 2^(-12) as a result.
+//
+//   Step 2: Approximation
+//
+//   logl(1 + r) is approximated by a short polynomial poly(r).
+//
+//   Step 3: Reconstruction
+//
+//   Finally,
+//
+//   logl( X )   =   logl( 2^N * (S_hi + S_lo) )
+//                 ~=~  N*logl(2) + logl(1/G) + logl(1 + r)
+//                 ~=~  N*logl(2) + logl(1/G) + poly(r).
+//
+//   For detailed description see logl or log1pl function, regular path.
+//
+// Registers used
+//==============================================================
+// Floating Point registers used:
+// f8, input
+// f32 -> f101 (70 registers)
+
+// General registers used:
+// r32 -> r57 (26 registers)
+
+// Predicate registers used:
+// p6 -> p11
+// p6  for '0, NaNs, Inf' path
+// p7  for '+ denormals' path
+// p8  for 'near 0' path
+// p9  for 'huges' path
+// p10 for '- denormals' path
+// p11 for negative values
+//
+// Data tables
+//==============================================================
+
+RODATA
+.align 64
+
+// C7, C9 'near 0' polynomial coefficients
+LOCAL_OBJECT_START(Poly_C_near_0_79)
+data8 0xF8DC939BBEDD5A54, 0x00003FF9
+data8 0xB6DB6DAB21565AC5, 0x0000BFFA
+LOCAL_OBJECT_END(Poly_C_near_0_79)
+
+// C3, C5 'near 0' polynomial coefficients
+LOCAL_OBJECT_START(Poly_C_near_0_35)
+data8 0x999999999991D582, 0x00003FFB
+data8 0xAAAAAAAAAAAAAAA9, 0x0000BFFC
+LOCAL_OBJECT_END(Poly_C_near_0_35)
+
+// Q coeffs
+LOCAL_OBJECT_START(Constants_Q)
+data4  0x00000000,0xB1721800,0x00003FFE,0x00000000
+data4  0x4361C4C6,0x82E30865,0x0000BFE2,0x00000000
+data4  0x328833CB,0xCCCCCAF2,0x00003FFC,0x00000000
+data4  0xA9D4BAFB,0x80000077,0x0000BFFD,0x00000000
+data4  0xAAABE3D2,0xAAAAAAAA,0x00003FFD,0x00000000
+data4  0xFFFFDAB7,0xFFFFFFFF,0x0000BFFD,0x00000000
+LOCAL_OBJECT_END(Constants_Q)
+
+// Z1 - 16 bit fixed
+LOCAL_OBJECT_START(Constants_Z_1)
+data4  0x00008000
+data4  0x00007879
+data4  0x000071C8
+data4  0x00006BCB
+data4  0x00006667
+data4  0x00006187
+data4  0x00005D18
+data4  0x0000590C
+data4  0x00005556
+data4  0x000051EC
+data4  0x00004EC5
+data4  0x00004BDB
+data4  0x00004925
+data4  0x0000469F
+data4  0x00004445
+data4  0x00004211
+LOCAL_OBJECT_END(Constants_Z_1)
+
+// G1 and H1 - IEEE single and h1 - IEEE double
+LOCAL_OBJECT_START(Constants_G_H_h1)
+data4  0x3F800000,0x00000000
+data8  0x0000000000000000
+data4  0x3F70F0F0,0x3D785196
+data8  0x3DA163A6617D741C
+data4  0x3F638E38,0x3DF13843
+data8  0x3E2C55E6CBD3D5BB
+data4  0x3F579430,0x3E2FF9A0
+data8  0xBE3EB0BFD86EA5E7
+data4  0x3F4CCCC8,0x3E647FD6
+data8  0x3E2E6A8C86B12760
+data4  0x3F430C30,0x3E8B3AE7
+data8  0x3E47574C5C0739BA
+data4  0x3F3A2E88,0x3EA30C68
+data8  0x3E20E30F13E8AF2F
+data4  0x3F321640,0x3EB9CEC8
+data8  0xBE42885BF2C630BD
+data4  0x3F2AAAA8,0x3ECF9927
+data8  0x3E497F3497E577C6
+data4  0x3F23D708,0x3EE47FC5
+data8  0x3E3E6A6EA6B0A5AB
+data4  0x3F1D89D8,0x3EF8947D
+data8  0xBDF43E3CD328D9BE
+data4  0x3F17B420,0x3F05F3A1
+data8  0x3E4094C30ADB090A
+data4  0x3F124920,0x3F0F4303
+data8  0xBE28FBB2FC1FE510
+data4  0x3F0D3DC8,0x3F183EBF
+data8  0x3E3A789510FDE3FA
+data4  0x3F088888,0x3F20EC80
+data8  0x3E508CE57CC8C98F
+data4  0x3F042108,0x3F29516A
+data8  0xBE534874A223106C
+LOCAL_OBJECT_END(Constants_G_H_h1)
+
+// Z2 - 16 bit fixed
+LOCAL_OBJECT_START(Constants_Z_2)
+data4  0x00008000
+data4  0x00007F81
+data4  0x00007F02
+data4  0x00007E85
+data4  0x00007E08
+data4  0x00007D8D
+data4  0x00007D12
+data4  0x00007C98
+data4  0x00007C20
+data4  0x00007BA8
+data4  0x00007B31
+data4  0x00007ABB
+data4  0x00007A45
+data4  0x000079D1
+data4  0x0000795D
+data4  0x000078EB
+LOCAL_OBJECT_END(Constants_Z_2)
+
+// G2 and H2 - IEEE single and h2 - IEEE double
+LOCAL_OBJECT_START(Constants_G_H_h2)
+data4  0x3F800000,0x00000000
+data8  0x0000000000000000
+data4  0x3F7F00F8,0x3B7F875D
+data8  0x3DB5A11622C42273
+data4  0x3F7E03F8,0x3BFF015B
+data8  0x3DE620CF21F86ED3
+data4  0x3F7D08E0,0x3C3EE393
+data8  0xBDAFA07E484F34ED
+data4  0x3F7C0FC0,0x3C7E0586
+data8  0xBDFE07F03860BCF6
+data4  0x3F7B1880,0x3C9E75D2
+data8  0x3DEA370FA78093D6
+data4  0x3F7A2328,0x3CBDC97A
+data8  0x3DFF579172A753D0
+data4  0x3F792FB0,0x3CDCFE47
+data8  0x3DFEBE6CA7EF896B
+data4  0x3F783E08,0x3CFC15D0
+data8  0x3E0CF156409ECB43
+data4  0x3F774E38,0x3D0D874D
+data8  0xBE0B6F97FFEF71DF
+data4  0x3F766038,0x3D1CF49B
+data8  0xBE0804835D59EEE8
+data4  0x3F757400,0x3D2C531D
+data8  0x3E1F91E9A9192A74
+data4  0x3F748988,0x3D3BA322
+data8  0xBE139A06BF72A8CD
+data4  0x3F73A0D0,0x3D4AE46F
+data8  0x3E1D9202F8FBA6CF
+data4  0x3F72B9D0,0x3D5A1756
+data8  0xBE1DCCC4BA796223
+data4  0x3F71D488,0x3D693B9D
+data8  0xBE049391B6B7C239
+LOCAL_OBJECT_END(Constants_G_H_h2)
+
+// G3 and H3 - IEEE single and h3 - IEEE double
+LOCAL_OBJECT_START(Constants_G_H_h3)
+data4  0x3F7FFC00,0x38800100
+data8  0x3D355595562224CD
+data4  0x3F7FF400,0x39400480
+data8  0x3D8200A206136FF6
+data4  0x3F7FEC00,0x39A00640
+data8  0x3DA4D68DE8DE9AF0
+data4  0x3F7FE400,0x39E00C41
+data8  0xBD8B4291B10238DC
+data4  0x3F7FDC00,0x3A100A21
+data8  0xBD89CCB83B1952CA
+data4  0x3F7FD400,0x3A300F22
+data8  0xBDB107071DC46826
+data4  0x3F7FCC08,0x3A4FF51C
+data8  0x3DB6FCB9F43307DB
+data4  0x3F7FC408,0x3A6FFC1D
+data8  0xBD9B7C4762DC7872
+data4  0x3F7FBC10,0x3A87F20B
+data8  0xBDC3725E3F89154A
+data4  0x3F7FB410,0x3A97F68B
+data8  0xBD93519D62B9D392
+data4  0x3F7FAC18,0x3AA7EB86
+data8  0x3DC184410F21BD9D
+data4  0x3F7FA420,0x3AB7E101
+data8  0xBDA64B952245E0A6
+data4  0x3F7F9C20,0x3AC7E701
+data8  0x3DB4B0ECAABB34B8
+data4  0x3F7F9428,0x3AD7DD7B
+data8  0x3D9923376DC40A7E
+data4  0x3F7F8C30,0x3AE7D474
+data8  0x3DC6E17B4F2083D3
+data4  0x3F7F8438,0x3AF7CBED
+data8  0x3DAE314B811D4394
+data4  0x3F7F7C40,0x3B03E1F3
+data8  0xBDD46F21B08F2DB1
+data4  0x3F7F7448,0x3B0BDE2F
+data8  0xBDDC30A46D34522B
+data4  0x3F7F6C50,0x3B13DAAA
+data8  0x3DCB0070B1F473DB
+data4  0x3F7F6458,0x3B1BD766
+data8  0xBDD65DDC6AD282FD
+data4  0x3F7F5C68,0x3B23CC5C
+data8  0xBDCDAB83F153761A
+data4  0x3F7F5470,0x3B2BC997
+data8  0xBDDADA40341D0F8F
+data4  0x3F7F4C78,0x3B33C711
+data8  0x3DCD1BD7EBC394E8
+data4  0x3F7F4488,0x3B3BBCC6
+data8  0xBDC3532B52E3E695
+data4  0x3F7F3C90,0x3B43BAC0
+data8  0xBDA3961EE846B3DE
+data4  0x3F7F34A0,0x3B4BB0F4
+data8  0xBDDADF06785778D4
+data4  0x3F7F2CA8,0x3B53AF6D
+data8  0x3DCC3ED1E55CE212
+data4  0x3F7F24B8,0x3B5BA620
+data8  0xBDBA31039E382C15
+data4  0x3F7F1CC8,0x3B639D12
+data8  0x3D635A0B5C5AF197
+data4  0x3F7F14D8,0x3B6B9444
+data8  0xBDDCCB1971D34EFC
+data4  0x3F7F0CE0,0x3B7393BC
+data8  0x3DC7450252CD7ADA
+data4  0x3F7F04F0,0x3B7B8B6D
+data8  0xBDB68F177D7F2A42
+LOCAL_OBJECT_END(Constants_G_H_h3)
+
+// Assembly macros
+//==============================================================
+
+// Floating Point Registers
+
+FR_Arg          = f8
+FR_Res          = f8
+FR_AX           = f32
+FR_XLog_Hi      = f33
+FR_XLog_Lo      = f34
+
+    // Special logl registers
+FR_Y_hi         = f35
+FR_Y_lo         = f36
+
+FR_Scale        = f37
+FR_X_Prime      = f38
+FR_S_hi         = f39
+FR_W            = f40
+FR_G            = f41
+
+FR_H            = f42
+FR_wsq          = f43
+FR_w4           = f44
+FR_h            = f45
+FR_w6           = f46
+
+FR_G2           = f47
+FR_H2           = f48
+FR_poly_lo      = f49
+FR_P8           = f50
+FR_poly_hi      = f51
+
+FR_P7           = f52
+FR_h2           = f53
+FR_rsq          = f54
+FR_P6           = f55
+FR_r            = f56
+
+FR_log2_hi      = f57
+FR_log2_lo      = f58
+
+FR_float_N      = f59
+FR_Q4           = f60
+
+FR_G3           = f61
+FR_H3           = f62
+FR_h3           = f63
+
+FR_Q3           = f64
+FR_Q2           = f65
+FR_1LN10_hi     = f66
+
+FR_Q1           = f67
+FR_1LN10_lo     = f68
+FR_P5           = f69
+FR_rcub         = f70
+
+FR_Neg_One      = f71
+FR_Z            = f72
+FR_AA           = f73
+FR_BB           = f74
+FR_S_lo         = f75
+FR_2_to_minus_N = f76
+
+
+    // Huge & Main path prolog registers
+FR_Half         = f77
+FR_Two          = f78
+FR_X2           = f79
+FR_P2           = f80
+FR_P2L          = f81
+FR_Rcp          = f82
+FR_GG           = f83
+FR_HH           = f84
+FR_EE           = f85
+FR_DD           = f86
+FR_GL           = f87
+FR_A            = f88
+FR_AL           = f89
+FR_B            = f90
+FR_BL           = f91
+FR_Tmp          = f92
+
+    // Near 0 & Huges path prolog registers
+FR_C3           = f93
+FR_C5           = f94
+FR_C7           = f95
+FR_C9           = f96
+
+FR_X3           = f97
+FR_X4           = f98
+FR_P9           = f99
+FR_P5           = f100
+FR_P3           = f101
+
+
+// General Purpose Registers
+
+    // General prolog registers
+GR_PFS          = r32
+GR_TwoN7        = r40
+GR_TwoP63       = r41
+GR_ExpMask      = r42
+GR_ArgExp       = r43
+GR_Half         = r44
+
+    // Near 0 path prolog registers
+GR_Poly_C_35    = r45
+GR_Poly_C_79    = r46
+
+    // Special logl registers
+GR_Index1       = r34
+GR_Index2       = r35
+GR_signif       = r36
+GR_X_0          = r37
+GR_X_1          = r38
+GR_X_2          = r39
+GR_Z_1          = r40
+GR_Z_2          = r41
+GR_N            = r42
+GR_Bias         = r43
+GR_M            = r44
+GR_Index3       = r45
+GR_exp_2tom80   = r45
+GR_exp_mask     = r47
+GR_exp_2tom7    = r48
+GR_ad_ln10      = r49
+GR_ad_tbl_1     = r50
+GR_ad_tbl_2     = r51
+GR_ad_tbl_3     = r52
+GR_ad_q         = r53
+GR_ad_z_1       = r54
+GR_ad_z_2       = r55
+GR_ad_z_3       = r56
+GR_minus_N      = r57
+
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(asinhl)
+
+{ .mfi
+      alloc     GR_PFS        = ar.pfs,0,27,0,0
+      fma.s1    FR_P2         = FR_Arg, FR_Arg, f1  // p2 = x^2 + 1
+      mov   	GR_Half       = 0xfffe              // 0.5's exp
+}
+{ .mfi
+      addl      GR_Poly_C_79  = @ltoff(Poly_C_near_0_79), gp // C7, C9 coeffs
+      fma.s1    FR_X2         = FR_Arg, FR_Arg, f0           // Obtain x^2
+      addl      GR_Poly_C_35  = @ltoff(Poly_C_near_0_35), gp // C3, C5 coeffs
+};;
+
+{ .mfi
+      getf.exp  GR_ArgExp     = FR_Arg        // get arument's exponent
+      fabs      FR_AX         = FR_Arg        // absolute value of argument
+      mov       GR_TwoN7      = 0xfff8        // 2^-7 exp
+}
+{ .mfi
+      ld8       GR_Poly_C_79  = [GR_Poly_C_79] // get actual coeff table address
+      fma.s0       FR_Two        = f1, f1, f1        // construct 2.0
+      mov       GR_ExpMask    = 0x1ffff        // mask for exp
+};;
+
+{ .mfi
+      ld8       GR_Poly_C_35  = [GR_Poly_C_35] // get actual coeff table address
+      fclass.m  p6,p0         = FR_Arg, 0xe7   // if arg NaN inf zero
+      mov       GR_TwoP63     = 0x1003e        // 2^63 exp
+}
+{ .mfi
+      addl      GR_ad_z_1     = @ltoff(Constants_Z_1#),gp
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      setf.exp	FR_Half       = GR_Half              // construct 0.5
+      fclass.m  p7,p0         = FR_Arg, 0x09  //  if arg + denorm
+      and       GR_ArgExp     = GR_ExpMask, GR_ArgExp // select exp
+}
+{ .mfb
+      ld8       GR_ad_z_1     = [GR_ad_z_1]   // Get pointer to Constants_Z_1
+      nop.f 0
+      nop.b 0
+};;
+{ .mfi
+      ldfe      FR_C9         = [GR_Poly_C_79],16 // load C9
+      fclass.m  p10,p0        = FR_Arg, 0x0a    //  if arg - denorm
+      cmp.gt    p8, p0        = GR_TwoN7,  GR_ArgExp // if arg < 2^-7 ('near 0')
+}
+{ .mfb
+      cmp.le    p9, p0        = GR_TwoP63, GR_ArgExp  // if arg > 2^63 ('huges')
+(p6)  fma.s0    FR_Res        = FR_Arg,f1,FR_Arg     // r = a + a
+(p6)  br.ret.spnt b0                            // return
+};;
+// (X^2 + 1) computation
+{ .mfi
+(p8)  ldfe      FR_C5         = [GR_Poly_C_35],16        // load C5
+      fms.s1    FR_Tmp        = f1, f1, FR_P2           // Tmp = 1 - p2
+      add       GR_ad_tbl_1   = 0x040, GR_ad_z_1    // Point to Constants_G_H_h1
+}
+{ .mfb
+(p8)  ldfe      FR_C7         = [GR_Poly_C_79],16        // load C7
+(p7)  fnma.s0   FR_Res        =  FR_Arg,FR_Arg,FR_Arg // r = a - a*a
+(p7)  br.ret.spnt b0                              // return
+};;
+
+{ .mfi
+(p8)  ldfe      FR_C3         = [GR_Poly_C_35],16     // load C3
+      fcmp.lt.s1 p11, p12      = FR_Arg, f0     // if arg is negative
+      add       GR_ad_q       = -0x60, GR_ad_z_1    // Point to Constants_P
+}
+{ .mfb
+      add       GR_ad_z_2     = 0x140, GR_ad_z_1    // Point to Constants_Z_2
+(p10) fma.s0    FR_Res        =  FR_Arg,FR_Arg,FR_Arg // r = a + a*a
+(p10) br.ret.spnt b0                             // return
+};;
+
+{ .mfi
+      add       GR_ad_tbl_2   = 0x180, GR_ad_z_1    // Point to Constants_G_H_h2
+      frsqrta.s1 FR_Rcp, p0   = FR_P2           // Rcp = 1/p2 reciprocal appr.
+      add       GR_ad_tbl_3   = 0x280, GR_ad_z_1    // Point to Constants_G_H_h3
+}
+{ .mfi
+      nop.m 0
+      fms.s1    FR_P2L        = FR_AX, FR_AX, FR_X2 //low part of p2=fma(X*X-p2)
+      mov       GR_Bias       = 0x0FFFF            // Create exponent bias
+};;
+
+{ .mfb
+      nop.m 0
+(p9)  fms.s1    FR_XLog_Hi    = FR_Two, FR_AX, f0  // Hi  of log1p arg = 2*X - 1
+(p9)  br.cond.spnt huges_logl                      // special version of log1p
+};;
+
+{ .mfb
+      ldfe      FR_log2_hi    = [GR_ad_q],16      // Load log2_hi
+(p8)  fma.s1    FR_X3         = FR_X2, FR_Arg, f0        // x^3 = x^2 * x
+(p8)  br.cond.spnt near_0                                // Go to near 0 branch
+};;
+
+{ .mfi
+      ldfe      FR_log2_lo    = [GR_ad_q],16      // Load log2_lo
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      ldfe      FR_Q4         = [GR_ad_q],16          // Load Q4
+      fma.s1    FR_Tmp        = FR_Tmp, f1, FR_X2       // Tmp = Tmp + x^2
+      mov       GR_exp_mask   = 0x1FFFF        // Create exponent mask
+};;
+
+{ .mfi
+      ldfe      FR_Q3         = [GR_ad_q],16   // Load Q3
+      fma.s1    FR_GG         = FR_Rcp, FR_P2, f0        // g = Rcp * p2
+                                               // 8 bit Newton Raphson iteration
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_HH         = FR_Half, FR_Rcp, f0      // h = 0.5 * Rcp
+      nop.i 0
+};;
+{ .mfi
+      ldfe      FR_Q2         = [GR_ad_q],16      // Load Q2
+      fnma.s1   FR_EE         = FR_GG, FR_HH, FR_Half   // e = 0.5 - g * h
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_P2L        = FR_Tmp, f1, FR_P2L // low part of p2 = Tmp + p2l
+      nop.i 0
+};;
+
+{ .mfi
+      ldfe      FR_Q1         = [GR_ad_q]                // Load Q1
+      fma.s1    FR_GG         = FR_GG, FR_EE, FR_GG     // g = g * e + g
+                                              // 16 bit Newton Raphson iteration
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_HH         = FR_HH, FR_EE, FR_HH     // h = h * e + h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fnma.s1   FR_EE         = FR_GG, FR_HH, FR_Half   // e = 0.5 - g * h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_GG         = FR_GG, FR_EE, FR_GG     // g = g * e + g
+                                              // 32 bit Newton Raphson iteration
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_HH         = FR_HH, FR_EE, FR_HH     // h = h * e + h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fnma.s1   FR_EE         = FR_GG, FR_HH, FR_Half   // e = 0.5 - g * h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_GG         = FR_GG, FR_EE, FR_GG     // g = g * e + g
+                                              // 64 bit Newton Raphson iteration
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_HH         = FR_HH, FR_EE, FR_HH     // h = h * e + h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fnma.s1   FR_DD         = FR_GG, FR_GG, FR_P2  // Remainder d = g * g - p2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_XLog_Hi     = FR_AX, f1, FR_GG // bh = z + gh
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_DD         = FR_DD, f1, FR_P2L       // add p2l: d = d + p2l
+      nop.i 0
+};;
+
+
+{ .mfi
+      getf.sig  GR_signif     = FR_XLog_Hi     // Get significand of x+1
+      fmerge.ns FR_Neg_One    = f1, f1         // Form -1.0
+      mov       GR_exp_2tom7  = 0x0fff8        // Exponent of 2^-7
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_GL         = FR_DD, FR_HH, f0        // gl = d * h
+      extr.u    GR_Index1     = GR_signif, 59, 4    // Get high 4 bits of signif
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_XLog_Hi     = FR_DD,  FR_HH, FR_XLog_Hi // bh = bh + gl
+      nop.i 0
+};;
+
+{ .mmi
+      shladd    GR_ad_z_1     = GR_Index1, 2, GR_ad_z_1  // Point to Z_1
+      shladd    GR_ad_tbl_1   = GR_Index1, 4, GR_ad_tbl_1  // Point to G_1
+      extr.u    GR_X_0        = GR_signif, 49, 15 // Get high 15 bits of signif.
+};;
+
+{ .mmi
+      ld4       GR_Z_1        = [GR_ad_z_1]    // Load Z_1
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mmi
+      ldfps     FR_G, FR_H    = [GR_ad_tbl_1],8     // Load G_1, H_1
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fms.s1    FR_XLog_Lo     = FR_GG,  f1,   FR_XLog_Hi // bl = gh - bh
+      pmpyshr2.u GR_X_1       = GR_X_0,GR_Z_1,15  // Get bits 30-15 of X_0 * Z_1
+};;
+
+// WE CANNOT USE GR_X_1 IN NEXT 3 CYCLES BECAUSE OF POSSIBLE 10 CLOCKS STALL!
+// "DEAD" ZONE!
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fmerge.se FR_S_hi       =  f1,FR_XLog_Hi            // Form |x+1|
+      nop.i 0
+};;
+
+{ .mmi
+      getf.exp  GR_N          =  FR_XLog_Hi    // Get N = exponent of x+1
+      ldfd      FR_h          = [GR_ad_tbl_1]        // Load h_1
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      extr.u    GR_Index2     = GR_X_1, 6, 4      // Extract bits 6-9 of X_1
+};;
+
+
+{ .mfi
+      shladd    GR_ad_tbl_2   = GR_Index2, 4, GR_ad_tbl_2  // Point to G_2
+      fma.s1    FR_XLog_Lo    = FR_XLog_Lo, f1, FR_AX // bl = bl + x
+      mov       GR_exp_2tom80 = 0x0ffaf           // Exponent of 2^-80
+}
+{ .mfi
+      shladd    GR_ad_z_2     = GR_Index2, 2, GR_ad_z_2  // Point to Z_2
+      nop.f 0
+      sub       GR_N          = GR_N, GR_Bias // sub bias from exp
+};;
+
+{ .mmi
+      ldfps     FR_G2, FR_H2  = [GR_ad_tbl_2],8       // Load G_2, H_2
+      ld4       GR_Z_2        = [GR_ad_z_2]                // Load Z_2
+      sub       GR_minus_N    = GR_Bias, GR_N         // Form exponent of 2^(-N)
+};;
+
+{ .mmi
+      ldfd      FR_h2         = [GR_ad_tbl_2]             // Load h_2
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mmi
+      setf.sig  FR_float_N    = GR_N        // Put integer N into rightmost sign
+      setf.exp  FR_2_to_minus_N = GR_minus_N   // Form 2^(-N)
+      pmpyshr2.u GR_X_2       = GR_X_1,GR_Z_2,15 // Get bits 30-15 of X_1 * Z_2
+};;
+
+// WE CANNOT USE GR_X_2 IN NEXT 3 CYCLES ("DEAD" ZONE!)
+// BECAUSE OF POSSIBLE 10 CLOCKS STALL!
+// So we can negate Q coefficients there for negative values
+
+{ .mfi
+      nop.m 0
+(p11) fma.s1    FR_Q1         = FR_Q1, FR_Neg_One, f0 // Negate Q1
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_XLog_Lo     = FR_XLog_Lo, f1, FR_GL // bl = bl + gl
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p11) fma.s1    FR_Q2         = FR_Q2, FR_Neg_One, f0 // Negate Q2
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p11) fma.s1    FR_Q3         = FR_Q3, FR_Neg_One, f0 // Negate Q3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p11) fma.s1    FR_Q4         = FR_Q4, FR_Neg_One, f0 // Negate Q4
+      extr.u    GR_Index3     = GR_X_2, 1, 5         // Extract bits 1-5 of X_2
+};;
+
+{ .mfi
+      shladd    GR_ad_tbl_3   = GR_Index3, 4, GR_ad_tbl_3  // Point to G_3
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      ldfps     FR_G3, FR_H3  = [GR_ad_tbl_3],8   // Load G_3, H_3
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      ldfd      FR_h3         = [GR_ad_tbl_3]            // Load h_3
+	  fcvt.xf   FR_float_N    = FR_float_N
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fmpy.s1   FR_G          = FR_G, FR_G2              // G = G_1 * G_2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fadd.s1   FR_H          = FR_H, FR_H2              // H = H_1 + H_2
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fadd.s1   FR_h          = FR_h, FR_h2              // h = h_1 + h_2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_S_lo       = FR_XLog_Lo, FR_2_to_minus_N, f0 //S_lo=S_lo*2^-N
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fmpy.s1   FR_G          = FR_G, FR_G3             // G = (G_1 * G_2) * G_3
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fadd.s1   FR_H          = FR_H, FR_H3             // H = (H_1 + H_2) + H_3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fadd.s1   FR_h          = FR_h, FR_h3             // h = (h_1 + h_2) + h_3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fms.s1    FR_r          = FR_G, FR_S_hi, f1           // r = G * S_hi - 1
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_Y_hi       = FR_float_N, FR_log2_hi, FR_H // Y_hi=N*log2_hi+H
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_h          = FR_float_N, FR_log2_lo, FR_h  // h=N*log2_lo+h
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_r          = FR_G, FR_S_lo, FR_r  // r=G*S_lo+(G*S_hi-1)
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_poly_lo    = FR_r, FR_Q4, FR_Q3      // poly_lo = r * Q4 + Q3
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fmpy.s1   FR_rsq        = FR_r, FR_r              // rsq = r * r
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_poly_lo    = FR_poly_lo, FR_r, FR_Q2 // poly_lo=poly_lo*r+Q2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_rcub       = FR_rsq, FR_r, f0        // rcub = r^3
+      nop.i 0
+};;
+
+.pred.rel "mutex",p12,p11
+{ .mfi
+      nop.m 0
+(p12) fma.s1    FR_poly_hi    = FR_Q1, FR_rsq, FR_r // poly_hi = Q1*rsq + r
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p11) fms.s1    FR_poly_hi    = FR_Q1, FR_rsq, FR_r     // poly_hi = Q1*rsq + r
+      nop.i 0
+};;
+
+
+.pred.rel "mutex",p12,p11
+{ .mfi
+      nop.m 0
+(p12) fma.s1    FR_poly_lo    = FR_poly_lo, FR_rcub, FR_h//poly_lo=poly_lo*r^3+h
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p11) fms.s1    FR_poly_lo    = FR_poly_lo, FR_rcub, FR_h//poly_lo=poly_lo*r^3+h
+      nop.i 0
+}
+;;
+
+{ .mfi
+      nop.m 0
+      fadd.s0   FR_Y_lo       = FR_poly_hi, FR_poly_lo
+	                                                     // Y_lo=poly_hi+poly_lo
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p11) fma.s0    FR_Y_hi       = FR_Y_hi, FR_Neg_One, f0 // FR_Y_hi sign for neg
+      nop.i 0
+};;
+
+{ .mfb
+      nop.m 0
+      fadd.s0   FR_Res        = FR_Y_lo,FR_Y_hi    // Result=Y_lo+Y_hi
+      br.ret.sptk   b0                         // Common exit for 2^-7 < x < inf
+};;
+
+// * SPECIAL VERSION OF LOGL FOR HUGE ARGUMENTS *
+
+huges_logl:
+{ .mfi
+      getf.sig  GR_signif     = FR_XLog_Hi     // Get significand of x+1
+      fmerge.ns FR_Neg_One    = f1, f1         // Form -1.0
+      mov       GR_exp_2tom7  = 0x0fff8        // Exponent of 2^-7
+};;
+
+{ .mfi
+      add       GR_ad_tbl_1   = 0x040, GR_ad_z_1    // Point to Constants_G_H_h1
+      nop.f 0
+      add       GR_ad_q       = -0x60, GR_ad_z_1    // Point to Constants_P
+}
+{ .mfi
+      add       GR_ad_z_2     = 0x140, GR_ad_z_1    // Point to Constants_Z_2
+      nop.f 0
+      add       GR_ad_tbl_2   = 0x180, GR_ad_z_1    // Point to Constants_G_H_h2
+};;
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      extr.u    GR_Index1     = GR_signif, 59, 4    // Get high 4 bits of signif
+}
+{ .mfi
+      add       GR_ad_tbl_3   = 0x280, GR_ad_z_1    // Point to Constants_G_H_h3
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      shladd    GR_ad_z_1     = GR_Index1, 2, GR_ad_z_1  // Point to Z_1
+      nop.f 0
+      extr.u    GR_X_0        = GR_signif, 49, 15 // Get high 15 bits of signif.
+};;
+
+{ .mfi
+      ld4       GR_Z_1        = [GR_ad_z_1]    // Load Z_1
+      nop.f 0
+      mov       GR_exp_mask   = 0x1FFFF        // Create exponent mask
+}
+{ .mfi
+      shladd    GR_ad_tbl_1   = GR_Index1, 4, GR_ad_tbl_1  // Point to G_1
+      nop.f 0
+      mov       GR_Bias       = 0x0FFFF            // Create exponent bias
+};;
+
+{ .mfi
+      ldfps     FR_G, FR_H    = [GR_ad_tbl_1],8     // Load G_1, H_1
+      fmerge.se FR_S_hi       =  f1,FR_XLog_Hi            // Form |x+1|
+      nop.i 0
+};;
+
+{ .mmi
+      getf.exp  GR_N          =  FR_XLog_Hi          // Get N = exponent of x+1
+      ldfd      FR_h          = [GR_ad_tbl_1]        // Load h_1
+      nop.i 0
+};;
+
+{ .mfi
+      ldfe      FR_log2_hi    = [GR_ad_q],16      // Load log2_hi
+      nop.f 0
+      pmpyshr2.u GR_X_1       = GR_X_0,GR_Z_1,15  // Get bits 30-15 of X_0 * Z_1
+};;
+
+// WE CANNOT USE GR_X_1 IN NEXT 3 CYCLES BECAUSE OF POSSIBLE 10 CLOCKS STALL!
+// "DEAD" ZONE!
+
+{ .mmi
+      ldfe      FR_log2_lo    = [GR_ad_q],16      // Load log2_lo
+      sub       GR_N          = GR_N, GR_Bias
+      mov       GR_exp_2tom80 = 0x0ffaf           // Exponent of 2^-80
+};;
+
+{ .mfi
+      ldfe      FR_Q4         = [GR_ad_q],16          // Load Q4
+      nop.f 0
+      sub       GR_minus_N    = GR_Bias, GR_N         // Form exponent of 2^(-N)
+};;
+
+{ .mmf
+      ldfe      FR_Q3         = [GR_ad_q],16   // Load Q3
+      setf.sig  FR_float_N    = GR_N        // Put integer N into rightmost sign
+      nop.f 0
+};;
+
+{ .mmi
+      nop.m 0
+      ldfe      FR_Q2         = [GR_ad_q],16      // Load Q2
+      extr.u    GR_Index2     = GR_X_1, 6, 4      // Extract bits 6-9 of X_1
+};;
+
+{ .mmi
+      ldfe      FR_Q1         = [GR_ad_q]                // Load Q1
+      shladd    GR_ad_z_2     = GR_Index2, 2, GR_ad_z_2  // Point to Z_2
+      nop.i 0
+};;
+
+{ .mmi
+      ld4       GR_Z_2        = [GR_ad_z_2]                // Load Z_2
+      shladd    GR_ad_tbl_2   = GR_Index2, 4, GR_ad_tbl_2  // Point to G_2
+      nop.i 0
+};;
+
+{ .mmi
+      ldfps     FR_G2, FR_H2  = [GR_ad_tbl_2],8       // Load G_2, H_2
+      nop.m 0
+      nop.i 0
+};;
+
+{ .mfi
+      ldfd      FR_h2         = [GR_ad_tbl_2]             // Load h_2
+      nop.f 0
+      nop.i 0
+}
+{ .mfi
+      setf.exp  FR_2_to_minus_N = GR_minus_N   // Form 2^(-N)
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      pmpyshr2.u GR_X_2       = GR_X_1,GR_Z_2,15 // Get bits 30-15 of X_1 * Z_2
+};;
+
+// WE CANNOT USE GR_X_2 IN NEXT 3 CYCLES BECAUSE OF POSSIBLE 10 CLOCKS STALL!
+// "DEAD" ZONE!
+// JUST HAVE TO INSERT 3 NOP CYCLES (nothing to do here)
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      nop.f 0
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+(p11) fma.s1    FR_Q4         = FR_Q4, FR_Neg_One, f0 // Negate Q4
+      extr.u    GR_Index3     = GR_X_2, 1, 5          // Extract bits 1-5 of X_2
+ };;
+
+{ .mfi
+      shladd    GR_ad_tbl_3   = GR_Index3, 4, GR_ad_tbl_3  // Point to G_3
+	  fcvt.xf   FR_float_N    = FR_float_N
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p11) fma.s1    FR_Q3         = FR_Q3, FR_Neg_One, f0 // Negate Q3
+      nop.i 0
+};;
+
+{ .mfi
+      ldfps     FR_G3, FR_H3  = [GR_ad_tbl_3],8   // Load G_3, H_3
+(p11) fma.s1    FR_Q2         = FR_Q2, FR_Neg_One, f0 // Negate Q2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p11) fma.s1    FR_Q1         = FR_Q1, FR_Neg_One, f0 // Negate Q1
+      nop.i 0
+};;
+
+{ .mfi
+      ldfd      FR_h3         = [GR_ad_tbl_3]            // Load h_3
+      fmpy.s1   FR_G          = FR_G, FR_G2              // G = G_1 * G_2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fadd.s1   FR_H          = FR_H, FR_H2              // H = H_1 + H_2
+      nop.i 0
+};;
+
+{ .mmf
+      nop.m 0
+      nop.m 0
+      fadd.s1   FR_h          = FR_h, FR_h2              // h = h_1 + h_2
+};;
+
+{ .mfi
+      nop.m 0
+      fmpy.s1   FR_G          = FR_G, FR_G3             // G = (G_1 * G_2) * G_3
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fadd.s1   FR_H          = FR_H, FR_H3             // H = (H_1 + H_2) + H_3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fadd.s1   FR_h          = FR_h, FR_h3             // h = (h_1 + h_2) + h_3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fms.s1    FR_r          = FR_G, FR_S_hi, f1           // r = G * S_hi - 1
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_Y_hi       = FR_float_N, FR_log2_hi, FR_H // Y_hi=N*log2_hi+H
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_h          = FR_float_N, FR_log2_lo, FR_h  // h=N*log2_lo+h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_poly_lo    = FR_r, FR_Q4, FR_Q3      // poly_lo = r * Q4 + Q3
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fmpy.s1   FR_rsq        = FR_r, FR_r              // rsq = r * r
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_poly_lo    = FR_poly_lo, FR_r, FR_Q2 // poly_lo=poly_lo*r+Q2
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_rcub       = FR_rsq, FR_r, f0        // rcub = r^3
+      nop.i 0
+};;
+
+.pred.rel "mutex",p12,p11
+{ .mfi
+      nop.m 0
+(p12) fma.s1    FR_poly_hi    = FR_Q1, FR_rsq, FR_r // poly_hi = Q1*rsq + r
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p11) fms.s1    FR_poly_hi    = FR_Q1, FR_rsq, FR_r // poly_hi = Q1*rsq + r
+      nop.i 0
+};;
+
+
+.pred.rel "mutex",p12,p11
+{ .mfi
+      nop.m 0
+(p12) fma.s1    FR_poly_lo    = FR_poly_lo, FR_rcub, FR_h//poly_lo=poly_lo*r^3+h
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p11) fms.s1    FR_poly_lo    = FR_poly_lo, FR_rcub, FR_h//poly_lo=poly_lo*r^3+h
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fadd.s0   FR_Y_lo       = FR_poly_hi, FR_poly_lo  // Y_lo=poly_hi+poly_lo
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+(p11) fma.s0    FR_Y_hi       = FR_Y_hi, FR_Neg_One, f0 // FR_Y_hi sign for neg
+      nop.i 0
+};;
+
+{ .mfb
+      nop.m 0
+      fadd.s0   FR_Res        = FR_Y_lo,FR_Y_hi    // Result=Y_lo+Y_hi
+      br.ret.sptk   b0                         // Common exit for 2^-7 < x < inf
+};;
+
+// NEAR ZERO POLYNOMIAL INTERVAL
+near_0:
+{ .mfi
+      nop.m 0
+      fma.s1    FR_X4         = FR_X2, FR_X2, f0 // x^4 = x^2 * x^2
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_P9         = FR_C9,FR_X2,FR_C7  // p9 = C9*x^2 + C7
+      nop.i 0
+}
+{ .mfi
+      nop.m 0
+      fma.s1    FR_P5         = FR_C5,FR_X2,FR_C3  // p5 = C5*x^2 + C3
+      nop.i 0
+};;
+
+{ .mfi
+      nop.m 0
+      fma.s1    FR_P3         = FR_P9,FR_X4,FR_P5  // p3 = p9*x^4 + p5
+      nop.i 0
+};;
+
+{ .mfb
+      nop.m 0
+      fma.s0    FR_Res        = FR_P3,FR_X3,FR_Arg // res = p3*C3 + x
+      br.ret.sptk   b0                          // Near 0 path return
+};;
+
+GLOBAL_LIBM_END(asinhl)
+libm_alias_ldouble_other (asinh, asinh)
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_atan.S
@@ -0,0 +1,753 @@
+.file "atan.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00  Initial version
+// 04/13/00  Improved speed
+// 04/19/00  Removed the qualifying predicate from the fmerge.s that
+//           takes the absolute value.
+// 06/16/00  Reassigned FP registers to eliminate stalls on loads
+// 08/30/00  Saved 5 cycles in main path by rearranging large argument logic
+//           and delaying use of result of fcmp in load by 1 group
+// 05/20/02  Cleaned up namespace and sf0 syntax
+// 08/20/02  Use atan2 algorithm with x=1 for better accuracy
+// 02/06/03  Reordered header: .section, .global, .proc, .align
+//
+// API
+//==============================================================
+// double atan(double Y)
+//
+// Overview of operation
+//==============================================================
+//
+// The atan function returns values in the interval [-pi/2,+pi/2].
+//
+// The algorithm used is the atan2(Y,X) algorithm where we fix X=1.0.
+//
+// There are two basic paths: swap true and swap false.
+// atan2(Y,X) ==> atan2(V/U) where U >= V. If Y > X, we must swap.
+//
+// p6  swap True    |Y| > |X|
+// p7  swap False   |Y| <= |X|
+//
+//
+// Simple trigonometric identities show
+//   Region 1
+//         |Y|<=1.0, V=Y, U=1.0     atan2(Y,X) = sgnY * (0 + atan(V/U))
+//
+//   Region 2
+//         |Y|>1.0, V=1.0, U=Y      atan2(Y,X) = sgnY * (pi/2 - atan(V/U))
+//
+//
+// We compute atan(V/U) from the identity
+//      atan(z) + atan([(V/U)-z] / [1+(V/U)z])
+//      where z is a limited precision approximation (16 bits) to V/U
+//
+// z is calculated with the assistance of the frcpa instruction.
+//
+// atan(z) is calculated by a polynomial z + z^3 * p(w),  w=z^2
+// where p(w) = P0+P1*w+...+P22*w^22
+//
+// Let d = [(V/U)-z] / [1+(V/U)z]) = (V-U*z)/(U+V*z)
+//
+// Approximate atan(d) by d + P0*d^3
+// Let F = 1/(U+V*z) * (1-a), where |a|< 2^-8.8.
+// Compute q(a) = 1 + a + ... + a^5.
+// Then F*q(a) approximates the reciprocal to more than 50 bits.
+
+// Special values
+//==============================================================
+// atan(QNAN)  = QNAN
+// atan(SNAN)  = quieted SNAN
+// atan(+-inf) = +- pi/2
+// atan(+-0)   = +-0
+
+// Registers used
+//==============================================================
+
+// predicate registers used:
+// p6 -> p15
+
+// floating-point registers used:
+// f8, input
+// f32 -> f116
+
+// general registers used
+// r14 -> r16
+
+// Assembly macros
+//==============================================================
+
+EXP_AD_P1                    = r14
+EXP_AD_P2                    = r15
+rsig_near_one                = r16
+
+atan2_Y                      = f8
+atan2_X                      = f1
+
+atan2_u1_X                   = f32
+atan2_u1_Y                   = f33
+atan2_z2_X                   = f34
+
+atan2_two                    = f36
+atan2_B1sq_Y                 = f37
+atan2_z1_X                   = f38
+atan2_B1X                    = f40
+
+atan2_B1Y                    = f41
+atan2_wp_X                   = f42
+atan2_B1sq_X                 = f43
+atan2_z                      = f44
+atan2_w                      = f45
+
+atan2_P0                     = f46
+atan2_P1                     = f47
+atan2_P2                     = f48
+atan2_P3                     = f49
+atan2_P4                     = f50
+
+atan2_P5                     = f51
+atan2_P6                     = f52
+atan2_P7                     = f53
+atan2_P8                     = f54
+atan2_P9                     = f55
+
+atan2_P10                    = f56
+atan2_P11                    = f57
+atan2_P12                    = f58
+atan2_P13                    = f59
+atan2_P14                    = f60
+
+atan2_P15                    = f61
+atan2_P16                    = f62
+atan2_P17                    = f63
+atan2_P18                    = f64
+atan2_P19                    = f65
+
+atan2_P20                    = f66
+atan2_P21                    = f67
+atan2_P22                    = f68
+atan2_pi_by_2                = f69
+atan2_sgn_pi_by_2            = f69
+atan2_V13                    = f70
+
+atan2_W11                    = f71
+atan2_E                      = f72
+atan2_wp_Y                   = f73
+atan2_V11                    = f74
+atan2_V12                    = f75
+
+atan2_V7                     = f76
+atan2_V8                     = f77
+atan2_W7                     = f78
+atan2_W8                     = f79
+atan2_W3                     = f80
+
+atan2_W4                     = f81
+atan2_V3                     = f82
+atan2_V4                     = f83
+atan2_F                      = f84
+atan2_gV                     = f85
+
+atan2_V10                    = f86
+atan2_zcub                   = f87
+atan2_V6                     = f88
+atan2_V9                     = f89
+atan2_W10                    = f90
+
+atan2_W6                     = f91
+atan2_W2                     = f92
+atan2_V2                     = f93
+atan2_alpha                  = f94
+atan2_alpha_1                = f95
+
+atan2_gVF                    = f96
+atan2_V5                     = f97
+atan2_W12                    = f98
+atan2_W5                     = f99
+atan2_alpha_sq               = f100
+
+atan2_Cp                     = f101
+atan2_V1                     = f102
+atan2_ysq                    = f103
+atan2_W1                     = f104
+atan2_alpha_cub              = f105
+
+atan2_C                      = f106
+atan2_d                      = f108
+atan2_A_hi                   = f109
+atan2_dsq                    = f110
+
+atan2_pd                     = f111
+atan2_A_lo                   = f112
+atan2_A                      = f113
+atan2_Pp                     = f114
+atan2_sgnY                   = f115
+
+atan2_sig_near_one           = f116
+atan2_near_one               = f116
+
+/////////////////////////////////////////////////////////////
+
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(atan2_tb1)
+data8 0xA21922DC45605EA1 ,  0x00003FFA // P11
+data8 0xB199DD6D2675C40F ,  0x0000BFFA // P10
+data8 0xC2F01E5DDD100DBE ,  0x00003FFA // P9
+data8 0xD78F28FC2A592781 ,  0x0000BFFA // P8
+data8 0xF0F03ADB3FC930D3 ,  0x00003FFA // P7
+data8 0x88887EBB209E3543 ,  0x0000BFFB // P6
+data8 0x9D89D7D55C3287A5 ,  0x00003FFB // P5
+data8 0xBA2E8B9793955C77 ,  0x0000BFFB // P4
+data8 0xE38E38E320A8A098 ,  0x00003FFB // P3
+data8 0x9249249247E37913 ,  0x0000BFFC // P2
+data8 0xCCCCCCCCCCC906CD ,  0x00003FFC // P1
+data8 0xAAAAAAAAAAAAA8A9 ,  0x0000BFFD // P0
+data8 0x0000000000000000 ,  0x00000000 // pad to avoid bank conflict
+LOCAL_OBJECT_END(atan2_tb1)
+
+LOCAL_OBJECT_START(atan2_tb2)
+data8 0xCE585A259BD8374C ,  0x00003FF0 // P21
+data8 0x9F90FB984D8E39D0 ,  0x0000BFF3 // P20
+data8 0x9D3436AABE218776 ,  0x00003FF5 // P19
+data8 0xDEC343E068A6D2A8 ,  0x0000BFF6 // P18
+data8 0xF396268151CFB11C ,  0x00003FF7 // P17
+data8 0xD818B4BB43D84BF2 ,  0x0000BFF8 // P16
+data8 0xA2270D30A90AA220 ,  0x00003FF9 // P15
+data8 0xD5F4F2182E7A8725 ,  0x0000BFF9 // P14
+data8 0x80D601879218B53A ,  0x00003FFA // P13
+data8 0x9297B23CCFFB291F ,  0x0000BFFA // P12
+data8 0xFE7E52D2A89995B3 ,  0x0000BFEC // P22
+data8 0xC90FDAA22168C235 ,  0x00003FFF // pi/2
+LOCAL_OBJECT_END(atan2_tb2)
+
+
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(atan)
+
+{ .mfi
+           nop.m 999
+           frcpa.s1     atan2_u1_Y,p7 = f1,atan2_Y
+           nop.i 999
+}
+{ .mfi
+           addl         EXP_AD_P1   = @ltoff(atan2_tb1), gp
+           fma.s1       atan2_two  = f1,f1,f1
+           nop.i 999
+;;
+}
+
+{ .mfi
+           ld8  EXP_AD_P1 = [EXP_AD_P1]
+           frcpa.s1     atan2_u1_X,p6 = f1,atan2_X
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_ysq  = atan2_Y,atan2_Y,f0
+           nop.i 999
+}
+;;
+
+{ .mfi
+           add  EXP_AD_P2 = 0xd0,EXP_AD_P1
+           fmerge.s     atan2_sgnY = atan2_Y,f1
+           nop.i 999
+}
+;;
+
+
+{ .mfi
+           ldfe         atan2_P11  = [EXP_AD_P1],16
+           fclass.m p10,p0 = atan2_Y, 0xc3     // Test for y=nan
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P21  = [EXP_AD_P2],16
+           nop.f 999
+           nop.i 999
+;;
+}
+
+
+{ .mfi
+           ldfe         atan2_P10  = [EXP_AD_P1],16
+           fnma.s1      atan2_B1Y  = atan2_u1_Y, atan2_Y, atan2_two
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P20  = [EXP_AD_P2],16
+           fma.s1       atan2_wp_Y   = atan2_u1_Y, atan2_u1_Y, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           ldfe         atan2_P9   = [EXP_AD_P1],16
+           fma.s1       atan2_z1_X = atan2_u1_X, atan2_Y, f0
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P19  = [EXP_AD_P2],16
+           fnma.s1      atan2_B1X  = atan2_u1_X, atan2_X, atan2_two
+           nop.i 999
+}
+;;
+
+{ .mfi
+           ldfe         atan2_P8   = [EXP_AD_P1],16
+           fma.s1       atan2_z2_X = atan2_u1_X, atan2_ysq, f0
+           nop.i 999
+}
+{ .mfb
+           ldfe         atan2_P18  = [EXP_AD_P2],16
+(p10)      fma.d.s0 f8 = atan2_Y,atan2_X,f0   // If y=nan, result quietized y
+(p10)      br.ret.spnt b0        // Exit if y=nan
+}
+;;
+
+// p6 true if swap,    means |y| >  1.0    or ysq > 1.0
+// p7 true if no swap, means 1.0 >= |y|    or 1.0 >= ysq
+{ .mfi
+           ldfe         atan2_P7   = [EXP_AD_P1],16
+           fcmp.ge.s1 p7,p6    = f1, atan2_ysq
+           nop.i 999
+}
+{ .mmf
+           ldfe         atan2_P17  = [EXP_AD_P2],16
+           nop.m 999
+           nop.f 999
+}
+;;
+
+{ .mfi
+           ldfe         atan2_P6   = [EXP_AD_P1],16
+           fma.s1       atan2_E         = atan2_u1_Y, atan2_B1Y, atan2_Y
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P16  = [EXP_AD_P2],16
+           fma.s1       atan2_B1sq_Y = atan2_B1Y, atan2_B1Y, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           ldfe         atan2_P5   = [EXP_AD_P1],16
+(p7)       fma.s1       atan2_wp_X   = atan2_z1_X, atan2_z1_X, f0
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P15       = [EXP_AD_P2],16
+(p7)       fma.s1       atan2_B1sq_X = atan2_B1X, atan2_B1X, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           ldfe         atan2_P4   = [EXP_AD_P1],16
+(p6)       fma.s1       atan2_z         = atan2_u1_Y, atan2_B1Y, f0
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P14  = [EXP_AD_P2],16
+(p7)       fma.s1       atan2_E         = atan2_z2_X, atan2_B1X, atan2_X
+           nop.i 999
+;;
+}
+
+
+{ .mfi
+           ldfe         atan2_P3        = [EXP_AD_P1],16
+           fcmp.eq.s0  p14,p15=atan2_X,atan2_Y  // Dummy for denorm and invalid
+           nop.i 999
+}
+{ .mmf
+           ldfe         atan2_P13  = [EXP_AD_P2],16
+           nop.m 999
+(p7)       fma.s1       atan2_z         = atan2_z1_X, atan2_B1X, f0
+;;
+}
+
+{ .mfi
+           ldfe         atan2_P2        = [EXP_AD_P1],16
+(p6)       fma.s1       atan2_w         = atan2_wp_Y, atan2_B1sq_Y,f0
+           nop.i 999
+}
+{ .mlx
+           ldfe         atan2_P12  = [EXP_AD_P2],16
+           movl         rsig_near_one = 0x8000000000000001 // signif near 1.0
+;;
+}
+
+{ .mfi
+           ldfe         atan2_P1        = [EXP_AD_P1],16
+           fclass.m p9,p0 = atan2_Y, 0x23  // test if y inf
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_P22       = [EXP_AD_P2],16
+(p7)       fma.s1       atan2_w         = atan2_wp_X, atan2_B1sq_X,f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           ldfe         atan2_P0        = [EXP_AD_P1],16
+           frcpa.s1     atan2_F,p0     = f1, atan2_E
+           nop.i 999
+}
+{ .mfi
+           ldfe         atan2_pi_by_2   = [EXP_AD_P2],16
+(p6)       fnma.s1       atan2_gV        = atan2_Y, atan2_z, atan2_X
+           nop.i 999
+;;
+}
+
+{ .mfi
+           setf.sig      atan2_sig_near_one = rsig_near_one
+(p7)       fnma.s1       atan2_gV        = atan2_X, atan2_z, atan2_Y
+           nop.i 999
+}
+{ .mfb
+           nop.m 999
+(p9)       fma.d.s0  f8 = atan2_sgnY, atan2_pi_by_2, f0  // +-pi/2 if y inf
+(p9)       br.ret.spnt b0      // exit if y inf, result is +-pi/2
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V13       = atan2_w, atan2_P11, atan2_P10
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W11       = atan2_w, atan2_P21, atan2_P20
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V11       = atan2_w, atan2_P9, atan2_P8
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V12       = atan2_w, atan2_w, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V8        = atan2_w, atan2_P7 , atan2_P6
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W8        = atan2_w, atan2_P19, atan2_P18
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fnma.s1      atan2_alpha     = atan2_E, atan2_F, f1
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fnma.s1      atan2_alpha_1   = atan2_E, atan2_F, atan2_two
+           nop.i 999
+;;
+}
+
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V7        = atan2_w, atan2_P5 , atan2_P4
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W7        = atan2_w, atan2_P17, atan2_P16
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V4        = atan2_w, atan2_P3 , atan2_P2
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W4        = atan2_w, atan2_P15, atan2_P14
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V3        = atan2_w, atan2_P1 , atan2_P0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W3        = atan2_w, atan2_P13, atan2_P12
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V10       = atan2_V12, atan2_V13, atan2_V11
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_gVF       = atan2_gV, atan2_F, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_alpha_sq  = atan2_alpha, atan2_alpha, f0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_Cp        = atan2_alpha, atan2_alpha_1, f1
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V9        = atan2_V12, atan2_V12, f0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W10       = atan2_V12, atan2_P22 , atan2_W11
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V6        = atan2_V12, atan2_V8 , atan2_V7
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W6        = atan2_V12, atan2_W8 , atan2_W7
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V2        = atan2_V12, atan2_V4 , atan2_V3
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W2        = atan2_V12, atan2_W4  , atan2_W3
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_alpha_cub = atan2_alpha, atan2_alpha_sq, f0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_C         = atan2_gVF, atan2_Cp, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W12       = atan2_V9, atan2_V9, f0
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V5        = atan2_V9, atan2_V10, atan2_V6
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W5        = atan2_V9, atan2_W10, atan2_W6
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fclass.m p8,p0 = atan2_Y, 0x07  // Test for y=0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_d         = atan2_alpha_cub, atan2_C, atan2_C
+           nop.i 999
+}
+;;
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W12       = atan2_V9, atan2_W12, f0
+           nop.i 999
+}
+;;
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_V1        = atan2_V9, atan2_V5, atan2_V2
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_W1        = atan2_V9, atan2_W5, atan2_W2
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+(p8)       fmerge.s     f8              = atan2_sgnY, f0  // +-0 if y=0
+           nop.i 999
+}
+{ .mfb
+           nop.m 999
+           fma.s1       atan2_zcub      = atan2_z, atan2_w, f0
+(p8)       br.ret.spnt b0      // Exit if y=0
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_pd        = atan2_P0, atan2_d, f0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_dsq       = atan2_d, atan2_d, f0
+           nop.i 999
+;;
+}
+
+
+{ .mfi
+           nop.m 999
+           fmerge.se    atan2_near_one = f1, atan2_sig_near_one // Const ~1.0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_Pp        = atan2_W12, atan2_W1, atan2_V1
+           nop.i 999
+;;
+}
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_sgn_pi_by_2 = atan2_pi_by_2, atan2_sgnY, f0
+           nop.i 999
+}
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_A_lo      = atan2_pd, atan2_dsq, atan2_d
+           nop.i 999
+;;
+}
+
+
+{ .mfi
+           nop.m 999
+           fma.s1       atan2_A_hi      = atan2_zcub, atan2_Pp, atan2_z
+           nop.i 999
+;;
+}
+
+
+{ .mfi
+           nop.m 999
+(p6)       fma.s1       atan2_A         = atan2_A_hi, f1, atan2_A_lo
+           nop.i 999
+}
+// For |Y| <= |X| and X > 0, result is A_hi + A_lo
+{ .mfi
+           nop.m 999
+(p7)       fma.d.s0       f8         = atan2_A_hi, f1, atan2_A_lo
+           nop.i 999
+;;
+}
+
+// For |Y| > |X|, result is  +- pi/2 - (A_hi + A_lo)
+// We perturb A by multiplying by 1.0+1ulp as we produce the result
+// in order to get symmetrically rounded results in directed rounding modes.
+// If we don't do this, there are a few cases where the trailing 11 bits of
+// the significand of the result, before converting to double, are zero.  These
+// cases do not round symmetrically in round to +infinity or round to -infinity.
+{ .mfb
+           nop.m 999
+(p6)       fnma.d.s0      f8        = atan2_A, atan2_near_one, atan2_sgn_pi_by_2
+           br.ret.sptk  b0
+;;
+}
+
+GLOBAL_LIBM_END(atan)
+libm_alias_double_other (atan, atan)
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_atanf.S
@@ -0,0 +1,555 @@
+.file "atanf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+
+
+// History
+//==============================================================
+// 02/20/00 Initial version
+// 08/17/00 Changed predicate register macro-usage to direct predicate
+//          names due to an assembler bug.
+// 02/06/02 Corrected .section statement
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header: .section, .global, .proc, .align;
+//          added missing bundling
+
+//
+// Assembly macros
+//==============================================================
+
+// integer registers used
+EXP_Addr1          = r33
+EXP_Addr2          = r34
+
+// floating point registers used
+atanf_coeff_R4     = f32
+atanf_coeff_R5     = f33
+atanf_coeff_R1     = f34
+atanf_coeff_R2     = f35
+
+atanf_coeff_R3     = f36
+atanf_coeff_P1     = f37
+atanf_coeff_Q6     = f38
+atanf_coeff_Q7     = f39
+atanf_coeff_Q8     = f40
+
+atanf_coeff_Q9     = f41
+atanf_coeff_Q4     = f42
+atanf_coeff_Q5     = f43
+atanf_coeff_Q2     = f44
+atanf_coeff_Q3     = f45
+
+atanf_coeff_P5     = f46
+atanf_coeff_P6     = f47
+atanf_coeff_Q0     = f48
+atanf_coeff_Q1     = f49
+atanf_coeff_P7     = f50
+
+atanf_coeff_P8     = f51
+atanf_coeff_P3     = f52
+atanf_coeff_P4     = f53
+atanf_coeff_P9     = f54
+atanf_coeff_P10    = f55
+
+atanf_coeff_P2     = f56
+atanf_piby2        = f57
+atanf_z            = f58
+atanf_b            = f59
+atanf_zsq          = f60
+
+atanf_sgn_x        = f61
+atanf_sgnx_piby2   = f62
+atanf_abs_x        = f63
+atanf_t            = f64
+atanf_xcub         = f65
+
+atanf_tsq          = f66
+atanf_t4           = f67
+atanf_x5           = f68
+atanf_x6           = f69
+atanf_x11          = f70
+
+atanf_poly_p1      = f71
+atanf_poly_p2      = f72
+atanf_poly_p3      = f73
+atanf_poly_p4      = f74
+atanf_poly_p5      = f75
+
+atanf_poly_q1      = f76
+atanf_poly_q2      = f77
+atanf_poly_q3      = f78
+atanf_poly_q4      = f79
+atanf_poly_q5      = f80
+
+atanf_poly_q       = f81
+atanf_poly_r1      = f81
+atanf_poly_r2      = f82
+atanf_poly_r3      = f83
+atanf_bsq          = f84
+atanf_z4           = f85
+
+atanf_z5           = f86
+atanf_z8           = f87
+atanf_z13          = f88
+atanf_poly_r2      = f89
+atanf_poly_r1      = f90
+
+atanf_z8_bsq       = f91
+atanf_poly_r       = f92
+atanf_z21_poly_r   = f93
+atanf_answer       = f8
+
+
+// predicate registers used
+//atanf_pred_LE1     = p6
+//atanf_pred_GT1     = p7
+
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(atanf_coeff_1_table)
+data8 0x40c4c241be751ff2  // r4
+data8 0x40e9f300c2f3070b  // r5
+data8 0x409babffef772075  // r3
+data8 0xbfd5555512191621  // p1
+data8 0x3fc9997e7afbff4e  // p2  = q8
+data8 0xbfd5555512191621  // p1  = q9
+data8 0x3f97105b4160f86b  // p8  = q2
+data8 0xbfa6e10ba401393f  // p7  = q3
+data8 0x3f522e5d33bc9baa  // p10 = q0
+data8 0xbf7deaadaa336451  // p9  = q1
+data8 0xbfc2473c5145ee38  // p3
+data8 0x3fbc4f512b1865f5  // p4
+data8 0x3fc9997e7afbff4e  // p2
+data8 0x3ff921fb54442d18  // pi/2
+LOCAL_OBJECT_END(atanf_coeff_1_table)
+
+
+
+LOCAL_OBJECT_START(atanf_coeff_2_table)
+data8 0x4035000000004284  // r1
+data8 0x406cdffff336a59b  // r2
+data8 0x3fbc4f512b1865f5  // p4 = q6
+data8 0xbfc2473c5145ee38  // p3 = q7
+data8 0x3fb142a73d7c54e3  // p6 = q4
+data8 0xbfb68eed6a8cfa32  // p5 = q5
+data8 0xbfb68eed6a8cfa32  // p5
+data8 0x3fb142a73d7c54e3  // p6
+data8 0xbfa6e10ba401393f  // p7
+data8 0x3f97105b4160f86b  // p8
+data8 0xbf7deaadaa336451  // p9
+data8 0x3f522e5d33bc9baa  // p10
+LOCAL_OBJECT_END(atanf_coeff_2_table)
+
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(atanf)
+
+{     .mfi
+     alloc      r32                  = ar.pfs,1,2,0,0
+     frcpa.s1  atanf_z,p0   =    f1,f8
+     addl      EXP_Addr2           =    @ltoff(atanf_coeff_2_table),gp
+}
+{     .mfi
+     addl      EXP_Addr1 =    @ltoff(atanf_coeff_1_table),gp
+     fma.s1    atanf_t   =    f8,f8,f0
+     nop.i                 999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fmerge.s  atanf_sgn_x    =    f8,f1
+     nop.i                      999;;
+}
+
+{     .mfi
+     ld8       EXP_Addr1      =    [EXP_Addr1]
+     fmerge.s  atanf_abs_x    =    f1,f8
+     nop.i                      999
+}
+{     .mfi
+     ld8       EXP_Addr2 =    [EXP_Addr2]
+     nop.f                 999
+     nop.i                 999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fclass.m  p8,p0   =    f8,0x7	// @zero
+     nop.i                      999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fcmp.eq.unc.s0 p9,p10    =    f8,f1
+     nop.i                      999;;
+}
+
+{     .mfi
+     ldfpd     atanf_coeff_R4,atanf_coeff_R5 =    [EXP_Addr1],16
+     fnma.s1   atanf_b                       =    f8,atanf_z,f1
+     nop.i                                     999
+}
+{     .mfi
+     ldfpd     atanf_coeff_R1,atanf_coeff_R2 =    [EXP_Addr2],16
+     fma.s1    atanf_zsq                     =    atanf_z,atanf_z,f0
+     nop.i                                     999;;
+}
+
+
+{     .mfi
+     ldfpd     atanf_coeff_R3,atanf_coeff_P1 =    [EXP_Addr1],16
+     fma.s1    atanf_xcub                    =    f8,atanf_t,f0
+     nop.i                                     999
+}
+{     .mfi
+     ldfpd     atanf_coeff_Q6,atanf_coeff_Q7 =    [EXP_Addr2],16
+     fma.s1    atanf_tsq                     =    atanf_t,atanf_t,f0
+     nop.i                                     999;;
+}
+
+
+{     .mfi
+     ldfpd          atanf_coeff_Q8,atanf_coeff_Q9 =    [EXP_Addr1],16
+//     fcmp.le.s1     atanf_pred_LE1,atanf_pred_GT1 =    atanf_abs_x,f1
+     fcmp.le.s1     p6,p7 =    atanf_abs_x,f1
+     nop.i                                          999
+}
+{     .mfi
+     ldfpd     atanf_coeff_Q4,atanf_coeff_Q5 =    [EXP_Addr2],16
+     nop.f                                     999
+     nop.i                                     999;;
+}
+
+
+{     .mfi
+     ldfpd     atanf_coeff_Q2,atanf_coeff_Q3 =    [EXP_Addr1],16
+     fclass.m  p8,p0                  =    f8,0xe7	// @inf|@qnan|@snan|@zero
+     nop.i                                     999
+}
+{     .mfi
+     ldfpd     atanf_coeff_P5,atanf_coeff_P6 =    [EXP_Addr2],16
+     nop.f                                     999
+     nop.i                                     999;;
+}
+
+
+{     .mfi
+     ldfpd     atanf_coeff_Q0,atanf_coeff_Q1 =    [EXP_Addr1],16
+     nop.f                                     999
+     nop.i                                     999
+}
+{     .mfi
+     ldfpd     atanf_coeff_P7,atanf_coeff_P8 =    [EXP_Addr2],16
+     nop.f                                     999
+     nop.i                                     999;;
+}
+
+
+{     .mfi
+     ldfpd     atanf_coeff_P3,atanf_coeff_P4 =    [EXP_Addr1],16
+     fma.s1    atanf_bsq                     =    atanf_b,atanf_b,f0
+     nop.i                                     999
+}
+{     .mfi
+     ldfpd     atanf_coeff_P9,atanf_coeff_P10     =    [EXP_Addr2]
+     fma.s1    atanf_z4                           =    atanf_zsq,atanf_zsq,f0
+     nop.i                                          999;;
+}
+
+
+{     .mfi
+     ldfpd     atanf_coeff_P2,atanf_piby2    =    [EXP_Addr1]
+     fma.s1    atanf_x6                      =    atanf_t,atanf_tsq,f0
+     nop.i                                     999
+}
+{     .mfi
+     nop.m                 999
+     fma.s1    atanf_t4  =    atanf_tsq,atanf_tsq,f0
+     nop.i                 999;;
+}
+
+
+{     .mfb
+     nop.m                 999
+     fma.s1    atanf_x5  =    atanf_t,atanf_xcub,f0
+(p8)  br.cond.spnt   ATANF_X_INF_NAN_ZERO
+}
+;;
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_r1  =    atanf_b,atanf_coeff_R1,f1
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_r3  =    atanf_b,atanf_coeff_R5,atanf_coeff_R4
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_r2  =    atanf_b,atanf_coeff_R3,atanf_coeff_R2
+     nop.i                      999
+}
+{     .mfi
+     nop.m                 999
+     fma.s1    atanf_z8  =    atanf_z4,atanf_z4,f0
+     nop.i                 999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_q2  =    atanf_t,atanf_coeff_Q5,atanf_coeff_Q4
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_q3  =    atanf_t,atanf_coeff_Q7,atanf_coeff_Q6
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                 999
+     fma.s1    atanf_z5  =    atanf_z,atanf_z4,f0
+     nop.i                 999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_q1  =    atanf_t,atanf_coeff_Q9,atanf_coeff_Q8
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_q4  =    atanf_t,atanf_coeff_Q1,atanf_coeff_Q0
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_q5  =    atanf_t,atanf_coeff_Q3,atanf_coeff_Q2
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_p4  =    f8,atanf_coeff_P1,f0
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_p5  =    atanf_t,atanf_coeff_P4,atanf_coeff_P3
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_r1  =    atanf_z8,atanf_poly_r1,f0
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_z8_bsq   =    atanf_z8,atanf_bsq,f0
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_q2  =    atanf_tsq,atanf_poly_q3,atanf_poly_q2
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_r2  =    atanf_bsq,atanf_poly_r3,atanf_poly_r2
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_p2  =    atanf_t,atanf_coeff_P8,atanf_coeff_P7
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_q1  =    atanf_poly_q1,f1,atanf_tsq
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                 999
+     fma.s1    atanf_z13 =    atanf_z5,atanf_z8,f0
+     nop.i                 999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_p1  =    atanf_t,atanf_coeff_P10,atanf_coeff_P9
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_p4  =    atanf_t,atanf_poly_p4,f8
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_q4  =    atanf_tsq,atanf_poly_q5,atanf_poly_q4
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_p3  =    atanf_t,atanf_coeff_P6,atanf_coeff_P5
+     nop.i                      999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_p5  =    atanf_t,atanf_poly_p5,atanf_coeff_P2
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                 999
+     fma.s1    atanf_x11 =    atanf_x5,atanf_x6,f0
+     nop.i                 999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_r   =    atanf_z8_bsq,atanf_poly_r2,atanf_poly_r1
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                           999
+     fma.s0       atanf_sgnx_piby2    =    atanf_sgn_x,atanf_piby2,f0
+     nop.i                           999
+}
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_q2  =    atanf_t4,atanf_poly_q1,atanf_poly_q2
+     nop.i                      999;;
+}
+
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_p1  =    atanf_tsq,atanf_poly_p1,atanf_poly_p2
+     nop.i                      999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_p4  =    atanf_x5,atanf_poly_p5,atanf_poly_p4
+     nop.i                      999;;
+}
+
+{     .mfi
+     nop.m                           999
+     fma.s1    atanf_z21_poly_r    =    atanf_z13,atanf_poly_r,f0
+     nop.i                           999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_q   =    atanf_t4,atanf_poly_q2,atanf_poly_q4
+     nop.i                      999;;
+}
+
+{     .mfi
+     nop.m                      999
+     fma.s1    atanf_poly_p1  =    atanf_tsq,atanf_poly_p1,atanf_poly_p3
+     nop.i                      999;;
+}
+
+{     .mfi
+                    nop.m                      999
+//(atanf_pred_GT1)    fnma.s    atanf_answer   =    atanf_poly_q,atanf_z21_poly_r,atanf_sgnx_piby2
+(p7)    fnma.s.s0    atanf_answer   =    atanf_poly_q,atanf_z21_poly_r,atanf_sgnx_piby2
+                    nop.i                      999;;
+}
+
+{     .mfb
+                    nop.m                      999
+//(atanf_pred_LE1)    fma.s     atanf_answer   =    atanf_x11,atanf_poly_p1,atanf_poly_p4
+(p6)    fma.s.s0     atanf_answer   =    atanf_x11,atanf_poly_p1,atanf_poly_p4
+                    br.ret.sptk b0
+}
+
+
+
+ATANF_X_INF_NAN_ZERO:
+
+{ .mfi
+      nop.m 0
+      fclass.m p8,p9 = f8,0x23  // @inf
+      nop.i 0
+}
+;;
+{ .mfi
+      nop.m 0
+(p8)  fmerge.s f8 = f8, atanf_piby2
+      nop.i 0
+}
+;;
+{ .mfb
+      nop.m 0
+      fnorm.s.s0 f8 = f8
+      br.ret.sptk b0
+}
+;;
+
+GLOBAL_LIBM_END(atanf)
+libm_alias_float_other (atan, atan)
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_atanl.S
@@ -0,0 +1,2008 @@
+.file "atanl.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//
+//*********************************************************************
+//
+// History
+// 02/02/00 (hand-optimized)
+// 04/04/00 Unwind support added
+// 08/15/00 Bundle added after call to __libm_error_support to properly
+//          set [the previously overwritten] GR_Parameter_RESULT.
+// 03/13/01 Fixed flags when denormal raised on intermediate result
+// 01/08/02 Improved speed.
+// 02/06/02 Corrected .section statement
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/10/03 Reordered header: .section, .global, .proc, .align;
+//          used data8 for long double table values
+// 03/31/05 Reformatted delimiters between data tables
+//
+//*********************************************************************
+//
+// Function:   atanl(x) = inverse tangent(x), for double extended x values
+// Function:   atan2l(y,x) = atan(y/x), for double extended y, x values
+//
+// API
+//
+//  long double atanl  (long double x)
+//  long double atan2l (long double y, long double x)
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8 (Input and Return Value)
+//                              f9 (Input for atan2l)
+//                              f10-f15, f32-f83
+//
+//    General Purpose Registers:
+//      r32-r51
+//      r49-r52 (Arguments to error support for 0,0 case)
+//
+//    Predicate Registers:      p6-p15
+//
+//*********************************************************************
+//
+// IEEE Special Conditions:
+//
+//    Denormal fault raised on denormal inputs
+//    Underflow exceptions may occur
+//    Special error handling for the y=0 and x=0 case
+//    Inexact raised when appropriate by algorithm
+//
+//    atanl(SNaN) = QNaN
+//    atanl(QNaN) = QNaN
+//    atanl(+/-0) = +/- 0
+//    atanl(+/-Inf) = +/-pi/2
+//
+//    atan2l(Any NaN for x or y) = QNaN
+//    atan2l(+/-0,x) = +/-0 for x > 0
+//    atan2l(+/-0,x) = +/-pi for x < 0
+//    atan2l(+/-0,+0) = +/-0
+//    atan2l(+/-0,-0) = +/-pi
+//    atan2l(y,+/-0) = pi/2 y > 0
+//    atan2l(y,+/-0) = -pi/2 y < 0
+//    atan2l(+/-y, Inf) = +/-0 for finite y > 0
+//    atan2l(+/-Inf, x) = +/-pi/2 for finite x
+//    atan2l(+/-y, -Inf) = +/-pi for finite  y > 0
+//    atan2l(+/-Inf, Inf) = +/-pi/4
+//    atan2l(+/-Inf, -Inf) = +/-3pi/4
+//
+//*********************************************************************
+//
+// Mathematical Description
+// ---------------------------
+//
+// The function ATANL( Arg_Y, Arg_X ) returns the "argument"
+// or the "phase" of the complex number
+//
+//           Arg_X + i Arg_Y
+//
+// or equivalently, the angle in radians from the positive
+// x-axis to the line joining the origin and the point
+// (Arg_X,Arg_Y)
+//
+//
+//        (Arg_X, Arg_Y) x
+//                        \
+//                \
+//                 \
+//                  \
+//                   \ angle between is ATANL(Arg_Y,Arg_X)
+
+
+
+
+//                    \
+//                     ------------------> X-axis
+
+//                   Origin
+//
+// Moreover, this angle is reported in the range [-pi,pi] thus
+//
+//      -pi <= ATANL( Arg_Y, Arg_X ) <= pi.
+//
+// From the geometry, it is easy to define ATANL when one of
+// Arg_X or Arg_Y is +-0 or +-inf:
+//
+//
+//      \ Y |
+//     X \  |  +0  | -0  |  +inf |  -inf  |  finite non-zero
+//        \ |      |     |       |        |
+//    ______________________________________________________
+//          |            |       |        |
+//     +-0  |   Invalid/ |  pi/2 | -pi/2  |  sign(Y)*pi/2
+//          |    qNaN    |       |        |
+//  --------------------------------------------------------
+//          |      |     |       |        |
+//     +inf |  +0  | -0  |  pi/4 | -pi/4  |  sign(Y)*0
+//  --------------------------------------------------------
+//          |      |     |       |        |
+//     -inf |  +pi | -pi | 3pi/4 | -3pi/4 |  sign(Y)*pi
+//  --------------------------------------------------------
+//   finite |    X>0?    |  pi/2 | -pi/2  |  normal case
+//  non-zero| sign(Y)*0: |       |        |
+//       | sign(Y)*pi |       |        |
+//
+//
+// One must take note that ATANL is NOT the arctangent of the
+// value Arg_Y/Arg_X; but rather ATANL and arctan are related
+// in a slightly more complicated way as follows:
+//
+// Let U := max(|Arg_X|, |Arg_Y|);  V := min(|Arg_X|, |Arg_Y|);
+// sign_X be the sign bit of Arg_X, i.e., sign_X is 0 or 1;
+// s_X    be the sign     of Arg_X, i.e., s_X = (-1)^sign_X;
+//
+// sign_Y be the sign bit of Arg_Y, i.e., sign_Y is 0 or 1;
+// s_Y    be the sign     of Arg_Y, i.e., s_Y = (-1)^sign_Y;
+//
+// swap   be 0  if |Arg_X| >= |Arg_Y|  and 1 otherwise.
+//
+// Then, ATANL(Arg_Y, Arg_X) =
+//
+//       /    arctan(V/U)     \      sign_X = 0 & swap = 0
+//       | pi/2 - arctan(V/U) |      sign_X = 0 & swap = 1
+// s_Y * |                    |
+//       |  pi  - arctan(V/U) |      sign_X = 1 & swap = 0
+//       \ pi/2 + arctan(V/U) /      sign_X = 1 & swap = 1
+//
+//
+// This relationship also suggest that the algorithm's major
+// task is to calculate arctan(V/U) for 0 < V <= U; and the
+// final Result is given by
+//
+//      s_Y * { (P_hi + P_lo) + sigma * arctan(V/U) }
+//
+// where
+//
+//   (P_hi,P_lo) represents M(sign_X,swap)*(pi/2) accurately
+//
+//   M(sign_X,swap) = 0  for sign_X = 0 and swap = 0
+//              1  for swap   = 1
+//              2  for sign_X = 1 and swap = 0
+//
+// and
+//
+//   sigma = { (sign_X  XOR  swap) :  -1.0 : 1.0 }
+//
+//      =  (-1) ^ ( sign_X XOR swap )
+//
+// Both (P_hi,P_lo) and sigma can be stored in a table and fetched
+// using (sign_X,swap) as an index. (P_hi, P_lo) can be stored as a
+// double-precision, and single-precision pair; and sigma can
+// obviously be just a single-precision number.
+//
+// In the algorithm we propose, arctan(V/U) is calculated to high accuracy
+// as A_hi + A_lo. Consequently, the Result ATANL( Arg_Y, Arg_X ) is
+// given by
+//
+//    s_Y*P_hi + s_Y*sigma*A_hi + s_Y*(sigma*A_lo + P_lo)
+//
+// We now discuss the calculation of arctan(V/U) for 0 < V <= U.
+//
+// For (V/U) < 2^(-3), we use a simple polynomial of the form
+//
+//      z + z^3*(P_1 + z^2*(P_2 + z^2*(P_3 + ... + P_8)))
+//
+// where z = V/U.
+//
+// For the sake of accuracy, the first term "z" must approximate V/U to
+// extra precision. For z^3 and higher power, a working precision
+// approximation to V/U suffices. Thus, we obtain:
+//
+//      z_hi + z_lo = V/U  to extra precision and
+//      z           = V/U  to working precision
+//
+// The value arctan(V/U) is delivered as two pieces (A_hi, A_lo)
+//
+//      (A_hi,A_lo) = (z_hi, z^3*(P_1 + ... + P_8) + z_lo).
+//
+//
+// For 2^(-3) <= (V/U) <= 1, we use a table-driven approach.
+// Consider
+//
+//      (V/U) = 2^k * 1.b_1 b_2 .... b_63 b_64 b_65 ....
+//
+// Define
+//
+//       z_hi = 2^k * 1.b_1 b_2 b_3 b_4 1
+//
+// then
+//                                            /                \
+//                                            |  (V/U) - z_hi  |
+
+//      arctan(V/U) = arctan(z_hi) + acrtan| -------------- |
+//                                            | 1 + (V/U)*z_hi |
+//                                            \                /
+//
+//                                            /                \
+//                                            |   V - z_hi*U   |
+
+//                  = arctan(z_hi) + acrtan| -------------- |
+//                                            |   U + V*z_hi   |
+//                                            \                /
+//
+//                  = arctan(z_hi) + acrtan( V' / U' )
+//
+//
+// where
+//
+//      V' = V - U*z_hi;   U' = U + V*z_hi.
+//
+// Let
+//
+//      w_hi + w_lo  = V'/U' to extra precision and
+//           w       = V'/U' to working precision
+//
+// then we can approximate arctan(V'/U') by
+//
+//      arctan(V'/U') = w_hi + w_lo
+//                     + w^3*(Q_1 + w^2*(Q_2 + w^2*(Q_3 + w^2*Q_4)))
+//
+//                       = w_hi + w_lo + poly
+//
+// Finally, arctan(z_hi) is calculated beforehand and stored in a table
+// as Tbl_hi, Tbl_lo. Thus,
+//
+//      (A_hi, A_lo) = (Tbl_hi, w_hi+(poly+(w_lo+Tbl_lo)))
+//
+// This completes the mathematical description.
+//
+//
+// Algorithm
+// -------------
+//
+// Step 0. Check for unsupported format.
+//
+//    If
+//       ( expo(Arg_X) not zero AND msb(Arg_X) = 0 ) OR
+//       ( expo(Arg_Y) not zero AND msb(Arg_Y) = 0 )
+//
+//    then one of the arguments is unsupported. Generate an
+//    invalid and return qNaN.
+//
+// Step 1. Initialize
+//
+//    Normalize Arg_X and Arg_Y and set the following
+//
+//    sign_X :=  sign_bit(Arg_X)
+//    s_Y    := (sign_bit(Arg_Y)==0? 1.0 : -1.0)
+//    swap   := (|Arg_X| >= |Arg_Y|?   0 :  1  )
+//    U      := max( |Arg_X|, |Arg_Y| )
+//    V      := min( |Arg_X|, |Arg_Y| )
+//
+//    execute: frcpa E, pred, V, U
+//    If pred is 0, go to Step 5 for special cases handling.
+//
+// Step 2. Decide on branch.
+//
+//    Q := E * V
+//    If Q < 2^(-3) go to Step 4 for simple polynomial case.
+//
+// Step 3. Table-driven algorithm.
+//
+//    Q is represented as
+//
+//      2^(-k) * 1.b_1 b_2 b_3 ... b_63; k = 0,-1,-2,-3
+//
+// and that if k = 0, b_1 = b_2 = b_3 = b_4 = 0.
+//
+// Define
+//
+//      z_hi := 2^(-k) * 1.b_1 b_2 b_3 b_4 1
+//
+// (note that there are 49 possible values of z_hi).
+//
+//      ...We now calculate V' and U'. While V' is representable
+//      ...as a 64-bit number because of cancellation, U' is
+//      ...not in general a 64-bit number. Obtaining U' accurately
+//      ...requires two working precision numbers
+//
+//      U_prime_hi := U + V * z_hi            ...WP approx. to U'
+//      U_prime_lo := ( U - U_prime_hi ) + V*z_hi ...observe order
+//      V_prime    := V - U * z_hi             ...this is exact
+//
+//         C_hi := frcpa (1.0, U_prime_hi)  ...C_hi approx 1/U'_hi
+//
+//      loop 3 times
+//         C_hi := C_hi + C_hi*(1.0 - C_hi*U_prime_hi)
+//
+//      ...at this point C_hi is (1/U_prime_hi) to roughly 64 bits
+//
+//      w_hi := V_prime * C_hi     ...w_hi is V_prime/U_prime to
+//                     ...roughly working precision
+//
+//         ...note that we want w_hi + w_lo to approximate
+//      ...V_prime/(U_prime_hi + U_prime_lo) to extra precision
+//         ...but for now, w_hi is good enough for the polynomial
+//      ...calculation.
+//
+//         wsq  := w_hi*w_hi
+//      poly := w_hi*wsq*(Q_1 + wsq*(Q_2 + wsq*(Q_3 + wsq*Q_4)))
+//
+//      Fetch
+//      (Tbl_hi, Tbl_lo) = atan(z_hi) indexed by (k,b_1,b_2,b_3,b_4)
+//      ...Tbl_hi is a double-precision number
+//      ...Tbl_lo is a single-precision number
+//
+//         (P_hi, P_lo) := M(sign_X,swap)*(Pi_by_2_hi, Pi_by_2_lo)
+//      ...as discussed previous. Again; the implementation can
+//      ...chose to fetch P_hi and P_lo from a table indexed by
+//      ...(sign_X, swap).
+//      ...P_hi is a double-precision number;
+//      ...P_lo is a single-precision number.
+//
+//      ...calculate w_lo so that w_hi + w_lo is V'/U' accurately
+//         w_lo := ((V_prime - w_hi*U_prime_hi) -
+//              w_hi*U_prime_lo) * C_hi     ...observe order
+//
+//
+//      ...Ready to deliver arctan(V'/U') as A_hi, A_lo
+//      A_hi := Tbl_hi
+//      A_lo := w_hi + (poly + (Tbl_lo + w_lo)) ...observe order
+//
+//      ...Deliver final Result
+//      ...s_Y*P_hi + s_Y*sigma*A_hi + s_Y*(sigma*A_lo + P_lo)
+//
+//      sigma := ( (sign_X XOR swap) ? -1.0 : 1.0 )
+//      ...sigma can be obtained by a table lookup using
+//      ...(sign_X,swap) as index and stored as single precision
+//         ...sigma should be calculated earlier
+//
+//      P_hi := s_Y*P_hi
+//      A_hi := s_Y*A_hi
+//
+//      Res_hi := P_hi + sigma*A_hi     ...this is exact because
+//                          ...both P_hi and Tbl_hi
+//                          ...are double-precision
+//                          ...and |Tbl_hi| > 2^(-4)
+//                          ...P_hi is either 0 or
+//                          ...between (1,4)
+//
+//      Res_lo := sigma*A_lo + P_lo
+//
+//      Return Res_hi + s_Y*Res_lo in user-defined rounding control
+//
+// Step 4. Simple polynomial case.
+//
+//    ...E and Q are inherited from Step 2.
+//
+//    A_hi := Q     ...Q is inherited from Step 2 Q approx V/U
+//
+//    loop 3 times
+//       E := E + E2(1.0 - E*U1
+//    ...at this point E approximates 1/U to roughly working precision
+//
+//    z := V * E     ...z approximates V/U to roughly working precision
+//    zsq := z * z
+//    z4 := zsq * zsq; z8 := z4 * z4
+//
+//    poly1 := P_4 + zsq*(P_5 + zsq*(P_6 + zsq*(P_7 + zsq*P_8)))
+//    poly2 := zsq*(P_1 + zsq*(P_2 + zsq*P_3))
+//
+//    poly  := poly1 + z8*poly2
+//
+//    z_lo := (V - A_hi*U)*E
+//
+//    A_lo := z*poly + z_lo
+//    ...A_hi, A_lo approximate arctan(V/U) accurately
+//
+//    (P_hi, P_lo) := M(sign_X,swap)*(Pi_by_2_hi, Pi_by_2_lo)
+//    ...one can store the M(sign_X,swap) as single precision
+//    ...values
+//
+//    ...Deliver final Result
+//    ...s_Y*P_hi + s_Y*sigma*A_hi + s_Y*(sigma*A_lo + P_lo)
+//
+//    sigma := ( (sign_X XOR swap) ? -1.0 : 1.0 )
+//    ...sigma can be obtained by a table lookup using
+//    ...(sign_X,swap) as index and stored as single precision
+//    ...sigma should be calculated earlier
+//
+//    P_hi := s_Y*P_hi
+//    A_hi := s_Y*A_hi
+//
+//    Res_hi := P_hi + sigma*A_hi          ...need to compute
+//                          ...P_hi + sigma*A_hi
+//                          ...exactly
+//
+//    tmp    := (P_hi - Res_hi) + sigma*A_hi
+//
+//    Res_lo := s_Y*(sigma*A_lo + P_lo) + tmp
+//
+//    Return Res_hi + Res_lo in user-defined rounding control
+//
+// Step 5. Special Cases
+//
+//    These are detected early in the function by fclass instructions.
+//
+//    We are in one of those special cases when X or Y is 0,+-inf or NaN
+//
+//    If one of X and Y is NaN, return X+Y (which will generate
+//    invalid in case one is a signaling NaN). Otherwise,
+//    return the Result as described in the table
+//
+//
+//
+//      \ Y |
+//     X \  |  +0  | -0  |  +inf |  -inf  |  finite non-zero
+//        \ |      |     |       |        |
+//    ______________________________________________________
+//          |            |       |        |
+//     +-0  |   Invalid/ |  pi/2 | -pi/2  |  sign(Y)*pi/2
+//          |    qNaN    |       |        |
+//  --------------------------------------------------------
+//          |      |     |       |        |
+//     +inf |  +0  | -0  |  pi/4 | -pi/4  |  sign(Y)*0
+//  --------------------------------------------------------
+//          |      |     |       |        |
+//     -inf |  +pi | -pi | 3pi/4 | -3pi/4 |  sign(Y)*pi
+//  --------------------------------------------------------
+//   finite |    X>0?    |  pi/2 | -pi/2  |
+//  non-zero| sign(Y)*0: |       |        |      N/A
+//       | sign(Y)*pi |       |        |
+//
+//
+
+ArgY_orig   =   f8
+Result      =   f8
+FR_RESULT   =   f8
+ArgX_orig   =   f9
+ArgX        =   f10
+FR_X        =   f10
+ArgY        =   f11
+FR_Y        =   f11
+s_Y         =   f12
+U           =   f13
+V           =   f14
+E           =   f15
+Q           =   f32
+z_hi        =   f33
+U_prime_hi  =   f34
+U_prime_lo  =   f35
+V_prime     =   f36
+C_hi        =   f37
+w_hi        =   f38
+w_lo        =   f39
+wsq         =   f40
+poly        =   f41
+Tbl_hi      =   f42
+Tbl_lo      =   f43
+P_hi        =   f44
+P_lo        =   f45
+A_hi        =   f46
+A_lo        =   f47
+sigma       =   f48
+Res_hi      =   f49
+Res_lo      =   f50
+Z           =   f52
+zsq         =   f53
+z4          =   f54
+z8          =   f54
+poly1       =   f55
+poly2       =   f56
+z_lo        =   f57
+tmp         =   f58
+P_1         =   f59
+Q_1         =   f60
+P_2         =   f61
+Q_2         =   f62
+P_3         =   f63
+Q_3         =   f64
+P_4         =   f65
+Q_4         =   f66
+P_5         =   f67
+P_6         =   f68
+P_7         =   f69
+P_8         =   f70
+U_hold      =   f71
+TWO_TO_NEG3 =   f72
+C_hi_hold   =   f73
+E_hold      =   f74
+M           =   f75
+ArgX_abs    =   f76
+ArgY_abs    =   f77
+Result_lo   =   f78
+A_temp      =   f79
+FR_temp     =   f80
+Xsq         =   f81
+Ysq         =   f82
+tmp_small   =   f83
+
+GR_SAVE_PFS   = r33
+GR_SAVE_B0    = r34
+GR_SAVE_GP    = r35
+sign_X        = r36
+sign_Y        = r37
+swap          = r38
+table_ptr1    = r39
+table_ptr2    = r40
+k             = r41
+lookup        = r42
+exp_ArgX      = r43
+exp_ArgY      = r44
+exponent_Q    = r45
+significand_Q = r46
+special       = r47
+sp_exp_Q      = r48
+sp_exp_4sig_Q = r49
+table_base    = r50
+int_temp      = r51
+
+GR_Parameter_X      = r49
+GR_Parameter_Y      = r50
+GR_Parameter_RESULT = r51
+GR_Parameter_TAG    = r52
+GR_temp             = r52
+
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(Constants_atan)
+//       double pi/2
+data8 0x3FF921FB54442D18
+//       single lo_pi/2, two**(-3)
+data4 0x248D3132, 0x3E000000
+data8 0xAAAAAAAAAAAAAAA3, 0xBFFD // P_1
+data8 0xCCCCCCCCCCCC54B2, 0x3FFC // P_2
+data8 0x9249249247E4D0C2, 0xBFFC // P_3
+data8 0xE38E38E058870889, 0x3FFB // P_4
+data8 0xBA2E895B290149F8, 0xBFFB // P_5
+data8 0x9D88E6D4250F733D, 0x3FFB // P_6
+data8 0x884E51FFFB8745A0, 0xBFFB // P_7
+data8 0xE1C7412B394396BD, 0x3FFA // P_8
+data8 0xAAAAAAAAAAAAA52F, 0xBFFD // Q_1
+data8 0xCCCCCCCCC75B60D3, 0x3FFC // Q_2
+data8 0x924923AD011F1940, 0xBFFC // Q_3
+data8 0xE36F716D2A5F89BD, 0x3FFB // Q_4
+//
+//    Entries Tbl_hi  (double precision)
+//    B = 1+Index/16+1/32  Index = 0
+//    Entries Tbl_lo (single precision)
+//    B = 1+Index/16+1/32  Index = 0
+//
+data8 0x3FE9A000A935BD8E
+data4 0x23ACA08F, 0x00000000
+//
+//    Entries Tbl_hi  (double precision) Index = 0,1,...,15
+//    B = 2^(-1)*(1+Index/16+1/32)
+//    Entries Tbl_lo (single precision)
+//    Index = 0,1,...,15  B = 2^(-1)*(1+Index/16+1/32)
+//
+data8 0x3FDE77EB7F175A34
+data4 0x238729EE, 0x00000000
+data8 0x3FE0039C73C1A40B
+data4 0x249334DB, 0x00000000
+data8 0x3FE0C6145B5B43DA
+data4 0x22CBA7D1, 0x00000000
+data8 0x3FE1835A88BE7C13
+data4 0x246310E7, 0x00000000
+data8 0x3FE23B71E2CC9E6A
+data4 0x236210E5, 0x00000000
+data8 0x3FE2EE628406CBCA
+data4 0x2462EAF5, 0x00000000
+data8 0x3FE39C391CD41719
+data4 0x24B73EF3, 0x00000000
+data8 0x3FE445065B795B55
+data4 0x24C11260, 0x00000000
+data8 0x3FE4E8DE5BB6EC04
+data4 0x242519EE, 0x00000000
+data8 0x3FE587D81F732FBA
+data4 0x24D4346C, 0x00000000
+data8 0x3FE6220D115D7B8D
+data4 0x24ED487B, 0x00000000
+data8 0x3FE6B798920B3D98
+data4 0x2495FF1E, 0x00000000
+data8 0x3FE748978FBA8E0F
+data4 0x223D9531, 0x00000000
+data8 0x3FE7D528289FA093
+data4 0x242B0411, 0x00000000
+data8 0x3FE85D69576CC2C5
+data4 0x2335B374, 0x00000000
+data8 0x3FE8E17AA99CC05D
+data4 0x24C27CFB, 0x00000000
+//
+//    Entries Tbl_hi  (double precision) Index = 0,1,...,15
+//    B = 2^(-2)*(1+Index/16+1/32)
+//    Entries Tbl_lo (single precision)
+//    Index = 0,1,...,15  B = 2^(-2)*(1+Index/16+1/32)
+//
+data8 0x3FD025FA510665B5
+data4 0x24263482, 0x00000000
+data8 0x3FD1151A362431C9
+data4 0x242C8DC9, 0x00000000
+data8 0x3FD2025567E47C95
+data4 0x245CF9BA, 0x00000000
+data8 0x3FD2ED987A823CFE
+data4 0x235C892C, 0x00000000
+data8 0x3FD3D6D129271134
+data4 0x2389BE52, 0x00000000
+data8 0x3FD4BDEE586890E6
+data4 0x24436471, 0x00000000
+data8 0x3FD5A2E0175E0F4E
+data4 0x2389DBD4, 0x00000000
+data8 0x3FD685979F5FA6FD
+data4 0x2476D43F, 0x00000000
+data8 0x3FD7660752817501
+data4 0x24711774, 0x00000000
+data8 0x3FD84422B8DF95D7
+data4 0x23EBB501, 0x00000000
+data8 0x3FD91FDE7CD0C662
+data4 0x23883A0C, 0x00000000
+data8 0x3FD9F93066168001
+data4 0x240DF63F, 0x00000000
+data8 0x3FDAD00F5422058B
+data4 0x23FE261A, 0x00000000
+data8 0x3FDBA473378624A5
+data4 0x23A8CD0E, 0x00000000
+data8 0x3FDC76550AAD71F8
+data4 0x2422D1D0, 0x00000000
+data8 0x3FDD45AEC9EC862B
+data4 0x2344A109, 0x00000000
+//
+//    Entries Tbl_hi  (double precision) Index = 0,1,...,15
+//    B = 2^(-3)*(1+Index/16+1/32)
+//    Entries Tbl_lo (single precision)
+//    Index = 0,1,...,15  B = 2^(-3)*(1+Index/16+1/32)
+//
+data8 0x3FC068D584212B3D
+data4 0x239874B6, 0x00000000
+data8 0x3FC1646541060850
+data4 0x2335E774, 0x00000000
+data8 0x3FC25F6E171A535C
+data4 0x233E36BE, 0x00000000
+data8 0x3FC359E8EDEB99A3
+data4 0x239680A3, 0x00000000
+data8 0x3FC453CEC6092A9E
+data4 0x230FB29E, 0x00000000
+data8 0x3FC54D18BA11570A
+data4 0x230C1418, 0x00000000
+data8 0x3FC645BFFFB3AA73
+data4 0x23F0564A, 0x00000000
+data8 0x3FC73DBDE8A7D201
+data4 0x23D4A5E1, 0x00000000
+data8 0x3FC8350BE398EBC7
+data4 0x23D4ADDA, 0x00000000
+data8 0x3FC92BA37D050271
+data4 0x23BCB085, 0x00000000
+data8 0x3FCA217E601081A5
+data4 0x23BC841D, 0x00000000
+data8 0x3FCB1696574D780B
+data4 0x23CF4A8E, 0x00000000
+data8 0x3FCC0AE54D768466
+data4 0x23BECC90, 0x00000000
+data8 0x3FCCFE654E1D5395
+data4 0x2323DCD2, 0x00000000
+data8 0x3FCDF110864C9D9D
+data4 0x23F53F3A, 0x00000000
+data8 0x3FCEE2E1451D980C
+data4 0x23CCB11F, 0x00000000
+//
+data8 0x400921FB54442D18, 0x3CA1A62633145C07 // PI two doubles
+data8 0x3FF921FB54442D18, 0x3C91A62633145C07 // PI_by_2 two dbles
+data8 0x3FE921FB54442D18, 0x3C81A62633145C07 // PI_by_4 two dbles
+data8 0x4002D97C7F3321D2, 0x3C9A79394C9E8A0A // 3PI_by_4 two dbles
+LOCAL_OBJECT_END(Constants_atan)
+
+
+.section .text
+GLOBAL_IEEE754_ENTRY(atanl)
+
+// Use common code with atan2l after setting x=1.0
+{ .mfi
+      alloc r32 = ar.pfs, 0, 17, 4, 0
+      fma.s1 Ysq = ArgY_orig, ArgY_orig, f0          // Form y*y
+      nop.i 999
+}
+{ .mfi
+      addl table_ptr1 = @ltoff(Constants_atan#), gp  // Address of table pointer
+      fma.s1 Xsq = f1, f1, f0                        // Form x*x
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ld8 table_ptr1 = [table_ptr1]                  // Get table pointer
+      fnorm.s1 ArgY = ArgY_orig
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fnorm.s1 ArgX = f1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      getf.exp sign_X = f1               // Get signexp of x
+      fmerge.s ArgX_abs = f0, f1         // Form |x|
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fnorm.s1 ArgX_orig = f1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      getf.exp sign_Y = ArgY_orig        // Get signexp of y
+      fmerge.s ArgY_abs = f0, ArgY_orig  // Form |y|
+      mov table_base = table_ptr1        // Save base pointer to tables
+}
+;;
+
+{ .mfi
+      ldfd P_hi = [table_ptr1],8         // Load double precision hi part of pi
+      fclass.m p8,p0 = ArgY_orig, 0x1e7  // Test y natval, nan, inf, zero
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfps P_lo, TWO_TO_NEG3 = [table_ptr1], 8 // Load P_lo and constant 2^-3
+      nop.f 999
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 M = f1, f1, f0              // Set M = 1.0
+      nop.i 999
+}
+;;
+
+//
+//     Check for everything - if false, then must be pseudo-zero
+//     or pseudo-nan (IA unsupporteds).
+//
+{ .mfb
+      nop.m 999
+      fclass.m p0,p12 = f1, 0x1FF        // Test x unsupported
+(p8)  br.cond.spnt ATANL_Y_SPECIAL       // Branch if y natval, nan, inf, zero
+}
+;;
+
+//     U = max(ArgX_abs,ArgY_abs)
+//     V = min(ArgX_abs,ArgY_abs)
+{ .mfi
+      nop.m 999
+      fcmp.ge.s1 p6,p7 = Xsq, Ysq        // Test for |x| >= |y| using squares
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+      fma.s1 V = ArgX_abs, f1, f0        // Set V assuming |x| < |y|
+      br.cond.sptk ATANL_COMMON          // Branch to common code
+}
+;;
+
+GLOBAL_IEEE754_END(atanl)
+libm_alias_ldouble_other (__atan, atan)
+
+GLOBAL_IEEE754_ENTRY(atan2l)
+
+{ .mfi
+      alloc r32 = ar.pfs, 0, 17, 4, 0
+      fma.s1 Ysq = ArgY_orig, ArgY_orig, f0          // Form y*y
+      nop.i 999
+}
+{ .mfi
+      addl table_ptr1 = @ltoff(Constants_atan#), gp  // Address of table pointer
+      fma.s1 Xsq = ArgX_orig, ArgX_orig, f0          // Form x*x
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ld8 table_ptr1 = [table_ptr1]                  // Get table pointer
+      fnorm.s1 ArgY = ArgY_orig
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fnorm.s1 ArgX = ArgX_orig
+      nop.i 999
+}
+;;
+
+{ .mfi
+      getf.exp sign_X = ArgX_orig        // Get signexp of x
+      fmerge.s ArgX_abs = f0, ArgX_orig  // Form |x|
+      nop.i 999
+}
+;;
+
+{ .mfi
+      getf.exp sign_Y = ArgY_orig        // Get signexp of y
+      fmerge.s ArgY_abs = f0, ArgY_orig  // Form |y|
+      mov table_base = table_ptr1        // Save base pointer to tables
+}
+;;
+
+{ .mfi
+      ldfd P_hi = [table_ptr1],8         // Load double precision hi part of pi
+      fclass.m p8,p0 = ArgY_orig, 0x1e7  // Test y natval, nan, inf, zero
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfps P_lo, TWO_TO_NEG3 = [table_ptr1], 8 // Load P_lo and constant 2^-3
+      fclass.m p9,p0 = ArgX_orig, 0x1e7  // Test x natval, nan, inf, zero
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 M = f1, f1, f0              // Set M = 1.0
+      nop.i 999
+}
+;;
+
+//
+//     Check for everything - if false, then must be pseudo-zero
+//     or pseudo-nan (IA unsupporteds).
+//
+{ .mfb
+      nop.m 999
+      fclass.m p0,p12 = ArgX_orig, 0x1FF // Test x unsupported
+(p8)  br.cond.spnt ATANL_Y_SPECIAL       // Branch if y natval, nan, inf, zero
+}
+;;
+
+//     U = max(ArgX_abs,ArgY_abs)
+//     V = min(ArgX_abs,ArgY_abs)
+{ .mfi
+      nop.m 999
+      fcmp.ge.s1 p6,p7 = Xsq, Ysq        // Test for |x| >= |y| using squares
+      nop.i 999
+}
+{ .mfb
+      nop.m 999
+      fma.s1 V = ArgX_abs, f1, f0        // Set V assuming |x| < |y|
+(p9)  br.cond.spnt ATANL_X_SPECIAL       // Branch if x natval, nan, inf, zero
+}
+;;
+
+// Now common code for atanl and atan2l
+ATANL_COMMON:
+{ .mfi
+      nop.m 999
+      fclass.m p0,p13 = ArgY_orig, 0x1FF // Test y unsupported
+      shr sign_X = sign_X, 17            // Get sign bit of x
+}
+{ .mfi
+      nop.m 999
+      fma.s1 U = ArgY_abs, f1, f0        // Set U assuming |x| < |y|
+      adds table_ptr1 = 176, table_ptr1  // Point to Q4
+}
+;;
+
+{ .mfi
+(p6)  add swap = r0, r0                  // Set swap=0 if |x| >= |y|
+(p6)  frcpa.s1 E, p0 = ArgY_abs, ArgX_abs // Compute E if |x| >= |y|
+      shr sign_Y = sign_Y, 17            // Get sign bit of y
+}
+{ .mfb
+      nop.m 999
+(p6)  fma.s1 V = ArgY_abs, f1, f0        // Set V if |x| >= |y|
+(p12) br.cond.spnt ATANL_UNSUPPORTED     // Branch if x unsupported
+}
+;;
+
+// Set p8 if y >=0
+// Set p9 if y < 0
+// Set p10 if |x| >= |y| and x >=0
+// Set p11 if |x| >= |y| and x < 0
+{ .mfi
+      cmp.eq p8, p9 = 0, sign_Y          // Test for y >= 0
+(p7)  frcpa.s1 E, p0 = ArgX_abs, ArgY_abs // Compute E if |x| < |y|
+(p7)  add swap = 1, r0                   // Set swap=1 if |x| < |y|
+}
+{ .mfb
+(p6)  cmp.eq.unc p10, p11 = 0, sign_X    // If |x| >= |y|, test for x >= 0
+(p6)  fma.s1 U = ArgX_abs, f1, f0        // Set U if |x| >= |y|
+(p13) br.cond.spnt ATANL_UNSUPPORTED     // Branch if y unsupported
+}
+;;
+
+//
+//     if p8, s_Y = 1.0
+//     if p9, s_Y = -1.0
+//
+.pred.rel "mutex",p8,p9
+{ .mfi
+      nop.m 999
+(p8)  fadd.s1 s_Y = f0, f1               // If y >= 0 set s_Y = 1.0
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p9)  fsub.s1 s_Y = f0, f1               // If y < 0 set s_Y = -1.0
+      nop.i 999
+}
+;;
+
+.pred.rel "mutex",p10,p11
+{ .mfi
+      nop.m 999
+(p10) fsub.s1 M = M, f1                  // If |x| >= |y| and x >=0, set M=0
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p11) fadd.s1 M = M, f1                  // If |x| >= |y| and x < 0, set M=2.0
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fcmp.eq.s0 p0, p9 = ArgX_orig, ArgY_orig // Dummy to set denormal flag
+      nop.i 999
+}
+// *************************************************
+// ********************* STEP2 *********************
+// *************************************************
+//
+//     Q = E * V
+//
+{ .mfi
+      nop.m 999
+      fmpy.s1 Q = E, V
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fnma.s1 E_hold = E, U, f1           // E_hold = 1.0 - E*U (1) if POLY path
+      nop.i 999
+}
+;;
+
+// Create a single precision representation of the signexp of Q with the
+// 4 most significant bits of the significand followed by a 1 and then 18 0's
+{ .mfi
+      nop.m 999
+      fmpy.s1 P_hi = M, P_hi
+      dep.z special = 0x1, 18, 1           // Form 0x0000000000040000
+}
+{ .mfi
+      nop.m 999
+      fmpy.s1 P_lo = M, P_lo
+      add table_ptr2 = 32, table_ptr1
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 A_temp = Q, f1, f0            // Set A_temp if POLY path
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 E = E, E_hold, E              // E = E + E*E_hold (1) if POLY path
+      nop.i 999
+}
+;;
+
+//
+//     Is Q < 2**(-3)?
+//     swap = xor(swap,sign_X)
+//
+{ .mfi
+      nop.m 999
+      fcmp.lt.s1 p9, p0 = Q, TWO_TO_NEG3    // Test Q < 2^-3
+      xor swap = sign_X, swap
+}
+;;
+
+//     P_hi = s_Y * P_hi
+{ .mmf
+      getf.exp exponent_Q =  Q              // Get signexp of Q
+      cmp.eq.unc p7, p6 = 0x00000, swap
+      fmpy.s1 P_hi = s_Y, P_hi
+}
+;;
+
+//
+//     if (PR_1) sigma = -1.0
+//     if (PR_2) sigma =  1.0
+//
+{ .mfi
+      getf.sig significand_Q = Q            // Get significand of Q
+(p6)  fsub.s1 sigma = f0, f1
+      nop.i 999
+}
+{ .mfb
+(p9)  add table_ptr1 = 128, table_base      // Point to P8 if POLY path
+(p7)  fadd.s1 sigma = f0, f1
+(p9)  br.cond.spnt ATANL_POLY               // Branch to POLY if 0 < Q < 2^-3
+}
+;;
+
+//
+// *************************************************
+// ******************** STEP3 **********************
+// *************************************************
+//
+//     lookup = b_1 b_2 b_3 B_4
+//
+{ .mmi
+      nop.m 999
+      nop.m 999
+      andcm k = 0x0003, exponent_Q  // k=0,1,2,3 for exp_Q=0,-1,-2,-3
+}
+;;
+
+//
+//  Generate sign_exp_Q b_1 b_2 b_3 b_4 1 0 0 0 ... 0  in single precision
+//  representation.  Note sign of Q is always 0.
+//
+{ .mfi
+      cmp.eq p8, p9 = 0x0000, k             // Test k=0
+      nop.f 999
+      extr.u lookup = significand_Q, 59, 4  // Extract b_1 b_2 b_3 b_4 for index
+}
+{ .mfi
+      sub sp_exp_Q = 0x7f, k                // Form single prec biased exp of Q
+      nop.f 999
+      sub k = k, r0, 1                      // Decrement k
+}
+;;
+
+//     Form pointer to B index table
+{ .mfi
+      ldfe Q_4 = [table_ptr1], -16          // Load Q_4
+      nop.f 999
+(p9)  shl k = k, 8                          // k = 0, 256, or 512
+}
+{ .mfi
+(p9)  shladd table_ptr2 = lookup, 4, table_ptr2
+      nop.f 999
+      shladd sp_exp_4sig_Q = sp_exp_Q, 4, lookup // Shift and add in 4 high bits
+}
+;;
+
+{ .mmi
+(p8)  add table_ptr2 = -16, table_ptr2      // Pointer if original k was 0
+(p9)  add table_ptr2 = k, table_ptr2        // Pointer if k was 1, 2, 3
+      dep special = sp_exp_4sig_Q, special, 19, 13 // Form z_hi as single prec
+}
+;;
+
+//     z_hi = s exp 1.b_1 b_2 b_3 b_4 1 0 0 0 ... 0
+{ .mmi
+      ldfd Tbl_hi = [table_ptr2], 8         // Load Tbl_hi from index table
+;;
+      setf.s z_hi = special                 // Form z_hi
+      nop.i 999
+}
+{ .mmi
+      ldfs Tbl_lo = [table_ptr2], 8         // Load Tbl_lo from index table
+;;
+      ldfe Q_3 = [table_ptr1], -16          // Load Q_3
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ldfe Q_2 = [table_ptr1], -16          // Load Q_2
+      nop.m 999
+      nop.i 999
+}
+;;
+
+{ .mmf
+      ldfe Q_1 = [table_ptr1], -16          // Load Q_1
+      nop.m 999
+      nop.f 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 U_prime_hi = V, z_hi, U        // U_prime_hi = U + V * z_hi
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fnma.s1 V_prime = U, z_hi, V          // V_prime =  V - U * z_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      mov A_hi = Tbl_hi                     // Start with A_hi = Tbl_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fsub.s1 U_hold = U, U_prime_hi        // U_hold = U - U_prime_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      frcpa.s1 C_hi, p0 = f1, U_prime_hi    // C_hi = frcpa(1,U_prime_hi)
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 A_hi = s_Y, A_hi              // A_hi = s_Y * A_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 U_prime_lo = z_hi, V, U_hold   // U_prime_lo =  U_hold + V * z_hi
+      nop.i 999
+}
+;;
+
+//     C_hi_hold = 1 - C_hi * U_prime_hi (1)
+{ .mfi
+      nop.m 999
+      fnma.s1 C_hi_hold = C_hi, U_prime_hi, f1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 Res_hi = sigma, A_hi, P_hi   // Res_hi = P_hi + sigma * A_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 C_hi = C_hi_hold, C_hi, C_hi // C_hi = C_hi + C_hi * C_hi_hold (1)
+      nop.i 999
+}
+;;
+
+//     C_hi_hold = 1 - C_hi * U_prime_hi (2)
+{ .mfi
+      nop.m 999
+      fnma.s1 C_hi_hold = C_hi, U_prime_hi, f1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 C_hi = C_hi_hold, C_hi, C_hi // C_hi = C_hi + C_hi * C_hi_hold (2)
+      nop.i 999
+}
+;;
+
+//     C_hi_hold = 1 - C_hi * U_prime_hi (3)
+{ .mfi
+      nop.m 999
+      fnma.s1 C_hi_hold = C_hi, U_prime_hi, f1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 C_hi = C_hi_hold, C_hi, C_hi // C_hi = C_hi + C_hi * C_hi_hold (3)
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 w_hi = V_prime, C_hi           // w_hi = V_prime * C_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 wsq = w_hi, w_hi               // wsq = w_hi * w_hi
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fnma.s1 w_lo = w_hi, U_prime_hi, V_prime // w_lo = V_prime-w_hi*U_prime_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 poly =  wsq, Q_4, Q_3           // poly = Q_3 + wsq * Q_4
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fnma.s1 w_lo = w_hi, U_prime_lo, w_lo  // w_lo = w_lo - w_hi * U_prime_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 poly = wsq, poly, Q_2           // poly = Q_2 + wsq * poly
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fmpy.s1 w_lo = C_hi, w_lo              // w_lo =  = w_lo * C_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 poly = wsq, poly, Q_1           // poly = Q_1 + wsq * poly
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s1 A_lo = Tbl_lo, w_lo            // A_lo = Tbl_lo + w_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s0 Q_1 =  Q_1, Q_1                // Dummy operation to raise inexact
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 poly = wsq, poly               // poly = wsq * poly
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 poly = w_hi, poly              // poly = w_hi * poly
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fadd.s1 A_lo = A_lo, poly              // A_lo = A_lo + poly
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fadd.s1 A_lo = A_lo, w_hi              // A_lo = A_lo + w_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 Res_lo = sigma, A_lo, P_lo      // Res_lo = P_lo + sigma * A_lo
+      nop.i 999
+}
+;;
+
+//
+//     Result  =  Res_hi + Res_lo * s_Y  (User Supplied Rounding Mode)
+//
+{ .mfb
+      nop.m 999
+      fma.s0 Result = Res_lo, s_Y, Res_hi
+      br.ret.sptk   b0                        // Exit table path 2^-3 <= V/U < 1
+}
+;;
+
+
+ATANL_POLY:
+// Here if 0 < V/U < 2^-3
+//
+// ***********************************************
+// ******************** STEP4 ********************
+// ***********************************************
+
+//
+//     Following:
+//     Iterate 3 times E = E + E*(1.0 - E*U)
+//     Also load P_8, P_7, P_6, P_5, P_4
+//
+{ .mfi
+      ldfe P_8 = [table_ptr1], -16            // Load P_8
+      fnma.s1 z_lo = A_temp, U, V             // z_lo = V - A_temp * U
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fnma.s1 E_hold = E, U, f1               // E_hold = 1.0 - E*U (2)
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ldfe P_7 = [table_ptr1], -16            // Load P_7
+;;
+      ldfe P_6 = [table_ptr1], -16            // Load P_6
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe P_5 = [table_ptr1], -16            // Load P_5
+      fma.s1 E = E, E_hold, E                 // E = E + E_hold*E (2)
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ldfe P_4 = [table_ptr1], -16            // Load P_4
+;;
+      ldfe P_3 = [table_ptr1], -16            // Load P_3
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe P_2 = [table_ptr1], -16            // Load P_2
+      fnma.s1 E_hold = E, U, f1               // E_hold = 1.0 - E*U (3)
+      nop.i 999
+}
+{ .mlx
+      nop.m 999
+      movl         int_temp = 0x24005         // Signexp for small neg number
+}
+;;
+
+{ .mmf
+      ldfe P_1 = [table_ptr1], -16            // Load P_1
+      setf.exp     tmp_small = int_temp       // Form small neg number
+      fma.s1 E = E, E_hold, E                 // E = E + E_hold*E (3)
+}
+;;
+
+//
+//
+// At this point E approximates 1/U to roughly working precision
+// Z = V*E approximates V/U
+//
+{ .mfi
+      nop.m 999
+      fmpy.s1 Z = V, E                         // Z = V * E
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fmpy.s1 z_lo = z_lo, E                   // z_lo = z_lo * E
+      nop.i 999
+}
+;;
+
+//
+//     Now what we want to do is
+//     poly1 = P_4 + zsq*(P_5 + zsq*(P_6 + zsq*(P_7 + zsq*P_8)))
+//     poly2 = zsq*(P_1 + zsq*(P_2 + zsq*P_3))
+//
+//
+//     Fixup added to force inexact later -
+//     A_hi = A_temp + z_lo
+//     z_lo = (A_temp - A_hi) + z_lo
+//
+{ .mfi
+      nop.m 999
+      fmpy.s1 zsq = Z, Z                        // zsq = Z * Z
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s1 A_hi = A_temp, z_lo               // A_hi = A_temp + z_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 poly1 = zsq, P_8, P_7              // poly1 = P_7 + zsq * P_8
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 poly2 = zsq, P_3, P_2              // poly2 = P_2 + zsq * P_3
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 z4 = zsq, zsq                     // z4 = zsq * zsq
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fsub.s1 A_temp = A_temp, A_hi             // A_temp = A_temp - A_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmerge.s     tmp = A_hi, A_hi             // Copy tmp = A_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 poly1 = zsq, poly1, P_6            // poly1 = P_6 + zsq * poly1
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 poly2 = zsq, poly2, P_1            // poly2 = P_2 + zsq * poly2
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmpy.s1 z8 = z4, z4                       // z8 = z4 * z4
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fadd.s1 z_lo = A_temp, z_lo               // z_lo = (A_temp - A_hi) + z_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 poly1 = zsq, poly1, P_5            // poly1 = P_5 + zsq * poly1
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fmpy.s1 poly2 = poly2, zsq                // poly2 = zsq * poly2
+      nop.i 999
+}
+;;
+
+//     Create small GR double in case need to raise underflow
+{ .mfi
+      nop.m 999
+      fma.s1 poly1 = zsq, poly1, P_4            // poly1 = P_4 + zsq * poly1
+      dep GR_temp = -1,r0,0,53
+}
+;;
+
+//     Create small double in case need to raise underflow
+{ .mfi
+      setf.d FR_temp = GR_temp
+      fma.s1 poly = z8, poly1, poly2            // poly = poly2 + z8 * poly1
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 A_lo = Z, poly, z_lo               // A_lo = z_lo + Z * poly
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fadd.s1      A_hi = tmp, A_lo             // A_hi = tmp + A_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fsub.s1      tmp = tmp, A_hi              // tmp = tmp - A_hi
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fmpy.s1 A_hi = s_Y, A_hi                  // A_hi = s_Y * A_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fadd.s1      A_lo = tmp, A_lo             // A_lo = tmp + A_lo
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 Res_hi = sigma, A_hi, P_hi         // Res_hi = P_hi + sigma * A_hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fsub.s1 tmp =  P_hi, Res_hi               // tmp = P_hi - Res_hi
+      nop.i 999
+}
+;;
+
+//
+//     Test if A_lo is zero
+//
+{ .mfi
+      nop.m 999
+      fclass.m p6,p0 = A_lo, 0x007              // Test A_lo = 0
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p6)  mov          A_lo = tmp_small             // If A_lo zero, make very small
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 tmp = A_hi, sigma, tmp             // tmp = sigma * A_hi  + tmp
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 sigma =  A_lo, sigma, P_lo         // sigma = A_lo * sigma  + P_lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fma.s1 Res_lo = s_Y, sigma, tmp           // Res_lo = s_Y * sigma + tmp
+      nop.i 999
+}
+;;
+
+//
+//     Test if Res_lo is denormal
+//
+{ .mfi
+      nop.m 999
+      fclass.m p14, p15 = Res_lo, 0x0b
+      nop.i 999
+}
+;;
+
+//
+//     Compute Result = Res_lo + Res_hi.  Use s3 if Res_lo is denormal.
+//
+{ .mfi
+      nop.m 999
+(p14) fadd.s3 Result = Res_lo, Res_hi     // Result for Res_lo denormal
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p15) fadd.s0 Result = Res_lo, Res_hi     // Result for Res_lo normal
+      nop.i 999
+}
+;;
+
+//
+//     If Res_lo is denormal test if Result equals zero
+//
+{ .mfi
+      nop.m 999
+(p14) fclass.m.unc p14, p0 = Result, 0x07
+      nop.i 999
+}
+;;
+
+//
+//     If Res_lo is denormal and Result equals zero, raise inexact, underflow
+//     by squaring small double
+//
+{ .mfb
+      nop.m 999
+(p14) fmpy.d.s0 FR_temp = FR_temp, FR_temp
+      br.ret.sptk   b0                     // Exit POLY path, 0 < Q < 2^-3
+}
+;;
+
+
+ATANL_UNSUPPORTED:
+{ .mfb
+      nop.m 999
+      fmpy.s0 Result = ArgX,ArgY
+      br.ret.sptk   b0
+}
+;;
+
+// Here if y natval, nan, inf, zero
+ATANL_Y_SPECIAL:
+// Here if x natval, nan, inf, zero
+ATANL_X_SPECIAL:
+{ .mfi
+      nop.m 999
+      fclass.m p13,p12 = ArgY_orig, 0x0c3  // Test y nan
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m p15,p14 = ArgY_orig, 0x103  // Test y natval
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p12) fclass.m p13,p0 = ArgX_orig, 0x0c3  // Test x nan
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p14) fclass.m p15,p0 = ArgX_orig, 0x103  // Test x natval
+      nop.i 999
+}
+;;
+
+{ .mfb
+      nop.m 999
+(p13) fmpy.s0 Result = ArgX_orig, ArgY_orig // Result nan if x or y nan
+(p13) br.ret.spnt b0                      // Exit if x or y nan
+}
+;;
+
+{ .mfb
+      nop.m 999
+(p15) fmpy.s0 Result = ArgX_orig, ArgY_orig // Result natval if x or y natval
+(p15) br.ret.spnt b0                      // Exit if x or y natval
+}
+;;
+
+
+// Here if x or y inf or zero
+ATANL_SPECIAL_HANDLING:
+{ .mfi
+      nop.m 999
+      fclass.m p6, p7 = ArgY_orig, 0x007        // Test y zero
+      mov special = 992                         // Offset to table
+}
+;;
+
+{ .mfb
+      add table_ptr1 = table_base, special      // Point to 3pi/4
+      fcmp.eq.s0 p0, p9 = ArgX_orig, ArgY_orig  // Dummy to set denormal flag
+(p7)  br.cond.spnt ATANL_ArgY_Not_ZERO          // Branch if y not zero
+}
+;;
+
+// Here if y zero
+{ .mmf
+      ldfd  Result = [table_ptr1], 8            // Get pi high
+      nop.m 999
+      fclass.m p14, p0 = ArgX, 0x035            // Test for x>=+0
+}
+;;
+
+{ .mmf
+      nop.m 999
+      ldfd  Result_lo = [table_ptr1], -8        // Get pi lo
+      fclass.m p15, p0 = ArgX, 0x036            // Test for x<=-0
+}
+;;
+
+//
+//     Return sign_Y * 0 when  ArgX > +0
+//
+{ .mfi
+      nop.m 999
+(p14) fmerge.s Result = ArgY, f0               // If x>=+0, y=0, hi sgn(y)*0
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m p13, p0 = ArgX, 0x007           // Test for x=0
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p14) fmerge.s Result_lo = ArgY, f0            // If x>=+0, y=0, lo sgn(y)*0
+      nop.i 999
+}
+;;
+
+{ .mfi
+(p13) mov GR_Parameter_TAG = 36                // Error tag for x=0, y=0
+      nop.f 999
+      nop.i 999
+}
+;;
+
+//
+//     Return sign_Y * pi when  ArgX < -0
+//
+{ .mfi
+      nop.m 999
+(p15) fmerge.s Result = ArgY, Result           // If x<0, y=0, hi=sgn(y)*pi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p15) fmerge.s Result_lo = ArgY, Result_lo     // If x<0, y=0, lo=sgn(y)*pi
+      nop.i 999
+}
+;;
+
+//
+//     Call error support function for atan(0,0)
+//
+{ .mfb
+      nop.m 999
+      fadd.s0 Result = Result, Result_lo
+(p13) br.cond.spnt __libm_error_region         // Branch if atan(0,0)
+}
+;;
+
+{ .mib
+      nop.m 999
+      nop.i 999
+      br.ret.sptk   b0                         // Exit for y=0, x not 0
+}
+;;
+
+// Here if y not zero
+ATANL_ArgY_Not_ZERO:
+{ .mfi
+      nop.m 999
+      fclass.m p0, p10 = ArgY, 0x023           // Test y inf
+      nop.i 999
+}
+;;
+
+{ .mfb
+      nop.m 999
+      fclass.m p6, p0 = ArgX, 0x017            // Test for 0 <= |x| < inf
+(p10) br.cond.spnt  ATANL_ArgY_Not_INF         // Branch if 0 < |y| < inf
+}
+;;
+
+// Here if y=inf
+//
+//     Return +PI/2 when ArgY = +Inf and ArgX = +/-0 or normal
+//     Return -PI/2 when ArgY = -Inf and ArgX = +/-0 or normal
+//     Return +PI/4 when ArgY = +Inf and ArgX = +Inf
+//     Return -PI/4 when ArgY = -Inf and ArgX = +Inf
+//     Return +3PI/4 when ArgY = +Inf and ArgX = -Inf
+//     Return -3PI/4 when ArgY = -Inf and ArgX = -Inf
+//
+{ .mfi
+      nop.m 999
+      fclass.m p7, p0 = ArgX, 0x021            // Test for x=+inf
+      nop.i 999
+}
+;;
+
+{ .mfi
+(p6)  add table_ptr1 =  16, table_ptr1         // Point to pi/2, if x finite
+      fclass.m p8, p0 = ArgX, 0x022            // Test for x=-inf
+      nop.i 999
+}
+;;
+
+{ .mmi
+(p7)  add table_ptr1 =  32, table_ptr1         // Point to pi/4 if x=+inf
+;;
+(p8)  add table_ptr1 =  48, table_ptr1         // Point to 3pi/4 if x=-inf
+
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ldfd Result = [table_ptr1], 8            // Load pi/2, pi/4, or 3pi/4 hi
+;;
+      ldfd Result_lo = [table_ptr1], -8        // Load pi/2, pi/4, or 3pi/4 lo
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmerge.s Result = ArgY, Result           // Merge sgn(y) in hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fmerge.s Result_lo = ArgY, Result_lo     // Merge sgn(y) in lo
+      nop.i 999
+}
+;;
+
+{ .mfb
+      nop.m 999
+      fadd.s0 Result = Result, Result_lo       // Compute complete result
+      br.ret.sptk   b0                         // Exit for y=inf
+}
+;;
+
+// Here if y not INF, and x=0 or INF
+ATANL_ArgY_Not_INF:
+//
+//     Return +PI/2 when ArgY NOT Inf, ArgY > 0 and ArgX = +/-0
+//     Return -PI/2 when ArgY NOT Inf, ArgY < 0 and ArgX = +/-0
+//     Return +0    when ArgY NOT Inf, ArgY > 0 and ArgX = +Inf
+//     Return -0    when ArgY NOT Inf, ArgY > 0 and ArgX = +Inf
+//     Return +PI   when ArgY NOT Inf, ArgY > 0 and ArgX = -Inf
+//     Return -PI   when ArgY NOT Inf, ArgY > 0 and ArgX = -Inf
+//
+{ .mfi
+      nop.m 999
+      fclass.m p7, p9 = ArgX, 0x021            // Test for x=+inf
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fclass.m p6, p0 = ArgX, 0x007            // Test for x=0
+      nop.i 999
+}
+;;
+
+{ .mfi
+(p6)  add table_ptr1 = 16, table_ptr1          // Point to pi/2
+      fclass.m p8, p0 = ArgX, 0x022            // Test for x=-inf
+      nop.i 999
+}
+;;
+
+.pred.rel "mutex",p7,p9
+{ .mfi
+(p9)  ldfd Result = [table_ptr1], 8           // Load pi or pi/2 hi
+(p7)  fmerge.s Result = ArgY, f0              // If y not inf, x=+inf, sgn(y)*0
+      nop.i 999
+}
+;;
+
+{ .mfi
+(p9)  ldfd Result_lo = [table_ptr1], -8       // Load pi or pi/2 lo
+(p7)  fnorm.s0 Result = Result                // If y not inf, x=+inf normalize
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fmerge.s Result = ArgY, Result          // Merge sgn(y) in hi
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p9)  fmerge.s Result_lo = ArgY, Result_lo    // Merge sgn(y) in lo
+      nop.i 999
+}
+;;
+
+{ .mfb
+      nop.m 999
+(p9)  fadd.s0 Result = Result, Result_lo      // Compute complete result
+      br.ret.spnt   b0                        // Exit for y not inf, x=0,inf
+}
+;;
+
+GLOBAL_IEEE754_END(atan2l)
+libm_alias_ldouble_other (__atan2, atan2)
+
+LOCAL_LIBM_ENTRY(__libm_error_region)
+.prologue
+{ .mfi
+        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
+        nop.f 0
+.save   ar.pfs,GR_SAVE_PFS
+        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
+}
+{ .mfi
+.fframe 64
+        add sp=-64,sp                           // Create new stack
+        nop.f 0
+        mov GR_SAVE_GP=gp                       // Save gp
+};;
+{ .mmi
+        stfe [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
+        add GR_Parameter_X = 16,sp              // Parameter 1 address
+.save   b0, GR_SAVE_B0
+        mov GR_SAVE_B0=b0                       // Save b0
+};;
+.body
+{ .mib
+        stfe [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
+        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
+        nop.b 0                                 // Parameter 3 address
+}
+{ .mib
+        stfe [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
+        add   GR_Parameter_Y = -16,GR_Parameter_Y
+        br.call.sptk b0=__libm_error_support#  // Call error handling function
+};;
+{ .mmi
+        nop.m 0
+        nop.m 0
+        add   GR_Parameter_RESULT = 48,sp
+};;
+{ .mmi
+        ldfe  f8 = [GR_Parameter_RESULT]       // Get return result off stack
+.restore sp
+        add   sp = 64,sp                       // Restore stack pointer
+        mov   b0 = GR_SAVE_B0                  // Restore return address
+};;
+{ .mib
+        mov   gp = GR_SAVE_GP                  // Restore gp
+        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
+        br.ret.sptk     b0                     // Return
+};;
+
+LOCAL_LIBM_END(__libm_error_region#)
+.type   __libm_error_support#,@function
+.global __libm_error_support#
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_cbrt.S
@@ -0,0 +1,767 @@
+.file "cbrt.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 05/19/00 New version (modified algorithm)
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 01/28/03 Updated polynomial coefficients (changed to Remez coefficients),
+//          to slightly improve accuracy
+//
+// API
+//==============================================================
+// double cbrt(double)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// Let y= frcpa(a), where a is the argument
+//
+// cbrt(a)= cbrt(a*y)/cbrt(y) = cbrt(1 - (1-a*y)) * (1/cbrt(y))
+//
+// For all values of y, the 3 possible significands of 1/cbrt(y)
+// are stored in a table (T0) to 64 bits of accuracy. (There are
+// 3 possible significands because the exponent of y modulo 3
+// can be 0, 1, or 2.)
+//
+//
+// * cbrt(1 - (1-a*y)) is approximated by a degree-5 polynomial ~
+//
+// ~ 1 - (1/3)*r - (1/9)*r^2 - (5/81)*r^3 - (10/243)*r^4 - (22/729)*r^5
+//
+// in r = 1-a*y.
+//
+//
+// The table values are stored for three exponent values and are
+// then multiplied by e/3 where e is the exponent of the input number.
+// This computation is carried out in parallel with the polynomial
+// evaluation:
+//
+// T= 2^(e/3) * T0
+
+
+
+
+
+//===============
+// input= x
+// C= frcpa(x)
+// r= 1 - C * x
+//
+// Special values
+//==============================================================
+
+
+
+// Registers used
+//==============================================================
+// f6-f15
+// GR_GP, r23-r26, r28-r30
+// p6, p7, p8, p12
+
+       FR_R        = f6
+       FR_COEFF1   = f7
+       FR_COEFF2   = f9
+       FR_COEFF3   = f10
+       FR_COEFF4   = f11
+       FR_COEFF5   = f12
+       FR_R2       = f13
+       FR_ARG      = f14
+       FR_P23      = f15
+       FR_P25      = f32
+       FR_P15      = f33
+       FR_P1       = f34
+       FR_P45      = f35
+       FR_2EXP     = f36
+       FR_TMP63    = f37
+
+       GR_GP       = r2
+       GR_ADDR     = r2
+       GR_CONST1   = r3
+       GR_I1       = r8
+       GR_EXP      = r9
+       GR_ADDR2    = r10
+       GR_IT1      = r11
+       GR_TMP2     = r11
+       GR_EXPON    = r15
+       GR_TMP1     = r16
+       GR_TMP6     = r16
+       GR_ITB1     = r17
+       GR_TMP3     = r18
+       GR_TMP4     = r19
+       GR_TMP63    = r19
+       GR_TMP5     = r20
+       GR_EXP_BY_3 = r20
+       GR_CONST4   = r21
+       GR_TMP6     = r22
+       GR_INDEX    = r23
+       GR_EBIAS    = r24
+       GR_SIGNIF   = r25
+       GR_SIGNIF2  = r25
+       GR_TEST     = r25
+       GR_ARGEXP   = r26
+       GR_CONST2   = r27
+       GR_SIGN     = r28
+       GR_REM      = r29
+       GR_CONST3   = r30
+       GR_SEXP     = r31
+
+
+
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+
+       data8 0xaaaaaaaaaaaaaab4, 0x0000bffd // ~ 1/3
+       data8 0xbfbc71c71c718e45, 0xbfaf9add3c0bbb43
+       data8 0xbfa511edb93dc98d, 0xbf9ee71c45f0dfbc
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+//   For every entry B in the frcpa table, this table contains
+// the significands of cbrt(1/B), cbrt(2/B), cbrt(4/B).
+// The index to this table is the same as the frcpa index.
+
+LOCAL_OBJECT_START(T_table)
+
+
+       data8 0x80155c748c374836, 0xa160019ed37fb4ae
+       data8 0xcb51ddcb9e93095e, 0x8040404b0879f7f9
+       data8 0xa1960b5966da4608, 0xcb95f333968ad59b
+       data8 0x806b5dce4b405c10, 0xa1cc5dbe6dc2aab4
+       data8 0xcbda64292d3ffd97, 0x8096b586974669b1
+       data8 0xa202f97995b69c0d, 0xcc1f3184af961596
+       data8 0x80bcd273d952a028, 0xa232fe6eb0c0577d
+       data8 0xcc5bb1ac954d33e2, 0x80e898c52813f2f3
+       data8 0xa26a2582012f6e17, 0xcca12e9831fc6402
+       data8 0x81149add67c2d208, 0xa2a197e5d10465cb
+       data8 0xcce70a67b64f24ad, 0x813b4e2c856b6e9a
+       data8 0xa2d25a532efefbc8, 0xcd24794726477ea5
+       data8 0x8167c1dde03de7aa, 0xa30a5bd6e49e4ab8
+       data8 0xcd6b096a0b70ee87, 0x818ed973b811135e
+       data8 0xa33b9c9b59879e24, 0xcda9177738b15a90
+       data8 0x81bbc0c33e13ec98, 0xa3742fca6a3c1f21
+       data8 0xcdf05f2247dffab9, 0x81e33e69fbe7504a
+       data8 0xa3a5f1273887bf22, 0xce2f0f347f96f906
+       data8 0x820aec524e3c23e9, 0xa3d7ef508ff11574
+       data8 0xce6e0be0cd551a61, 0x823880f78e70b805
+       data8 0xa4115ce30548bc15, 0xceb666b2c347d1de
+       data8 0x826097a62a8e5200, 0xa443df0e53df577a
+       data8 0xcef609b0cb874f00, 0x8288dfe00e9b5eaf
+       data8 0xa4769fa5913c0ec3, 0xcf35fb5447e5c765
+       data8 0x82b15a10c5371624, 0xa4a99f303bc7def5
+       data8 0xcf763c47ee869f00, 0x82da06a527b18937
+       data8 0xa4dcde37779adf4b, 0xcfb6cd3888d71785
+       data8 0x8302e60b635ab394, 0xa5105d46152c938a
+       data8 0xcff7aed4fbfbb447, 0x832bf8b2feec2f0e
+       data8 0xa5441ce89825cb8d, 0xd038e1ce5167e3c6
+       data8 0x83553f0ce00e276b, 0xa5781dad3e54d899
+       data8 0xd07a66d7bfa0ebba, 0x837eb98b50f8322a
+       data8 0xa5ac602406c4e68c, 0xd0bc3ea6b32d1b21
+       data8 0x83a270f44c84f699, 0xa5d9601d95c2c0bc
+       data8 0xd0f4f0e8f36c1bf8, 0x83cc4d7cfcfac5ca
+       data8 0xa60e1e1a2de14745, 0xd1376458e34b037e
+       data8 0x83f65f78a8872b4c, 0xa6431f6e3fbd9658
+       data8 0xd17a2ca133f78572, 0x8420a75f2f7b53c8
+       data8 0xa67864b0d432fda4, 0xd1bd4a80301c5715
+       data8 0x844510461ff14209, 0xa6a6444aa0243c0b
+       data8 0xd1f71682b2fa4575, 0x846fbd91b930bed2
+       data8 0xa6dc094d10f25792, 0xd23ad555f773f059
+       data8 0x84947e18234f3294, 0xa70a574cc02bba69
+       data8 0xd2752c7039a5bf73, 0x84bf92755825045a
+       data8 0xa7409e2af9549084, 0xd2b98ee008c06b59
+       data8 0x84e4ac0ee112ba51, 0xa76f5c64ca2cf13b
+       data8 0xd2f4735ffd700280, 0x8509ef44b86f20be
+       data8 0xa79e4f0babab5dc0, 0xd32f99ed6d9ac0e1
+       data8 0x85359d5d91768427, 0xa7d5579ae5164b85
+       data8 0xd374f0666c75d51c, 0x855b3bd5b7384357
+       data8 0xa804bd3c6fe61cc8, 0xd3b0a7d13618e4a1
+       data8 0x858104f0c415f79a, 0xa8345895e5250a5a
+       data8 0xd3eca2ea53bcec0c, 0x85a6f90390d29864
+       data8 0xa8642a122b44ef0b, 0xd428e23874f13a17
+       data8 0x85d3772fcd56a1dd, 0xa89c38ca18f6108b
+       data8 0xd46f82fe293bc6d3, 0x85f9c982fcc002f3
+       data8 0xa8cc81063b6e87ca, 0xd4ac57e9b7186420
+       data8 0x862047e0e7ea554b, 0xa8fd00bfa409285e
+       data8 0xd4e972becb04e8b8, 0x8646f2a26f7f5852
+       data8 0xa92db8664d5516da, 0xd526d40a7a9b43a3
+       data8 0x866dca21754096b5, 0xa95ea86b75cc2c20
+       data8 0xd5647c5b73917370, 0x8694ceb8dfd17a37
+       data8 0xa98fd141a4992deb, 0xd5a26c4201bd6d13
+       data8 0x86bc00c49e9307e8, 0xa9c1335cae7446ba
+       data8 0xd5e0a45015350a7e, 0x86dccd74fce79610
+       data8 0xa9ea8686f556f645, 0xd614b539c6194104
+       data8 0x870453c845acf90f, 0xaa1c52d17906bb19
+       data8 0xd6537310e224283f, 0x872c089a1e90342c
+       data8 0xaa4e59b046dab887, 0xd6927ab62244c917
+       data8 0x8753ec4a92d16c5e, 0xaa809b9c60d1890b
+       data8 0xd6d1ccc1fc4ef4b7, 0x877bff3aca19f6b4
+       data8 0xaab319102f3f9b33, 0xd71169cea98fdded
+       data8 0x879d88b6fe1c324c, 0xaadd5a18c1e21274
+       data8 0xd746a66a5bc9f6d9, 0x87c5f346dbf98c3a
+       data8 0xab1045f2ac31bdf5, 0xd786ce8f0fae5317
+       data8 0x87e7c653efacef2c, 0xab3ae3ab2df7231e
+       data8 0xd7bc7ff214c4e75a, 0x881089d4e73ffefc
+       data8 0xab6e3f945d1e96fc, 0xd7fd35467a517ed1
+       data8 0x88397e6a366f2a8a, 0xaba1d953a08fa94e
+       data8 0xd83e38838648d815, 0x885bc559e5e1c081
+       data8 0xabcd090db7ef4c3f, 0xd874a1db598b8951
+       data8 0x887e2ee392bb7a93, 0xabf864602d7c323d
+       data8 0xd8ab42205b80edaf, 0x88a7a8587e404257
+       data8 0xac2ca5886ccf9b57, 0xd8ed1849d202f965
+       data8 0x88ca5eda67594784, 0xac5861d4aa441f0f
+       data8 0xd92432bd5a173685, 0x88f4356166bd590e
+       data8 0xac8d183fe3a2fbed, 0xd9669ca45b03c23e
+       data8 0x89173a0acf5ce026, 0xacb93703ff51571e
+       data8 0xd99e3327cf89574e, 0x893a62a098b6a57b
+       data8 0xace5830ad0c3f14b, 0xd9d602b19b100466
+       data8 0x895daf637236ae2c, 0xad11fca5d78b3ff2
+       data8 0xda0e0ba86c096841, 0x89883b9d1c2fa9c5
+       data8 0xad4797fddf91a798, 0xda5195fcdb1c3dce
+       data8 0x89abd8dd374a5d7b, 0xad747701e559ebcb
+       data8 0xda8a1eb87a491f6c, 0x89cf9b1dcd197fa0
+       data8 0xada184a47e9c7613, 0xdac2e230b91c3f84
+       data8 0x89f382a258ea79de, 0xadcec13ab0dda8ff
+       data8 0xdafbe0d0b66aea30, 0x8a178faf06648f29
+       data8 0xadfc2d1a5fd21ba8, 0xdb351b04a8fafced
+       data8 0x8a3bc288b3e1d18a, 0xae29c89a5053c33a
+       data8 0xdb6e9139e33cdd8e, 0x8a601b74f4d1f835
+       data8 0xae5794122b638df9, 0xdba843ded7151ea1
+       data8 0x8a849aba14274764, 0xae858fda8137ae0a
+       data8 0xdbe2336319b61fc8, 0x8aa9409f16cdbc9b
+       data8 0xaeb3bc4ccc56d3d1, 0xdc1c60376789fa68
+       data8 0x8ace0d6bbe2cb316, 0xaee219c374c09920
+       data8 0xdc56cacda82d0cd5, 0x8af301688ab33558
+       data8 0xaf10a899d3235fe7, 0xdc917398f2797814
+       data8 0x8b181cdebe6f3206, 0xaf3f692c341fe8b4
+       data8 0xdccc5b0d90a3e628, 0x8b3d60185fafcb7c
+       data8 0xaf6e5bd7db9ae6c2, 0xdd0781a10469f0f2
+       data8 0x8b62cb603bb2fad0, 0xaf9d80fb081cd91b
+       data8 0xdd42e7ca0b52838f, 0x8b80d7d6bc4104de
+       data8 0xafc35ce063eb3787, 0xdd729ad01c69114d
+       data8 0x8ba68bf73ac74f39, 0xaff2ddcb5f28f03d
+       data8 0xddae749c001fbf5e, 0x8bcc68fb9f9f7335
+       data8 0xb022923b148e05c5, 0xddea8f50a51c69b1
+       data8 0x8bf26f31c534fca2, 0xb0527a919adbf58b
+       data8 0xde26eb69a0f0f111, 0x8c10f86e13a1a1f9
+       data8 0xb078f3ab1d701c65, 0xde576480262399bc
+       data8 0x8c3749916cc6abb5, 0xb0a93a6870649f31
+       data8 0xde943789645933c8, 0x8c5dc4c4f7706032
+       data8 0xb0d9b624d62ec856, 0xded14d58139a28af
+       data8 0x8c7cac3a8c42e3e0, 0xb100a5f53fb3c8e1
+       data8 0xdf025c00bbf2b5c7, 0x8ca373f1b7bf2716
+       data8 0xb131821882f5540a, 0xdf3feb44d723a713
+       data8 0x8cc29907fb951294, 0xb158bf8e4cb04055
+       data8 0xdf715bc16c159be0, 0x8ce9ae4e9492aac8
+       data8 0xb189fd69d56b238f, 0xdfaf66240e29cda8
+       data8 0x8d0911dddbfdad0e, 0xb1b189958e8108e4
+       data8 0xdfe139cbf6e19bdc, 0x8d3075c4f20f04ee
+       data8 0xb1e32a8165b09832, 0xe01fc0fe94d9fc52
+       data8 0x8d5018a9d4de77d5, 0xb20b0678fc271eec
+       data8 0xe051f92ffcc0bd60, 0x8d77cc47dd143515
+       data8 0xb23d0bd3f7592b6e, 0xe090feec9c9a06ac
+       data8 0x8d97af6352739cb7, 0xb26538b2db8420dc
+       data8 0xe0c39d0c9ff862d6, 0x8db7af523167800f
+       data8 0xb28d89e339ceca14, 0xe0f668eeb99f188d
+       data8 0x8ddfd80bc68c32ff, 0xb2c022ca12e55a16
+       data8 0xe1362890eb663139, 0x8e00197e1e7c88fe
+       data8 0xb2e8c6852c6b03f1, 0xe1695c7212aecbaa
+       data8 0x8e207859f77e20e7, 0xb3118f4eda9fe40f
+       data8 0xe19cbf0391bbbbe9, 0x8e40f4ce60c9f8e2
+       data8 0xb33a7d6268109ebe, 0xe1d050901c531e85
+       data8 0x8e69ba46cf2fde4d, 0xb36ddbc5ea70ec55
+       data8 0xe2110903b4f4047a, 0x8e8a7a00bd7ae63e
+       data8 0xb3971e9b39264023, 0xe2450559b4d80b6d
+       data8 0x8eab57ef1cf2f529, 0xb3c0877ecc18e24a
+       data8 0xe27931a231554ef3, 0x8ecc5442cffb1dad
+       data8 0xb3ea16ae3a6c905f, 0xe2ad8e2ac3c5b04b
+       data8 0x8eed6f2d2a4acbfe, 0xb413cc67aa0e4d2d
+       data8 0xe2e21b41b9694cce, 0x8f0ea8dff24441ff
+       data8 0xb43da8e9d163e1af, 0xe316d93615862714
+       data8 0x8f385c95d696b817, 0xb47233773b84d425
+       data8 0xe3590bd86a0d30f9, 0x8f59dc43edd930f3
+       data8 0xb49c6825430fe730, 0xe38e38e38e38e38e
+       data8 0x8f7b7b5f5ffad1c4, 0xb4c6c46bcdb27dcf
+       data8 0xe3c397d1e6db7839, 0x8f9d3a1bea165f38
+       data8 0xb4f1488c0b35d26f, 0xe3f928f5953feb9e
+       data8 0x8fbf18adc34b66da, 0xb51bf4c7c51f0168
+       data8 0xe42eeca17c62886c, 0x8fe117499e356095
+       data8 0xb546c9616087ab9c, 0xe464e32943446305
+       data8 0x90033624aa685f8d, 0xb571c69bdffd9a70
+       data8 0xe49b0ce15747a8a2, 0x9025757495f36b86
+       data8 0xb59cecbae56984c3, 0xe4d16a1eee94e9d4
+       data8 0x903f3a5dcc091203, 0xb5bd64512bb14bb7
+       data8 0xe4fa52107353f67d, 0x9061b2fceb2bdbab
+       data8 0xb5e8d2a4bf5ba416, 0xe5310a471f4d2dc3
+       data8 0x90844ca7211032a7, 0xb6146a9a1bc47819
+       data8 0xe567f6f1c2b9c224, 0x90a7079403e6a15d
+       data8 0xb6402c7749d621c0, 0xe59f18689a9e4c9a
+       data8 0x90c9e3fbafd63799, 0xb66c1882fb435ea2
+       data8 0xe5d66f04b8a68ecf, 0x90ece216c8a16ee4
+       data8 0xb6982f048c999a56, 0xe60dfb2005c192e9
+       data8 0x9110021e7b516f0a, 0xb6c47044075b4142
+       data8 0xe645bd1544c7ea51, 0x912a708a39be9075
+       data8 0xb6e5bd6bfd02bafd, 0xe66fb21b505b20a0
+       data8 0x914dcc7b31146370, 0xb7124a2736ff8ef2
+       data8 0xe6a7d32af4a7c59a, 0x91714af8cfe984d5
+       data8 0xb73f026a01e94177, 0xe6e02b129c6a5ae4
+       data8 0x918c00a6f3795e97, 0xb760a959f1d0a7a7
+       data8 0xe70a9136a7403039, 0x91afbc299ed0295d
+       data8 0xb78dae7e06868ab0, 0xe74349fb2d92a589
+       data8 0x91d39add3e958db0, 0xb7badff8ad9e4e02
+       data8 0xe77c3a9c86ed7d42, 0x91ee9920a8974d92
+       data8 0xb7dce25b8e17ae9f, 0xe7a713f88151518a
+       data8 0x9212b5fcac537c19, 0xb80a6226904045e2
+       data8 0xe7e067453317ed2b, 0x9236f6b256923fcf
+       data8 0xb8380f1cafd73c1c, 0xe819f37a81871bb5
+       data8 0x92523ee6f90dcfc3, 0xb85a6ea8e321b4d8
+       data8 0xe8454236bfaeca14, 0x9276bef031e6eb79
+       data8 0xb8886b684ae7d2fa, 0xe87f32f24c3fc90e
+       data8 0x929236ec237a24ad, 0xb8ab0726fa00cf5d
+       data8 0xe8aacd8688892ba6, 0x92b6f70b7efe9dc3
+       data8 0xb8d954a4d13b7cb1, 0xe8e523fd32f606f7
+       data8 0x92d29f61eec7dc2b, 0xb8fc2d4f6cd9f04a
+       data8 0xe9110b5311407927, 0x92f7a05d5b8ba92f
+       data8 0xb92acc851476b1ab, 0xe94bc8bf0c108fa3
+       data8 0x931379a403be5c16, 0xb94de2d841a184c2
+       data8 0xe977fdc439c2ca3c, 0x9338bc44de2e3f34
+       data8 0xb97cd4c36c92693c, 0xe9b3236528fc349e
+       data8 0x9354c71412c69486, 0xb9a0297f172665e3
+       data8 0xe9dfa70b745ac1b4, 0x937a4c273907e262
+       data8 0xb9cf6f21e36c3924, 0xea1b36268d0eaa38
+       data8 0x93968919f6e7975d, 0xb9f3030951267208
+       data8 0xea480963fd394197, 0x93bc516fdd4680c9
+       data8 0xba229d6a618e7c59, 0xea84034425f27484
+       data8 0x93d8c123d9be59b2, 0xba467144459f9855
+       data8 0xeab12713138dd1cc, 0x93f546c955e60076
+       data8 0xba6a60c3c48f1a4b, 0xeade6db73a5e503b
+       data8 0x941b70a65879079f, 0xba9a76056b67ee7a
+       data8 0xeb1b0268343b121b, 0x943829f337410591
+       data8 0xbabea699563ada6e, 0xeb489b0b2bdb5f14
+       data8 0x9454f995765bc4d2, 0xbae2f350b262cc4b
+       data8 0xeb765721e85f03d0, 0x947b86b57f5842ed
+       data8 0xbb1385a23be24e57, 0xebb389645f222f62
+       data8 0x94988aeb23470f86, 0xbb3814975e17c680
+       data8 0xebe198f090607e0c, 0x94b5a5dc9695f42a
+       data8 0xbb5cc031009bf467, 0xec0fcc9321024509
+       data8 0x94d2d7a9170d8b42, 0xbb81889680024764
+       data8 0xec3e247da8b82f61, 0x94f9e87dd78bf019
+       data8 0xbbb2c0d8703ae95d, 0xec7c27d21321c9f7
+       data8 0x95175019a503d89e, 0xbbd7cd09ba3c5463
+       data8 0xecaad5278824e453, 0x9534cefa625fcb3a
+       data8 0xbbfcf68c4977718f, 0xecd9a76d097d4e77
+       data8 0x955265405c491a25, 0xbc223d88cfc88eee
+       data8 0xed089ed5dcd99446, 0x9570130c1f9bb857
+       data8 0xbc47a2284fee4ff8, 0xed37bb95add09a1c
+       data8 0x9597ca4119525184, 0xbc79ac0916ed7b8a
+       data8 0xed76c70508f904b6, 0x95b5af6fb5aa4d3c
+       data8 0xbc9f5670d1a13030, 0xeda63bb05e7f93c6
+       data8 0x95d3ac9273aafd7a, 0xbcc51f068cb95c1d
+       data8 0xedd5d661daed2dc4, 0x95f1c1cafdfd3684
+       data8 0xbceb05f4b30a9bc0, 0xee05974eef86b903
+       data8 0x960fef3b430b8d5f, 0xbd110b6604c7d306
+       data8 0xee357ead791fc670, 0x962e350575b409c5
+       data8 0xbd372f8598620f19, 0xee658cb3c134a463
+       data8 0x964c934c0dfc1708, 0xbd5d727edb6b3c7e
+       data8 0xee95c1987f080211, 0x966b0a31c9c6bc7d
+       data8 0xbd83d47d937bbc6d, 0xeec61d92d8c4314f
+       data8 0x968999d9ad8d264e, 0xbdaa55addf1ae47d
+       data8 0xeef6a0da64a014ac, 0x96a8426705198795
+       data8 0xbdd0f63c36aa73f0, 0xef274ba72a07c811
+       data8 0x96c703fd64445ee5, 0xbdf7b6556d550a15
+       data8 0xef581e31a2c91260, 0x96e5dec0a7b4268d
+       data8 0xbe1e9626b1ffa96b, 0xef8918b2bc43aec6
+       data8 0x9704d2d4f59f79f3, 0xbe4595dd903e5371
+       data8 0xefba3b63d89d7cbf, 0x9723e05ebe91b9b0
+       data8 0xbe6cb5a7f14bc935, 0xefeb867ecffaa607
+       data8 0x97430782be323831, 0xbe93f5b41d047cf7
+       data8 0xf01cfa3df1b9c9fa, 0x97624865fc0df8bf
+       data8 0xbebb5630bae4c15f, 0xf04e96dc05b43e2d
+       data8 0x9781a32dcc640b2a, 0xbee2d74cd30a430c
+       data8 0xf0805c944d827454, 0x97a117ffd0f48e46
+       data8 0xbf0a7937cf38d981, 0xf0b24ba285c495cb
+       data8 0x97c0a701f9d263c9, 0xbf323c217be2bc8c
+       data8 0xf0e46442e76f6569, 0x97e0505a8637a036
+       data8 0xbf5a203a09342bbb, 0xf116a6b2291d7896
+       data8 0x97f57a9fb0b08c6e, 0xbf74cad1c14ebfc4
+       data8 0xf1383fa9e9b5b381, 0x9815503365914a9d
+       data8 0xbf9ce6a497a89f78, 0xf16ac84f90083b9b
+       data8 0x98354085054fd204, 0xbfc52428bec6e72f
+       data8 0xf19d7b686dcb03d7, 0x98554bbbf8a77902
+       data8 0xbfed838fddab024b, 0xf1d0593311db1757
+       data8 0x987571fffb7f94f6, 0xc016050c0420981a
+       data8 0xf20361ee8f1c711e, 0x9895b3791dd03c23
+       data8 0xc03ea8cfabddc330, 0xf23695da7de51d3f
+       data8 0x98ab43a5fc65d0c8, 0xc059d3cbd65ddbce
+       data8 0xf258d095e465cc35, 0x98cbb2d196bd713d
+       data8 0xc082b122a3c78c9d, 0xf28c4d0bfc982b34
+       data8 0x98ec3d9ec7b6f21a, 0xc0abb1499ae736c4
+       data8 0xf2bff55eb3f0ea71, 0x990ce436db5e8344
+       data8 0xc0d4d474c3aedaaf, 0xf2f3c9cf9884636e
+       data8 0x9922b8218160967a, 0xc0f054ca33eb3437
+       data8 0xf31670135ab9cc0f, 0x99438d686f75779d
+       data8 0xc119b2c67e600ed0, 0xf34a8e9f0b54cdfb
+       data8 0x99647eea131fa20b, 0xc1433453de2033ff
+       data8 0xf37ed9fa6b8add3f, 0x997a85045a47c6d0
+       data8 0xc15ef3e44e10032d, 0xf3a1cfe884ef6bb6
+       data8 0x999ba5f14f8add02, 0xc188b130431d80e6
+       data8 0xf3d66689dcc8e8d3, 0x99bce38b5465ecae
+       data8 0xc1b2929d6067730e, 0xf40b2ab069d5c96a
+       data8 0x99d31ca0887f30f9, 0xc1ce9268f31cc734
+       data8 0xf42e718b90c8bc16, 0x99f48a669c74c09e
+       data8 0xc1f8b0877c1b0c08, 0xf463822a0a3b4b00
+       data8 0x9a16154eb445c873, 0xc222f35a87b415ba
+       data8 0xf498c1076015faf8, 0x9a2c822ec198d667
+       data8 0xc23f3467349e5c88, 0xf4bc5a19a33990b5
+       data8 0x9a4e3e080cd91b78, 0xc269b4e40e088c01
+       data8 0xf4f1e6a7d6f5425f, 0x9a70177afe52322e
+       data8 0xc2945aac24daaf6e, 0xf527a232cf6be334
+       data8 0x9a86b8fa94eebe10, 0xc2b0de05e43c1d66
+       data8 0xf54b8ecdcda90851, 0x9aa8c42866ae2958
+       data8 0xc2dbc275e1229d09, 0xf5819949c7ad87b4
+       data8 0x9abf86f9e12fc45e, 0xc2f86fca9d80eeff
+       data8 0xf5a5bac9213b48a9, 0x9ae1c462fc05f49d
+       data8 0xc323938449a2587e, 0xf5dc1501f324a812
+       data8 0x9af8a8dc936b84d0, 0xc3406b40a538ed20
+       data8 0xf6006bee86b5589e, 0x9b1b19033be35730
+       data8 0xc36bcee8211d15e0, 0xf63716b2fa067fa4
+       data8 0x9b3da7daf04c2892, 0xc397593adf2ba366
+       data8 0xf66df22fb6132b9c, 0x9b54c2e4c8a9012b
+       data8 0xc3b475b6206155d5, 0xf6929fb98225deb1
+       data8 0x9b77854e6c661200, 0xc3e0410243b97383
+       data8 0xf6c9cd13021e3fea, 0x9b8ec2e678d56d2f
+       data8 0xc3fd890709833d37, 0xf6eeb177472cedae
+       data8 0x9ba60e6a5ca133b6, 0xc41ae295f7e7fa06
+       data8 0xf713abf4cb0b3afb, 0x9bc919ea66a151a4
+       data8 0xc44709f7bb8a4dd2, 0xf74b4d5333684ef1
+       data8 0x9be0887c09ef82bb, 0xc4648fb0e0bec4c1
+       data8 0xf7707f75a72f8e94, 0x9c03c8d5fffc3503
+       data8 0xc490f9a94695ba14, 0xf7a874b97927af44
+       data8 0x9c1b5ad21a81cbb9, 0xc4aeac0173b7d390
+       data8 0xf7cddf140aedf1d8, 0x9c3ed09216e9ca02
+       data8 0xc4db5941007aa853, 0xf806291bacb7f7a9
+       data8 0x9c568656c0423def, 0xc4f938aec206291a
+       data8 0xf82bcc43b92eafef, 0x9c7a320af242ce60
+       data8 0xc52629e899dfd622, 0xf8646bf0defb759e
+       data8 0x9c920bf7a8c01dc2, 0xc54436e44043b965
+       data8 0xf88a487dfc3ff5f7, 0x9ca9f475d98b159c
+       data8 0xc562563abf9ea07f, 0xf8b03c2b46cdc17f
+       data8 0x9ccdeca60e80b5f8, 0xc58fa7d1dc42921c
+       data8 0xf8e95541c152ae7a, 0x9ce5f9d4653d4902
+       data8 0xc5adf561b91e110a, 0xf90f832c2700c160
+       data8 0x9cfe15cb38bfdd8e, 0xc5cc5591bdbd82fa
+       data8 0xf935c88e0c7f419b, 0x9d225b983f6c1f96
+       data8 0xc5fa08f1ff20593c, 0xf96f5cd84fd86873
+       data8 0x9d3a9cca32261ed7, 0xc618980a79ce6862
+       data8 0xf995dd53ebdd9d6d, 0x9d52ecfccebe1768
+       data8 0xc6373a09e34b50fa, 0xf9bc75a034436a41
+       data8 0x9d77818d95b82f86, 0xc66550a6e0baaf35
+       data8 0xf9f686f26d5518de, 0x9d8ff7893fa4706c
+       data8 0xc6842241926342c9, 0xfa1d5b39b910a8c5
+       data8 0x9da87cbef36f2a5e, 0xc6a3070b7c93bb9e
+       data8 0xfa4447acc4ecbfd2, 0x9dcd6140b4a35aeb
+       data8 0xc6d18260bb84081b, 0xfa7ed7e51e6fdfb4
+       data8 0x9de60cd06dc6e2d4, 0xc6f0977c9416828b
+       data8 0xfaa601394d49a1a0, 0x9dfec7d4cc43b76f
+       data8 0xc70fc0117c641630, 0xfacd431644ce0e40
+       data8 0x9e17925ec9fccc4a, 0xc72efc34d7e615be
+       data8 0xfaf49d96f7a75909, 0x9e3cdf6db57dc075
+       data8 0xc75dfb441594141e, 0xfb2fd3c65e562fd5
+       data8 0x9e55d110b63637a8, 0xc77d68aa019bda4c
+       data8 0xfb576c5762024805, 0x9e6ed27594550d2e
+       data8 0xc79ce9ea478dbc4f, 0xfb7f1debc22c4040
+       data8 0x9e87e3adc385d393, 0xc7bc7f1ae453219d
+       data8 0xfba6e89f32d0190a, 0x9ead9b54b37a1055
+       data8 0xc7ec0476e15e141a, 0xfbe2c803a0894893
+       data8 0x9ec6d46a3d7de215, 0xc80bcbe16f1d540f
+       data8 0xfc0ad1ff0ed9ecf0, 0x9ee01d9108be3154
+       data8 0xc82ba78a5d349735, 0xfc32f57bdfbcbe7f
+       data8 0x9ef976db07288d04, 0xc84b978847a06b87
+       data8 0xfc5b32968f99b21c, 0x9f12e05a4759ec25
+       data8 0xc86b9bf1ee817bc6, 0xfc83896bc861ab08
+       data8 0x9f2c5a20f4da6668, 0xc88bb4de3667cdf4
+       data8 0xfcabfa1861ed4815, 0x9f52af78ed1733ca
+       data8 0xc8bc00e7fe9e23a3, 0xfce8d3cea7d3163e
+       data8 0x9f6c52426a39d003, 0xc8dc4d7ff2d25232
+       data8 0xfd118595143ee273, 0x9f860593d42fd7f3
+       data8 0xc8fcaeebcb40eb47, 0xfd3a519943d4865a
+       data8 0x9f9fc97fdb96bd51, 0xc91d25431426a663
+       data8 0xfd6337f8e1ae5a4b, 0x9fb99e194f4a7037
+       data8 0xc93db09d7fdb2949, 0xfd8c38d1c8e927eb
+       data8 0x9fd383731ca51db9, 0xc95e5112e721582a
+       data8 0xfdb5544205095a53, 0x9fed79a04fbf9423
+       data8 0xc97f06bb49787677, 0xfdde8a67d2613531
+       data8 0xa00780b413b24ee8, 0xc99fd1aecd6e1b06
+       data8 0xfe07db619e781611, 0xa02eab2c4474b0cd
+       data8 0xc9d12a3e27bb1625, 0xfe460768d80bf758
+       data8 0xa048dcd51ccfd142, 0xc9f22ad82ba3d5f0
+       data8 0xfe6f9bfb06cd32f6, 0xa0631fa894b11b8d
+       data8 0xca134113105e67b2, 0xfe994bcd3d14fcc2
+       data8 0xa07d73ba65e680af, 0xca346d07b045a876
+       data8 0xfec316fecaf3f2ab, 0xa097d91e6aaf71b0
+       data8 0xca55aecf0e94bb88, 0xfeecfdaf33fadb80
+       data8 0xa0b24fe89e02602f, 0xca77068257be9bab
+       data8 0xff16fffe2fa8fad6, 0xa0ccd82d1bd2f68b
+       data8 0xca98743ae1c693a8, 0xff411e0ba9db886d
+       data8 0xa0e77200215909e6, 0xcab9f8122c99a101
+       data8 0xff6b57f7c33e4e9a, 0xa1021d760d584855
+       data8 0xcadb9221e268c3b5, 0xff95ade2d1bd7358
+       data8 0xa11cdaa36068a57d, 0xcafd4283d8043dfd
+       data8 0xffc01fed60f86fb5, 0xa137a99cbd3f880b
+       data8 0xcb1f09520d37c6fb, 0xffeaae3832b63956
+LOCAL_OBJECT_END(T_table)
+
+
+
+
+
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(cbrt)
+
+
+{.mfi
+       // get significand
+       getf.sig GR_SIGNIF = f8
+       // normalize a
+       fma.s1 FR_ARG = f8, f1, f0
+       // GR_GP = pointer to C_1,..., C_5 followed by T_table
+       addl GR_GP = @ltoff(poly_coeffs), gp ;;
+}
+
+{.mfi
+       // get exponent
+       getf.exp GR_ARGEXP = f8
+       // will continue only for normal/denormal numbers
+       fclass.m.unc p12, p13 = f8, 0x1e7
+       // GR_CONST4 = bias-((2^{12}-1)/3)-63 = 0xffff-0x555-0x3f = 0xfa6b
+       mov GR_CONST4 = 0xfa6b ;;
+}
+
+{.mlx
+       mov GR_CONST2 = 0x20000
+       // GR_CONST3 = 2^52
+       movl GR_CONST3 = 0x8000000000000000 ;;
+}
+
+.pred.rel "mutex", p12, p13
+{.mfi
+       // load start address for C_1,..., C_5 followed by T_table
+       ld8 GR_ADDR = [ GR_GP ]
+       // y = frcpa(a)
+ (p13) frcpa.s0 f8, p0 = f1, f8
+       // p7 = 1 if denormal input
+       cmp.gtu p7, p0 = GR_CONST3, GR_SIGNIF
+}
+{.mfb
+       nop.m 0
+       // if argument is 0, +/-Infinity, NaN, or NaTVal, then return
+ (p12) fma.d.s0 f8 = f8, f1, f0
+ (p12) br.ret.spnt b0 ;;
+}
+
+{.mmi
+       // get exponent (for denormal input)
+ (p7) getf.exp GR_ARGEXP = FR_ARG
+       // get normalized significand (for denormal input)
+ (p7) getf.sig GR_SIGNIF = FR_ARG
+       // GR_CONST1 = bias-(2^{12}-1)
+       mov GR_CONST1 = 0xf000 ;;
+}
+
+{.mii
+       // get GR_SIGN = sign
+       and GR_SIGN = GR_ARGEXP, GR_CONST2
+       // eliminate leading 1 from GR_I1 = 1st table index
+       shl GR_I1 = GR_SIGNIF, 1
+       // eliminate sign from exponent
+       andcm GR_EXP = GR_ARGEXP, GR_CONST2 ;;
+}
+
+{.mib
+       add GR_ADDR2 = 32, GR_ADDR
+       // GR_IT1 = 1st table index (y_index, 8 bits)
+       shr.u GR_IT1 = GR_I1, 56
+       nop.b 0
+}
+{.mib
+       // load C_1
+       ldfe FR_COEFF1 = [ GR_ADDR ], 16
+       // subtract bias from GR_EXPON = exponent
+       sub GR_EXPON = GR_EXP, GR_CONST1
+       nop.b 0 ;;
+}
+
+{.mib
+       // load C_2, C_3
+       ldfpd FR_COEFF2, FR_COEFF3 = [ GR_ADDR ]
+       // 1: exponent* = 5; // (2^{16}-1)/3 = 0x5555
+       shladd GR_TMP1 = GR_EXPON, 2, GR_EXPON
+       nop.b 0
+}
+{.mib
+       // load C_4, C_5
+       ldfpd FR_COEFF4, FR_COEFF5 = [ GR_ADDR2 ], 16
+       // GR_TMP2 = 3*y_index
+       shladd GR_TMP2 = GR_IT1, 1, GR_IT1
+       nop.b 0 ;;
+}
+
+{.mfi
+       // GR_TMP6 = (5*expon)*16+5*expon = (0x55)*expon
+       shladd GR_TMP6 = GR_TMP1, 4, GR_TMP1
+       // r = 1-a*y
+       fnma.s1 FR_R = f8, FR_ARG, f1
+       // adjust T_table pointer by 1st index
+       shladd GR_ITB1 = GR_TMP2, 3, GR_ADDR2 ;;
+}
+
+{.mii
+       // eliminate leading 1 from significand
+       add GR_SIGNIF2 = GR_SIGNIF, GR_SIGNIF
+       // GR_TMP3 = (0x5500)*expon
+       shl GR_TMP3 = GR_TMP6, 8 ;;
+       // GR_TMP4 = (0x5555)*expon
+       add GR_TMP4 = GR_TMP3, GR_TMP6 ;;
+}
+
+{.mii
+       // GR_TMP5 = (0x5556)*expon // 0x5556 = (2^{16}+2)/3
+       add GR_TMP5 = GR_TMP4, GR_EXPON
+       nop.i 0 ;;
+       // GR_EXP_BY_3 = floor(expon/3)
+       shr GR_EXP_BY_3 = GR_TMP5, 16 ;;
+}
+
+{.mfi
+       // GR_TMP6 = 3*exponent
+       shladd GR_TMP6 = GR_EXP_BY_3, 1, GR_EXP_BY_3
+       // r*r
+       fma.s1 FR_R2 = FR_R, FR_R, f0
+       // bias exponent
+       add GR_EBIAS = GR_CONST4, GR_EXP_BY_3 ;;
+}
+
+{.mfi
+       // get remainder of exponent/3
+       sub GR_REM = GR_EXPON, GR_TMP6
+       // c2+c3*r
+       fma.s1 FR_P23 = FR_COEFF3, FR_R, FR_COEFF2
+       nop.i 0
+}
+{.mfi
+       // add sign to exponent
+       or GR_SEXP = GR_EBIAS, GR_SIGN
+       // c4+c5*r
+       fma.s1 FR_P45 = FR_COEFF5, FR_R, FR_COEFF4
+       mov GR_TMP63 = 63+0xffff ;;
+}
+
+{.mmi
+       // FR_2EXP = sign*2^{exponent/3}
+       setf.exp FR_2EXP = GR_SEXP
+       // adjust T_table pointer by 2nd index
+       shladd GR_INDEX = GR_REM, 3, GR_ITB1
+       // is the argument of the form 2^(3*k) ?
+       // get (significand - leading 1) | (exponent mod 3)
+       or GR_TEST = GR_REM, GR_SIGNIF2 ;;
+}
+
+{.mmi
+       // 2^63
+       setf.exp FR_TMP63 = GR_TMP63
+       // load T
+       ldf8 f8 = [ GR_INDEX ]
+       // is the argument of the form 2^(3*k) ?
+       cmp.eq p14, p0 = GR_TEST, r0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // (c2+c3*r)+r^2*(c4+c5*r)
+       fma.s1 FR_P25 = FR_P45, FR_R2, FR_P23
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // c1*r
+       fma.s1 FR_P1 = FR_COEFF1, FR_R, f0
+       nop.i 0 ;;
+}
+
+{.mfb
+       nop.m 0
+ (p14) fma.d.s0 f8 = FR_2EXP, FR_TMP63, f0
+ (p14) br.ret.spnt b0 ;;
+}
+
+{.mfi
+       nop.m 0
+       // P = c1*r+r^2* [ (c2+c3*r)+r^2*(c4+c5*r) ]
+       fma.s1 FR_P15 = FR_P25, FR_R2, FR_P1
+       nop.i 0
+}
+{.mfi
+       nop.m 0
+       // T' = T*(2^exp)
+       fma.s1 f8 = f8, FR_2EXP, f0
+       nop.i 0 ;;
+}
+
+{.mfb
+       nop.m 0
+       // result = T'+T'*P
+       fma.d.s0 f8 = f8, FR_P15, f8
+       br.ret.sptk b0 ;;
+}
+
+
+GLOBAL_LIBM_END(cbrt)
+libm_alias_double_other (cbrt, cbrt)
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_cbrtf.S
@@ -0,0 +1,761 @@
+.file "cbrtf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 05/18/00 New version (modified algorithm)
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 01/28/03 Rescheduled some instructions for better performance
+//          on Itanium 2, and reformatted
+//
+// API
+//==============================================================
+// float cbrtf(float)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// Let y= frcpa(a), where a is the argument
+//
+// cbrt(a)= cbrt(a*y)/cbrt(y) = cbrt(1 - (1-a*y)) * (1/cbrt(y))
+//
+// For all values of y, the 3 possible significands of 1/cbrt(y)
+// are stored in a table (T0) to 64 bits of accuracy. (There are
+// 3 possible significands because the exponent of y modulo 3
+// can be 0, 1, or 2.)
+//
+//
+// * cbrt(1 - (1-a*y)) is approximated by a degree-2 polynomial
+//
+// 1 - (1/3)*r - (1/9)*r^2
+//
+// in r = 1-a*y.
+//
+// The table values are stored for three exponent values and are
+// then multiplied by 2^(e/3) where e is the exponent of the input number.
+// This computation is carried out in parallel with the polynomial
+// evaluation:
+//
+// T= 2^(e/3) * T0
+
+
+
+
+
+//===============
+// input= x
+// C= frcpa(x)
+// r= 1 - C * x
+//
+// Special values
+//==============================================================
+
+
+
+// Registers used
+//==============================================================
+// p6, p7, p8, p12
+
+       FR_R      = f6
+       FR_COEFF1 = f7
+       FR_COEFF2 = f9
+       FR_T0     = f10
+       FR_T1     = f11
+       FR_T2     = f12
+       FR_2M63   = f13
+       FR_ARG    = f14
+       FR_Y      = f15
+
+       GR_GP     = r2
+       GR_ADDR   = r2
+       GR_TMP5   = r3
+       GR_CONST  = r8
+       GR_TMP63  = r8
+       GR_SIGN   = r9
+       GR_CT2    = r10
+       GR_CT3    = r11
+       GR_TMP4   = r14
+       GR_EBIAS3 = r15
+       GR_REM    = r16
+       GR_SEXP   = r17
+       GR_2P63   = r18
+       GR_SIGNIF = r19
+       GR_I1     = r20
+       GR_EBIAS  = r21
+       GR_EXP    = r22
+       GR_IT1    = r23
+       GR_E5     = r24
+       GR_IT1_3  = r25
+       GR_TP1    = r26
+       GR_TMP    = r27
+       GR_TMP2   = r28
+       GR_TMP3   = r29
+       GR_EXP3   = r30
+       GR_ARGEXP = r31
+
+
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+
+       data8 0xaaaab19b7e1f5ef9, 0x00003ffd // ~ 1/3
+       data8 0xe38e5192a5a8e56c, 0x00003ffb // ~ 1/9
+LOCAL_OBJECT_END(poly_coeffs)
+
+//   For every entry B in the frcpa table, this table contains
+// the significands of cbrt(1/B), cbrt(2/B), cbrt(4/B).
+// The index to this table is the same as the frcpa index.
+
+LOCAL_OBJECT_START(T_table)
+
+       data8 0x80155c748c374836, 0xa160019ed37fb4ae
+       data8 0xcb51ddcb9e93095e, 0x8040404b0879f7f9
+       data8 0xa1960b5966da4608, 0xcb95f333968ad59b
+       data8 0x806b5dce4b405c10, 0xa1cc5dbe6dc2aab4
+       data8 0xcbda64292d3ffd97, 0x8096b586974669b1
+       data8 0xa202f97995b69c0d, 0xcc1f3184af961596
+       data8 0x80bcd273d952a028, 0xa232fe6eb0c0577d
+       data8 0xcc5bb1ac954d33e2, 0x80e898c52813f2f3
+       data8 0xa26a2582012f6e17, 0xcca12e9831fc6402
+       data8 0x81149add67c2d208, 0xa2a197e5d10465cb
+       data8 0xcce70a67b64f24ad, 0x813b4e2c856b6e9a
+       data8 0xa2d25a532efefbc8, 0xcd24794726477ea5
+       data8 0x8167c1dde03de7aa, 0xa30a5bd6e49e4ab8
+       data8 0xcd6b096a0b70ee87, 0x818ed973b811135e
+       data8 0xa33b9c9b59879e24, 0xcda9177738b15a90
+       data8 0x81bbc0c33e13ec98, 0xa3742fca6a3c1f21
+       data8 0xcdf05f2247dffab9, 0x81e33e69fbe7504a
+       data8 0xa3a5f1273887bf22, 0xce2f0f347f96f906
+       data8 0x820aec524e3c23e9, 0xa3d7ef508ff11574
+       data8 0xce6e0be0cd551a61, 0x823880f78e70b805
+       data8 0xa4115ce30548bc15, 0xceb666b2c347d1de
+       data8 0x826097a62a8e5200, 0xa443df0e53df577a
+       data8 0xcef609b0cb874f00, 0x8288dfe00e9b5eaf
+       data8 0xa4769fa5913c0ec3, 0xcf35fb5447e5c765
+       data8 0x82b15a10c5371624, 0xa4a99f303bc7def5
+       data8 0xcf763c47ee869f00, 0x82da06a527b18937
+       data8 0xa4dcde37779adf4b, 0xcfb6cd3888d71785
+       data8 0x8302e60b635ab394, 0xa5105d46152c938a
+       data8 0xcff7aed4fbfbb447, 0x832bf8b2feec2f0e
+       data8 0xa5441ce89825cb8d, 0xd038e1ce5167e3c6
+       data8 0x83553f0ce00e276b, 0xa5781dad3e54d899
+       data8 0xd07a66d7bfa0ebba, 0x837eb98b50f8322a
+       data8 0xa5ac602406c4e68c, 0xd0bc3ea6b32d1b21
+       data8 0x83a270f44c84f699, 0xa5d9601d95c2c0bc
+       data8 0xd0f4f0e8f36c1bf8, 0x83cc4d7cfcfac5ca
+       data8 0xa60e1e1a2de14745, 0xd1376458e34b037e
+       data8 0x83f65f78a8872b4c, 0xa6431f6e3fbd9658
+       data8 0xd17a2ca133f78572, 0x8420a75f2f7b53c8
+       data8 0xa67864b0d432fda4, 0xd1bd4a80301c5715
+       data8 0x844510461ff14209, 0xa6a6444aa0243c0b
+       data8 0xd1f71682b2fa4575, 0x846fbd91b930bed2
+       data8 0xa6dc094d10f25792, 0xd23ad555f773f059
+       data8 0x84947e18234f3294, 0xa70a574cc02bba69
+       data8 0xd2752c7039a5bf73, 0x84bf92755825045a
+       data8 0xa7409e2af9549084, 0xd2b98ee008c06b59
+       data8 0x84e4ac0ee112ba51, 0xa76f5c64ca2cf13b
+       data8 0xd2f4735ffd700280, 0x8509ef44b86f20be
+       data8 0xa79e4f0babab5dc0, 0xd32f99ed6d9ac0e1
+       data8 0x85359d5d91768427, 0xa7d5579ae5164b85
+       data8 0xd374f0666c75d51c, 0x855b3bd5b7384357
+       data8 0xa804bd3c6fe61cc8, 0xd3b0a7d13618e4a1
+       data8 0x858104f0c415f79a, 0xa8345895e5250a5a
+       data8 0xd3eca2ea53bcec0c, 0x85a6f90390d29864
+       data8 0xa8642a122b44ef0b, 0xd428e23874f13a17
+       data8 0x85d3772fcd56a1dd, 0xa89c38ca18f6108b
+       data8 0xd46f82fe293bc6d3, 0x85f9c982fcc002f3
+       data8 0xa8cc81063b6e87ca, 0xd4ac57e9b7186420
+       data8 0x862047e0e7ea554b, 0xa8fd00bfa409285e
+       data8 0xd4e972becb04e8b8, 0x8646f2a26f7f5852
+       data8 0xa92db8664d5516da, 0xd526d40a7a9b43a3
+       data8 0x866dca21754096b5, 0xa95ea86b75cc2c20
+       data8 0xd5647c5b73917370, 0x8694ceb8dfd17a37
+       data8 0xa98fd141a4992deb, 0xd5a26c4201bd6d13
+       data8 0x86bc00c49e9307e8, 0xa9c1335cae7446ba
+       data8 0xd5e0a45015350a7e, 0x86dccd74fce79610
+       data8 0xa9ea8686f556f645, 0xd614b539c6194104
+       data8 0x870453c845acf90f, 0xaa1c52d17906bb19
+       data8 0xd6537310e224283f, 0x872c089a1e90342c
+       data8 0xaa4e59b046dab887, 0xd6927ab62244c917
+       data8 0x8753ec4a92d16c5e, 0xaa809b9c60d1890b
+       data8 0xd6d1ccc1fc4ef4b7, 0x877bff3aca19f6b4
+       data8 0xaab319102f3f9b33, 0xd71169cea98fdded
+       data8 0x879d88b6fe1c324c, 0xaadd5a18c1e21274
+       data8 0xd746a66a5bc9f6d9, 0x87c5f346dbf98c3a
+       data8 0xab1045f2ac31bdf5, 0xd786ce8f0fae5317
+       data8 0x87e7c653efacef2c, 0xab3ae3ab2df7231e
+       data8 0xd7bc7ff214c4e75a, 0x881089d4e73ffefc
+       data8 0xab6e3f945d1e96fc, 0xd7fd35467a517ed1
+       data8 0x88397e6a366f2a8a, 0xaba1d953a08fa94e
+       data8 0xd83e38838648d815, 0x885bc559e5e1c081
+       data8 0xabcd090db7ef4c3f, 0xd874a1db598b8951
+       data8 0x887e2ee392bb7a93, 0xabf864602d7c323d
+       data8 0xd8ab42205b80edaf, 0x88a7a8587e404257
+       data8 0xac2ca5886ccf9b57, 0xd8ed1849d202f965
+       data8 0x88ca5eda67594784, 0xac5861d4aa441f0f
+       data8 0xd92432bd5a173685, 0x88f4356166bd590e
+       data8 0xac8d183fe3a2fbed, 0xd9669ca45b03c23e
+       data8 0x89173a0acf5ce026, 0xacb93703ff51571e
+       data8 0xd99e3327cf89574e, 0x893a62a098b6a57b
+       data8 0xace5830ad0c3f14b, 0xd9d602b19b100466
+       data8 0x895daf637236ae2c, 0xad11fca5d78b3ff2
+       data8 0xda0e0ba86c096841, 0x89883b9d1c2fa9c5
+       data8 0xad4797fddf91a798, 0xda5195fcdb1c3dce
+       data8 0x89abd8dd374a5d7b, 0xad747701e559ebcb
+       data8 0xda8a1eb87a491f6c, 0x89cf9b1dcd197fa0
+       data8 0xada184a47e9c7613, 0xdac2e230b91c3f84
+       data8 0x89f382a258ea79de, 0xadcec13ab0dda8ff
+       data8 0xdafbe0d0b66aea30, 0x8a178faf06648f29
+       data8 0xadfc2d1a5fd21ba8, 0xdb351b04a8fafced
+       data8 0x8a3bc288b3e1d18a, 0xae29c89a5053c33a
+       data8 0xdb6e9139e33cdd8e, 0x8a601b74f4d1f835
+       data8 0xae5794122b638df9, 0xdba843ded7151ea1
+       data8 0x8a849aba14274764, 0xae858fda8137ae0a
+       data8 0xdbe2336319b61fc8, 0x8aa9409f16cdbc9b
+       data8 0xaeb3bc4ccc56d3d1, 0xdc1c60376789fa68
+       data8 0x8ace0d6bbe2cb316, 0xaee219c374c09920
+       data8 0xdc56cacda82d0cd5, 0x8af301688ab33558
+       data8 0xaf10a899d3235fe7, 0xdc917398f2797814
+       data8 0x8b181cdebe6f3206, 0xaf3f692c341fe8b4
+       data8 0xdccc5b0d90a3e628, 0x8b3d60185fafcb7c
+       data8 0xaf6e5bd7db9ae6c2, 0xdd0781a10469f0f2
+       data8 0x8b62cb603bb2fad0, 0xaf9d80fb081cd91b
+       data8 0xdd42e7ca0b52838f, 0x8b80d7d6bc4104de
+       data8 0xafc35ce063eb3787, 0xdd729ad01c69114d
+       data8 0x8ba68bf73ac74f39, 0xaff2ddcb5f28f03d
+       data8 0xddae749c001fbf5e, 0x8bcc68fb9f9f7335
+       data8 0xb022923b148e05c5, 0xddea8f50a51c69b1
+       data8 0x8bf26f31c534fca2, 0xb0527a919adbf58b
+       data8 0xde26eb69a0f0f111, 0x8c10f86e13a1a1f9
+       data8 0xb078f3ab1d701c65, 0xde576480262399bc
+       data8 0x8c3749916cc6abb5, 0xb0a93a6870649f31
+       data8 0xde943789645933c8, 0x8c5dc4c4f7706032
+       data8 0xb0d9b624d62ec856, 0xded14d58139a28af
+       data8 0x8c7cac3a8c42e3e0, 0xb100a5f53fb3c8e1
+       data8 0xdf025c00bbf2b5c7, 0x8ca373f1b7bf2716
+       data8 0xb131821882f5540a, 0xdf3feb44d723a713
+       data8 0x8cc29907fb951294, 0xb158bf8e4cb04055
+       data8 0xdf715bc16c159be0, 0x8ce9ae4e9492aac8
+       data8 0xb189fd69d56b238f, 0xdfaf66240e29cda8
+       data8 0x8d0911dddbfdad0e, 0xb1b189958e8108e4
+       data8 0xdfe139cbf6e19bdc, 0x8d3075c4f20f04ee
+       data8 0xb1e32a8165b09832, 0xe01fc0fe94d9fc52
+       data8 0x8d5018a9d4de77d5, 0xb20b0678fc271eec
+       data8 0xe051f92ffcc0bd60, 0x8d77cc47dd143515
+       data8 0xb23d0bd3f7592b6e, 0xe090feec9c9a06ac
+       data8 0x8d97af6352739cb7, 0xb26538b2db8420dc
+       data8 0xe0c39d0c9ff862d6, 0x8db7af523167800f
+       data8 0xb28d89e339ceca14, 0xe0f668eeb99f188d
+       data8 0x8ddfd80bc68c32ff, 0xb2c022ca12e55a16
+       data8 0xe1362890eb663139, 0x8e00197e1e7c88fe
+       data8 0xb2e8c6852c6b03f1, 0xe1695c7212aecbaa
+       data8 0x8e207859f77e20e7, 0xb3118f4eda9fe40f
+       data8 0xe19cbf0391bbbbe9, 0x8e40f4ce60c9f8e2
+       data8 0xb33a7d6268109ebe, 0xe1d050901c531e85
+       data8 0x8e69ba46cf2fde4d, 0xb36ddbc5ea70ec55
+       data8 0xe2110903b4f4047a, 0x8e8a7a00bd7ae63e
+       data8 0xb3971e9b39264023, 0xe2450559b4d80b6d
+       data8 0x8eab57ef1cf2f529, 0xb3c0877ecc18e24a
+       data8 0xe27931a231554ef3, 0x8ecc5442cffb1dad
+       data8 0xb3ea16ae3a6c905f, 0xe2ad8e2ac3c5b04b
+       data8 0x8eed6f2d2a4acbfe, 0xb413cc67aa0e4d2d
+       data8 0xe2e21b41b9694cce, 0x8f0ea8dff24441ff
+       data8 0xb43da8e9d163e1af, 0xe316d93615862714
+       data8 0x8f385c95d696b817, 0xb47233773b84d425
+       data8 0xe3590bd86a0d30f9, 0x8f59dc43edd930f3
+       data8 0xb49c6825430fe730, 0xe38e38e38e38e38e
+       data8 0x8f7b7b5f5ffad1c4, 0xb4c6c46bcdb27dcf
+       data8 0xe3c397d1e6db7839, 0x8f9d3a1bea165f38
+       data8 0xb4f1488c0b35d26f, 0xe3f928f5953feb9e
+       data8 0x8fbf18adc34b66da, 0xb51bf4c7c51f0168
+       data8 0xe42eeca17c62886c, 0x8fe117499e356095
+       data8 0xb546c9616087ab9c, 0xe464e32943446305
+       data8 0x90033624aa685f8d, 0xb571c69bdffd9a70
+       data8 0xe49b0ce15747a8a2, 0x9025757495f36b86
+       data8 0xb59cecbae56984c3, 0xe4d16a1eee94e9d4
+       data8 0x903f3a5dcc091203, 0xb5bd64512bb14bb7
+       data8 0xe4fa52107353f67d, 0x9061b2fceb2bdbab
+       data8 0xb5e8d2a4bf5ba416, 0xe5310a471f4d2dc3
+       data8 0x90844ca7211032a7, 0xb6146a9a1bc47819
+       data8 0xe567f6f1c2b9c224, 0x90a7079403e6a15d
+       data8 0xb6402c7749d621c0, 0xe59f18689a9e4c9a
+       data8 0x90c9e3fbafd63799, 0xb66c1882fb435ea2
+       data8 0xe5d66f04b8a68ecf, 0x90ece216c8a16ee4
+       data8 0xb6982f048c999a56, 0xe60dfb2005c192e9
+       data8 0x9110021e7b516f0a, 0xb6c47044075b4142
+       data8 0xe645bd1544c7ea51, 0x912a708a39be9075
+       data8 0xb6e5bd6bfd02bafd, 0xe66fb21b505b20a0
+       data8 0x914dcc7b31146370, 0xb7124a2736ff8ef2
+       data8 0xe6a7d32af4a7c59a, 0x91714af8cfe984d5
+       data8 0xb73f026a01e94177, 0xe6e02b129c6a5ae4
+       data8 0x918c00a6f3795e97, 0xb760a959f1d0a7a7
+       data8 0xe70a9136a7403039, 0x91afbc299ed0295d
+       data8 0xb78dae7e06868ab0, 0xe74349fb2d92a589
+       data8 0x91d39add3e958db0, 0xb7badff8ad9e4e02
+       data8 0xe77c3a9c86ed7d42, 0x91ee9920a8974d92
+       data8 0xb7dce25b8e17ae9f, 0xe7a713f88151518a
+       data8 0x9212b5fcac537c19, 0xb80a6226904045e2
+       data8 0xe7e067453317ed2b, 0x9236f6b256923fcf
+       data8 0xb8380f1cafd73c1c, 0xe819f37a81871bb5
+       data8 0x92523ee6f90dcfc3, 0xb85a6ea8e321b4d8
+       data8 0xe8454236bfaeca14, 0x9276bef031e6eb79
+       data8 0xb8886b684ae7d2fa, 0xe87f32f24c3fc90e
+       data8 0x929236ec237a24ad, 0xb8ab0726fa00cf5d
+       data8 0xe8aacd8688892ba6, 0x92b6f70b7efe9dc3
+       data8 0xb8d954a4d13b7cb1, 0xe8e523fd32f606f7
+       data8 0x92d29f61eec7dc2b, 0xb8fc2d4f6cd9f04a
+       data8 0xe9110b5311407927, 0x92f7a05d5b8ba92f
+       data8 0xb92acc851476b1ab, 0xe94bc8bf0c108fa3
+       data8 0x931379a403be5c16, 0xb94de2d841a184c2
+       data8 0xe977fdc439c2ca3c, 0x9338bc44de2e3f34
+       data8 0xb97cd4c36c92693c, 0xe9b3236528fc349e
+       data8 0x9354c71412c69486, 0xb9a0297f172665e3
+       data8 0xe9dfa70b745ac1b4, 0x937a4c273907e262
+       data8 0xb9cf6f21e36c3924, 0xea1b36268d0eaa38
+       data8 0x93968919f6e7975d, 0xb9f3030951267208
+       data8 0xea480963fd394197, 0x93bc516fdd4680c9
+       data8 0xba229d6a618e7c59, 0xea84034425f27484
+       data8 0x93d8c123d9be59b2, 0xba467144459f9855
+       data8 0xeab12713138dd1cc, 0x93f546c955e60076
+       data8 0xba6a60c3c48f1a4b, 0xeade6db73a5e503b
+       data8 0x941b70a65879079f, 0xba9a76056b67ee7a
+       data8 0xeb1b0268343b121b, 0x943829f337410591
+       data8 0xbabea699563ada6e, 0xeb489b0b2bdb5f14
+       data8 0x9454f995765bc4d2, 0xbae2f350b262cc4b
+       data8 0xeb765721e85f03d0, 0x947b86b57f5842ed
+       data8 0xbb1385a23be24e57, 0xebb389645f222f62
+       data8 0x94988aeb23470f86, 0xbb3814975e17c680
+       data8 0xebe198f090607e0c, 0x94b5a5dc9695f42a
+       data8 0xbb5cc031009bf467, 0xec0fcc9321024509
+       data8 0x94d2d7a9170d8b42, 0xbb81889680024764
+       data8 0xec3e247da8b82f61, 0x94f9e87dd78bf019
+       data8 0xbbb2c0d8703ae95d, 0xec7c27d21321c9f7
+       data8 0x95175019a503d89e, 0xbbd7cd09ba3c5463
+       data8 0xecaad5278824e453, 0x9534cefa625fcb3a
+       data8 0xbbfcf68c4977718f, 0xecd9a76d097d4e77
+       data8 0x955265405c491a25, 0xbc223d88cfc88eee
+       data8 0xed089ed5dcd99446, 0x9570130c1f9bb857
+       data8 0xbc47a2284fee4ff8, 0xed37bb95add09a1c
+       data8 0x9597ca4119525184, 0xbc79ac0916ed7b8a
+       data8 0xed76c70508f904b6, 0x95b5af6fb5aa4d3c
+       data8 0xbc9f5670d1a13030, 0xeda63bb05e7f93c6
+       data8 0x95d3ac9273aafd7a, 0xbcc51f068cb95c1d
+       data8 0xedd5d661daed2dc4, 0x95f1c1cafdfd3684
+       data8 0xbceb05f4b30a9bc0, 0xee05974eef86b903
+       data8 0x960fef3b430b8d5f, 0xbd110b6604c7d306
+       data8 0xee357ead791fc670, 0x962e350575b409c5
+       data8 0xbd372f8598620f19, 0xee658cb3c134a463
+       data8 0x964c934c0dfc1708, 0xbd5d727edb6b3c7e
+       data8 0xee95c1987f080211, 0x966b0a31c9c6bc7d
+       data8 0xbd83d47d937bbc6d, 0xeec61d92d8c4314f
+       data8 0x968999d9ad8d264e, 0xbdaa55addf1ae47d
+       data8 0xeef6a0da64a014ac, 0x96a8426705198795
+       data8 0xbdd0f63c36aa73f0, 0xef274ba72a07c811
+       data8 0x96c703fd64445ee5, 0xbdf7b6556d550a15
+       data8 0xef581e31a2c91260, 0x96e5dec0a7b4268d
+       data8 0xbe1e9626b1ffa96b, 0xef8918b2bc43aec6
+       data8 0x9704d2d4f59f79f3, 0xbe4595dd903e5371
+       data8 0xefba3b63d89d7cbf, 0x9723e05ebe91b9b0
+       data8 0xbe6cb5a7f14bc935, 0xefeb867ecffaa607
+       data8 0x97430782be323831, 0xbe93f5b41d047cf7
+       data8 0xf01cfa3df1b9c9fa, 0x97624865fc0df8bf
+       data8 0xbebb5630bae4c15f, 0xf04e96dc05b43e2d
+       data8 0x9781a32dcc640b2a, 0xbee2d74cd30a430c
+       data8 0xf0805c944d827454, 0x97a117ffd0f48e46
+       data8 0xbf0a7937cf38d981, 0xf0b24ba285c495cb
+       data8 0x97c0a701f9d263c9, 0xbf323c217be2bc8c
+       data8 0xf0e46442e76f6569, 0x97e0505a8637a036
+       data8 0xbf5a203a09342bbb, 0xf116a6b2291d7896
+       data8 0x97f57a9fb0b08c6e, 0xbf74cad1c14ebfc4
+       data8 0xf1383fa9e9b5b381, 0x9815503365914a9d
+       data8 0xbf9ce6a497a89f78, 0xf16ac84f90083b9b
+       data8 0x98354085054fd204, 0xbfc52428bec6e72f
+       data8 0xf19d7b686dcb03d7, 0x98554bbbf8a77902
+       data8 0xbfed838fddab024b, 0xf1d0593311db1757
+       data8 0x987571fffb7f94f6, 0xc016050c0420981a
+       data8 0xf20361ee8f1c711e, 0x9895b3791dd03c23
+       data8 0xc03ea8cfabddc330, 0xf23695da7de51d3f
+       data8 0x98ab43a5fc65d0c8, 0xc059d3cbd65ddbce
+       data8 0xf258d095e465cc35, 0x98cbb2d196bd713d
+       data8 0xc082b122a3c78c9d, 0xf28c4d0bfc982b34
+       data8 0x98ec3d9ec7b6f21a, 0xc0abb1499ae736c4
+       data8 0xf2bff55eb3f0ea71, 0x990ce436db5e8344
+       data8 0xc0d4d474c3aedaaf, 0xf2f3c9cf9884636e
+       data8 0x9922b8218160967a, 0xc0f054ca33eb3437
+       data8 0xf31670135ab9cc0f, 0x99438d686f75779d
+       data8 0xc119b2c67e600ed0, 0xf34a8e9f0b54cdfb
+       data8 0x99647eea131fa20b, 0xc1433453de2033ff
+       data8 0xf37ed9fa6b8add3f, 0x997a85045a47c6d0
+       data8 0xc15ef3e44e10032d, 0xf3a1cfe884ef6bb6
+       data8 0x999ba5f14f8add02, 0xc188b130431d80e6
+       data8 0xf3d66689dcc8e8d3, 0x99bce38b5465ecae
+       data8 0xc1b2929d6067730e, 0xf40b2ab069d5c96a
+       data8 0x99d31ca0887f30f9, 0xc1ce9268f31cc734
+       data8 0xf42e718b90c8bc16, 0x99f48a669c74c09e
+       data8 0xc1f8b0877c1b0c08, 0xf463822a0a3b4b00
+       data8 0x9a16154eb445c873, 0xc222f35a87b415ba
+       data8 0xf498c1076015faf8, 0x9a2c822ec198d667
+       data8 0xc23f3467349e5c88, 0xf4bc5a19a33990b5
+       data8 0x9a4e3e080cd91b78, 0xc269b4e40e088c01
+       data8 0xf4f1e6a7d6f5425f, 0x9a70177afe52322e
+       data8 0xc2945aac24daaf6e, 0xf527a232cf6be334
+       data8 0x9a86b8fa94eebe10, 0xc2b0de05e43c1d66
+       data8 0xf54b8ecdcda90851, 0x9aa8c42866ae2958
+       data8 0xc2dbc275e1229d09, 0xf5819949c7ad87b4
+       data8 0x9abf86f9e12fc45e, 0xc2f86fca9d80eeff
+       data8 0xf5a5bac9213b48a9, 0x9ae1c462fc05f49d
+       data8 0xc323938449a2587e, 0xf5dc1501f324a812
+       data8 0x9af8a8dc936b84d0, 0xc3406b40a538ed20
+       data8 0xf6006bee86b5589e, 0x9b1b19033be35730
+       data8 0xc36bcee8211d15e0, 0xf63716b2fa067fa4
+       data8 0x9b3da7daf04c2892, 0xc397593adf2ba366
+       data8 0xf66df22fb6132b9c, 0x9b54c2e4c8a9012b
+       data8 0xc3b475b6206155d5, 0xf6929fb98225deb1
+       data8 0x9b77854e6c661200, 0xc3e0410243b97383
+       data8 0xf6c9cd13021e3fea, 0x9b8ec2e678d56d2f
+       data8 0xc3fd890709833d37, 0xf6eeb177472cedae
+       data8 0x9ba60e6a5ca133b6, 0xc41ae295f7e7fa06
+       data8 0xf713abf4cb0b3afb, 0x9bc919ea66a151a4
+       data8 0xc44709f7bb8a4dd2, 0xf74b4d5333684ef1
+       data8 0x9be0887c09ef82bb, 0xc4648fb0e0bec4c1
+       data8 0xf7707f75a72f8e94, 0x9c03c8d5fffc3503
+       data8 0xc490f9a94695ba14, 0xf7a874b97927af44
+       data8 0x9c1b5ad21a81cbb9, 0xc4aeac0173b7d390
+       data8 0xf7cddf140aedf1d8, 0x9c3ed09216e9ca02
+       data8 0xc4db5941007aa853, 0xf806291bacb7f7a9
+       data8 0x9c568656c0423def, 0xc4f938aec206291a
+       data8 0xf82bcc43b92eafef, 0x9c7a320af242ce60
+       data8 0xc52629e899dfd622, 0xf8646bf0defb759e
+       data8 0x9c920bf7a8c01dc2, 0xc54436e44043b965
+       data8 0xf88a487dfc3ff5f7, 0x9ca9f475d98b159c
+       data8 0xc562563abf9ea07f, 0xf8b03c2b46cdc17f
+       data8 0x9ccdeca60e80b5f8, 0xc58fa7d1dc42921c
+       data8 0xf8e95541c152ae7a, 0x9ce5f9d4653d4902
+       data8 0xc5adf561b91e110a, 0xf90f832c2700c160
+       data8 0x9cfe15cb38bfdd8e, 0xc5cc5591bdbd82fa
+       data8 0xf935c88e0c7f419b, 0x9d225b983f6c1f96
+       data8 0xc5fa08f1ff20593c, 0xf96f5cd84fd86873
+       data8 0x9d3a9cca32261ed7, 0xc618980a79ce6862
+       data8 0xf995dd53ebdd9d6d, 0x9d52ecfccebe1768
+       data8 0xc6373a09e34b50fa, 0xf9bc75a034436a41
+       data8 0x9d77818d95b82f86, 0xc66550a6e0baaf35
+       data8 0xf9f686f26d5518de, 0x9d8ff7893fa4706c
+       data8 0xc6842241926342c9, 0xfa1d5b39b910a8c5
+       data8 0x9da87cbef36f2a5e, 0xc6a3070b7c93bb9e
+       data8 0xfa4447acc4ecbfd2, 0x9dcd6140b4a35aeb
+       data8 0xc6d18260bb84081b, 0xfa7ed7e51e6fdfb4
+       data8 0x9de60cd06dc6e2d4, 0xc6f0977c9416828b
+       data8 0xfaa601394d49a1a0, 0x9dfec7d4cc43b76f
+       data8 0xc70fc0117c641630, 0xfacd431644ce0e40
+       data8 0x9e17925ec9fccc4a, 0xc72efc34d7e615be
+       data8 0xfaf49d96f7a75909, 0x9e3cdf6db57dc075
+       data8 0xc75dfb441594141e, 0xfb2fd3c65e562fd5
+       data8 0x9e55d110b63637a8, 0xc77d68aa019bda4c
+       data8 0xfb576c5762024805, 0x9e6ed27594550d2e
+       data8 0xc79ce9ea478dbc4f, 0xfb7f1debc22c4040
+       data8 0x9e87e3adc385d393, 0xc7bc7f1ae453219d
+       data8 0xfba6e89f32d0190a, 0x9ead9b54b37a1055
+       data8 0xc7ec0476e15e141a, 0xfbe2c803a0894893
+       data8 0x9ec6d46a3d7de215, 0xc80bcbe16f1d540f
+       data8 0xfc0ad1ff0ed9ecf0, 0x9ee01d9108be3154
+       data8 0xc82ba78a5d349735, 0xfc32f57bdfbcbe7f
+       data8 0x9ef976db07288d04, 0xc84b978847a06b87
+       data8 0xfc5b32968f99b21c, 0x9f12e05a4759ec25
+       data8 0xc86b9bf1ee817bc6, 0xfc83896bc861ab08
+       data8 0x9f2c5a20f4da6668, 0xc88bb4de3667cdf4
+       data8 0xfcabfa1861ed4815, 0x9f52af78ed1733ca
+       data8 0xc8bc00e7fe9e23a3, 0xfce8d3cea7d3163e
+       data8 0x9f6c52426a39d003, 0xc8dc4d7ff2d25232
+       data8 0xfd118595143ee273, 0x9f860593d42fd7f3
+       data8 0xc8fcaeebcb40eb47, 0xfd3a519943d4865a
+       data8 0x9f9fc97fdb96bd51, 0xc91d25431426a663
+       data8 0xfd6337f8e1ae5a4b, 0x9fb99e194f4a7037
+       data8 0xc93db09d7fdb2949, 0xfd8c38d1c8e927eb
+       data8 0x9fd383731ca51db9, 0xc95e5112e721582a
+       data8 0xfdb5544205095a53, 0x9fed79a04fbf9423
+       data8 0xc97f06bb49787677, 0xfdde8a67d2613531
+       data8 0xa00780b413b24ee8, 0xc99fd1aecd6e1b06
+       data8 0xfe07db619e781611, 0xa02eab2c4474b0cd
+       data8 0xc9d12a3e27bb1625, 0xfe460768d80bf758
+       data8 0xa048dcd51ccfd142, 0xc9f22ad82ba3d5f0
+       data8 0xfe6f9bfb06cd32f6, 0xa0631fa894b11b8d
+       data8 0xca134113105e67b2, 0xfe994bcd3d14fcc2
+       data8 0xa07d73ba65e680af, 0xca346d07b045a876
+       data8 0xfec316fecaf3f2ab, 0xa097d91e6aaf71b0
+       data8 0xca55aecf0e94bb88, 0xfeecfdaf33fadb80
+       data8 0xa0b24fe89e02602f, 0xca77068257be9bab
+       data8 0xff16fffe2fa8fad6, 0xa0ccd82d1bd2f68b
+       data8 0xca98743ae1c693a8, 0xff411e0ba9db886d
+       data8 0xa0e77200215909e6, 0xcab9f8122c99a101
+       data8 0xff6b57f7c33e4e9a, 0xa1021d760d584855
+       data8 0xcadb9221e268c3b5, 0xff95ade2d1bd7358
+       data8 0xa11cdaa36068a57d, 0xcafd4283d8043dfd
+       data8 0xffc01fed60f86fb5, 0xa137a99cbd3f880b
+       data8 0xcb1f09520d37c6fb, 0xffeaae3832b63956
+LOCAL_OBJECT_END(T_table)
+
+
+
+
+
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(cbrtf)
+
+
+{.mfi
+       getf.sig GR_SIGNIF = f8
+       // will continue only for normal/denormal numbers
+       fclass.nm.unc p12, p7 = f8, 0x1b
+       // GR_GP = pointer to C_1, C_2 followed by T_table
+       nop.i 0
+}
+{.mfi
+       addl GR_GP = @ltoff(poly_coeffs), gp
+       // normalize a
+       fma.s1 FR_ARG = f8, f1, f0
+       // GR_CT3 = bias-((2^8-1)/3) -63 = 0xffff-0x55-0x3f = 0xff6b
+       mov GR_CT3 = 0xff6b ;;
+}
+
+{.mmi
+       // get exponent
+       getf.exp GR_ARGEXP = f8
+       // load start address for C_1, C_2 followed by T_table
+       ld8 GR_ADDR = [ GR_GP ]
+       nop.i 0 ;;
+}
+
+{.mlx
+       // check if input significand is 0
+ (p7)  cmp.eq p12, p7 = GR_SIGNIF, r0
+       // GR_2P63 = 2^63
+       movl GR_2P63 = 0x8000000000000000 ;;
+}
+
+{.mfi
+       nop.m 0
+       // y = frcpa(a)
+       // p7 = 1 for normal and denormal (but non-zero) arguments
+ (p7)  frcpa.s0 FR_Y, p0 = f1, f8
+       // p9 = 1 if denormal input
+       cmp.gtu p9, p0 = GR_2P63, GR_SIGNIF
+}
+{.mfb
+       // load C_1
+       ldfe FR_COEFF1 = [ GR_ADDR ], 16
+       // if argument is 0, +/-Infinity, or NaN, return
+ (p12) fma.s.s0 f8 = f8, f1, f0
+ (p12) br.ret.spnt b0 ;;
+}
+
+{.mmi
+       // get normalized significand (for denormal inputs only)
+ (p9)  getf.sig GR_SIGNIF = FR_ARG
+       // load C_2
+       ldfe FR_COEFF2 = [ GR_ADDR ], 16
+       // GR_CT2 = bias-(2^8-1)
+       mov GR_CT2 = 0xff00
+}
+
+{.mii
+       // get exponent (for denormal inputs only)
+ (p9)  getf.exp GR_ARGEXP = FR_ARG
+       nop.i 0
+       mov GR_CONST = 0x20000 ;;
+}
+
+
+{.mii
+       // get GR_SIGN = sign
+       and GR_SIGN = GR_ARGEXP, GR_CONST
+       // eliminate leading 1 from GR_I1 = 1st table index
+       shl GR_I1 = GR_SIGNIF, 1
+       // eliminate sign from exponent
+       andcm GR_EBIAS = GR_ARGEXP, GR_CONST ;;
+}
+
+
+{.mfi
+       // subtract bias from GR_EXP = exponent
+       sub GR_EXP = GR_EBIAS, GR_CT2
+       // r = 1-a*y
+       fnma.s1 FR_R = FR_Y, FR_ARG, f1
+       // GR_IT1 = 1st table index (y_index8 bits)
+       shr.u GR_IT1 = GR_I1, 56 ;;
+}
+
+
+{.mii
+       // 1: exponent* = 5; // (2^{16}-1)/3 = 0x5555
+       shladd GR_E5 = GR_EXP, 2, GR_EXP
+       // GR_IT1_3 = 3*y_index
+       shladd GR_IT1_3 = GR_IT1, 1, GR_IT1
+       nop.i 0 ;;
+}
+
+
+{.mmi
+       // GR_TMP5 = (5*expon)*16+5*expon = (0x55)*expon
+       shladd GR_TMP5 = GR_E5, 4, GR_E5
+       // adjust T_table pointer by 1st index
+       shladd GR_TP1 = GR_IT1_3, 3, GR_ADDR
+       nop.i 0 ;;
+}
+
+
+{.mmi
+       // FR_T0 = T [ 0 ] [ y ]
+       ldf8 FR_T0 = [ GR_TP1 ], 8
+       // get 2^{-63}
+       mov GR_TMP63 = 0xffff + 63
+       // GR_TMP = (0x5500)*expon
+       shl GR_TMP = GR_TMP5, 8 ;;
+}
+
+
+{.mfi
+       // FR_T1 = T [ 1 ] [ y ]
+       ldf8 FR_T1 = [ GR_TP1 ], 8
+       // P_1 = C_1+C_2*r
+       fma.s1 FR_COEFF1 = FR_COEFF2, FR_R, FR_COEFF1
+       // GR_TMP2 = (0x5555)*expon
+       add GR_TMP2 = GR_TMP, GR_TMP5 ;;
+}
+
+
+{.mmi
+       // GR_TMP3 = (0x5556)*expon // 0x5556 = (2^{16}+2)/3
+       add GR_TMP3 = GR_TMP2, GR_EXP ;;
+       // FR_T2 = T [ 2 ] [ y ]
+       ldf8 FR_T2 = [ GR_TP1 ]
+       // GR_EXP3 = floor(expon/3)
+       shr GR_EXP3 = GR_TMP3, 16 ;;
+}
+
+
+{.mmi
+       setf.exp FR_2M63 = GR_TMP63
+       // GR_TMP4 = 3*exponent
+       shladd GR_TMP4 = GR_EXP3, 1, GR_EXP3
+       // bias exponent
+       add GR_EBIAS3 = GR_CT3, GR_EXP3 ;;
+}
+
+
+{.mmf
+       // get remainder of exponent/3
+       sub GR_REM = GR_EXP, GR_TMP4
+       // add sign to exponent
+       or GR_SEXP = GR_EBIAS3, GR_SIGN
+       // P_2 = -r*P_1
+       fnma.s1 FR_R = FR_COEFF1, FR_R, f0 ;;
+}
+
+
+
+{.mmi
+       // FR_ARG = sign*2^{exponent/3}
+       setf.exp FR_ARG = GR_SEXP
+       nop.m 0
+       // remainder = 0 ?
+       // p7=1 if input exponent is 3*j (remainder is 0)
+       cmp.eq.unc p7, p8 = r0, GR_REM ;;
+}
+
+
+{.mfi
+       // remainder = 1 ?
+       // p8=1 if input exponent is 3*j+1 (remainder is 1)
+       // p12=1 if input exponent is 3*j+2 (remainder is 2)
+  (p8) cmp.eq.unc p8, p12 = 1, GR_REM
+       // p7=1 -> remainder = 0 -> use T = FR_T0
+  (p7)  fma.s1 f8 = FR_T0, FR_R, FR_T0
+       // argument is of the form 2^(3*k) ?
+       // ( GR_I1 holds significand bits, without the leading 1)
+       or GR_I1 = GR_I1, GR_REM ;;
+}
+
+
+.pred.rel "mutex", p12, p8
+{.mfi
+       nop.m 0
+       // p8=1 -> remainder = 1 -> use FR_T1
+  (p8) fma.s1 f8 = FR_T1, FR_R, FR_T1
+       // argument is of the form 2^(3*k) ?
+       cmp.eq p14, p7 = GR_I1, r0
+}
+
+
+{.mfi
+       nop.m 0
+       // p12=1 -> remainder=2 -> result = T+T*P_2
+ (p12) fma.s1 f8 = FR_T2, FR_R, FR_T2
+       nop.i 0 ;;
+}
+
+
+.pred.rel "mutex", p14, p7
+{.mfi
+       nop.m 0
+       // if argument is sgn*2^{3*(expon/3)}
+ (p14) fma.s.s0 f8 = FR_2M63, FR_ARG, f0
+       nop.i 0
+}
+{.mfb
+       nop.m 0
+       // T* = sgn*2^{expon/3}
+  (p7) fma.s.s0 f8 = f8, FR_ARG, f0
+       br.ret.sptk b0 ;;
+}
+
+
+GLOBAL_LIBM_END(cbrtf)
+libm_alias_float_other (cbrt, cbrt)
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_cbrtl.S
@@ -0,0 +1,984 @@
+.file "cbrtl.s"
+
+
+// Copyright (c) 2000 - 2004, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 04/28/00 Initial version
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 02/06/03 Reordered header:.section,.global,.proc,.align
+// 11/23/04 Reformatted routine and improved speed
+//
+// API
+//==============================================================
+// long double cbrtl(long double)
+//
+// Overview of operation
+//==============================================================
+// Background
+//
+// Implementation
+//
+// The result is computed as
+// cbrt(x)= cbrt(1 - (1 - x*y)) * (1/cbrt(y))
+// where y = frcpa(x) = (-1)^sgn_y * 2^(3*k+j) * m_y,
+//       m_y in [1,2),  j in {0,1,2}
+//
+//  cbrt(1 - (1 - x*y)) is approximated by a degree-6 polynomial
+//  in r= 1 - x*y :
+// P = 1 - c_1 r - c_2 * r^2 - c_3 * r^3 - c_4 * r^4 - c_5 * r^5 - c_6 * r^6
+//
+//
+// The values (1/cbrt(y)) are stored as two tables of constants T_hi
+// (double-extended precision) and D (single precision) as follows:
+// T_hi (1 + D)= 1/cbrt(y) to about 80 bits of accuracy
+//
+// The tables are only stored for three exponent values (i.e.
+// only for 2^j * m_y, where j in {0,1,2} and m_y covers the 256
+// possible mantissas for an frcpa result); the index is formed
+// by the 8 leading mantissa bits of x, which is the same index used
+// by the hardware to get frcpa(x).
+//
+// The table values are multiplied by 2^k where e is the exponent of
+// the input number.  This multiplication is carried out in parallel with
+// the polynomial evaluation:
+// T= 2^(k) * T_hi
+//
+//=======================================================================
+
+//===============
+// Special values
+//==============================================================
+
+// Registers used
+//==============================================================
+// p6, p7, p12
+           FR_R       =  f6
+           FR_C1      =  f7
+           FR_C2      =  f9
+           FR_C3      =  f10
+           FR_C4      =  f11
+           FR_C5      =  f12
+           FR_C6      =  f13
+           FR_XNORM   =  f14
+           FR_D       =  f15
+           FR_SPECIAL =  f32
+           FR_RCP     =  f33
+           FR_R2      =  f34
+           FR_P1      =  f35
+           FR_P2      =  f36
+           FR_P3      =  f37
+           FR_P4      =  f38
+           FR_P5      =  f39
+           FR_R3      =  f40
+           FR_T       =  f41
+           FR_TF      =  f42
+           FR_P       =  f43
+           FR_SGNEXP  =  f44
+
+           GR_ADDR       = r2
+           GR_C_START    = r2
+           GR_ARGSIG     = r3
+           GR_NORMSIG    = r15
+           GR_D_ADDR     = r16
+           GR_D_START    = r16
+           GR_INDEX2     = r17
+           GR_IX2        = r17
+           GR_NORMEXP    = r18
+           GR_EXP5       = r19
+           GR_EXP3       = r20
+           GR_EXP6       = r20
+           GR_EXP17      = r21
+           GR_TMP1       = r21
+           GR_SGNMASK    = r22
+           GR_T_INDEX    = r23
+           GR_IX_T       = r23
+           GR_IX_D       = r24
+           GR_D_INDEX    = r24
+           GR_TMP2       = r25
+           GR_TMP3       = r25
+           GR_TMP4       = r25
+           GR_EXP_RES    = r26
+           GR_BIAS23     = r27
+           GR_EXPBIAS    = r27
+           GR_EXP_MOD_3  = r28
+           GR_SIGN       = r29
+           GR_EXPSIGNRES = r29
+           GR_REMTMP     = r30
+           GR_NORMEXPSGN = r31
+
+
+// Data tables
+//==============================================================
+
+RODATA
+
+.align 16
+
+LOCAL_OBJECT_START(poly_coeffs)
+
+       data8 0xaaaaaaaaaaaaaab1, 0x00003ffd // C_1
+       data8 0xe38e38e38e38e3e0, 0x00003ffb // C_2
+       data8 0x3faf9add3c0be9a6, 0x3fa511e8d2b1f749 // C_3, C_4
+       data8 0x3f9ee71b2c6ebe99, 0x3f9809180fd0340c // C_5, C_6
+LOCAL_OBJECT_END(poly_coeffs)
+
+
+LOCAL_OBJECT_START(T_table)
+
+       data8 0x80155c748c374836, 0x8040404b0879f7f9
+       data8 0x806b5dce4b405c10, 0x8096b586974669b1
+       data8 0x80bcd273d952a028, 0x80e898c52813f2f3
+       data8 0x81149add67c2d208, 0x813b4e2c856b6e9a
+       data8 0x8167c1dde03de7aa, 0x818ed973b811135e
+       data8 0x81bbc0c33e13ec98, 0x81e33e69fbe7504a
+       data8 0x820aec524e3c23e9, 0x823880f78e70b805
+       data8 0x826097a62a8e5200, 0x8288dfe00e9b5eaf
+       data8 0x82b15a10c5371624, 0x82da06a527b18937
+       data8 0x8302e60b635ab394, 0x832bf8b2feec2f0e
+       data8 0x83553f0ce00e276b, 0x837eb98b50f8322a
+       data8 0x83a270f44c84f699, 0x83cc4d7cfcfac5ca
+       data8 0x83f65f78a8872b4c, 0x8420a75f2f7b53c8
+       data8 0x844510461ff14209, 0x846fbd91b930bed2
+       data8 0x84947e18234f3294, 0x84bf92755825045a
+       data8 0x84e4ac0ee112ba51, 0x8509ef44b86f20be
+       data8 0x85359d5d91768427, 0x855b3bd5b7384357
+       data8 0x858104f0c415f79a, 0x85a6f90390d29864
+       data8 0x85d3772fcd56a1dd, 0x85f9c982fcc002f3
+       data8 0x862047e0e7ea554b, 0x8646f2a26f7f5852
+       data8 0x866dca21754096b5, 0x8694ceb8dfd17a37
+       data8 0x86bc00c49e9307e8, 0x86dccd74fce79610
+       data8 0x870453c845acf90f, 0x872c089a1e90342c
+       data8 0x8753ec4a92d16c5e, 0x877bff3aca19f6b4
+       data8 0x879d88b6fe1c324c, 0x87c5f346dbf98c3a
+       data8 0x87e7c653efacef2c, 0x881089d4e73ffefc
+       data8 0x88397e6a366f2a8a, 0x885bc559e5e1c081
+       data8 0x887e2ee392bb7a93, 0x88a7a8587e404257
+       data8 0x88ca5eda67594784, 0x88f4356166bd590e
+       data8 0x89173a0acf5ce026, 0x893a62a098b6a57b
+       data8 0x895daf637236ae2c, 0x89883b9d1c2fa9c5
+       data8 0x89abd8dd374a5d7b, 0x89cf9b1dcd197fa0
+       data8 0x89f382a258ea79de, 0x8a178faf06648f29
+       data8 0x8a3bc288b3e1d18a, 0x8a601b74f4d1f835
+       data8 0x8a849aba14274764, 0x8aa9409f16cdbc9b
+       data8 0x8ace0d6bbe2cb316, 0x8af301688ab33558
+       data8 0x8b181cdebe6f3206, 0x8b3d60185fafcb7c
+       data8 0x8b62cb603bb2fad0, 0x8b80d7d6bc4104de
+       data8 0x8ba68bf73ac74f39, 0x8bcc68fb9f9f7335
+       data8 0x8bf26f31c534fca2, 0x8c10f86e13a1a1f9
+       data8 0x8c3749916cc6abb5, 0x8c5dc4c4f7706032
+       data8 0x8c7cac3a8c42e3e0, 0x8ca373f1b7bf2716
+       data8 0x8cc29907fb951294, 0x8ce9ae4e9492aac8
+       data8 0x8d0911dddbfdad0e, 0x8d3075c4f20f04ee
+       data8 0x8d5018a9d4de77d5, 0x8d77cc47dd143515
+       data8 0x8d97af6352739cb7, 0x8db7af523167800f
+       data8 0x8ddfd80bc68c32ff, 0x8e00197e1e7c88fe
+       data8 0x8e207859f77e20e7, 0x8e40f4ce60c9f8e2
+       data8 0x8e69ba46cf2fde4d, 0x8e8a7a00bd7ae63e
+       data8 0x8eab57ef1cf2f529, 0x8ecc5442cffb1dad
+       data8 0x8eed6f2d2a4acbfe, 0x8f0ea8dff24441ff
+       data8 0x8f385c95d696b817, 0x8f59dc43edd930f3
+       data8 0x8f7b7b5f5ffad1c4, 0x8f9d3a1bea165f38
+       data8 0x8fbf18adc34b66da, 0x8fe117499e356095
+       data8 0x90033624aa685f8d, 0x9025757495f36b86
+       data8 0x903f3a5dcc091203, 0x9061b2fceb2bdbab
+       data8 0x90844ca7211032a7, 0x90a7079403e6a15d
+       data8 0x90c9e3fbafd63799, 0x90ece216c8a16ee4
+       data8 0x9110021e7b516f0a, 0x912a708a39be9075
+       data8 0x914dcc7b31146370, 0x91714af8cfe984d5
+       data8 0x918c00a6f3795e97, 0x91afbc299ed0295d
+       data8 0x91d39add3e958db0, 0x91ee9920a8974d92
+       data8 0x9212b5fcac537c19, 0x9236f6b256923fcf
+       data8 0x92523ee6f90dcfc3, 0x9276bef031e6eb79
+       data8 0x929236ec237a24ad, 0x92b6f70b7efe9dc3
+       data8 0x92d29f61eec7dc2b, 0x92f7a05d5b8ba92f
+       data8 0x931379a403be5c16, 0x9338bc44de2e3f34
+       data8 0x9354c71412c69486, 0x937a4c273907e262
+       data8 0x93968919f6e7975d, 0x93bc516fdd4680c9
+       data8 0x93d8c123d9be59b2, 0x93f546c955e60076
+       data8 0x941b70a65879079f, 0x943829f337410591
+       data8 0x9454f995765bc4d2, 0x947b86b57f5842ed
+       data8 0x94988aeb23470f86, 0x94b5a5dc9695f42a
+       data8 0x94d2d7a9170d8b42, 0x94f9e87dd78bf019
+       data8 0x95175019a503d89e, 0x9534cefa625fcb3a
+       data8 0x955265405c491a25, 0x9570130c1f9bb857
+       data8 0x9597ca4119525184, 0x95b5af6fb5aa4d3c
+       data8 0x95d3ac9273aafd7a, 0x95f1c1cafdfd3684
+       data8 0x960fef3b430b8d5f, 0x962e350575b409c5
+       data8 0x964c934c0dfc1708, 0x966b0a31c9c6bc7d
+       data8 0x968999d9ad8d264e, 0x96a8426705198795
+       data8 0x96c703fd64445ee5, 0x96e5dec0a7b4268d
+       data8 0x9704d2d4f59f79f3, 0x9723e05ebe91b9b0
+       data8 0x97430782be323831, 0x97624865fc0df8bf
+       data8 0x9781a32dcc640b2a, 0x97a117ffd0f48e46
+       data8 0x97c0a701f9d263c9, 0x97e0505a8637a036
+       data8 0x97f57a9fb0b08c6e, 0x9815503365914a9d
+       data8 0x98354085054fd204, 0x98554bbbf8a77902
+       data8 0x987571fffb7f94f6, 0x9895b3791dd03c23
+       data8 0x98ab43a5fc65d0c8, 0x98cbb2d196bd713d
+       data8 0x98ec3d9ec7b6f21a, 0x990ce436db5e8344
+       data8 0x9922b8218160967a, 0x99438d686f75779d
+       data8 0x99647eea131fa20b, 0x997a85045a47c6d0
+       data8 0x999ba5f14f8add02, 0x99bce38b5465ecae
+       data8 0x99d31ca0887f30f9, 0x99f48a669c74c09e
+       data8 0x9a16154eb445c873, 0x9a2c822ec198d667
+       data8 0x9a4e3e080cd91b78, 0x9a70177afe52322e
+       data8 0x9a86b8fa94eebe10, 0x9aa8c42866ae2958
+       data8 0x9abf86f9e12fc45e, 0x9ae1c462fc05f49d
+       data8 0x9af8a8dc936b84d0, 0x9b1b19033be35730
+       data8 0x9b3da7daf04c2892, 0x9b54c2e4c8a9012b
+       data8 0x9b77854e6c661200, 0x9b8ec2e678d56d2f
+       data8 0x9ba60e6a5ca133b6, 0x9bc919ea66a151a4
+       data8 0x9be0887c09ef82bb, 0x9c03c8d5fffc3503
+       data8 0x9c1b5ad21a81cbb9, 0x9c3ed09216e9ca02
+       data8 0x9c568656c0423def, 0x9c7a320af242ce60
+       data8 0x9c920bf7a8c01dc2, 0x9ca9f475d98b159c
+       data8 0x9ccdeca60e80b5f8, 0x9ce5f9d4653d4902
+       data8 0x9cfe15cb38bfdd8e, 0x9d225b983f6c1f96
+       data8 0x9d3a9cca32261ed7, 0x9d52ecfccebe1768
+       data8 0x9d77818d95b82f86, 0x9d8ff7893fa4706c
+       data8 0x9da87cbef36f2a5e, 0x9dcd6140b4a35aeb
+       data8 0x9de60cd06dc6e2d4, 0x9dfec7d4cc43b76f
+       data8 0x9e17925ec9fccc4a, 0x9e3cdf6db57dc075
+       data8 0x9e55d110b63637a8, 0x9e6ed27594550d2e
+       data8 0x9e87e3adc385d393, 0x9ead9b54b37a1055
+       data8 0x9ec6d46a3d7de215, 0x9ee01d9108be3154
+       data8 0x9ef976db07288d04, 0x9f12e05a4759ec25
+       data8 0x9f2c5a20f4da6668, 0x9f52af78ed1733ca
+       data8 0x9f6c52426a39d003, 0x9f860593d42fd7f3
+       data8 0x9f9fc97fdb96bd51, 0x9fb99e194f4a7037
+       data8 0x9fd383731ca51db9, 0x9fed79a04fbf9423
+       data8 0xa00780b413b24ee8, 0xa02eab2c4474b0cd
+       data8 0xa048dcd51ccfd142, 0xa0631fa894b11b8d
+       data8 0xa07d73ba65e680af, 0xa097d91e6aaf71b0
+       data8 0xa0b24fe89e02602f, 0xa0ccd82d1bd2f68b
+       data8 0xa0e77200215909e6, 0xa1021d760d584855
+       data8 0xa11cdaa36068a57d, 0xa137a99cbd3f880b
+       data8 0xa160019ed37fb4ae, 0xa1960b5966da4608
+       data8 0xa1cc5dbe6dc2aab4, 0xa202f97995b69c0d
+       data8 0xa232fe6eb0c0577d, 0xa26a2582012f6e17
+       data8 0xa2a197e5d10465cb, 0xa2d25a532efefbc8
+       data8 0xa30a5bd6e49e4ab8, 0xa33b9c9b59879e24
+       data8 0xa3742fca6a3c1f21, 0xa3a5f1273887bf22
+       data8 0xa3d7ef508ff11574, 0xa4115ce30548bc15
+       data8 0xa443df0e53df577a, 0xa4769fa5913c0ec3
+       data8 0xa4a99f303bc7def5, 0xa4dcde37779adf4b
+       data8 0xa5105d46152c938a, 0xa5441ce89825cb8d
+       data8 0xa5781dad3e54d899, 0xa5ac602406c4e68c
+       data8 0xa5d9601d95c2c0bc, 0xa60e1e1a2de14745
+       data8 0xa6431f6e3fbd9658, 0xa67864b0d432fda4
+       data8 0xa6a6444aa0243c0b, 0xa6dc094d10f25792
+       data8 0xa70a574cc02bba69, 0xa7409e2af9549084
+       data8 0xa76f5c64ca2cf13b, 0xa79e4f0babab5dc0
+       data8 0xa7d5579ae5164b85, 0xa804bd3c6fe61cc8
+       data8 0xa8345895e5250a5a, 0xa8642a122b44ef0b
+       data8 0xa89c38ca18f6108b, 0xa8cc81063b6e87ca
+       data8 0xa8fd00bfa409285e, 0xa92db8664d5516da
+       data8 0xa95ea86b75cc2c20, 0xa98fd141a4992deb
+       data8 0xa9c1335cae7446ba, 0xa9ea8686f556f645
+       data8 0xaa1c52d17906bb19, 0xaa4e59b046dab887
+       data8 0xaa809b9c60d1890b, 0xaab319102f3f9b33
+       data8 0xaadd5a18c1e21274, 0xab1045f2ac31bdf5
+       data8 0xab3ae3ab2df7231e, 0xab6e3f945d1e96fc
+       data8 0xaba1d953a08fa94e, 0xabcd090db7ef4c3f
+       data8 0xabf864602d7c323d, 0xac2ca5886ccf9b57
+       data8 0xac5861d4aa441f0f, 0xac8d183fe3a2fbed
+       data8 0xacb93703ff51571e, 0xace5830ad0c3f14b
+       data8 0xad11fca5d78b3ff2, 0xad4797fddf91a798
+       data8 0xad747701e559ebcb, 0xada184a47e9c7613
+       data8 0xadcec13ab0dda8ff, 0xadfc2d1a5fd21ba8
+       data8 0xae29c89a5053c33a, 0xae5794122b638df9
+       data8 0xae858fda8137ae0a, 0xaeb3bc4ccc56d3d1
+       data8 0xaee219c374c09920, 0xaf10a899d3235fe7
+       data8 0xaf3f692c341fe8b4, 0xaf6e5bd7db9ae6c2
+       data8 0xaf9d80fb081cd91b, 0xafc35ce063eb3787
+       data8 0xaff2ddcb5f28f03d, 0xb022923b148e05c5
+       data8 0xb0527a919adbf58b, 0xb078f3ab1d701c65
+       data8 0xb0a93a6870649f31, 0xb0d9b624d62ec856
+       data8 0xb100a5f53fb3c8e1, 0xb131821882f5540a
+       data8 0xb158bf8e4cb04055, 0xb189fd69d56b238f
+       data8 0xb1b189958e8108e4, 0xb1e32a8165b09832
+       data8 0xb20b0678fc271eec, 0xb23d0bd3f7592b6e
+       data8 0xb26538b2db8420dc, 0xb28d89e339ceca14
+       data8 0xb2c022ca12e55a16, 0xb2e8c6852c6b03f1
+       data8 0xb3118f4eda9fe40f, 0xb33a7d6268109ebe
+       data8 0xb36ddbc5ea70ec55, 0xb3971e9b39264023
+       data8 0xb3c0877ecc18e24a, 0xb3ea16ae3a6c905f
+       data8 0xb413cc67aa0e4d2d, 0xb43da8e9d163e1af
+       data8 0xb47233773b84d425, 0xb49c6825430fe730
+       data8 0xb4c6c46bcdb27dcf, 0xb4f1488c0b35d26f
+       data8 0xb51bf4c7c51f0168, 0xb546c9616087ab9c
+       data8 0xb571c69bdffd9a70, 0xb59cecbae56984c3
+       data8 0xb5bd64512bb14bb7, 0xb5e8d2a4bf5ba416
+       data8 0xb6146a9a1bc47819, 0xb6402c7749d621c0
+       data8 0xb66c1882fb435ea2, 0xb6982f048c999a56
+       data8 0xb6c47044075b4142, 0xb6e5bd6bfd02bafd
+       data8 0xb7124a2736ff8ef2, 0xb73f026a01e94177
+       data8 0xb760a959f1d0a7a7, 0xb78dae7e06868ab0
+       data8 0xb7badff8ad9e4e02, 0xb7dce25b8e17ae9f
+       data8 0xb80a6226904045e2, 0xb8380f1cafd73c1c
+       data8 0xb85a6ea8e321b4d8, 0xb8886b684ae7d2fa
+       data8 0xb8ab0726fa00cf5d, 0xb8d954a4d13b7cb1
+       data8 0xb8fc2d4f6cd9f04a, 0xb92acc851476b1ab
+       data8 0xb94de2d841a184c2, 0xb97cd4c36c92693c
+       data8 0xb9a0297f172665e3, 0xb9cf6f21e36c3924
+       data8 0xb9f3030951267208, 0xba229d6a618e7c59
+       data8 0xba467144459f9855, 0xba6a60c3c48f1a4b
+       data8 0xba9a76056b67ee7a, 0xbabea699563ada6e
+       data8 0xbae2f350b262cc4b, 0xbb1385a23be24e57
+       data8 0xbb3814975e17c680, 0xbb5cc031009bf467
+       data8 0xbb81889680024764, 0xbbb2c0d8703ae95d
+       data8 0xbbd7cd09ba3c5463, 0xbbfcf68c4977718f
+       data8 0xbc223d88cfc88eee, 0xbc47a2284fee4ff8
+       data8 0xbc79ac0916ed7b8a, 0xbc9f5670d1a13030
+       data8 0xbcc51f068cb95c1d, 0xbceb05f4b30a9bc0
+       data8 0xbd110b6604c7d306, 0xbd372f8598620f19
+       data8 0xbd5d727edb6b3c7e, 0xbd83d47d937bbc6d
+       data8 0xbdaa55addf1ae47d, 0xbdd0f63c36aa73f0
+       data8 0xbdf7b6556d550a15, 0xbe1e9626b1ffa96b
+       data8 0xbe4595dd903e5371, 0xbe6cb5a7f14bc935
+       data8 0xbe93f5b41d047cf7, 0xbebb5630bae4c15f
+       data8 0xbee2d74cd30a430c, 0xbf0a7937cf38d981
+       data8 0xbf323c217be2bc8c, 0xbf5a203a09342bbb
+       data8 0xbf74cad1c14ebfc4, 0xbf9ce6a497a89f78
+       data8 0xbfc52428bec6e72f, 0xbfed838fddab024b
+       data8 0xc016050c0420981a, 0xc03ea8cfabddc330
+       data8 0xc059d3cbd65ddbce, 0xc082b122a3c78c9d
+       data8 0xc0abb1499ae736c4, 0xc0d4d474c3aedaaf
+       data8 0xc0f054ca33eb3437, 0xc119b2c67e600ed0
+       data8 0xc1433453de2033ff, 0xc15ef3e44e10032d
+       data8 0xc188b130431d80e6, 0xc1b2929d6067730e
+       data8 0xc1ce9268f31cc734, 0xc1f8b0877c1b0c08
+       data8 0xc222f35a87b415ba, 0xc23f3467349e5c88
+       data8 0xc269b4e40e088c01, 0xc2945aac24daaf6e
+       data8 0xc2b0de05e43c1d66, 0xc2dbc275e1229d09
+       data8 0xc2f86fca9d80eeff, 0xc323938449a2587e
+       data8 0xc3406b40a538ed20, 0xc36bcee8211d15e0
+       data8 0xc397593adf2ba366, 0xc3b475b6206155d5
+       data8 0xc3e0410243b97383, 0xc3fd890709833d37
+       data8 0xc41ae295f7e7fa06, 0xc44709f7bb8a4dd2
+       data8 0xc4648fb0e0bec4c1, 0xc490f9a94695ba14
+       data8 0xc4aeac0173b7d390, 0xc4db5941007aa853
+       data8 0xc4f938aec206291a, 0xc52629e899dfd622
+       data8 0xc54436e44043b965, 0xc562563abf9ea07f
+       data8 0xc58fa7d1dc42921c, 0xc5adf561b91e110a
+       data8 0xc5cc5591bdbd82fa, 0xc5fa08f1ff20593c
+       data8 0xc618980a79ce6862, 0xc6373a09e34b50fa
+       data8 0xc66550a6e0baaf35, 0xc6842241926342c9
+       data8 0xc6a3070b7c93bb9e, 0xc6d18260bb84081b
+       data8 0xc6f0977c9416828b, 0xc70fc0117c641630
+       data8 0xc72efc34d7e615be, 0xc75dfb441594141e
+       data8 0xc77d68aa019bda4c, 0xc79ce9ea478dbc4f
+       data8 0xc7bc7f1ae453219d, 0xc7ec0476e15e141a
+       data8 0xc80bcbe16f1d540f, 0xc82ba78a5d349735
+       data8 0xc84b978847a06b87, 0xc86b9bf1ee817bc6
+       data8 0xc88bb4de3667cdf4, 0xc8bc00e7fe9e23a3
+       data8 0xc8dc4d7ff2d25232, 0xc8fcaeebcb40eb47
+       data8 0xc91d25431426a663, 0xc93db09d7fdb2949
+       data8 0xc95e5112e721582a, 0xc97f06bb49787677
+       data8 0xc99fd1aecd6e1b06, 0xc9d12a3e27bb1625
+       data8 0xc9f22ad82ba3d5f0, 0xca134113105e67b2
+       data8 0xca346d07b045a876, 0xca55aecf0e94bb88
+       data8 0xca77068257be9bab, 0xca98743ae1c693a8
+       data8 0xcab9f8122c99a101, 0xcadb9221e268c3b5
+       data8 0xcafd4283d8043dfd, 0xcb1f09520d37c6fb
+       data8 0xcb51ddcb9e93095e, 0xcb95f333968ad59b
+       data8 0xcbda64292d3ffd97, 0xcc1f3184af961596
+       data8 0xcc5bb1ac954d33e2, 0xcca12e9831fc6402
+       data8 0xcce70a67b64f24ad, 0xcd24794726477ea5
+       data8 0xcd6b096a0b70ee87, 0xcda9177738b15a90
+       data8 0xcdf05f2247dffab9, 0xce2f0f347f96f906
+       data8 0xce6e0be0cd551a61, 0xceb666b2c347d1de
+       data8 0xcef609b0cb874f00, 0xcf35fb5447e5c765
+       data8 0xcf763c47ee869f00, 0xcfb6cd3888d71785
+       data8 0xcff7aed4fbfbb447, 0xd038e1ce5167e3c6
+       data8 0xd07a66d7bfa0ebba, 0xd0bc3ea6b32d1b21
+       data8 0xd0f4f0e8f36c1bf8, 0xd1376458e34b037e
+       data8 0xd17a2ca133f78572, 0xd1bd4a80301c5715
+       data8 0xd1f71682b2fa4575, 0xd23ad555f773f059
+       data8 0xd2752c7039a5bf73, 0xd2b98ee008c06b59
+       data8 0xd2f4735ffd700280, 0xd32f99ed6d9ac0e1
+       data8 0xd374f0666c75d51c, 0xd3b0a7d13618e4a1
+       data8 0xd3eca2ea53bcec0c, 0xd428e23874f13a17
+       data8 0xd46f82fe293bc6d3, 0xd4ac57e9b7186420
+       data8 0xd4e972becb04e8b8, 0xd526d40a7a9b43a3
+       data8 0xd5647c5b73917370, 0xd5a26c4201bd6d13
+       data8 0xd5e0a45015350a7e, 0xd614b539c6194104
+       data8 0xd6537310e224283f, 0xd6927ab62244c917
+       data8 0xd6d1ccc1fc4ef4b7, 0xd71169cea98fdded
+       data8 0xd746a66a5bc9f6d9, 0xd786ce8f0fae5317
+       data8 0xd7bc7ff214c4e75a, 0xd7fd35467a517ed1
+       data8 0xd83e38838648d815, 0xd874a1db598b8951
+       data8 0xd8ab42205b80edaf, 0xd8ed1849d202f965
+       data8 0xd92432bd5a173685, 0xd9669ca45b03c23e
+       data8 0xd99e3327cf89574e, 0xd9d602b19b100466
+       data8 0xda0e0ba86c096841, 0xda5195fcdb1c3dce
+       data8 0xda8a1eb87a491f6c, 0xdac2e230b91c3f84
+       data8 0xdafbe0d0b66aea30, 0xdb351b04a8fafced
+       data8 0xdb6e9139e33cdd8e, 0xdba843ded7151ea1
+       data8 0xdbe2336319b61fc8, 0xdc1c60376789fa68
+       data8 0xdc56cacda82d0cd5, 0xdc917398f2797814
+       data8 0xdccc5b0d90a3e628, 0xdd0781a10469f0f2
+       data8 0xdd42e7ca0b52838f, 0xdd729ad01c69114d
+       data8 0xddae749c001fbf5e, 0xddea8f50a51c69b1
+       data8 0xde26eb69a0f0f111, 0xde576480262399bc
+       data8 0xde943789645933c8, 0xded14d58139a28af
+       data8 0xdf025c00bbf2b5c7, 0xdf3feb44d723a713
+       data8 0xdf715bc16c159be0, 0xdfaf66240e29cda8
+       data8 0xdfe139cbf6e19bdc, 0xe01fc0fe94d9fc52
+       data8 0xe051f92ffcc0bd60, 0xe090feec9c9a06ac
+       data8 0xe0c39d0c9ff862d6, 0xe0f668eeb99f188d
+       data8 0xe1362890eb663139, 0xe1695c7212aecbaa
+       data8 0xe19cbf0391bbbbe9, 0xe1d050901c531e85
+       data8 0xe2110903b4f4047a, 0xe2450559b4d80b6d
+       data8 0xe27931a231554ef3, 0xe2ad8e2ac3c5b04b
+       data8 0xe2e21b41b9694cce, 0xe316d93615862714
+       data8 0xe3590bd86a0d30f9, 0xe38e38e38e38e38e
+       data8 0xe3c397d1e6db7839, 0xe3f928f5953feb9e
+       data8 0xe42eeca17c62886c, 0xe464e32943446305
+       data8 0xe49b0ce15747a8a2, 0xe4d16a1eee94e9d4
+       data8 0xe4fa52107353f67d, 0xe5310a471f4d2dc3
+       data8 0xe567f6f1c2b9c224, 0xe59f18689a9e4c9a
+       data8 0xe5d66f04b8a68ecf, 0xe60dfb2005c192e9
+       data8 0xe645bd1544c7ea51, 0xe66fb21b505b20a0
+       data8 0xe6a7d32af4a7c59a, 0xe6e02b129c6a5ae4
+       data8 0xe70a9136a7403039, 0xe74349fb2d92a589
+       data8 0xe77c3a9c86ed7d42, 0xe7a713f88151518a
+       data8 0xe7e067453317ed2b, 0xe819f37a81871bb5
+       data8 0xe8454236bfaeca14, 0xe87f32f24c3fc90e
+       data8 0xe8aacd8688892ba6, 0xe8e523fd32f606f7
+       data8 0xe9110b5311407927, 0xe94bc8bf0c108fa3
+       data8 0xe977fdc439c2ca3c, 0xe9b3236528fc349e
+       data8 0xe9dfa70b745ac1b4, 0xea1b36268d0eaa38
+       data8 0xea480963fd394197, 0xea84034425f27484
+       data8 0xeab12713138dd1cc, 0xeade6db73a5e503b
+       data8 0xeb1b0268343b121b, 0xeb489b0b2bdb5f14
+       data8 0xeb765721e85f03d0, 0xebb389645f222f62
+       data8 0xebe198f090607e0c, 0xec0fcc9321024509
+       data8 0xec3e247da8b82f61, 0xec7c27d21321c9f7
+       data8 0xecaad5278824e453, 0xecd9a76d097d4e77
+       data8 0xed089ed5dcd99446, 0xed37bb95add09a1c
+       data8 0xed76c70508f904b6, 0xeda63bb05e7f93c6
+       data8 0xedd5d661daed2dc4, 0xee05974eef86b903
+       data8 0xee357ead791fc670, 0xee658cb3c134a463
+       data8 0xee95c1987f080211, 0xeec61d92d8c4314f
+       data8 0xeef6a0da64a014ac, 0xef274ba72a07c811
+       data8 0xef581e31a2c91260, 0xef8918b2bc43aec6
+       data8 0xefba3b63d89d7cbf, 0xefeb867ecffaa607
+       data8 0xf01cfa3df1b9c9fa, 0xf04e96dc05b43e2d
+       data8 0xf0805c944d827454, 0xf0b24ba285c495cb
+       data8 0xf0e46442e76f6569, 0xf116a6b2291d7896
+       data8 0xf1383fa9e9b5b381, 0xf16ac84f90083b9b
+       data8 0xf19d7b686dcb03d7, 0xf1d0593311db1757
+       data8 0xf20361ee8f1c711e, 0xf23695da7de51d3f
+       data8 0xf258d095e465cc35, 0xf28c4d0bfc982b34
+       data8 0xf2bff55eb3f0ea71, 0xf2f3c9cf9884636e
+       data8 0xf31670135ab9cc0f, 0xf34a8e9f0b54cdfb
+       data8 0xf37ed9fa6b8add3f, 0xf3a1cfe884ef6bb6
+       data8 0xf3d66689dcc8e8d3, 0xf40b2ab069d5c96a
+       data8 0xf42e718b90c8bc16, 0xf463822a0a3b4b00
+       data8 0xf498c1076015faf8, 0xf4bc5a19a33990b5
+       data8 0xf4f1e6a7d6f5425f, 0xf527a232cf6be334
+       data8 0xf54b8ecdcda90851, 0xf5819949c7ad87b4
+       data8 0xf5a5bac9213b48a9, 0xf5dc1501f324a812
+       data8 0xf6006bee86b5589e, 0xf63716b2fa067fa4
+       data8 0xf66df22fb6132b9c, 0xf6929fb98225deb1
+       data8 0xf6c9cd13021e3fea, 0xf6eeb177472cedae
+       data8 0xf713abf4cb0b3afb, 0xf74b4d5333684ef1
+       data8 0xf7707f75a72f8e94, 0xf7a874b97927af44
+       data8 0xf7cddf140aedf1d8, 0xf806291bacb7f7a9
+       data8 0xf82bcc43b92eafef, 0xf8646bf0defb759e
+       data8 0xf88a487dfc3ff5f7, 0xf8b03c2b46cdc17f
+       data8 0xf8e95541c152ae7a, 0xf90f832c2700c160
+       data8 0xf935c88e0c7f419b, 0xf96f5cd84fd86873
+       data8 0xf995dd53ebdd9d6d, 0xf9bc75a034436a41
+       data8 0xf9f686f26d5518de, 0xfa1d5b39b910a8c5
+       data8 0xfa4447acc4ecbfd2, 0xfa7ed7e51e6fdfb4
+       data8 0xfaa601394d49a1a0, 0xfacd431644ce0e40
+       data8 0xfaf49d96f7a75909, 0xfb2fd3c65e562fd5
+       data8 0xfb576c5762024805, 0xfb7f1debc22c4040
+       data8 0xfba6e89f32d0190a, 0xfbe2c803a0894893
+       data8 0xfc0ad1ff0ed9ecf0, 0xfc32f57bdfbcbe7f
+       data8 0xfc5b32968f99b21c, 0xfc83896bc861ab08
+       data8 0xfcabfa1861ed4815, 0xfce8d3cea7d3163e
+       data8 0xfd118595143ee273, 0xfd3a519943d4865a
+       data8 0xfd6337f8e1ae5a4b, 0xfd8c38d1c8e927eb
+       data8 0xfdb5544205095a53, 0xfdde8a67d2613531
+       data8 0xfe07db619e781611, 0xfe460768d80bf758
+       data8 0xfe6f9bfb06cd32f6, 0xfe994bcd3d14fcc2
+       data8 0xfec316fecaf3f2ab, 0xfeecfdaf33fadb80
+       data8 0xff16fffe2fa8fad6, 0xff411e0ba9db886d
+       data8 0xff6b57f7c33e4e9a, 0xff95ade2d1bd7358
+       data8 0xffc01fed60f86fb5, 0xffeaae3832b63956
+LOCAL_OBJECT_END(T_table)
+
+
+LOCAL_OBJECT_START(D_table)
+
+       data4 0x1e50f488, 0x1ebdc559, 0x1e649ec1, 0x9eed9b2c
+       data4 0x9e511c44, 0x9ec6d551, 0x9eefe248, 0x9e313854
+       data4 0x9f54ff18, 0x9d231411, 0x1ee5d63c, 0x9edf6b95
+       data4 0x9f332aaa, 0x1dc92a84, 0x1f73fb7b, 0x1e32f100
+       data4 0x9ea636f5, 0x9f6c3353, 0x9f405552, 0x1f33fd97
+       data4 0x1e975291, 0x9e59a11e, 0x1e47b0ba, 0x9d8ad33e
+       data4 0x1ea51bf6, 0x1f25d782, 0x9ecf534d, 0x1f55436f
+       data4 0x1d0975e4, 0x9f0633a1, 0x1f3e840a, 0x1f523a4c
+       data4 0x9f53cbbc, 0x9c8b5661, 0x9f6bc8eb, 0x1f4f6c7b
+       data4 0x9ed9b376, 0x9f5b30b6, 0x1f64fa5e, 0x1cbcc3e0
+       data4 0x1f343548, 0x1f62a6a2, 0x9f336abb, 0x9f1d15af
+       data4 0x1f476c83, 0x1ea86421, 0x1f33b2cf, 0x9e8f1348
+       data4 0x1f6fa829, 0x9f30ee3a, 0x9ebd6146, 0x1f2db598
+       data4 0x1ef9600d, 0x1f5b1427, 0x9edd741b, 0x1f51ef4e
+       data4 0x9f1aa57d, 0x9ee9b5e0, 0x9f17ecd7, 0x1ead71ff
+       data4 0x1f6c910e, 0x9e1837df, 0x9f0f17d9, 0x9e8350dd
+       data4 0x9d292f1b, 0x9e33b3ab, 0x9d6f0fe8, 0x9ed8c7cc
+       data4 0x9ec598c8, 0x9d56758c, 0x1e090c1e, 0x9ed4b941
+       data4 0x9f1fc4cf, 0x1f63513a, 0x9edd0abc, 0x1e3924dd
+       data4 0x1f60d56f, 0x1ea84424, 0x9e88f4fb, 0x1f205c09
+       data4 0x1ec9ae4e, 0x1d2d5738, 0x9f2c9f6d, 0x1e0765c2
+       data4 0x1e8bbdd7, 0x9f16d9f1, 0x9ea62627, 0x1f13904c
+       data4 0x1e566ab8, 0x9dca3d1a, 0x9e91f2a1, 0x9f14641c
+       data4 0x9f278946, 0x1f490c1e, 0x1f575eb6, 0x1f50b3fd
+       data4 0x9da32efb, 0x1ea95e59, 0x9e41e058, 0x9eada15f
+       data4 0x9e4fe66c, 0x1f3abc98, 0x1f1b8d1e, 0x9ece97e4
+       data4 0x1d188aed, 0x9e89b6ee, 0x1f287478, 0x9e8a161a
+       data4 0x1e4749f7, 0x9e68084a, 0x1e867f33, 0x9f462b63
+       data4 0x1db30792, 0x1f59a767, 0x9d1da4ae, 0x9f472a33
+       data4 0x1d1e91cd, 0x9f414824, 0x9f473d4f, 0x1f4b5783
+       data4 0x9f5b04b8, 0x9f5c205b, 0x1f309617, 0x9f0d6852
+       data4 0x9d96a609, 0x9f0965c2, 0x9e23f467, 0x9f089884
+       data4 0x9ec71458, 0x9ed6e955, 0x1e5e8691, 0x1f5b2bbc
+       data4 0x9f128268, 0x1ed40f5b, 0x1dc430ce, 0x1f345986
+       data4 0x1d778f72, 0x1e9b11d6, 0x9f5a40be, 0x9e07f61a
+       data4 0x9ed641a7, 0x9f334787, 0x1e952fd0, 0x1edeb5e2
+       data4 0x9e9f3eb1, 0x9e379fd9, 0x1f13102a, 0x9e5e80e1
+       data4 0x1c757944, 0x1dae2260, 0x1f183ab7, 0x1e55d576
+       data4 0x9e6bb99f, 0x9f52d7cb, 0x9e73a0f5, 0x1d4e1d14
+       data4 0x9dd05b53, 0x1f2261e4, 0x9d4ee73d, 0x1ede515e
+       data4 0x1f22a573, 0x9ecac348, 0x1e6a2ac0, 0x1e2787d2
+       data4 0x9eb64b87, 0x1f0c69c6, 0x9f470a01, 0x9d7c1686
+       data4 0x1e468ebe, 0x9f21ee2f, 0x9ee52116, 0x9e20f715
+       data4 0x1ed18533, 0x9f005b38, 0x9f20cb95, 0x1da72967
+       data4 0x1f1ba5d7, 0x1e2f8b16, 0x9c794f96, 0x9ca74ea3
+       data4 0x1f410555, 0x9eff2b96, 0x1ce8f0b1, 0x1f0cee77
+       data4 0x1f191edd, 0x9ed5fcbc, 0x1f30f242, 0x9e0ad369
+       data4 0x1ed8f3c8, 0x1f52bb0e, 0x9e9ce408, 0x1f18907f
+       data4 0x9ecdad40, 0x9e8af91d, 0x1d46698a, 0x9f4b93d6
+       data4 0x9f3f5d33, 0x1e2e52f7, 0x9f13aeec, 0x9f3b1969
+       data4 0x1f0996f4, 0x9f2a03df, 0x1e264767, 0x1f3ab1fb
+       data4 0x9f3193c9, 0x9f21ce22, 0x9eab624c, 0x9ecd8fb1
+       data4 0x1eaf9a85, 0x1f0c6a2c, 0x1eecbe61, 0x1f3fead9
+       data4 0x1f1d3a29, 0x1e9099ce, 0x1eadd875, 0x1e4dbfb8
+       data4 0x9dc640d2, 0x1f413680, 0x9f3f57b3, 0x1dfa1553
+       data4 0x1ec71c6b, 0x1e00cc00, 0x9f271e55, 0x1e5a88bb
+       data4 0x1f46cc2b, 0x1ee80ff9, 0x9e29c6f3, 0x1f15e229
+       data4 0x9ea83d66, 0x1f37408e, 0x9dacb66e, 0x1e6f6259
+       data4 0x9f106973, 0x1dd4e5ac, 0x1cbfdcc8, 0x9f231c9f
+       data4 0x9e8677e4, 0x9e9e695a, 0x1efd782b, 0x9dd26959
+       data4 0x9e80af69, 0x1f386fb3, 0x1f022e8c, 0x9e839967
+       data4 0x1ce6796f, 0x1e4c22c2, 0x1e57ef24, 0x1e919804
+       data4 0x9d7ea090, 0x1e40140a, 0x1f261b46, 0x1db75be2
+       data4 0x1f145019, 0x9e3102b9, 0x9e22507b, 0x1eae813c
+       data4 0x1f117e97, 0x1f282296, 0x1f3814b3, 0x1e17977b
+       data4 0x1f39d6ff, 0x9f1c81b9, 0x9eb5bcad, 0x1f0f596e
+       data4 0x1e757fd5, 0x9f090daa, 0x9f2532fc, 0x9eebafbb
+       data4 0x1f086556, 0x9eeedde8, 0x9f32e174, 0x1e33c030
+       data4 0x1f1f145a, 0x1e6e556c, 0x1e419ffb, 0x9eb6019a
+       data4 0x9e872a2e, 0x1e113136, 0x1e93096f, 0x1f39be40
+       data4 0x1f1665ad, 0x9db81d7d, 0x9cd29091, 0x1e3f4af7
+       data4 0x9f23176c, 0x9eccf9b3, 0x1f34fc6c, 0x9ed36894
+       data4 0x1ef08e06, 0x9f3b46bb, 0x9f2c850b, 0x1f1565a4
+       data4 0x1e887bc3, 0x1e92629c, 0x9f11ac9e, 0x9e5579f3
+       data4 0x1e4d5790, 0x9ee1c3d1, 0x9e916aec, 0x9eb8d9b8
+       data4 0x1db46105, 0x1e168663, 0x1f26a942, 0x9f0f0383
+       data4 0x9f079032, 0x9ecae1d8, 0x1ed3b34c, 0x9edc5ee6
+       data4 0x9e8a75a7, 0x1f3c3de2, 0x9ee5041e, 0x1f08c727
+       data4 0x1d02d7ae, 0x9f36adda, 0x9ef9a857, 0x9ef5cb3a
+       data4 0x9eee73da, 0x9da5d629, 0x1e0e99be, 0x1e5159b9
+       data4 0x1f2eac89, 0x9e8eedc5, 0x1dd0ec90, 0x1f229aff
+       data4 0x1ed9c3e6, 0x1e95c55a, 0x9f0c24e4, 0x1e8afed6
+       data4 0x1e599a96, 0x1e881b21, 0x1eab84b9, 0x9ba2bb0e
+       data4 0x9e33ab10, 0x1f1710b5, 0x1ebfa271, 0x9e90bbc5
+       data4 0x9f32515b, 0x9b32aae8, 0x1eda455c, 0x1da8186e
+       data4 0x9e8917ff, 0x1ec4d08e, 0x1c90069d, 0x9f2f1d29
+       data4 0x9ecee86d, 0x9f234d1f, 0x1f370724, 0x1da87496
+       data4 0x1e7959f0, 0x9e8ada34, 0x1f1c7f6f, 0x1edd576b
+       data4 0x9de91e8b, 0x1ec4ef89, 0x1f32078a, 0x1e9925e2
+       data4 0x9d8eeccb, 0x9ea3d011, 0x1f231fdf, 0x9f1dbdfa
+       data4 0x1e7507a3, 0x1ec42614, 0x9e8693cb, 0x9ec68398
+       data4 0x1d5b05fb, 0x1de32119, 0x9f003429, 0x9ec16d92
+       data4 0x9f095315, 0x9f119d2c, 0x9ed0c984, 0x9f090662
+       data4 0x9e59aa1f, 0x9ed4e64a, 0x9f2798a7, 0x9f23624d
+       data4 0x1e0467d9, 0x1f22e7e7, 0x1e915256, 0x9cb4df70
+       data4 0x9e6f687c, 0x9e3c35e5, 0x9e5757ab, 0x9f031fa1
+       data4 0x1f25bff7, 0x1f0e58c2, 0x1ef3ce04, 0x1f002ecb
+       data4 0x9ebdc836, 0x9ed657dd, 0x9f149441, 0x9e8544b2
+       data4 0x1cd8ff1e, 0x1e9bb463, 0x1eaa1c5c, 0x1f200c1a
+       data4 0x1edbfbaf, 0x1f18724d, 0x9ed63c22, 0x9f08e045
+       data4 0x1f13ad07, 0x9e949311, 0x9f0c50d4, 0x1e824516
+       data4 0x1d5e52ba, 0x1d583fbd, 0x1e3b60a9, 0x9effe6d3
+       data4 0x1f0d0508, 0x1f00be77, 0x9e404bfa, 0x9e1ca381
+       data4 0x9f084dd8, 0x9e6db85d, 0x1db698e4, 0x9ebd1871
+       data4 0x9ecc2679, 0x1ee68442, 0x1edb1050, 0x9dbc96a4
+       data4 0x9f27c1f4, 0x1c99b756, 0x1eb4400a, 0x9f24390a
+       data4 0x1d927875, 0x9f074faa, 0x1e9dc2c3, 0x1f13c0d2
+       data4 0x1e3c9685, 0x9e6b6f75, 0x9db9cb31, 0x1ea5f3aa
+       data4 0x9d992c61, 0x1f1015e4, 0x1f194f70, 0x9e19d2b3
+       data4 0x9d89116c, 0x1f23cd35, 0x1e33d3a2, 0x1ee331b8
+       data4 0x1d5ba7ec, 0x9f273788, 0x9e6907f4, 0x9ed5f912
+       data4 0x9edd458d, 0x1e2ca7b2, 0x1ef81fe4, 0x1dc7ade6
+       data4 0x1e876e51, 0x9f04ec89, 0x1f1da63a, 0x1ec02bd0
+       data4 0x9e71326f, 0x1e7847b4, 0x1f0de618, 0x9e036cb6
+       data4 0x1eec61e2, 0x1ef1758b, 0x9ee880a3, 0x1ed269d7
+       data4 0x1e27edd3, 0x9e8a81a1, 0x1eacb84d, 0x9e1aad37
+       data4 0x1f1aa8f7, 0x1e9bbd90, 0x1ea1b61f, 0x9ed41c2f
+       data4 0x1dbb5dd6, 0x1f0ec733, 0x9df06b1b, 0x1e06fef1
+       data4 0x9edede3a, 0x1edeb5e2, 0x1f0e63ee, 0x9db316bb
+       data4 0x9efc1ad3, 0x1f01fbb5, 0x9cc0d078, 0x1ea28b36
+       data4 0x9e9dd205, 0x9e791534, 0x1da1c8d5, 0x9e8195cc
+       data4 0x1f0681a4, 0x1eeaf1e2, 0x9ef83b37, 0x9f22a92b
+       data4 0x1eabc4ce, 0x1f10eefb, 0x1e06d9aa, 0x1e7cacd5
+       data4 0x1f1ea087, 0x1eb21983, 0x9f100c78, 0x1e840abe
+       data4 0x9efab66c, 0x1f183fa8, 0x9e84ee68, 0x9eea083d
+       data4 0x9ee23a74, 0x1f1351d7, 0x9ec5d42a, 0x9f071f57
+       data4 0x9ef578d9, 0x9f1aa7e7, 0x1eb02044, 0x1f151a2e
+       data4 0x9c0dc8b2, 0x9ef4087a, 0x1ec12b93, 0x1c1a946b
+       data4 0x1e89946f, 0x9dafe8c3, 0x1d295288, 0x9e8497ab
+       data4 0x1ec000c6, 0x1e102f29, 0x1e542256, 0x1e67d44d
+       data4 0x1ef688d8, 0x1f0e0f29, 0x1e67861f, 0x1e869748
+       data4 0x1ee6aa6e, 0x9e4d228b, 0x9e50be5b, 0x1e9fe225
+       data4 0x9ea34102, 0x9e628a3b, 0x9ed9fd83, 0x1ecd7109
+       data4 0x1f1864ff, 0x1ea19b76, 0x1db0d1c9, 0x9dff519b
+       data4 0x1e8fea71, 0x9ee82e9a, 0x9f08919b, 0x9ef5c8ae
+       data4 0x9ee446a4, 0x1ea59444, 0x1eb74230, 0x1ea13fbf
+       data4 0x9ea6a3ea, 0x1e5f2797, 0x9e0adb07, 0x9d3adadd
+       data4 0x1ebf2ee2, 0x1da19bfa, 0x1e8dea6d, 0x1ec4fea9
+       data4 0x1e669f22, 0x1dc5f919, 0x9ed25caa, 0x1ee475b1
+       data4 0x1ed0603e, 0x9eacb35c, 0x1dc00b27, 0x1e2f9991
+       data4 0x1e7b0406, 0x1eaa3387, 0x9d865bde, 0x1eb78a48
+       data4 0x1c40ae2e, 0x1ee9838b, 0x9f0f0d7f, 0x1e3e5d26
+       data4 0x1e99e7a6, 0x9e681ccf, 0x9e93ed65, 0x9eeb6a66
+       data4 0x1e29e9af, 0x9e96f923, 0x9e74f11d, 0x9f1474da
+       data4 0x1eec2ea7, 0x1ebf7aa3, 0x9c25dcca, 0x9f0553c2
+       data4 0x9e599efd, 0x1d2ab490, 0x1e95d7cd, 0x9ee4b20e
+       data4 0x9d988ce5, 0x9ef9787e, 0x9dbbba5b, 0x9f12c304
+       data4 0x1e3b9d70, 0x1e7bcae8, 0x9d98bb6e, 0x9e8e6b01
+       data4 0x9f07d03b, 0x9d67c822, 0x9f0ef69e, 0x1c7c0fe3
+       data4 0x9e9bfbb9, 0x9e83b84b, 0x1efbf15e, 0x9ecfa6a6
+       data4 0x9c91158e, 0x9ecf6770, 0x1ee1e3a8, 0x9dc95ec0
+       data4 0x1ef603f7, 0x1d5e52ba, 0x1c477d1b, 0x9e955cd8
+       data4 0x1ed665b0, 0x9e8376c4, 0x9c0ee88e, 0x1e8c989e
+       data4 0x1ea2df29, 0x9d961e5c, 0x1e101813, 0x1e7fffff
+       data4 0x9e5abff4, 0x1dbddd71, 0x1eb69100, 0x1e71f114
+       data4 0x1e9ca798, 0x1ef62c8d, 0x9db4e55a, 0x1dbe69ce
+       data4 0x9ef1c01f, 0x1f044a2a, 0x9eb9e0d7, 0x9ee59745
+       data4 0x9e874803, 0x1ea0b418, 0x9e13572a, 0x1ddbb3a2
+       data4 0x9ec0e391, 0x1e89fba1, 0x1ee8b261, 0x9e5d25f0
+       data4 0x9ef222cb, 0x9ef135ec, 0x1ea04b9a, 0x9f04291f
+       data4 0x9e969254, 0x9ee32f08, 0x9ed909d3, 0x9e362640
+       data4 0x9ec20735, 0x1e50131b, 0x9ed4e049, 0x1ee8e817
+       data4 0x1e1e09c0, 0x9ea643c5, 0x9e5a1ab6, 0x9e389059
+       data4 0x1e560947, 0x1d02b877, 0x1e4475ab, 0x9ea9aaf6
+       data4 0x1e95bc5e, 0x1eaf6afd, 0x1d43067d, 0x9d043821
+       data4 0x9e97baa9, 0x1de5c4f9, 0x9e9a0069, 0x9e1b9944
+       data4 0x1eb13686, 0x9eb907eb, 0x1e059589, 0x1cbd0f93
+       data4 0x9eb7e6ae, 0x1e9fa175, 0x1ee5bdf4, 0x1e8052f7
+       data4 0x9c80d1e3, 0x1bfbe28e, 0x9e672b3b, 0x9ecacf19
+       data4 0x9e3c04be, 0x1dfe8c5c, 0x1e1ba9cb, 0x1eb40b1e
+       data4 0x1ec7e7f6, 0x9d0d45b3, 0x1ef0113b, 0x9a155fa3
+       data4 0x1e28ec3b, 0x1e7ca8df, 0x9d2f91b4, 0x1eccd9ed
+       data4 0x9ed943bc, 0x9ccaab19, 0x9e8a5c58, 0x1ec3bca8
+       data4 0x1ed78dc7, 0x9ed391a8, 0x9e938f6e, 0x9ec4a030
+       data4 0x9e80346e, 0x1e7a4686, 0x9e284315, 0x9e39584c
+       data4 0x1ebdc9b4, 0x9e9cfce5, 0x9ef55c65, 0x1e2941e7
+       data4 0x9efbe59f, 0x1d87c41b, 0x1e40befc, 0x1e3d05b5
+       data4 0x1de9ea67, 0x1ec9a21c, 0x1decb69a, 0x1df6e75a
+       data4 0x9e8030ab, 0x9db20540, 0x9ef1e977, 0x1e3cdc43
+       data4 0x1e0492b0, 0x9e91d872, 0x1e775346, 0x9e939978
+       data4 0x1eb2714e, 0x1e49a203, 0x9e10195a, 0x1ef1ffc3
+       data4 0x9ea8b709, 0x9e832e27, 0x1ed5ac3b, 0x1edb20a6
+       data4 0x1e4dbd4e, 0x1efbb932, 0x1d8170ec, 0x1e6c4849
+       data4 0x1f008e17, 0x1e8000c4, 0x1d855ecf, 0x9e37cb85
+       data4 0x1ecffdf5, 0x1eba6519, 0x9edbe600, 0x1ea3e5e7
+       data4 0x1ed4fb39, 0x1f00be77, 0x1e6f4484, 0x9e9e7107
+       data4 0x9e30b29d, 0x9ee6e174, 0x1e3a2656, 0x9dd72f3f
+       data4 0x9ee12138, 0x1ed16fed, 0x9ece8a02, 0x9ca5b249
+       data4 0x9eafd508, 0x9ef0e9fc, 0x1d1307ac, 0x1eecee20
+       data4 0x1cf60c6f, 0x9d556216, 0x9eaed175, 0x9ec919f4
+       data4 0x1ec2c988, 0x1cd82772, 0x9dc99456, 0x1eab0467
+       data4 0x1e89b36f, 0x1c757944, 0x1eef9abd, 0x9e98664d
+LOCAL_OBJECT_END(D_table)
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(cbrtl)
+
+{ .mfi
+       getf.sig GR_ARGSIG = f8
+       // will continue on main path only for normal/denormal numbers
+       // all other values will be filtered out and will exit early
+       fclass.nm.unc p12, p7 = f8, 0x1b
+       // GR_ADDR = pointer to C_1...C_6 followed by T_table
+       addl GR_ADDR = @ltoff(poly_coeffs), gp
+}
+{ .mfi
+       // GR_BIAS23 = 2/3*bias -63 = 0xaaaa-0x3f = 0xaa6b
+       mov GR_BIAS23 = 0xaa6b
+       // normalize a
+       fma.s1 FR_XNORM = f8, f1, f0
+       // GR_D_ADDR = pointer to D table
+       addl GR_D_ADDR = @ltoff(D_table), gp
+}
+;;
+
+{ .mmf
+       // load start address for C_1...C_6 followed by T_table
+       ld8 GR_C_START = [ GR_ADDR ]
+       // load start address of D table
+       ld8 GR_D_START = [ GR_D_ADDR ]
+       // y = frcpa(a)
+       frcpa.s1 FR_RCP, p6 = f1, f8
+}
+;;
+
+{ .mmi
+        // get normalized significand
+       getf.sig GR_NORMSIG = FR_XNORM
+        // get exponent
+       getf.exp GR_NORMEXPSGN = FR_XNORM
+ (p7)  cmp.eq p12, p0 = GR_ARGSIG, r0
+}
+;;
+
+{ .mii
+       // load C_1
+       ldfe FR_C1 = [ GR_C_START ], 16
+       mov GR_SGNMASK = 0x20000
+       nop.i 0
+}
+;;
+
+{ .mfb
+       // load C_2
+       ldfe FR_C2 = [ GR_C_START ], 16
+ (p12) fma.s0 f8 = f8, f1, f0
+       // NaN/Infinities exit early
+ (p12) br.ret.spnt b0
+}
+;;
+
+{ .mfi
+       // load C_3, C_4
+       ldfpd FR_C3, FR_C4 = [ GR_C_START ], 16
+       // y = frcpa(a), set flags and result when argument is 0
+       // only used when p6=0
+       frcpa.s0 f8, p0 = f1, f8
+       nop.i 0
+}
+;;
+
+{ .mii
+       // get GR_SIGN = sign
+       and GR_SIGN = GR_NORMEXPSGN, GR_SGNMASK
+       // eliminate leading 1 from GR_NORMSIG = 2nd table index
+       shl GR_INDEX2 = GR_NORMSIG, 1
+       // eliminate sign from exponent
+       andcm GR_NORMEXP = GR_NORMEXPSGN, GR_SGNMASK
+}
+;;
+
+{ .mfi
+       // load C_5, C_6
+ (p6)  ldfpd FR_C5, FR_C6 = [ GR_C_START ], 16
+       // r = 1-a*y
+ (p6)  fnma.s1 FR_R = FR_RCP, FR_XNORM, f1
+       // Start computation of floor(exponent/3) by
+       // computing (2^20+2)/3*exponent = exponent*0x55556
+       // 1: exponent* = 5;
+       // (2^{16}-1)/3 = 0x5555:
+       // will form 0x5555*exponent by using shladd's
+       shladd GR_EXP5 = GR_NORMEXP, 2, GR_NORMEXP
+}
+;;
+
+{ .mib
+       // Next several integer steps compute floor(exponent/3)
+       // GR_TMP1 = (5*expon)*16
+       shladd GR_TMP1 = GR_EXP5, 4, r0
+       // GR_EXP3 = 3*exponent
+       shladd GR_EXP3 = GR_NORMEXP, 1, GR_NORMEXP
+       nop.b 0
+}
+;;
+
+{ .mmi
+       // GR_EXP6 = 6*exponent
+       shladd GR_EXP6 = GR_EXP3, 1, r0
+       // GR_EXP17 = 17*expon
+       add GR_EXP17 = GR_EXP5, GR_TMP1
+       // GR_IX2 = 2nd table index (8 bits)
+       shr.u GR_IX2 = GR_INDEX2, 56
+}
+;;
+
+{ .mmi
+       // adjust T_table pointer by 2nd index
+       shladd GR_T_INDEX = GR_IX2, 3, GR_C_START
+       // adjust D_table pointer by 2nd index
+       shladd GR_D_INDEX = GR_IX2, 2, GR_D_START
+       // GR_TMP2 = (17*expon)*16^2
+       shl GR_TMP2 = GR_EXP17, 8
+}
+;;
+
+{ .mmi
+       // GR_TMP3 = expon*(2^16-1)/3
+       add GR_TMP3 = GR_EXP17, GR_TMP2
+;;
+       // GR_TMP4 = expon*(2^20+2)/3 = expon*0x55556
+       shladd GR_TMP4 = GR_TMP3, 4, GR_EXP6
+       nop.i 0
+}
+;;
+
+{ .mii
+       nop.m 0
+       // GR_EXP_RES = floor(expon/3)
+       shr.u GR_EXP_RES = GR_TMP4, 20
+       nop.i 0
+}
+;;
+
+{ .mmi
+       nop.m 0
+       // r16 = 3*exponent
+       shladd r16 = GR_EXP_RES, 1, GR_EXP_RES
+       // bias exponent
+       add GR_EXPBIAS = GR_BIAS23, GR_EXP_RES
+}
+;;
+
+{ .mmi
+       // get remainder of exponent/3
+       sub GR_EXP_MOD_3 = GR_NORMEXP, r16
+;;
+       // add sign to exponent
+       or GR_EXPSIGNRES = GR_EXPBIAS, GR_SIGN
+       // remainder << = 8
+       shl GR_REMTMP = GR_EXP_MOD_3, 8
+}
+;;
+
+{ .mfi
+       // adjust D_table pointer by 1st index
+       shladd GR_IX_D = GR_REMTMP, 2, GR_D_INDEX
+       // P_1 = C_1+C_2*r
+ (p6)  fma.s1 FR_P1 = FR_C2, FR_R, FR_C1
+       // adjust T_table pointer by 1st index
+       shladd GR_IX_T = GR_REMTMP, 3, GR_T_INDEX
+}
+{ .mfi
+       // FR_SGNEXP = sign*2^{exponent/3}
+ (p6)  setf.exp FR_SGNEXP = GR_EXPSIGNRES
+       // r^2 = r*r
+ (p6)  fma.s1 FR_R2 = FR_R, FR_R, f0
+       nop.i 0
+}
+;;
+
+{ .mfi
+       // load D
+ (p6)  ldfs FR_D = [ GR_IX_D ]
+       // P_2 = C_3+C_4*r
+ (p6)  fma.s1 FR_P2 = FR_C4, FR_R, FR_C3
+       nop.i 0
+}
+{ .mfi
+       // load T
+ (p6)  ldf8 FR_T = [ GR_IX_T ]
+       // P_3 = C_5+C_6*r
+ (p6)  fma.s1 FR_P3 = FR_C6, FR_R, FR_C5
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // P_4 = D-r*P_1
+ (p6)  fnma.s1 FR_P4 = FR_R, FR_P1, FR_D
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       // r^3 = r*r^2
+ (p6)  fma.s1 FR_R3 = FR_R, FR_R2, f0
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // P_5 = P_2+r2*P_3
+ (p6)  fma.s1 FR_P5 = FR_R2, FR_P3, FR_P2
+       nop.i 0
+}
+;;
+
+{ .mfi
+       nop.m 0
+       // T = T*(sign*2^{exponent/3})
+ (p6)  fma.s1 FR_TF = FR_T, FR_SGNEXP, f0
+       nop.i 0
+}
+{ .mfi
+       nop.m 0
+       // P = P_4-r3*P_5
+ (p6)  fnma.s1 FR_P = FR_R3, FR_P5, FR_P4
+       nop.i 0
+}
+;;
+
+{ .mfb
+       nop.m 0
+       // result = T+T*p
+ (p6)  fma.s0 f8 = FR_TF, FR_P, FR_TF
+       br.ret.sptk b0
+}
+;;
+
+GLOBAL_LIBM_END(cbrtl)
+libm_alias_ldouble_other (cbrt, cbrt)
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_ceil.S
@@ -0,0 +1,224 @@
+.file "ceil.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 06/13/00 Improved speed
+// 06/27/00 Eliminated incorrect invalid flag setting
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 01/28/03 Improved performance
+//==============================================================
+
+// API
+//==============================================================
+// double ceil(double x)
+//==============================================================
+
+// general input registers:
+// r14 - r19
+
+rSignexp   = r14
+rExp       = r15
+rExpMask   = r16
+rBigexp    = r17
+rM1        = r18
+rSignexpM1 = r19
+
+// floating-point registers:
+// f8 - f13
+
+fXInt      = f9
+fNormX     = f10
+fTmp       = f11
+fAdj       = f12
+fPreResult = f13
+
+// predicate registers used:
+// p6 - p10
+
+// Overview of operation
+//==============================================================
+// double ceil(double x)
+// Return an integer value (represented as a double) that is the smallest
+// value not less than x
+// This is x rounded toward +infinity to an integral value.
+// Inexact is set if x != ceil(x)
+//==============================================================
+
+// double_extended
+// if the exponent is > 1003e => 3F(true) = 63(decimal)
+// we have a significand of 64 bits 1.63-bits.
+// If we multiply by 2^63, we no longer have a fractional part
+// So input is an integer value already.
+
+// double
+// if the exponent is >= 10033 => 34(true) = 52(decimal)
+// 34 + 3ff = 433
+// we have a significand of 53 bits 1.52-bits. (implicit 1)
+// If we multiply by 2^52, we no longer have a fractional part
+// So input is an integer value already.
+
+// single
+// if the exponent is > 10016 => 17(true) = 23(decimal)
+// we have a significand of 24 bits 1.23-bits. (implicit 1)
+// If we multiply by 2^23, we no longer have a fractional part
+// So input is an integer value already.
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(ceil)
+
+{ .mfi
+      getf.exp         rSignexp  = f8        // Get signexp, recompute if unorm
+      fclass.m         p7,p0 = f8, 0x0b      // Test x unorm
+      addl             rBigexp = 0x10033, r0 // Set exponent at which is integer
+}
+{ .mfi
+      mov              rM1 = -1              // Set all ones
+      fcvt.fx.trunc.s1 fXInt  = f8           // Convert to int in significand
+      mov              rExpMask    = 0x1FFFF // Form exponent mask
+}
+;;
+
+{ .mfi
+      mov              rSignexpM1  = 0x2FFFF // Form signexp of -1
+      fcmp.lt.s1       p8,p9 = f8, f0        // Test x < 0
+      nop.i            0
+}
+{ .mfb
+      setf.sig         fTmp = rM1            // Make const for setting inexact
+      fnorm.s1         fNormX  = f8          // Normalize input
+(p7)  br.cond.spnt     CEIL_UNORM            // Branch if x unorm
+}
+;;
+
+CEIL_COMMON:
+// Return here from CEIL_UNORM
+{ .mfi
+      nop.m            0
+      fclass.m         p6,p0 = f8, 0x1e7     // Test x natval, nan, inf, 0
+      nop.i            0
+}
+;;
+
+.pred.rel "mutex",p8,p9
+{ .mfi
+      nop.m            0
+(p8)  fma.s1           fAdj = f0, f0, f0     // If x < 0, adjustment is 0
+      nop.i            0
+}
+{ .mfi
+      nop.m            0
+(p9)  fma.s1           fAdj = f1, f1, f0     // If x > 0, adjustment is +1
+      nop.i            0
+}
+;;
+
+{ .mfi
+      nop.m            0
+      fcvt.xf          fPreResult = fXInt    // trunc(x)
+      nop.i            0
+}
+{ .mfb
+      nop.m            0
+(p6)  fma.d.s0         f8 = f8, f1, f0       // Result if x natval, nan, inf, 0
+(p6)  br.ret.spnt      b0                    // Exit if x natval, nan, inf, 0
+}
+;;
+
+{ .mmi
+      and              rExp = rSignexp, rExpMask // Get biased exponent
+;;
+      cmp.ge           p7,p6 = rExp, rBigexp  // Is |x| >= 2^52?
+(p8)  cmp.lt.unc       p10,p0 = rSignexp, rSignexpM1 // Is -1 < x < 0?
+}
+;;
+
+// If -1 < x < 0, we turn off p6 and compute result as -0
+{ .mfi
+(p10) cmp.ne           p6,p0 = r0,r0
+(p10) fmerge.s         f8 = fNormX, f0
+      nop.i            0
+}
+;;
+
+.pred.rel "mutex",p6,p7
+{ .mfi
+      nop.m            0
+(p6)  fma.d.s0         f8 = fPreResult, f1, fAdj // Result if !int, |x| < 2^52
+      nop.i            0
+}
+{ .mfi
+      nop.m            0
+(p7)  fma.d.s0         f8 = fNormX, f1, f0    // Result, if |x| >= 2^52
+(p10) cmp.eq           p6,p0 = r0,r0          // If -1 < x < 0, turn on p6 again
+}
+;;
+
+{ .mfi
+      nop.m            0
+(p6)  fcmp.eq.unc.s1   p8, p9 = fPreResult, fNormX // Is trunc(x) = x ?
+      nop.i            0
+}
+;;
+
+{ .mfi
+      nop.m            0
+(p9)  fmpy.s0          fTmp = fTmp, fTmp      // Dummy to set inexact
+      nop.i            0
+}
+{ .mfb
+      nop.m            0
+(p8)  fma.d.s0         f8 = fNormX, f1, f0    // If x int, result normalized x
+      br.ret.sptk      b0                     // Exit main path, 0 < |x| < 2^52
+}
+;;
+
+
+CEIL_UNORM:
+// Here if x unorm
+{ .mfb
+      getf.exp         rSignexp  = fNormX     // Get signexp, recompute if unorm
+      fcmp.eq.s0       p7,p0 = f8, f0         // Dummy op to set denormal flag
+      br.cond.sptk     CEIL_COMMON            // Return to main path
+}
+;;
+
+GLOBAL_LIBM_END(ceil)
+libm_alias_double_other (ceil, ceil)
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_ceilf.S
@@ -0,0 +1,224 @@
+.file "ceilf.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 06/13/00 Improved speed
+// 06/27/00 Eliminated incorrect invalid flag setting
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 01/28/03 Improved performance
+//==============================================================
+
+// API
+//==============================================================
+// float ceilf(float x)
+//==============================================================
+
+// general input registers:
+// r14 - r19
+
+rSignexp   = r14
+rExp       = r15
+rExpMask   = r16
+rBigexp    = r17
+rM1        = r18
+rSignexpM1 = r19
+
+// floating-point registers:
+// f8 - f13
+
+fXInt      = f9
+fNormX     = f10
+fTmp       = f11
+fAdj       = f12
+fPreResult = f13
+
+// predicate registers used:
+// p6 - p10
+
+// Overview of operation
+//==============================================================
+// float ceilf(float x)
+// Return an integer value (represented as a float) that is the smallest
+// value not less than x
+// This is x rounded toward +infinity to an integral value.
+// Inexact is set if x != ceilf(x)
+//==============================================================
+
+// double_extended
+// if the exponent is > 1003e => 3F(true) = 63(decimal)
+// we have a significand of 64 bits 1.63-bits.
+// If we multiply by 2^63, we no longer have a fractional part
+// So input is an integer value already.
+
+// double
+// if the exponent is >= 10033 => 34(true) = 52(decimal)
+// 34 + 3ff = 433
+// we have a significand of 53 bits 1.52-bits. (implicit 1)
+// If we multiply by 2^52, we no longer have a fractional part
+// So input is an integer value already.
+
+// single
+// if the exponent is > 10016 => 17(true) = 23(decimal)
+// we have a significand of 24 bits 1.23-bits. (implicit 1)
+// If we multiply by 2^23, we no longer have a fractional part
+// So input is an integer value already.
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(ceilf)
+
+{ .mfi
+      getf.exp         rSignexp  = f8        // Get signexp, recompute if unorm
+      fclass.m         p7,p0 = f8, 0x0b      // Test x unorm
+      addl             rBigexp = 0x10016, r0 // Set exponent at which is integer
+}
+{ .mfi
+      mov              rM1 = -1              // Set all ones
+      fcvt.fx.trunc.s1 fXInt  = f8           // Convert to int in significand
+      mov              rExpMask    = 0x1FFFF // Form exponent mask
+}
+;;
+
+{ .mfi
+      mov              rSignexpM1  = 0x2FFFF // Form signexp of -1
+      fcmp.lt.s1       p8,p9 = f8, f0        // Test x < 0
+      nop.i            0
+}
+{ .mfb
+      setf.sig         fTmp = rM1            // Make const for setting inexact
+      fnorm.s1         fNormX  = f8          // Normalize input
+(p7)  br.cond.spnt     CEIL_UNORM            // Branch if x unorm
+}
+;;
+
+CEIL_COMMON:
+// Return here from CEIL_UNORM
+{ .mfi
+      nop.m            0
+      fclass.m         p6,p0 = f8, 0x1e7     // Test x natval, nan, inf, 0
+      nop.i            0
+}
+;;
+
+.pred.rel "mutex",p8,p9
+{ .mfi
+      nop.m            0
+(p8)  fma.s1           fAdj = f0, f0, f0     // If x < 0, adjustment is 0
+      nop.i            0
+}
+{ .mfi
+      nop.m            0
+(p9)  fma.s1           fAdj = f1, f1, f0     // If x > 0, adjustment is +1
+      nop.i            0
+}
+;;
+
+{ .mfi
+      nop.m            0
+      fcvt.xf          fPreResult = fXInt    // trunc(x)
+      nop.i            0
+}
+{ .mfb
+      nop.m            0
+(p6)  fma.s.s0         f8 = f8, f1, f0       // Result if x natval, nan, inf, 0
+(p6)  br.ret.spnt      b0                    // Exit if x natval, nan, inf, 0
+}
+;;
+
+{ .mmi
+      and              rExp = rSignexp, rExpMask // Get biased exponent
+;;
+      cmp.ge           p7,p6 = rExp, rBigexp  // Is |x| >= 2^23?
+(p8)  cmp.lt.unc       p10,p0 = rSignexp, rSignexpM1 // Is -1 < x < 0?
+}
+;;
+
+// If -1 < x < 0, we turn off p6 and compute result as -0
+{ .mfi
+(p10) cmp.ne           p6,p0 = r0,r0
+(p10) fmerge.s         f8 = fNormX, f0
+      nop.i            0
+}
+;;
+
+.pred.rel "mutex",p6,p7
+{ .mfi
+      nop.m            0
+(p6)  fma.s.s0         f8 = fPreResult, f1, fAdj // Result if !int, |x| < 2^23
+      nop.i            0
+}
+{ .mfi
+      nop.m            0
+(p7)  fma.s.s0         f8 = fNormX, f1, f0    // Result, if |x| >= 2^23
+(p10) cmp.eq           p6,p0 = r0,r0          // If -1 < x < 0, turn on p6 again
+}
+;;
+
+{ .mfi
+      nop.m            0
+(p6)  fcmp.eq.unc.s1   p8, p9 = fPreResult, fNormX // Is trunc(x) = x ?
+      nop.i            0
+}
+;;
+
+{ .mfi
+      nop.m            0
+(p9)  fmpy.s0          fTmp = fTmp, fTmp      // Dummy to set inexact
+      nop.i            0
+}
+{ .mfb
+      nop.m            0
+(p8)  fma.s.s0         f8 = fNormX, f1, f0    // If x int, result normalized x
+      br.ret.sptk      b0                     // Exit main path, 0 < |x| < 2^23
+}
+;;
+
+
+CEIL_UNORM:
+// Here if x unorm
+{ .mfb
+      getf.exp         rSignexp  = fNormX     // Get signexp, recompute if unorm
+      fcmp.eq.s0       p7,p0 = f8, f0         // Dummy op to set denormal flag
+      br.cond.sptk     CEIL_COMMON            // Return to main path
+}
+;;
+
+GLOBAL_LIBM_END(ceilf)
+libm_alias_float_other (ceil, ceil)
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_ceill.S
@@ -0,0 +1,224 @@
+.file "ceill.s"
+
+
+// Copyright (c) 2000 - 2003, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 06/13/00 Improved speed
+// 06/27/00 Eliminated incorrect invalid flag setting
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 01/28/03 Improved performance
+//==============================================================
+
+// API
+//==============================================================
+// long double ceill(long double x)
+//==============================================================
+
+// general input registers:
+// r14 - r19
+
+rSignexp   = r14
+rExp       = r15
+rExpMask   = r16
+rBigexp    = r17
+rM1        = r18
+rSignexpM1 = r19
+
+// floating-point registers:
+// f8 - f13
+
+fXInt      = f9
+fNormX     = f10
+fTmp       = f11
+fAdj       = f12
+fPreResult = f13
+
+// predicate registers used:
+// p6 - p10
+
+// Overview of operation
+//==============================================================
+// long double ceill(long double x)
+// Return an integer value (represented as a long double) that is the smallest
+// value not less than x
+// This is x rounded toward +infinity to an integral value.
+// Inexact is set if x != ceill(x)
+//==============================================================
+
+// double_extended
+// if the exponent is > 1003e => 3F(true) = 63(decimal)
+// we have a significand of 64 bits 1.63-bits.
+// If we multiply by 2^63, we no longer have a fractional part
+// So input is an integer value already.
+
+// double
+// if the exponent is >= 10033 => 34(true) = 52(decimal)
+// 34 + 3ff = 433
+// we have a significand of 53 bits 1.52-bits. (implicit 1)
+// If we multiply by 2^52, we no longer have a fractional part
+// So input is an integer value already.
+
+// single
+// if the exponent is > 10016 => 17(true) = 23(decimal)
+// we have a significand of 24 bits 1.23-bits. (implicit 1)
+// If we multiply by 2^23, we no longer have a fractional part
+// So input is an integer value already.
+
+
+.section .text
+GLOBAL_LIBM_ENTRY(ceill)
+
+{ .mfi
+      getf.exp         rSignexp  = f8        // Get signexp, recompute if unorm
+      fclass.m         p7,p0 = f8, 0x0b      // Test x unorm
+      addl             rBigexp = 0x1003e, r0 // Set exponent at which is integer
+}
+{ .mfi
+      mov              rM1 = -1              // Set all ones
+      fcvt.fx.trunc.s1 fXInt  = f8           // Convert to int in significand
+      mov              rExpMask    = 0x1FFFF // Form exponent mask
+}
+;;
+
+{ .mfi
+      mov              rSignexpM1  = 0x2FFFF // Form signexp of -1
+      fcmp.lt.s1       p8,p9 = f8, f0        // Test x < 0
+      nop.i            0
+}
+{ .mfb
+      setf.sig         fTmp = rM1            // Make const for setting inexact
+      fnorm.s1         fNormX  = f8          // Normalize input
+(p7)  br.cond.spnt     CEIL_UNORM            // Branch if x unorm
+}
+;;
+
+CEIL_COMMON:
+// Return here from CEIL_UNORM
+{ .mfi
+      nop.m            0
+      fclass.m         p6,p0 = f8, 0x1e7     // Test x natval, nan, inf, 0
+      nop.i            0
+}
+;;
+
+.pred.rel "mutex",p8,p9
+{ .mfi
+      nop.m            0
+(p8)  fma.s1           fAdj = f0, f0, f0     // If x < 0, adjustment is 0
+      nop.i            0
+}
+{ .mfi
+      nop.m            0
+(p9)  fma.s1           fAdj = f1, f1, f0     // If x > 0, adjustment is +1
+      nop.i            0
+}
+;;
+
+{ .mfi
+      nop.m            0
+      fcvt.xf          fPreResult = fXInt    // trunc(x)
+      nop.i            0
+}
+{ .mfb
+      nop.m            0
+(p6)  fma.s0           f8 = f8, f1, f0       // Result if x natval, nan, inf, 0
+(p6)  br.ret.spnt      b0                    // Exit if x natval, nan, inf, 0
+}
+;;
+
+{ .mmi
+      and              rExp = rSignexp, rExpMask // Get biased exponent
+;;
+      cmp.ge           p7,p6 = rExp, rBigexp  // Is |x| >= 2^63?
+(p8)  cmp.lt.unc       p10,p0 = rSignexp, rSignexpM1 // Is -1 < x < 0?
+}
+;;
+
+// If -1 < x < 0, we turn off p6 and compute result as -0
+{ .mfi
+(p10) cmp.ne           p6,p0 = r0,r0
+(p10) fmerge.s         f8 = fNormX, f0
+      nop.i            0
+}
+;;
+
+.pred.rel "mutex",p6,p7
+{ .mfi
+      nop.m            0
+(p6)  fma.s0           f8 = fPreResult, f1, fAdj // Result if !int, |x| < 2^63
+      nop.i            0
+}
+{ .mfi
+      nop.m            0
+(p7)  fma.s0           f8 = fNormX, f1, f0    // Result, if |x| >= 2^63
+(p10) cmp.eq           p6,p0 = r0,r0          // If -1 < x < 0, turn on p6 again
+}
+;;
+
+{ .mfi
+      nop.m            0
+(p6)  fcmp.eq.unc.s1   p8, p9 = fPreResult, fNormX // Is trunc(x) = x ?
+      nop.i            0
+}
+;;
+
+{ .mfi
+      nop.m            0
+(p9)  fmpy.s0          fTmp = fTmp, fTmp      // Dummy to set inexact
+      nop.i            0
+}
+{ .mfb
+      nop.m            0
+(p8)  fma.s0           f8 = fNormX, f1, f0    // If x int, result normalized x
+      br.ret.sptk      b0                     // Exit main path, 0 < |x| < 2^63
+}
+;;
+
+
+CEIL_UNORM:
+// Here if x unorm
+{ .mfb
+      getf.exp         rSignexp  = fNormX     // Get signexp, recompute if unorm
+      fcmp.eq.s0       p7,p0 = f8, f0         // Dummy op to set denormal flag
+      br.cond.sptk     CEIL_COMMON            // Return to main path
+}
+;;
+
+GLOBAL_LIBM_END(ceill)
+libm_alias_ldouble_other (ceil, ceil)
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_cos.S
@@ -0,0 +1,768 @@
+.file "sincos.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 04/02/00 Unwind support added.
+// 06/16/00 Updated tables to enforce symmetry
+// 08/31/00 Saved 2 cycles in main path, and 9 in other paths.
+// 09/20/00 The updated tables regressed to an old version, so reinstated them
+// 10/18/00 Changed one table entry to ensure symmetry
+// 01/03/01 Improved speed, fixed flag settings for small arguments.
+// 02/18/02 Large arguments processing routine excluded
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 06/03/02 Insure inexact flag set for large arg result
+// 09/05/02 Work range is widened by reduction strengthen (3 parts of Pi/16)
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 08/08/03 Improved performance
+// 10/28/04 Saved sincos_r_sincos to avoid clobber by dynamic loader
+// 03/31/05 Reformatted delimiters between data tables
+
+// API
+//==============================================================
+// double sin( double x);
+// double cos( double x);
+//
+// Overview of operation
+//==============================================================
+//
+// Step 1
+// ======
+// Reduce x to region -1/2*pi/2^k ===== 0 ===== +1/2*pi/2^k  where k=4
+//    divide x by pi/2^k.
+//    Multiply by 2^k/pi.
+//    nfloat = Round result to integer (round-to-nearest)
+//
+// r = x -  nfloat * pi/2^k
+//    Do this as ((((x -  nfloat * HIGH(pi/2^k))) -
+//                        nfloat * LOW(pi/2^k)) -
+//                        nfloat * LOWEST(pi/2^k) for increased accuracy.
+//    pi/2^k is stored as two numbers that when added make pi/2^k.
+//       pi/2^k = HIGH(pi/2^k) + LOW(pi/2^k)
+//    HIGH and LOW parts are rounded to zero values,
+//    and LOWEST is rounded to nearest one.
+//
+// x = (nfloat * pi/2^k) + r
+//    r is small enough that we can use a polynomial approximation
+//    and is referred to as the reduced argument.
+//
+// Step 3
+// ======
+// Take the unreduced part and remove the multiples of 2pi.
+// So nfloat = nfloat (with lower k+1 bits cleared) + lower k+1 bits
+//
+//    nfloat (with lower k+1 bits cleared) is a multiple of 2^(k+1)
+//    N * 2^(k+1)
+//    nfloat * pi/2^k = N * 2^(k+1) * pi/2^k + (lower k+1 bits) * pi/2^k
+//    nfloat * pi/2^k = N * 2 * pi + (lower k+1 bits) * pi/2^k
+//    nfloat * pi/2^k = N2pi + M * pi/2^k
+//
+//
+// Sin(x) = Sin((nfloat * pi/2^k) + r)
+//        = Sin(nfloat * pi/2^k) * Cos(r) + Cos(nfloat * pi/2^k) * Sin(r)
+//
+//          Sin(nfloat * pi/2^k) = Sin(N2pi + Mpi/2^k)
+//                               = Sin(N2pi)Cos(Mpi/2^k) + Cos(N2pi)Sin(Mpi/2^k)
+//                               = Sin(Mpi/2^k)
+//
+//          Cos(nfloat * pi/2^k) = Cos(N2pi + Mpi/2^k)
+//                               = Cos(N2pi)Cos(Mpi/2^k) + Sin(N2pi)Sin(Mpi/2^k)
+//                               = Cos(Mpi/2^k)
+//
+// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
+//
+//
+// Step 4
+// ======
+// 0 <= M < 2^(k+1)
+// There are 2^(k+1) Sin entries in a table.
+// There are 2^(k+1) Cos entries in a table.
+//
+// Get Sin(Mpi/2^k) and Cos(Mpi/2^k) by table lookup.
+//
+//
+// Step 5
+// ======
+// Calculate Cos(r) and Sin(r) by polynomial approximation.
+//
+// Cos(r) = 1 + r^2 q1  + r^4 q2 + r^6 q3 + ... = Series for Cos
+// Sin(r) = r + r^3 p1  + r^5 p2 + r^7 p3 + ... = Series for Sin
+//
+// and the coefficients q1, q2, ... and p1, p2, ... are stored in a table
+//
+//
+// Calculate
+// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
+//
+// as follows
+//
+//    S[m] = Sin(Mpi/2^k) and C[m] = Cos(Mpi/2^k)
+//    rsq = r*r
+//
+//
+//    P = p1 + r^2p2 + r^4p3 + r^6p4
+//    Q = q1 + r^2q2 + r^4q3 + r^6q4
+//
+//       rcub = r * rsq
+//       Sin(r) = r + rcub * P
+//              = r + r^3p1  + r^5p2 + r^7p3 + r^9p4 + ... = Sin(r)
+//
+//            The coefficients are not exactly these values, but almost.
+//
+//            p1 = -1/6  = -1/3!
+//            p2 = 1/120 =  1/5!
+//            p3 = -1/5040 = -1/7!
+//            p4 = 1/362889 = 1/9!
+//
+//       P =  r + rcub * P
+//
+//    Answer = S[m] Cos(r) + [Cm] P
+//
+//       Cos(r) = 1 + rsq Q
+//       Cos(r) = 1 + r^2 Q
+//       Cos(r) = 1 + r^2 (q1 + r^2q2 + r^4q3 + r^6q4)
+//       Cos(r) = 1 + r^2q1 + r^4q2 + r^6q3 + r^8q4 + ...
+//
+//       S[m] Cos(r) = S[m](1 + rsq Q)
+//       S[m] Cos(r) = S[m] + Sm rsq Q
+//       S[m] Cos(r) = S[m] + s_rsq Q
+//       Q         = S[m] + s_rsq Q
+//
+// Then,
+//
+//    Answer = Q + C[m] P
+
+
+// Registers used
+//==============================================================
+// general input registers:
+// r14 -> r26
+// r32 -> r35
+
+// predicate registers used:
+// p6 -> p11
+
+// floating-point registers used
+// f9 -> f15
+// f32 -> f61
+
+// Assembly macros
+//==============================================================
+sincos_NORM_f8                 = f9
+sincos_W                       = f10
+sincos_int_Nfloat              = f11
+sincos_Nfloat                  = f12
+
+sincos_r                       = f13
+sincos_rsq                     = f14
+sincos_rcub                    = f15
+sincos_save_tmp                = f15
+
+sincos_Inv_Pi_by_16            = f32
+sincos_Pi_by_16_1              = f33
+sincos_Pi_by_16_2              = f34
+
+sincos_Inv_Pi_by_64            = f35
+
+sincos_Pi_by_16_3              = f36
+
+sincos_r_exact                 = f37
+
+sincos_Sm                      = f38
+sincos_Cm                      = f39
+
+sincos_P1                      = f40
+sincos_Q1                      = f41
+sincos_P2                      = f42
+sincos_Q2                      = f43
+sincos_P3                      = f44
+sincos_Q3                      = f45
+sincos_P4                      = f46
+sincos_Q4                      = f47
+
+sincos_P_temp1                 = f48
+sincos_P_temp2                 = f49
+
+sincos_Q_temp1                 = f50
+sincos_Q_temp2                 = f51
+
+sincos_P                       = f52
+sincos_Q                       = f53
+
+sincos_srsq                    = f54
+
+sincos_SIG_INV_PI_BY_16_2TO61  = f55
+sincos_RSHF_2TO61              = f56
+sincos_RSHF                    = f57
+sincos_2TOM61                  = f58
+sincos_NFLOAT                  = f59
+sincos_W_2TO61_RSH             = f60
+
+fp_tmp                         = f61
+
+/////////////////////////////////////////////////////////////
+
+sincos_GR_sig_inv_pi_by_16     = r14
+sincos_GR_rshf_2to61           = r15
+sincos_GR_rshf                 = r16
+sincos_GR_exp_2tom61           = r17
+sincos_GR_n                    = r18
+sincos_GR_m                    = r19
+sincos_GR_32m                  = r19
+sincos_GR_all_ones             = r19
+sincos_AD_1                    = r20
+sincos_AD_2                    = r21
+sincos_exp_limit               = r22
+sincos_r_signexp               = r23
+sincos_r_17_ones               = r24
+sincos_r_sincos                = r25
+sincos_r_exp                   = r26
+
+GR_SAVE_PFS                    = r33
+GR_SAVE_B0                     = r34
+GR_SAVE_GP                     = r35
+GR_SAVE_r_sincos               = r36
+
+
+RODATA
+
+// Pi/16 parts
+.align 16
+LOCAL_OBJECT_START(double_sincos_pi)
+   data8 0xC90FDAA22168C234, 0x00003FFC // pi/16 1st part
+   data8 0xC4C6628B80DC1CD1, 0x00003FBC // pi/16 2nd part
+   data8 0xA4093822299F31D0, 0x00003F7A // pi/16 3rd part
+LOCAL_OBJECT_END(double_sincos_pi)
+
+// Coefficients for polynomials
+LOCAL_OBJECT_START(double_sincos_pq_k4)
+   data8 0x3EC71C963717C63A // P4
+   data8 0x3EF9FFBA8F191AE6 // Q4
+   data8 0xBF2A01A00F4E11A8 // P3
+   data8 0xBF56C16C05AC77BF // Q3
+   data8 0x3F8111111110F167 // P2
+   data8 0x3FA555555554DD45 // Q2
+   data8 0xBFC5555555555555 // P1
+   data8 0xBFDFFFFFFFFFFFFC // Q1
+LOCAL_OBJECT_END(double_sincos_pq_k4)
+
+// Sincos table (S[m], C[m])
+LOCAL_OBJECT_START(double_sin_cos_beta_k4)
+
+data8 0x0000000000000000 , 0x00000000 // sin( 0 pi/16)  S0
+data8 0x8000000000000000 , 0x00003fff // cos( 0 pi/16)  C0
+//
+data8 0xc7c5c1e34d3055b3 , 0x00003ffc // sin( 1 pi/16)  S1
+data8 0xfb14be7fbae58157 , 0x00003ffe // cos( 1 pi/16)  C1
+//
+data8 0xc3ef1535754b168e , 0x00003ffd // sin( 2 pi/16)  S2
+data8 0xec835e79946a3146 , 0x00003ffe // cos( 2 pi/16)  C2
+//
+data8 0x8e39d9cd73464364 , 0x00003ffe // sin( 3 pi/16)  S3
+data8 0xd4db3148750d181a , 0x00003ffe // cos( 3 pi/16)  C3
+//
+data8 0xb504f333f9de6484 , 0x00003ffe // sin( 4 pi/16)  S4
+data8 0xb504f333f9de6484 , 0x00003ffe // cos( 4 pi/16)  C4
+//
+data8 0xd4db3148750d181a , 0x00003ffe // sin( 5 pi/16)  C3
+data8 0x8e39d9cd73464364 , 0x00003ffe // cos( 5 pi/16)  S3
+//
+data8 0xec835e79946a3146 , 0x00003ffe // sin( 6 pi/16)  C2
+data8 0xc3ef1535754b168e , 0x00003ffd // cos( 6 pi/16)  S2
+//
+data8 0xfb14be7fbae58157 , 0x00003ffe // sin( 7 pi/16)  C1
+data8 0xc7c5c1e34d3055b3 , 0x00003ffc // cos( 7 pi/16)  S1
+//
+data8 0x8000000000000000 , 0x00003fff // sin( 8 pi/16)  C0
+data8 0x0000000000000000 , 0x00000000 // cos( 8 pi/16)  S0
+//
+data8 0xfb14be7fbae58157 , 0x00003ffe // sin( 9 pi/16)  C1
+data8 0xc7c5c1e34d3055b3 , 0x0000bffc // cos( 9 pi/16)  -S1
+//
+data8 0xec835e79946a3146 , 0x00003ffe // sin(10 pi/16)  C2
+data8 0xc3ef1535754b168e , 0x0000bffd // cos(10 pi/16)  -S2
+//
+data8 0xd4db3148750d181a , 0x00003ffe // sin(11 pi/16)  C3
+data8 0x8e39d9cd73464364 , 0x0000bffe // cos(11 pi/16)  -S3
+//
+data8 0xb504f333f9de6484 , 0x00003ffe // sin(12 pi/16)  S4
+data8 0xb504f333f9de6484 , 0x0000bffe // cos(12 pi/16)  -S4
+//
+data8 0x8e39d9cd73464364 , 0x00003ffe // sin(13 pi/16) S3
+data8 0xd4db3148750d181a , 0x0000bffe // cos(13 pi/16) -C3
+//
+data8 0xc3ef1535754b168e , 0x00003ffd // sin(14 pi/16) S2
+data8 0xec835e79946a3146 , 0x0000bffe // cos(14 pi/16) -C2
+//
+data8 0xc7c5c1e34d3055b3 , 0x00003ffc // sin(15 pi/16) S1
+data8 0xfb14be7fbae58157 , 0x0000bffe // cos(15 pi/16) -C1
+//
+data8 0x0000000000000000 , 0x00000000 // sin(16 pi/16) S0
+data8 0x8000000000000000 , 0x0000bfff // cos(16 pi/16) -C0
+//
+data8 0xc7c5c1e34d3055b3 , 0x0000bffc // sin(17 pi/16) -S1
+data8 0xfb14be7fbae58157 , 0x0000bffe // cos(17 pi/16) -C1
+//
+data8 0xc3ef1535754b168e , 0x0000bffd // sin(18 pi/16) -S2
+data8 0xec835e79946a3146 , 0x0000bffe // cos(18 pi/16) -C2
+//
+data8 0x8e39d9cd73464364 , 0x0000bffe // sin(19 pi/16) -S3
+data8 0xd4db3148750d181a , 0x0000bffe // cos(19 pi/16) -C3
+//
+data8 0xb504f333f9de6484 , 0x0000bffe // sin(20 pi/16) -S4
+data8 0xb504f333f9de6484 , 0x0000bffe // cos(20 pi/16) -S4
+//
+data8 0xd4db3148750d181a , 0x0000bffe // sin(21 pi/16) -C3
+data8 0x8e39d9cd73464364 , 0x0000bffe // cos(21 pi/16) -S3
+//
+data8 0xec835e79946a3146 , 0x0000bffe // sin(22 pi/16) -C2
+data8 0xc3ef1535754b168e , 0x0000bffd // cos(22 pi/16) -S2
+//
+data8 0xfb14be7fbae58157 , 0x0000bffe // sin(23 pi/16) -C1
+data8 0xc7c5c1e34d3055b3 , 0x0000bffc // cos(23 pi/16) -S1
+//
+data8 0x8000000000000000 , 0x0000bfff // sin(24 pi/16) -C0
+data8 0x0000000000000000 , 0x00000000 // cos(24 pi/16) S0
+//
+data8 0xfb14be7fbae58157 , 0x0000bffe // sin(25 pi/16) -C1
+data8 0xc7c5c1e34d3055b3 , 0x00003ffc // cos(25 pi/16) S1
+//
+data8 0xec835e79946a3146 , 0x0000bffe // sin(26 pi/16) -C2
+data8 0xc3ef1535754b168e , 0x00003ffd // cos(26 pi/16) S2
+//
+data8 0xd4db3148750d181a , 0x0000bffe // sin(27 pi/16) -C3
+data8 0x8e39d9cd73464364 , 0x00003ffe // cos(27 pi/16) S3
+//
+data8 0xb504f333f9de6484 , 0x0000bffe // sin(28 pi/16) -S4
+data8 0xb504f333f9de6484 , 0x00003ffe // cos(28 pi/16) S4
+//
+data8 0x8e39d9cd73464364 , 0x0000bffe // sin(29 pi/16) -S3
+data8 0xd4db3148750d181a , 0x00003ffe // cos(29 pi/16) C3
+//
+data8 0xc3ef1535754b168e , 0x0000bffd // sin(30 pi/16) -S2
+data8 0xec835e79946a3146 , 0x00003ffe // cos(30 pi/16) C2
+//
+data8 0xc7c5c1e34d3055b3 , 0x0000bffc // sin(31 pi/16) -S1
+data8 0xfb14be7fbae58157 , 0x00003ffe // cos(31 pi/16) C1
+//
+data8 0x0000000000000000 , 0x00000000 // sin(32 pi/16) S0
+data8 0x8000000000000000 , 0x00003fff // cos(32 pi/16) C0
+LOCAL_OBJECT_END(double_sin_cos_beta_k4)
+
+.section .text
+
+////////////////////////////////////////////////////////
+// There are two entry points: sin and cos
+
+
+// If from sin, p8 is true
+// If from cos, p9 is true
+
+GLOBAL_IEEE754_ENTRY(sin)
+
+{ .mlx
+      getf.exp      sincos_r_signexp    = f8
+      movl sincos_GR_sig_inv_pi_by_16   = 0xA2F9836E4E44152A // signd of 16/pi
+}
+{ .mlx
+      addl          sincos_AD_1         = @ltoff(double_sincos_pi), gp
+      movl sincos_GR_rshf_2to61         = 0x47b8000000000000 // 1.1 2^(63+63-2)
+}
+;;
+
+{ .mfi
+      ld8           sincos_AD_1         = [sincos_AD_1]
+      fnorm.s0      sincos_NORM_f8      = f8  // Normalize argument
+      cmp.eq        p8,p9               = r0, r0 // set p8 (clear p9) for sin
+}
+{ .mib
+      mov           sincos_GR_exp_2tom61  = 0xffff-61 // exponent of scale 2^-61
+      mov           sincos_r_sincos       = 0x0 // sincos_r_sincos = 0 for sin
+      br.cond.sptk  _SINCOS_COMMON  // go to common part
+}
+;;
+
+GLOBAL_IEEE754_END(sin)
+libm_alias_double_other (__sin, sin)
+
+GLOBAL_IEEE754_ENTRY(cos)
+
+{ .mlx
+      getf.exp      sincos_r_signexp    = f8
+      movl sincos_GR_sig_inv_pi_by_16   = 0xA2F9836E4E44152A // signd of 16/pi
+}
+{ .mlx
+      addl          sincos_AD_1         = @ltoff(double_sincos_pi), gp
+      movl sincos_GR_rshf_2to61         = 0x47b8000000000000 // 1.1 2^(63+63-2)
+}
+;;
+
+{ .mfi
+      ld8           sincos_AD_1         = [sincos_AD_1]
+      fnorm.s1      sincos_NORM_f8      = f8 // Normalize argument
+      cmp.eq        p9,p8               = r0, r0 // set p9 (clear p8) for cos
+}
+{ .mib
+      mov           sincos_GR_exp_2tom61  = 0xffff-61 // exp of scale 2^-61
+      mov           sincos_r_sincos       = 0x8 // sincos_r_sincos = 8 for cos
+      nop.b         999
+}
+;;
+
+////////////////////////////////////////////////////////
+// All entry points end up here.
+// If from sin, sincos_r_sincos is 0 and p8 is true
+// If from cos, sincos_r_sincos is 8 = 2^(k-1) and p9 is true
+// We add sincos_r_sincos to N
+
+///////////// Common sin and cos part //////////////////
+_SINCOS_COMMON:
+
+
+// Form two constants we need
+//  16/pi * 2^-2 * 2^63, scaled by 2^61 since we just loaded the significand
+//  1.1000...000 * 2^(63+63-2) to right shift int(W) into the low significand
+{ .mfi
+      setf.sig      sincos_SIG_INV_PI_BY_16_2TO61 = sincos_GR_sig_inv_pi_by_16
+      fclass.m      p6,p0                         = f8, 0xe7 // if x = 0,inf,nan
+      mov           sincos_exp_limit              = 0x1001a
+}
+{ .mlx
+      setf.d        sincos_RSHF_2TO61   = sincos_GR_rshf_2to61
+      movl          sincos_GR_rshf      = 0x43e8000000000000 // 1.1 2^63
+}                                                            // Right shift
+;;
+
+// Form another constant
+//  2^-61 for scaling Nfloat
+// 0x1001a is register_bias + 27.
+// So if f8 >= 2^27, go to large argument routines
+{ .mfi
+      alloc         r32                 = ar.pfs, 1, 4, 0, 0
+      fclass.m      p11,p0              = f8, 0x0b // Test for x=unorm
+      mov           sincos_GR_all_ones  = -1 // For "inexect" constant create
+}
+{ .mib
+      setf.exp      sincos_2TOM61       = sincos_GR_exp_2tom61
+      nop.i         999
+(p6)  br.cond.spnt  _SINCOS_SPECIAL_ARGS
+}
+;;
+
+// Load the two pieces of pi/16
+// Form another constant
+//  1.1000...000 * 2^63, the right shift constant
+{ .mmb
+      ldfe          sincos_Pi_by_16_1   = [sincos_AD_1],16
+      setf.d        sincos_RSHF         = sincos_GR_rshf
+(p11) br.cond.spnt  _SINCOS_UNORM       // Branch if x=unorm
+}
+;;
+
+_SINCOS_COMMON2:
+// Return here if x=unorm
+// Create constant used to set inexact
+{ .mmi
+      ldfe          sincos_Pi_by_16_2   = [sincos_AD_1],16
+      setf.sig      fp_tmp              = sincos_GR_all_ones
+      nop.i         999
+};;
+
+// Select exponent (17 lsb)
+{ .mfi
+      ldfe          sincos_Pi_by_16_3   = [sincos_AD_1],16
+      nop.f         999
+      dep.z         sincos_r_exp        = sincos_r_signexp, 0, 17
+};;
+
+// Polynomial coefficients (Q4, P4, Q3, P3, Q2, Q1, P2, P1) loading
+// p10 is true if we must call routines to handle larger arguments
+// p10 is true if f8 exp is >= 0x1001a (2^27)
+{ .mmb
+      ldfpd         sincos_P4,sincos_Q4 = [sincos_AD_1],16
+      cmp.ge        p10,p0              = sincos_r_exp,sincos_exp_limit
+(p10) br.cond.spnt  _SINCOS_LARGE_ARGS // Go to "large args" routine
+};;
+
+// sincos_W          = x * sincos_Inv_Pi_by_16
+// Multiply x by scaled 16/pi and add large const to shift integer part of W to
+//   rightmost bits of significand
+{ .mfi
+      ldfpd         sincos_P3,sincos_Q3 = [sincos_AD_1],16
+      fma.s1 sincos_W_2TO61_RSH = sincos_NORM_f8,sincos_SIG_INV_PI_BY_16_2TO61,sincos_RSHF_2TO61
+      nop.i         999
+};;
+
+// get N = (int)sincos_int_Nfloat
+// sincos_NFLOAT = Round_Int_Nearest(sincos_W)
+// This is done by scaling back by 2^-61 and subtracting the shift constant
+{ .mmf
+      getf.sig      sincos_GR_n         = sincos_W_2TO61_RSH
+      ldfpd         sincos_P2,sincos_Q2 = [sincos_AD_1],16
+      fms.s1 sincos_NFLOAT = sincos_W_2TO61_RSH,sincos_2TOM61,sincos_RSHF
+};;
+
+// sincos_r          = -sincos_Nfloat * sincos_Pi_by_16_1 + x
+{ .mfi
+      ldfpd         sincos_P1,sincos_Q1 = [sincos_AD_1],16
+      fnma.s1 sincos_r = sincos_NFLOAT, sincos_Pi_by_16_1, sincos_NORM_f8
+      nop.i         999
+};;
+
+// Add 2^(k-1) (which is in sincos_r_sincos) to N
+{ .mmi
+      add           sincos_GR_n         = sincos_GR_n, sincos_r_sincos
+;;
+// Get M (least k+1 bits of N)
+      and           sincos_GR_m         = 0x1f,sincos_GR_n
+      nop.i         999
+};;
+
+// sincos_r          = sincos_r -sincos_Nfloat * sincos_Pi_by_16_2
+{ .mfi
+      nop.m         999
+      fnma.s1 sincos_r = sincos_NFLOAT, sincos_Pi_by_16_2,  sincos_r
+      shl           sincos_GR_32m       = sincos_GR_m,5
+};;
+
+// Add 32*M to address of sin_cos_beta table
+// For sin denorm. - set uflow
+{ .mfi
+      add           sincos_AD_2         = sincos_GR_32m, sincos_AD_1
+(p8)  fclass.m.unc  p10,p0              = f8,0x0b
+      nop.i         999
+};;
+
+// Load Sin and Cos table value using obtained index m  (sincosf_AD_2)
+{ .mfi
+      ldfe          sincos_Sm           = [sincos_AD_2],16
+      nop.f         999
+      nop.i         999
+};;
+
+// get rsq = r*r
+{ .mfi
+      ldfe          sincos_Cm           = [sincos_AD_2]
+      fma.s1        sincos_rsq          = sincos_r, sincos_r,   f0 // r^2 = r*r
+      nop.i         999
+}
+{ .mfi
+      nop.m         999
+      fmpy.s0       fp_tmp              = fp_tmp,fp_tmp // forces inexact flag
+      nop.i         999
+};;
+
+// sincos_r_exact = sincos_r -sincos_Nfloat * sincos_Pi_by_16_3
+{ .mfi
+      nop.m         999
+      fnma.s1 sincos_r_exact = sincos_NFLOAT, sincos_Pi_by_16_3, sincos_r
+      nop.i         999
+};;
+
+// Polynomials calculation
+// P_1 = P4*r^2 + P3
+// Q_2 = Q4*r^2 + Q3
+{ .mfi
+      nop.m         999
+      fma.s1        sincos_P_temp1      = sincos_rsq, sincos_P4, sincos_P3
+      nop.i         999
+}
+{ .mfi
+      nop.m         999
+      fma.s1        sincos_Q_temp1      = sincos_rsq, sincos_Q4, sincos_Q3
+      nop.i         999
+};;
+
+// get rcube = r^3 and S[m]*r^2
+{ .mfi
+      nop.m         999
+      fmpy.s1       sincos_srsq         = sincos_Sm,sincos_rsq
+      nop.i         999
+}
+{ .mfi
+      nop.m         999
+      fmpy.s1       sincos_rcub         = sincos_r_exact, sincos_rsq
+      nop.i         999
+};;
+
+// Polynomials calculation
+// Q_2 = Q_1*r^2 + Q2
+// P_1 = P_1*r^2 + P2
+{ .mfi
+      nop.m         999
+      fma.s1        sincos_Q_temp2      = sincos_rsq, sincos_Q_temp1, sincos_Q2
+      nop.i         999
+}
+{ .mfi
+      nop.m         999
+      fma.s1        sincos_P_temp2      = sincos_rsq, sincos_P_temp1, sincos_P2
+      nop.i         999
+};;
+
+// Polynomials calculation
+// Q = Q_2*r^2 + Q1
+// P = P_2*r^2 + P1
+{ .mfi
+      nop.m         999
+      fma.s1        sincos_Q            = sincos_rsq, sincos_Q_temp2, sincos_Q1
+      nop.i         999
+}
+{ .mfi
+      nop.m         999
+      fma.s1        sincos_P            = sincos_rsq, sincos_P_temp2, sincos_P1
+      nop.i         999
+};;
+
+// Get final P and Q
+// Q = Q*S[m]*r^2 + S[m]
+// P = P*r^3 + r
+{ .mfi
+      nop.m         999
+      fma.s1        sincos_Q            = sincos_srsq,sincos_Q, sincos_Sm
+      nop.i         999
+}
+{ .mfi
+      nop.m         999
+      fma.s1        sincos_P            = sincos_rcub,sincos_P, sincos_r_exact
+      nop.i         999
+};;
+
+// If sin(denormal), force underflow to be set
+{ .mfi
+      nop.m         999
+(p10) fmpy.d.s0     fp_tmp              = sincos_NORM_f8,sincos_NORM_f8
+      nop.i         999
+};;
+
+// Final calculation
+// result = C[m]*P + Q
+{ .mfb
+      nop.m         999
+      fma.d.s0      f8                  = sincos_Cm, sincos_P, sincos_Q
+      br.ret.sptk   b0  // Exit for common path
+};;
+
+////////// x = 0/Inf/NaN path //////////////////
+_SINCOS_SPECIAL_ARGS:
+.pred.rel "mutex",p8,p9
+// sin(+/-0) = +/-0
+// sin(Inf)  = NaN
+// sin(NaN)  = NaN
+{ .mfi
+      nop.m         999
+(p8)  fma.d.s0      f8                  = f8, f0, f0 // sin(+/-0,NaN,Inf)
+      nop.i         999
+}
+// cos(+/-0) = 1.0
+// cos(Inf)  = NaN
+// cos(NaN)  = NaN
+{ .mfb
+      nop.m         999
+(p9)  fma.d.s0      f8                  = f8, f0, f1 // cos(+/-0,NaN,Inf)
+      br.ret.sptk   b0 // Exit for x = 0/Inf/NaN path
+};;
+
+_SINCOS_UNORM:
+// Here if x=unorm
+{ .mfb
+      getf.exp      sincos_r_signexp    = sincos_NORM_f8 // Get signexp of x
+      fcmp.eq.s0    p11,p0              = f8, f0  // Dummy op to set denorm flag
+      br.cond.sptk  _SINCOS_COMMON2     // Return to main path
+};;
+
+GLOBAL_IEEE754_END(cos)
+libm_alias_double_other (__cos, cos)
+
+//////////// x >= 2^27 - large arguments routine call ////////////
+LOCAL_LIBM_ENTRY(__libm_callout_sincos)
+_SINCOS_LARGE_ARGS:
+.prologue
+{ .mfi
+      mov           GR_SAVE_r_sincos    = sincos_r_sincos // Save sin or cos
+      nop.f         999
+.save ar.pfs,GR_SAVE_PFS
+      mov           GR_SAVE_PFS         = ar.pfs
+}
+;;
+
+{ .mfi
+      mov           GR_SAVE_GP          = gp
+      nop.f         999
+.save b0, GR_SAVE_B0
+      mov           GR_SAVE_B0          = b0
+}
+
+.body
+{ .mbb
+      setf.sig      sincos_save_tmp     = sincos_GR_all_ones// inexact set
+      nop.b         999
+(p8)  br.call.sptk.many b0              = __libm_sin_large# // sin(large_X)
+
+};;
+
+{ .mbb
+      cmp.ne        p9,p0               = GR_SAVE_r_sincos, r0 // set p9 if cos
+      nop.b         999
+(p9)  br.call.sptk.many b0              = __libm_cos_large# // cos(large_X)
+};;
+
+{ .mfi
+      mov           gp                  = GR_SAVE_GP
+      fma.d.s0      f8                  = f8, f1, f0 // Round result to double
+      mov           b0                  = GR_SAVE_B0
+}
+// Force inexact set
+{ .mfi
+      nop.m         999
+      fmpy.s0       sincos_save_tmp     = sincos_save_tmp, sincos_save_tmp
+      nop.i         999
+};;
+
+{ .mib
+      nop.m         999
+      mov           ar.pfs              = GR_SAVE_PFS
+      br.ret.sptk   b0 // Exit for large arguments routine call
+};;
+
+LOCAL_LIBM_END(__libm_callout_sincos)
+
+.type    __libm_sin_large#,@function
+.global  __libm_sin_large#
+.type    __libm_cos_large#,@function
+.global  __libm_cos_large#
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_cosf.S
@@ -0,0 +1,717 @@
+.file "sincosf.s"
+
+
+// Copyright (c) 2000 - 2005, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+// History
+//==============================================================
+// 02/02/00 Initial version
+// 04/02/00 Unwind support added.
+// 06/16/00 Updated tables to enforce symmetry
+// 08/31/00 Saved 2 cycles in main path, and 9 in other paths.
+// 09/20/00 The updated tables regressed to an old version, so reinstated them
+// 10/18/00 Changed one table entry to ensure symmetry
+// 01/03/01 Improved speed, fixed flag settings for small arguments.
+// 02/18/02 Large arguments processing routine excluded
+// 05/20/02 Cleaned up namespace and sf0 syntax
+// 06/03/02 Insure inexact flag set for large arg result
+// 09/05/02 Single precision version is made using double precision one as base
+// 02/10/03 Reordered header: .section, .global, .proc, .align
+// 03/31/05 Reformatted delimiters between data tables
+//
+// API
+//==============================================================
+// float sinf( float x);
+// float cosf( float x);
+//
+// Overview of operation
+//==============================================================
+//
+// Step 1
+// ======
+// Reduce x to region -1/2*pi/2^k ===== 0 ===== +1/2*pi/2^k  where k=4
+//    divide x by pi/2^k.
+//    Multiply by 2^k/pi.
+//    nfloat = Round result to integer (round-to-nearest)
+//
+// r = x -  nfloat * pi/2^k
+//    Do this as (x -  nfloat * HIGH(pi/2^k)) - nfloat * LOW(pi/2^k)
+
+//    for increased accuracy.
+//    pi/2^k is stored as two numbers that when added make pi/2^k.
+//       pi/2^k = HIGH(pi/2^k) + LOW(pi/2^k)
+//    HIGH part is rounded to zero, LOW - to nearest
+//
+// x = (nfloat * pi/2^k) + r
+//    r is small enough that we can use a polynomial approximation
+//    and is referred to as the reduced argument.
+//
+// Step 3
+// ======
+// Take the unreduced part and remove the multiples of 2pi.
+// So nfloat = nfloat (with lower k+1 bits cleared) + lower k+1 bits
+//
+//    nfloat (with lower k+1 bits cleared) is a multiple of 2^(k+1)
+//    N * 2^(k+1)
+//    nfloat * pi/2^k = N * 2^(k+1) * pi/2^k + (lower k+1 bits) * pi/2^k
+//    nfloat * pi/2^k = N * 2 * pi + (lower k+1 bits) * pi/2^k
+//    nfloat * pi/2^k = N2pi + M * pi/2^k
+//
+//
+// Sin(x) = Sin((nfloat * pi/2^k) + r)
+//        = Sin(nfloat * pi/2^k) * Cos(r) + Cos(nfloat * pi/2^k) * Sin(r)
+//
+//          Sin(nfloat * pi/2^k) = Sin(N2pi + Mpi/2^k)
+//                               = Sin(N2pi)Cos(Mpi/2^k) + Cos(N2pi)Sin(Mpi/2^k)
+//                               = Sin(Mpi/2^k)
+//
+//          Cos(nfloat * pi/2^k) = Cos(N2pi + Mpi/2^k)
+//                               = Cos(N2pi)Cos(Mpi/2^k) + Sin(N2pi)Sin(Mpi/2^k)
+//                               = Cos(Mpi/2^k)
+//
+// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
+//
+//
+// Step 4
+// ======
+// 0 <= M < 2^(k+1)
+// There are 2^(k+1) Sin entries in a table.
+// There are 2^(k+1) Cos entries in a table.
+//
+// Get Sin(Mpi/2^k) and Cos(Mpi/2^k) by table lookup.
+//
+//
+// Step 5
+// ======
+// Calculate Cos(r) and Sin(r) by polynomial approximation.
+//
+// Cos(r) = 1 + r^2 q1  + r^4 q2  = Series for Cos
+// Sin(r) = r + r^3 p1  + r^5 p2  = Series for Sin
+//
+// and the coefficients q1, q2 and p1, p2 are stored in a table
+//
+//
+// Calculate
+// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
+//
+// as follows
+//
+//    S[m] = Sin(Mpi/2^k) and C[m] = Cos(Mpi/2^k)
+//    rsq = r*r
+//
+//
+//    P = P1 + r^2*P2
+//    Q = Q1 + r^2*Q2
+//
+//       rcub = r * rsq
+//       Sin(r) = r + rcub * P
+//              = r + r^3p1  + r^5p2 = Sin(r)
+//
+//            The coefficients are not exactly these values, but almost.
+//
+//            p1 = -1/6  = -1/3!
+//            p2 = 1/120 =  1/5!
+//            p3 = -1/5040 = -1/7!
+//            p4 = 1/362889 = 1/9!
+//
+//       P =  r + r^3 * P
+//
+//    Answer = S[m] Cos(r) + C[m] P
+//
+//       Cos(r) = 1 + rsq Q
+//       Cos(r) = 1 + r^2 Q
+//       Cos(r) = 1 + r^2 (q1 + r^2q2)
+//       Cos(r) = 1 + r^2q1 + r^4q2
+//
+//       S[m] Cos(r) = S[m](1 + rsq Q)
+//       S[m] Cos(r) = S[m] + S[m] rsq Q
+//       S[m] Cos(r) = S[m] + s_rsq Q
+//       Q         = S[m] + s_rsq Q
+//
+// Then,
+//
+//    Answer = Q + C[m] P
+
+
+// Registers used
+//==============================================================
+// general input registers:
+// r14 -> r19
+// r32 -> r45
+
+// predicate registers used:
+// p6 -> p14
+
+// floating-point registers used
+// f9 -> f15
+// f32 -> f61
+
+// Assembly macros
+//==============================================================
+sincosf_NORM_f8                 = f9
+sincosf_W                       = f10
+sincosf_int_Nfloat              = f11
+sincosf_Nfloat                  = f12
+
+sincosf_r                       = f13
+sincosf_rsq                     = f14
+sincosf_rcub                    = f15
+sincosf_save_tmp                = f15
+
+sincosf_Inv_Pi_by_16            = f32
+sincosf_Pi_by_16_1              = f33
+sincosf_Pi_by_16_2              = f34
+
+sincosf_Inv_Pi_by_64            = f35
+
+sincosf_Pi_by_16_3              = f36
+
+sincosf_r_exact                 = f37
+
+sincosf_Sm                      = f38
+sincosf_Cm                      = f39
+
+sincosf_P1                      = f40
+sincosf_Q1                      = f41
+sincosf_P2                      = f42
+sincosf_Q2                      = f43
+sincosf_P3                      = f44
+sincosf_Q3                      = f45
+sincosf_P4                      = f46
+sincosf_Q4                      = f47
+
+sincosf_P_temp1                 = f48
+sincosf_P_temp2                 = f49
+
+sincosf_Q_temp1                 = f50
+sincosf_Q_temp2                 = f51
+
+sincosf_P                       = f52
+sincosf_Q                       = f53
+
+sincosf_srsq                    = f54
+
+sincosf_SIG_INV_PI_BY_16_2TO61  = f55
+sincosf_RSHF_2TO61              = f56
+sincosf_RSHF                    = f57
+sincosf_2TOM61                  = f58
+sincosf_NFLOAT                  = f59
+sincosf_W_2TO61_RSH             = f60
+
+fp_tmp                          = f61
+
+/////////////////////////////////////////////////////////////
+
+sincosf_AD_1                    = r33
+sincosf_AD_2                    = r34
+sincosf_exp_limit               = r35
+sincosf_r_signexp               = r36
+sincosf_AD_beta_table           = r37
+sincosf_r_sincos                = r38
+
+sincosf_r_exp                   = r39
+sincosf_r_17_ones               = r40
+
+sincosf_GR_sig_inv_pi_by_16     = r14
+sincosf_GR_rshf_2to61           = r15
+sincosf_GR_rshf                 = r16
+sincosf_GR_exp_2tom61           = r17
+sincosf_GR_n                    = r18
+sincosf_GR_m                    = r19
+sincosf_GR_32m                  = r19
+sincosf_GR_all_ones             = r19
+
+gr_tmp                          = r41
+GR_SAVE_PFS                     = r41
+GR_SAVE_B0                      = r42
+GR_SAVE_GP                      = r43
+
+RODATA
+.align 16
+
+// Pi/16 parts
+LOCAL_OBJECT_START(double_sincosf_pi)
+   data8 0xC90FDAA22168C234, 0x00003FFC // pi/16 1st part
+   data8 0xC4C6628B80DC1CD1, 0x00003FBC // pi/16 2nd part
+LOCAL_OBJECT_END(double_sincosf_pi)
+
+// Coefficients for polynomials
+LOCAL_OBJECT_START(double_sincosf_pq_k4)
+   data8 0x3F810FABB668E9A2 // P2
+   data8 0x3FA552E3D6DE75C9 // Q2
+   data8 0xBFC555554447BC7F // P1
+   data8 0xBFDFFFFFC447610A // Q1
+LOCAL_OBJECT_END(double_sincosf_pq_k4)
+
+// Sincos table (S[m], C[m])
+LOCAL_OBJECT_START(double_sin_cos_beta_k4)
+    data8 0x0000000000000000 // sin ( 0 Pi / 16 )
+    data8 0x3FF0000000000000 // cos ( 0 Pi / 16 )
+//
+    data8 0x3FC8F8B83C69A60B // sin ( 1 Pi / 16 )
+    data8 0x3FEF6297CFF75CB0 // cos ( 1 Pi / 16 )
+//
+    data8 0x3FD87DE2A6AEA963 // sin ( 2 Pi / 16 )
+    data8 0x3FED906BCF328D46 // cos ( 2 Pi / 16 )
+//
+    data8 0x3FE1C73B39AE68C8 // sin ( 3 Pi / 16 )
+    data8 0x3FEA9B66290EA1A3 // cos ( 3 Pi / 16 )
+//
+    data8 0x3FE6A09E667F3BCD // sin ( 4 Pi / 16 )
+    data8 0x3FE6A09E667F3BCD // cos ( 4 Pi / 16 )
+//
+    data8 0x3FEA9B66290EA1A3 // sin ( 5 Pi / 16 )
+    data8 0x3FE1C73B39AE68C8 // cos ( 5 Pi / 16 )
+//
+    data8 0x3FED906BCF328D46 // sin ( 6 Pi / 16 )
+    data8 0x3FD87DE2A6AEA963 // cos ( 6 Pi / 16 )
+//
+    data8 0x3FEF6297CFF75CB0 // sin ( 7 Pi / 16 )
+    data8 0x3FC8F8B83C69A60B // cos ( 7 Pi / 16 )
+//
+    data8 0x3FF0000000000000 // sin ( 8 Pi / 16 )
+    data8 0x0000000000000000 // cos ( 8 Pi / 16 )
+//
+    data8 0x3FEF6297CFF75CB0 // sin ( 9 Pi / 16 )
+    data8 0xBFC8F8B83C69A60B // cos ( 9 Pi / 16 )
+//
+    data8 0x3FED906BCF328D46 // sin ( 10 Pi / 16 )
+    data8 0xBFD87DE2A6AEA963 // cos ( 10 Pi / 16 )
+//
+    data8 0x3FEA9B66290EA1A3 // sin ( 11 Pi / 16 )
+    data8 0xBFE1C73B39AE68C8 // cos ( 11 Pi / 16 )
+//
+    data8 0x3FE6A09E667F3BCD // sin ( 12 Pi / 16 )
+    data8 0xBFE6A09E667F3BCD // cos ( 12 Pi / 16 )
+//
+    data8 0x3FE1C73B39AE68C8 // sin ( 13 Pi / 16 )
+    data8 0xBFEA9B66290EA1A3 // cos ( 13 Pi / 16 )
+//
+    data8 0x3FD87DE2A6AEA963 // sin ( 14 Pi / 16 )
+    data8 0xBFED906BCF328D46 // cos ( 14 Pi / 16 )
+//
+    data8 0x3FC8F8B83C69A60B // sin ( 15 Pi / 16 )
+    data8 0xBFEF6297CFF75CB0 // cos ( 15 Pi / 16 )
+//
+    data8 0x0000000000000000 // sin ( 16 Pi / 16 )
+    data8 0xBFF0000000000000 // cos ( 16 Pi / 16 )
+//
+    data8 0xBFC8F8B83C69A60B // sin ( 17 Pi / 16 )
+    data8 0xBFEF6297CFF75CB0 // cos ( 17 Pi / 16 )
+//
+    data8 0xBFD87DE2A6AEA963 // sin ( 18 Pi / 16 )
+    data8 0xBFED906BCF328D46 // cos ( 18 Pi / 16 )
+//
+    data8 0xBFE1C73B39AE68C8 // sin ( 19 Pi / 16 )
+    data8 0xBFEA9B66290EA1A3 // cos ( 19 Pi / 16 )
+//
+    data8 0xBFE6A09E667F3BCD // sin ( 20 Pi / 16 )
+    data8 0xBFE6A09E667F3BCD // cos ( 20 Pi / 16 )
+//
+    data8 0xBFEA9B66290EA1A3 // sin ( 21 Pi / 16 )
+    data8 0xBFE1C73B39AE68C8 // cos ( 21 Pi / 16 )
+//
+    data8 0xBFED906BCF328D46 // sin ( 22 Pi / 16 )
+    data8 0xBFD87DE2A6AEA963 // cos ( 22 Pi / 16 )
+//
+    data8 0xBFEF6297CFF75CB0 // sin ( 23 Pi / 16 )
+    data8 0xBFC8F8B83C69A60B // cos ( 23 Pi / 16 )
+//
+    data8 0xBFF0000000000000 // sin ( 24 Pi / 16 )
+    data8 0x0000000000000000 // cos ( 24 Pi / 16 )
+//
+    data8 0xBFEF6297CFF75CB0 // sin ( 25 Pi / 16 )
+    data8 0x3FC8F8B83C69A60B // cos ( 25 Pi / 16 )
+//
+    data8 0xBFED906BCF328D46 // sin ( 26 Pi / 16 )
+    data8 0x3FD87DE2A6AEA963 // cos ( 26 Pi / 16 )
+//
+    data8 0xBFEA9B66290EA1A3 // sin ( 27 Pi / 16 )
+    data8 0x3FE1C73B39AE68C8 // cos ( 27 Pi / 16 )
+//
+    data8 0xBFE6A09E667F3BCD // sin ( 28 Pi / 16 )
+    data8 0x3FE6A09E667F3BCD // cos ( 28 Pi / 16 )
+//
+    data8 0xBFE1C73B39AE68C8 // sin ( 29 Pi / 16 )
+    data8 0x3FEA9B66290EA1A3 // cos ( 29 Pi / 16 )
+//
+    data8 0xBFD87DE2A6AEA963 // sin ( 30 Pi / 16 )
+    data8 0x3FED906BCF328D46 // cos ( 30 Pi / 16 )
+//
+    data8 0xBFC8F8B83C69A60B // sin ( 31 Pi / 16 )
+    data8 0x3FEF6297CFF75CB0 // cos ( 31 Pi / 16 )
+//
+    data8 0x0000000000000000 // sin ( 32 Pi / 16 )
+    data8 0x3FF0000000000000 // cos ( 32 Pi / 16 )
+LOCAL_OBJECT_END(double_sin_cos_beta_k4)
+
+.section .text
+
+////////////////////////////////////////////////////////
+// There are two entry points: sin and cos
+// If from sin, p8 is true
+// If from cos, p9 is true
+
+GLOBAL_IEEE754_ENTRY(sinf)
+
+{ .mlx
+      alloc         r32                 = ar.pfs,1,13,0,0
+      movl  sincosf_GR_sig_inv_pi_by_16 = 0xA2F9836E4E44152A //signd of 16/pi
+}
+{ .mlx
+      addl         sincosf_AD_1         = @ltoff(double_sincosf_pi), gp
+      movl  sincosf_GR_rshf_2to61       = 0x47b8000000000000 // 1.1 2^(63+63-2)
+};;
+
+{ .mfi
+      ld8           sincosf_AD_1        = [sincosf_AD_1]
+      fnorm.s1      sincosf_NORM_f8     = f8     // Normalize argument
+      cmp.eq        p8,p9               = r0, r0 // set p8 (clear p9) for sin
+}
+{ .mib
+      mov           sincosf_GR_exp_2tom61 = 0xffff-61 // exponent of scale 2^-61
+      mov           sincosf_r_sincos      = 0x0       // 0 for sin
+      br.cond.sptk  _SINCOSF_COMMON                 // go to common part
+};;
+
+GLOBAL_IEEE754_END(sinf)
+libm_alias_float_other (__sin, sin)
+
+GLOBAL_IEEE754_ENTRY(cosf)
+
+{ .mlx
+      alloc         r32                 = ar.pfs,1,13,0,0
+      movl  sincosf_GR_sig_inv_pi_by_16 = 0xA2F9836E4E44152A //signd of 16/pi
+}
+{ .mlx
+      addl          sincosf_AD_1        = @ltoff(double_sincosf_pi), gp
+      movl  sincosf_GR_rshf_2to61       = 0x47b8000000000000 // 1.1 2^(63+63-2)
+};;
+
+{ .mfi
+      ld8           sincosf_AD_1        = [sincosf_AD_1]
+      fnorm.s1      sincosf_NORM_f8     = f8        // Normalize argument
+      cmp.eq        p9,p8               = r0, r0    // set p9 (clear p8) for cos
+}
+{ .mib
+      mov           sincosf_GR_exp_2tom61 = 0xffff-61 // exponent of scale 2^-61
+      mov           sincosf_r_sincos      = 0x8       // 8 for cos
+      nop.b         999
+};;
+
+////////////////////////////////////////////////////////
+// All entry points end up here.
+// If from sin, sincosf_r_sincos is 0 and p8 is true
+// If from cos, sincosf_r_sincos is 8 = 2^(k-1) and p9 is true
+// We add sincosf_r_sincos to N
+
+///////////// Common sin and cos part //////////////////
+_SINCOSF_COMMON:
+
+//  Form two constants we need
+//  16/pi * 2^-2 * 2^63, scaled by 2^61 since we just loaded the significand
+//  1.1000...000 * 2^(63+63-2) to right shift int(W) into the low significand
+//  fcmp used to set denormal, and invalid on snans
+{ .mfi
+      setf.sig      sincosf_SIG_INV_PI_BY_16_2TO61 = sincosf_GR_sig_inv_pi_by_16
+      fclass.m      p6,p0                          = f8, 0xe7 // if x=0,inf,nan
+      mov           sincosf_exp_limit              = 0x10017
+}
+{ .mlx
+      setf.d        sincosf_RSHF_2TO61  = sincosf_GR_rshf_2to61
+      movl          sincosf_GR_rshf     = 0x43e8000000000000 // 1.1000 2^63
+};;                                                          // Right shift
+
+//  Form another constant
+//  2^-61 for scaling Nfloat
+//  0x10017 is register_bias + 24.
+//  So if f8 >= 2^24, go to large argument routines
+{ .mmi
+      getf.exp      sincosf_r_signexp   = f8
+      setf.exp      sincosf_2TOM61      = sincosf_GR_exp_2tom61
+      addl          gr_tmp              = -1,r0 // For "inexect" constant create
+};;
+
+// Load the two pieces of pi/16
+// Form another constant
+//  1.1000...000 * 2^63, the right shift constant
+{ .mmb
+      ldfe          sincosf_Pi_by_16_1  = [sincosf_AD_1],16
+      setf.d        sincosf_RSHF        = sincosf_GR_rshf
+(p6)  br.cond.spnt  _SINCOSF_SPECIAL_ARGS
+};;
+
+// Getting argument's exp for "large arguments" filtering
+{ .mmi
+      ldfe          sincosf_Pi_by_16_2  = [sincosf_AD_1],16
+      setf.sig      fp_tmp              = gr_tmp // constant for inexact set
+      nop.i         999
+};;
+
+// Polynomial coefficients (Q2, Q1, P2, P1) loading
+{ .mmi
+      ldfpd         sincosf_P2,sincosf_Q2 = [sincosf_AD_1],16
+      nop.m         999
+      nop.i         999
+};;
+
+// Select exponent (17 lsb)
+{ .mmi
+      ldfpd         sincosf_P1,sincosf_Q1 = [sincosf_AD_1],16
+      nop.m         999
+      dep.z         sincosf_r_exp         = sincosf_r_signexp, 0, 17
+};;
+
+// p10 is true if we must call routines to handle larger arguments
+// p10 is true if f8 exp is >= 0x10017 (2^24)
+{ .mfb
+      cmp.ge        p10,p0              = sincosf_r_exp,sincosf_exp_limit
+      nop.f         999
+(p10) br.cond.spnt  _SINCOSF_LARGE_ARGS // Go to "large args" routine
+};;
+
+// sincosf_W          = x * sincosf_Inv_Pi_by_16
+// Multiply x by scaled 16/pi and add large const to shift integer part of W to
+//   rightmost bits of significand
+{ .mfi
+      nop.m         999
+      fma.s1 sincosf_W_2TO61_RSH = sincosf_NORM_f8, sincosf_SIG_INV_PI_BY_16_2TO61, sincosf_RSHF_2TO61
+      nop.i         999
+};;
+
+// sincosf_NFLOAT = Round_Int_Nearest(sincosf_W)
+// This is done by scaling back by 2^-61 and subtracting the shift constant
+{ .mfi
+      nop.m         999
+      fms.s1 sincosf_NFLOAT = sincosf_W_2TO61_RSH,sincosf_2TOM61,sincosf_RSHF
+      nop.i         999
+};;
+
+// get N = (int)sincosf_int_Nfloat
+{ .mfi
+      getf.sig      sincosf_GR_n        = sincosf_W_2TO61_RSH // integer N value
+      nop.f         999
+      nop.i         999
+};;
+
+// Add 2^(k-1) (which is in sincosf_r_sincos=8) to N
+// sincosf_r          = -sincosf_Nfloat * sincosf_Pi_by_16_1 + x
+{ .mfi
+      add           sincosf_GR_n        = sincosf_GR_n, sincosf_r_sincos
+      fnma.s1 sincosf_r = sincosf_NFLOAT, sincosf_Pi_by_16_1, sincosf_NORM_f8
+      nop.i         999
+};;
+
+// Get M (least k+1 bits of N)
+{ .mmi
+      and           sincosf_GR_m        = 0x1f,sincosf_GR_n // Put mask 0x1F  -
+      nop.m         999                                     // - select k+1 bits
+      nop.i         999
+};;
+
+// Add 16*M to address of sin_cos_beta table
+{ .mfi
+      shladd        sincosf_AD_2        = sincosf_GR_32m, 4, sincosf_AD_1
+(p8)  fclass.m.unc  p10,p0              = f8,0x0b  // If sin denormal input -
+      nop.i         999
+};;
+
+// Load Sin and Cos table value using obtained index m  (sincosf_AD_2)
+{ .mfi
+      ldfd          sincosf_Sm          = [sincosf_AD_2],8 // Sin value S[m]
+(p9)  fclass.m.unc  p11,p0              = f8,0x0b  // If cos denormal input -
+      nop.i         999                            // - set denormal
+};;
+
+// sincosf_r          = sincosf_r -sincosf_Nfloat * sincosf_Pi_by_16_2
+{ .mfi
+      ldfd          sincosf_Cm          = [sincosf_AD_2] // Cos table value C[m]
+      fnma.s1  sincosf_r_exact = sincosf_NFLOAT, sincosf_Pi_by_16_2, sincosf_r
+      nop.i         999
+}
+// get rsq = r*r
+{ .mfi
+      nop.m         999
+      fma.s1        sincosf_rsq         = sincosf_r, sincosf_r,  f0 // r^2 = r*r
+      nop.i         999
+};;
+
+{ .mfi
+      nop.m         999
+      fmpy.s0       fp_tmp              = fp_tmp, fp_tmp // forces inexact flag
+      nop.i         999
+};;
+
+// Polynomials calculation
+// Q = Q2*r^2 + Q1
+// P = P2*r^2 + P1
+{ .mfi
+      nop.m         999
+      fma.s1        sincosf_Q           = sincosf_rsq, sincosf_Q2, sincosf_Q1
+      nop.i         999
+}
+{ .mfi
+      nop.m         999
+      fma.s1        sincosf_P           = sincosf_rsq, sincosf_P2, sincosf_P1
+      nop.i         999
+};;
+
+// get rcube and S[m]*r^2
+{ .mfi
+      nop.m         999
+      fmpy.s1       sincosf_srsq        = sincosf_Sm,sincosf_rsq // r^2*S[m]
+      nop.i         999
+}
+{ .mfi
+      nop.m         999
+      fmpy.s1       sincosf_rcub        = sincosf_r_exact, sincosf_rsq
+      nop.i         999
+};;
+
+// Get final P and Q
+// Q = Q*S[m]*r^2 + S[m]
+// P = P*r^3 + r
+{ .mfi
+      nop.m         999
+      fma.s1        sincosf_Q           = sincosf_srsq,sincosf_Q, sincosf_Sm
+      nop.i         999
+}
+{ .mfi
+      nop.m         999
+      fma.s1        sincosf_P           = sincosf_rcub,sincosf_P,sincosf_r_exact
+      nop.i         999
+};;
+
+// If sinf(denormal) - force underflow to be set
+.pred.rel "mutex",p10,p11
+{ .mfi
+      nop.m         999
+(p10) fmpy.s.s0     fp_tmp              = f8,f8 // forces underflow flag
+      nop.i         999                         // for denormal sine args
+}
+// If cosf(denormal) - force denormal to be set
+{ .mfi
+      nop.m         999
+(p11) fma.s.s0     fp_tmp              = f8, f1, f8 // forces denormal flag
+      nop.i         999                              // for denormal cosine args
+};;
+
+
+// Final calculation
+// result = C[m]*P + Q
+{ .mfb
+      nop.m         999
+      fma.s.s0      f8                  = sincosf_Cm, sincosf_P, sincosf_Q
+      br.ret.sptk   b0 // Exit for common path
+};;
+
+////////// x = 0/Inf/NaN path //////////////////
+_SINCOSF_SPECIAL_ARGS:
+.pred.rel "mutex",p8,p9
+// sinf(+/-0) = +/-0
+// sinf(Inf)  = NaN
+// sinf(NaN)  = NaN
+{ .mfi
+      nop.m         999
+(p8)  fma.s.s0      f8                  = f8, f0, f0 // sinf(+/-0,NaN,Inf)
+      nop.i         999
+}
+// cosf(+/-0) = 1.0
+// cosf(Inf)  = NaN
+// cosf(NaN)  = NaN
+{ .mfb
+      nop.m         999
+(p9)  fma.s.s0      f8                  = f8, f0, f1 // cosf(+/-0,NaN,Inf)
+      br.ret.sptk   b0 // Exit for x = 0/Inf/NaN path
+};;
+
+GLOBAL_IEEE754_END(cosf)
+libm_alias_float_other (__cos, cos)
+
+//////////// x >= 2^24 - large arguments routine call ////////////
+LOCAL_LIBM_ENTRY(__libm_callout_sincosf)
+_SINCOSF_LARGE_ARGS:
+.prologue
+{ .mfi
+      mov           sincosf_GR_all_ones = -1 // 0xffffffff
+      nop.f         999
+.save ar.pfs,GR_SAVE_PFS
+      mov           GR_SAVE_PFS         = ar.pfs
+}
+;;
+
+{ .mfi
+      mov           GR_SAVE_GP          = gp
+      nop.f         999
+.save b0, GR_SAVE_B0
+      mov           GR_SAVE_B0          = b0
+}
+.body
+
+{ .mbb
+      setf.sig      sincosf_save_tmp    = sincosf_GR_all_ones  // inexact set
+      nop.b         999
+(p8)  br.call.sptk.many b0              = __libm_sin_large# // sinf(large_X)
+};;
+
+{ .mbb
+      cmp.ne        p9,p0               = sincosf_r_sincos, r0 // set p9 if cos
+      nop.b         999
+(p9)  br.call.sptk.many b0              = __libm_cos_large# // cosf(large_X)
+};;
+
+{ .mfi
+      mov           gp                  = GR_SAVE_GP
+      fma.s.s0      f8                  = f8, f1, f0 // Round result to single
+      mov           b0                  = GR_SAVE_B0
+}
+{ .mfi // force inexact set
+      nop.m         999
+      fmpy.s0       sincosf_save_tmp    = sincosf_save_tmp, sincosf_save_tmp
+      nop.i         999
+};;
+
+{ .mib
+      nop.m         999
+      mov           ar.pfs              = GR_SAVE_PFS
+      br.ret.sptk   b0 // Exit for large arguments routine call
+};;
+LOCAL_LIBM_END(__libm_callout_sincosf)
+
+.type    __libm_sin_large#, @function
+.global  __libm_sin_large#
+.type    __libm_cos_large#, @function
+.global  __libm_cos_large#
--- /dev/null
+++ a/sysdeps/ia64/fpu/s_cosl.S
@@ -0,0 +1,2366 @@
+.file "sincosl.s"
+
+
+// Copyright (c) 2000 - 2004, Intel Corporation
+// All rights reserved.
+//
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+// * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//
+// * Redistributions in binary form must reproduce the above copyright
+// notice, this list of conditions and the following disclaimer in the
+// documentation and/or other materials provided with the distribution.
+//
+// * The name of Intel Corporation may not be used to endorse or promote
+// products derived from this software without specific prior written
+// permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
+// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Intel Corporation is the author of this code, and requests that all
+// problem reports or change requests be submitted to it directly at
+// http://www.intel.com/software/products/opensource/libraries/num.htm.
+//
+//*********************************************************************
+//
+// History:
+// 02/02/00 (hand-optimized)
+// 04/04/00 Unwind support added
+// 07/30/01 Improved speed on all paths
+// 08/20/01 Fixed bundling typo
+// 05/13/02 Changed interface to __libm_pi_by_2_reduce
+// 02/10/03 Reordered header: .section, .global, .proc, .align;
+//          used data8 for long double table values
+// 10/13/03 Corrected final .endp name to match .proc
+// 10/26/04 Avoided using r14-31 as scratch so not clobbered by dynamic loader
+//
+//*********************************************************************
+//
+// Function:   Combined sinl(x) and cosl(x), where
+//
+//             sinl(x) = sine(x), for double-extended precision x values
+//             cosl(x) = cosine(x), for double-extended precision x values
+//
+//*********************************************************************
+//
+// Resources Used:
+//
+//    Floating-Point Registers: f8 (Input and Return Value)
+//                              f32-f99
+//
+//    General Purpose Registers:
+//      r32-r58
+//
+//    Predicate Registers:      p6-p13
+//
+//*********************************************************************
+//
+//  IEEE Special Conditions:
+//
+//    Denormal  fault raised on denormal inputs
+//    Overflow exceptions do not occur
+//    Underflow exceptions raised when appropriate for sin
+//    (No specialized error handling for this routine)
+//    Inexact raised when appropriate by algorithm
+//
+//    sinl(SNaN) = QNaN
+//    sinl(QNaN) = QNaN
+//    sinl(inf) = QNaN
+//    sinl(+/-0) = +/-0
+//    cosl(inf) = QNaN
+//    cosl(SNaN) = QNaN
+//    cosl(QNaN) = QNaN
+//    cosl(0) = 1
+//
+//*********************************************************************
+//
+//  Mathematical Description
+//  ========================
+//
+//  The computation of FSIN and FCOS is best handled in one piece of
+//  code. The main reason is that given any argument Arg, computation
+//  of trigonometric functions first calculate N and an approximation
+//  to alpha where
+//
+//  Arg = N pi/2 + alpha, |alpha| <= pi/4.
+//
+//  Since
+//
+//  cosl( Arg ) = sinl( (N+1) pi/2 + alpha ),
+//
+//  therefore, the code for computing sine will produce cosine as long
+//  as 1 is added to N immediately after the argument reduction
+//  process.
+//
+//  Let M = N if sine
+//      N+1 if cosine.
+//
+//  Now, given
+//
+//  Arg = M pi/2  + alpha, |alpha| <= pi/4,
+//
+//  let I = M mod 4, or I be the two lsb of M when M is represented
+//  as 2's complement. I = [i_0 i_1]. Then
+//
+//  sinl( Arg ) = (-1)^i_0  sinl( alpha )        if i_1 = 0,
+//             = (-1)^i_0  cosl( alpha )     if i_1 = 1.
+//
+//  For example:
+//       if M = -1, I = 11
+//         sin ((-pi/2 + alpha) = (-1) cos (alpha)
+//       if M = 0, I = 00
+//         sin (alpha) = sin (alpha)
+//       if M = 1, I = 01
+//         sin (pi/2 + alpha) = cos (alpha)
+//       if M = 2, I = 10
+//         sin (pi + alpha) = (-1) sin (alpha)
+//       if M = 3, I = 11
+//         sin ((3/2)pi + alpha) = (-1) cos (alpha)
+//
+//  The value of alpha is obtained by argument reduction and
+//  represented by two working precision numbers r and c where
+//
+//  alpha =  r  +  c     accurately.
+//
+//  The reduction method is described in a previous write up.
+//  The argument reduction scheme identifies 4 cases. For Cases 2
+//  and 4, because |alpha| is small, sinl(r+c) and cosl(r+c) can be
+//  computed very easily by 2 or 3 terms of the Taylor series
+//  expansion as follows:
+//
+//  Case 2:
+//  -------
+//
+//  sinl(r + c) = r + c - r^3/6        accurately
+//  cosl(r + c) = 1 - 2^(-67)        accurately
+//
+//  Case 4:
+//  -------
+//
+//  sinl(r + c) = r + c - r^3/6 + r^5/120        accurately
+//  cosl(r + c) = 1 - r^2/2 + r^4/24                accurately
+//
+//  The only cases left are Cases 1 and 3 of the argument reduction
+//  procedure. These two cases will be merged since after the
+//  argument is reduced in either cases, we have the reduced argument
+//  represented as r + c and that the magnitude |r + c| is not small
+//  enough to allow the usage of a very short approximation.
+//
+//  The required calculation is either
+//
+//  sinl(r + c)  =  sinl(r)  +  correction,  or
+//  cosl(r + c)  =  cosl(r)  +  correction.
+//
+//  Specifically,
+//
+//        sinl(r + c) = sinl(r) + c sin'(r) + O(c^2)
+//                   = sinl(r) + c cos (r) + O(c^2)
+//                   = sinl(r) + c(1 - r^2/2)  accurately.
+//  Similarly,
+//
+//        cosl(r + c) = cosl(r) - c sinl(r) + O(c^2)
+//                   = cosl(r) - c(r - r^3/6)  accurately.
+//
+//  We therefore concentrate on accurately calculating sinl(r) and
+//  cosl(r) for a working-precision number r, |r| <= pi/4 to within
+//  0.1% or so.
+//
+//  The greatest challenge of this task is that the second terms of
+//  the Taylor series
+//
+//        r - r^3/3! + r^r/5! - ...
+//
+//  and
+//
+//        1 - r^2/2! + r^4/4! - ...
+//
+//  are not very small when |r| is close to pi/4 and the rounding
+//  errors will be a concern if simple polynomial accumulation is
+//  used. When |r| < 2^-3, however, the second terms will be small
+//  enough (6 bits or so of right shift) that a normal Horner
+//  recurrence suffices. Hence there are two cases that we consider
+//  in the accurate computation of sinl(r) and cosl(r), |r| <= pi/4.
+//
+//  Case small_r: |r| < 2^(-3)
+//  --------------------------
+//
+//  Since Arg = M pi/4 + r + c accurately, and M mod 4 is [i_0 i_1],
+//  we have
+//
+//        sinl(Arg) = (-1)^i_0 * sinl(r + c)        if i_1 = 0
+//                 = (-1)^i_0 * cosl(r + c)         if i_1 = 1
+//
+//  can be accurately approximated by
+//
+//  sinl(Arg) = (-1)^i_0 * [sinl(r) + c]        if i_1 = 0
+//           = (-1)^i_0 * [cosl(r) - c*r] if i_1 = 1
+//
+//  because |r| is small and thus the second terms in the correction
+//  are unnecessary.
+//
+//  Finally, sinl(r) and cosl(r) are approximated by polynomials of
+//  moderate lengths.
+//
+//  sinl(r) =  r + S_1 r^3 + S_2 r^5 + ... + S_5 r^11
+//  cosl(r) =  1 + C_1 r^2 + C_2 r^4 + ... + C_5 r^10
+//
+//  We can make use of predicates to selectively calculate
+//  sinl(r) or cosl(r) based on i_1.
+//
+//  Case normal_r: 2^(-3) <= |r| <= pi/4
+//  ------------------------------------
+//
+//  This case is more likely than the previous one if one considers
+//  r to be uniformly distributed in [-pi/4 pi/4]. Again,
+//
+//  sinl(Arg) = (-1)^i_0 * sinl(r + c)        if i_1 = 0
+//           = (-1)^i_0 * cosl(r + c)         if i_1 = 1.
+//
+//  Because |r| is now larger, we need one extra term in the
+//  correction. sinl(Arg) can be accurately approximated by
+//
+//  sinl(Arg) = (-1)^i_0 * [sinl(r) + c(1-r^2/2)]      if i_1 = 0
+//           = (-1)^i_0 * [cosl(r) - c*r*(1 - r^2/6)]    i_1 = 1.
+//
+//  Finally, sinl(r) and cosl(r) are approximated by polynomials of
+//  moderate lengths.
+//
+//        sinl(r) =  r + PP_1_hi r^3 + PP_1_lo r^3 +
+//                      PP_2 r^5 + ... + PP_8 r^17
+//
+//        cosl(r) =  1 + QQ_1 r^2 + QQ_2 r^4 + ... + QQ_8 r^16
+//
+//  where PP_1_hi is only about 16 bits long and QQ_1 is -1/2.
+//  The crux in accurate computation is to calculate
+//
+//  r + PP_1_hi r^3   or  1 + QQ_1 r^2
+//
+//  accurately as two pieces: U_hi and U_lo. The way to achieve this
+//  is to obtain r_hi as a 10 sig. bit number that approximates r to
+//  roughly 8 bits or so of accuracy. (One convenient way is
+//
+//  r_hi := frcpa( frcpa( r ) ).)
+//
+//  This way,
+//
+//        r + PP_1_hi r^3 =  r + PP_1_hi r_hi^3 +
+//                                PP_1_hi (r^3 - r_hi^3)
+//                        =  [r + PP_1_hi r_hi^3]  +
+//                           [PP_1_hi (r - r_hi)
+//                              (r^2 + r_hi r + r_hi^2) ]
+//                        =  U_hi  +  U_lo
+//
+//  Since r_hi is only 10 bit long and PP_1_hi is only 16 bit long,
+//  PP_1_hi * r_hi^3 is only at most 46 bit long and thus computed
+//  exactly. Furthermore, r and PP_1_hi r_hi^3 are of opposite sign
+//  and that there is no more than 8 bit shift off between r and
+//  PP_1_hi * r_hi^3. Hence the sum, U_hi, is representable and thus
+//  calculated without any error. Finally, the fact that
+//
+//        |U_lo| <= 2^(-8) |U_hi|
+//
+//  says that U_hi + U_lo is approximating r + PP_1_hi r^3 to roughly
+//  8 extra bits of accuracy.
+//
+//  Similarly,
+//
+//        1 + QQ_1 r^2  =  [1 + QQ_1 r_hi^2]  +
+//                            [QQ_1 (r - r_hi)(r + r_hi)]
+//                      =  U_hi  +  U_lo.
+//
+//  Summarizing, we calculate r_hi = frcpa( frcpa( r ) ).
+//
+//  If i_1 = 0, then
+//
+//    U_hi := r + PP_1_hi * r_hi^3
+//    U_lo := PP_1_hi * (r - r_hi) * (r^2 + r*r_hi + r_hi^2)
+//    poly := PP_1_lo r^3 + PP_2 r^5 + ... + PP_8 r^17
+//    correction := c * ( 1 + C_1 r^2 )
+//
+//  Else ...i_1 = 1
+//
+//    U_hi := 1 + QQ_1 * r_hi * r_hi
+//    U_lo := QQ_1 * (r - r_hi) * (r + r_hi)
+//    poly := QQ_2 * r^4 + QQ_3 * r^6 + ... + QQ_8 r^16
+//    correction := -c * r * (1 + S_1 * r^2)
+//
+//  End
+//
+//  Finally,
+//
+//        V := poly + ( U_lo + correction )
+//
+//                 /    U_hi  +  V         if i_0 = 0
+//        result := |
+//                 \  (-U_hi) -  V         if i_0 = 1
+//
+//  It is important that in the last step, negation of U_hi is
+//  performed prior to the subtraction which is to be performed in
+//  the user-set rounding mode.
+//
+//
+//  Algorithmic Description
+//  =======================
+//
+//  The argument reduction algorithm is tightly integrated into FSIN
+//  and FCOS which share the same code. The following is complete and
+//  self-contained. The argument reduction description given
+//  previously is repeated below.
+//
+//
+//  Step 0. Initialization.
+//
+//   If FSIN is invoked, set N_inc := 0; else if FCOS is invoked,
+//   set N_inc := 1.
+//
+//  Step 1. Check for exceptional and special cases.
+//
+//   * If Arg is +-0, +-inf, NaN, NaT, go to Step 10 for special
+//     handling.
+//   * If |Arg| < 2^24, go to Step 2 for reduction of moderate
+//     arguments. This is the most likely case.
+//   * If |Arg| < 2^63, go to Step 8 for pre-reduction of large
+//     arguments.
+//   * If |Arg| >= 2^63, go to Step 10 for special handling.
+//
+//  Step 2. Reduction of moderate arguments.
+//
+//  If |Arg| < pi/4         ...quick branch
+//     N_fix := N_inc        (integer)
+//     r     := Arg
+//     c     := 0.0
+//     Branch to Step 4, Case_1_complete
+//  Else                 ...cf. argument reduction
+//     N     := Arg * two_by_PI        (fp)
+//     N_fix := fcvt.fx( N )        (int)
+//     N     := fcvt.xf( N_fix )
+//     N_fix := N_fix + N_inc
+//     s     := Arg - N * P_1        (first piece of pi/2)
+//     w     := -N * P_2        (second piece of pi/2)
+//
+//     If |s| >= 2^(-33)
+//        go to Step 3, Case_1_reduce
+//     Else
+//        go to Step 7, Case_2_reduce
+//     Endif
+//  Endif
+//
+//  Step 3. Case_1_reduce.
+//
+//  r := s + w
+//  c := (s - r) + w        ...observe order
+//
+//  Step 4. Case_1_complete
+//
+//  ...At this point, the reduced argument alpha is
+//  ...accurately represented as r + c.
+//  If |r| < 2^(-3), go to Step 6, small_r.
+//
+//  Step 5. Normal_r.
+//
+//  Let [i_0 i_1] by the 2 lsb of N_fix.
+//  FR_rsq  := r * r
+//  r_hi := frcpa( frcpa( r ) )
+//  r_lo := r - r_hi
+//
+//  If i_1 = 0, then
+//    poly := r*FR_rsq*(PP_1_lo + FR_rsq*(PP_2 + ... FR_rsq*PP_8))
+//    U_hi := r + PP_1_hi*r_hi*r_hi*r_hi        ...any order
+//    U_lo := PP_1_hi*r_lo*(r*r + r*r_hi + r_hi*r_hi)
+//    correction := c + c*C_1*FR_rsq                ...any order
+//  Else
+//    poly := FR_rsq*FR_rsq*(QQ_2 + FR_rsq*(QQ_3 + ... + FR_rsq*QQ_8))
+//    U_hi := 1 + QQ_1 * r_hi * r_hi                ...any order
+//    U_lo := QQ_1 * r_lo * (r + r_hi)
+//    correction := -c*(r + S_1*FR_rsq*r)        ...any order
+//  Endif
+//
+//  V := poly + (U_lo + correction)        ...observe order
+//
+//  result := (i_0 == 0?   1.0 : -1.0)
+//
+//  Last instruction in user-set rounding mode
+//
+//  result := (i_0 == 0?   result*U_hi + V :
+//                        result*U_hi - V)
+//
+//  Return
+//
+//  Step 6. Small_r.
+//
+//  ...Use flush to zero mode without causing exception
+//    Let [i_0 i_1] be the two lsb of N_fix.
+//
+//  FR_rsq := r * r
+//
+//  If i_1 = 0 then
+//     z := FR_rsq*FR_rsq; z := FR_rsq*z *r
+//     poly_lo := S_3 + FR_rsq*(S_4 + FR_rsq*S_5)
+//     poly_hi := r*FR_rsq*(S_1 + FR_rsq*S_2)
+//     correction := c
+//     result := r
+//  Else
+//     z := FR_rsq*FR_rsq; z := FR_rsq*z
+//     poly_lo := C_3 + FR_rsq*(C_4 + FR_rsq*C_5)
+//     poly_hi := FR_rsq*(C_1 + FR_rsq*C_2)
+//     correction := -c*r
+//     result := 1
+//  Endif
+//
+//  poly := poly_hi + (z * poly_lo + correction)
+//
+//  If i_0 = 1, result := -result
+//
+//  Last operation. Perform in user-set rounding mode
+//
+//  result := (i_0 == 0?     result + poly :
+//                          result - poly )
+//  Return
+//
+//  Step 7. Case_2_reduce.
+//
+//  ...Refer to the write up for argument reduction for
+//  ...rationale. The reduction algorithm below is taken from
+//  ...argument reduction description and integrated this.
+//
+//  w := N*P_3
+//  U_1 := N*P_2 + w                ...FMA
+//  U_2 := (N*P_2 - U_1) + w        ...2 FMA
+//  ...U_1 + U_2 is  N*(P_2+P_3) accurately
+//
+//  r := s - U_1
+//  c := ( (s - r) - U_1 ) - U_2
+//
+//  ...The mathematical sum r + c approximates the reduced
+//  ...argument accurately. Note that although compared to
+//  ...Case 1, this case requires much more work to reduce
+//  ...the argument, the subsequent calculation needed for
+//  ...any of the trigonometric function is very little because
+//  ...|alpha| < 1.01*2^(-33) and thus two terms of the
+//  ...Taylor series expansion suffices.
+//
+//  If i_1 = 0 then
+//     poly := c + S_1 * r * r * r        ...any order
+//     result := r
+//  Else
+//     poly := -2^(-67)
+//     result := 1.0
+//  Endif
+//
+//  If i_0 = 1, result := -result
+//
+//  Last operation. Perform in user-set rounding mode
+//
+//  result := (i_0 == 0?     result + poly :
+//                           result - poly )
+//
+//  Return
+//
+//
+//  Step 8. Pre-reduction of large arguments.
+//
+//  ...Again, the following reduction procedure was described
+//  ...in the separate write up for argument reduction, which
+//  ...is tightly integrated here.
+
+//  N_0 := Arg * Inv_P_0
+//  N_0_fix := fcvt.fx( N_0 )
+//  N_0 := fcvt.xf( N_0_fix)
+
+//  Arg' := Arg - N_0 * P_0
+//  w := N_0 * d_1
+//  N := Arg' * two_by_PI
+//  N_fix := fcvt.fx( N )
+//  N := fcvt.xf( N_fix )
+//  N_fix := N_fix + N_inc
+//
+//  s := Arg' - N * P_1
+//  w := w - N * P_2
+//
+//  If |s| >= 2^(-14)
+//     go to Step 3
+//  Else
+//     go to Step 9
+//  Endif
+//
+//  Step 9. Case_4_reduce.
+//
+//    ...first obtain N_0*d_1 and -N*P_2 accurately
+//   U_hi := N_0 * d_1                V_hi := -N*P_2
+//   U_lo := N_0 * d_1 - U_hi        V_lo := -N*P_2 - U_hi        ...FMAs
+//
+//   ...compute the contribution from N_0*d_1 and -N*P_3
+//   w := -N*P_3
+//   w := w + N_0*d_2
+//   t := U_lo + V_lo + w                ...any order
+//
+//   ...at this point, the mathematical value
+//   ...s + U_hi + V_hi  + t approximates the true reduced argument
+//   ...accurately. Just need to compute this accurately.
+//
+//   ...Calculate U_hi + V_hi accurately:
+//   A := U_hi + V_hi
+//   if |U_hi| >= |V_hi| then
+//      a := (U_hi - A) + V_hi
+//   else
+//      a := (V_hi - A) + U_hi
+//   endif
+//   ...order in computing "a" must be observed. This branch is
+//   ...best implemented by predicates.
+//   ...A + a  is U_hi + V_hi accurately. Moreover, "a" is
+//   ...much smaller than A: |a| <= (1/2)ulp(A).
+//
+//   ...Just need to calculate   s + A + a + t
+//   C_hi := s + A                t := t + a
+//   C_lo := (s - C_hi) + A
+//   C_lo := C_lo + t
+//
+//   ...Final steps for reduction
+//   r := C_hi + C_lo
+//   c := (C_hi - r) + C_lo
+//
+//   ...At this point, we have r and c
+//   ...And all we need is a couple of terms of the corresponding
+//   ...Taylor series.
+//
+//   If i_1 = 0
+//      poly := c + r*FR_rsq*(S_1 + FR_rsq*S_2)
+//      result := r
+//   Else
+//      poly := FR_rsq*(C_1 + FR_rsq*C_2)
+//      result := 1
+//   Endif
+//
+//   If i_0 = 1, result := -result
+//
+//   Last operation. Perform in user-set rounding mode
+//
+//   result := (i_0 == 0?     result + poly :
+//                            result - poly )
+//   Return
+//
+//   Large Arguments: For arguments above 2**63, a Payne-Hanek
+//   style argument reduction is used and pi_by_2 reduce is called.
+//
+
+
+RODATA
+.align 16
+
+LOCAL_OBJECT_START(FSINCOSL_CONSTANTS)
+
+sincosl_table_p:
+data8 0xA2F9836E4E44152A, 0x00003FFE // Inv_pi_by_2
+data8 0xC84D32B0CE81B9F1, 0x00004016 // P_0
+data8 0xC90FDAA22168C235, 0x00003FFF // P_1
+data8 0xECE675D1FC8F8CBB, 0x0000BFBD // P_2
+data8 0xB7ED8FBBACC19C60, 0x0000BF7C // P_3
+data8 0x8D848E89DBD171A1, 0x0000BFBF // d_1
+data8 0xD5394C3618A66F8E, 0x0000BF7C // d_2
+LOCAL_OBJECT_END(FSINCOSL_CONSTANTS)
+
+LOCAL_OBJECT_START(sincosl_table_d)
+data8 0xC90FDAA22168C234, 0x00003FFE // pi_by_4
+data8 0xA397E5046EC6B45A, 0x00003FE7 // Inv_P_0
+data4 0x3E000000, 0xBE000000         // 2^-3 and -2^-3
+data4 0x2F000000, 0xAF000000         // 2^-33 and -2^-33
+data4 0x9E000000, 0x00000000         // -2^-67
+data4 0x00000000, 0x00000000         // pad
+LOCAL_OBJECT_END(sincosl_table_d)
+
+LOCAL_OBJECT_START(sincosl_table_pp)
+data8 0xCC8ABEBCA21C0BC9, 0x00003FCE // PP_8
+data8 0xD7468A05720221DA, 0x0000BFD6 // PP_7
+data8 0xB092382F640AD517, 0x00003FDE // PP_6
+data8 0xD7322B47D1EB75A4, 0x0000BFE5 // PP_5
+data8 0xFFFFFFFFFFFFFFFE, 0x0000BFFD // C_1
+data8 0xAAAA000000000000, 0x0000BFFC // PP_1_hi
+data8 0xB8EF1D2ABAF69EEA, 0x00003FEC // PP_4
+data8 0xD00D00D00D03BB69, 0x0000BFF2 // PP_3
+data8 0x8888888888888962, 0x00003FF8 // PP_2
+data8 0xAAAAAAAAAAAB0000, 0x0000BFEC // PP_1_lo
+LOCAL_OBJECT_END(sincosl_table_pp)
+
+LOCAL_OBJECT_START(sincosl_table_qq)
+data8 0xD56232EFC2B0FE52, 0x00003FD2 // QQ_8
+data8 0xC9C99ABA2B48DCA6, 0x0000BFDA // QQ_7
+data8 0x8F76C6509C716658, 0x00003FE2 // QQ_6
+data8 0x93F27DBAFDA8D0FC, 0x0000BFE9 // QQ_5
+data8 0xAAAAAAAAAAAAAAAA, 0x0000BFFC // S_1
+data8 0x8000000000000000, 0x0000BFFE // QQ_1
+data8 0xD00D00D00C6E5041, 0x00003FEF // QQ_4
+data8 0xB60B60B60B607F60, 0x0000BFF5 // QQ_3
+data8 0xAAAAAAAAAAAAAA9B, 0x00003FFA // QQ_2
+LOCAL_OBJECT_END(sincosl_table_qq)
+
+LOCAL_OBJECT_START(sincosl_table_c)
+data8 0xFFFFFFFFFFFFFFFE, 0x0000BFFD // C_1
+data8 0xAAAAAAAAAAAA719F, 0x00003FFA // C_2
+data8 0xB60B60B60356F994, 0x0000BFF5 // C_3
+data8 0xD00CFFD5B2385EA9, 0x00003FEF // C_4
+data8 0x93E4BD18292A14CD, 0x0000BFE9 // C_5
+LOCAL_OBJECT_END(sincosl_table_c)
+
+LOCAL_OBJECT_START(sincosl_table_s)
+data8 0xAAAAAAAAAAAAAAAA, 0x0000BFFC // S_1
+data8 0x88888888888868DB, 0x00003FF8 // S_2
+data8 0xD00D00D0055EFD4B, 0x0000BFF2 // S_3
+data8 0xB8EF1C5D839730B9, 0x00003FEC // S_4
+data8 0xD71EA3A4E5B3F492, 0x0000BFE5 // S_5
+data4 0x38800000, 0xB8800000                        // two**-14 and -two**-14
+LOCAL_OBJECT_END(sincosl_table_s)
+
+FR_Input_X        = f8
+FR_Result         = f8
+
+FR_r              = f8
+FR_c              = f9
+
+FR_norm_x         = f9
+FR_inv_pi_2to63   = f10
+FR_rshf_2to64     = f11
+FR_2tom64         = f12
+FR_rshf           = f13
+FR_N_float_signif = f14
+FR_abs_x          = f15
+FR_Pi_by_4        = f34
+FR_Two_to_M14     = f35
+FR_Neg_Two_to_M14 = f36
+FR_Two_to_M33     = f37
+FR_Neg_Two_to_M33 = f38
+FR_Neg_Two_to_M67 = f39
+FR_Inv_pi_by_2    = f40
+FR_N_float        = f41
+FR_N_fix          = f42
+FR_P_1            = f43
+FR_P_2            = f44
+FR_P_3            = f45
+FR_s              = f46
+FR_w              = f47
+FR_d_2            = f48
+FR_tmp_result     = f49
+FR_Z              = f50
+FR_A              = f51
+FR_a              = f52
+FR_t              = f53
+FR_U_1            = f54
+FR_U_2            = f55
+FR_C_1            = f56
+FR_C_2            = f57
+FR_C_3            = f58
+FR_C_4            = f59
+FR_C_5            = f60
+FR_S_1            = f61
+FR_S_2            = f62
+FR_S_3            = f63
+FR_S_4            = f64
+FR_S_5            = f65
+FR_poly_hi        = f66
+FR_poly_lo        = f67
+FR_r_hi           = f68
+FR_r_lo           = f69
+FR_rsq            = f70
+FR_r_cubed        = f71
+FR_C_hi           = f72
+FR_N_0            = f73
+FR_d_1            = f74
+FR_V              = f75
+FR_V_hi           = f75
+FR_V_lo           = f76
+FR_U_hi           = f77
+FR_U_lo           = f78
+FR_U_hiabs        = f79
+FR_V_hiabs        = f80
+FR_PP_8           = f81
+FR_QQ_8           = f101
+FR_PP_7           = f82
+FR_QQ_7           = f102
+FR_PP_6           = f83
+FR_QQ_6           = f103
+FR_PP_5           = f84
+FR_QQ_5           = f104
+FR_PP_4           = f85
+FR_QQ_4           = f105
+FR_PP_3           = f86
+FR_QQ_3           = f106
+FR_PP_2           = f87
+FR_QQ_2           = f107
+FR_QQ_1           = f108
+FR_r_hi_sq        = f88
+FR_N_0_fix        = f89
+FR_Inv_P_0        = f90
+FR_corr           = f91
+FR_poly           = f92
+FR_Neg_Two_to_M3  = f93
+FR_Two_to_M3      = f94
+FR_P_0            = f95
+FR_C_lo           = f96
+FR_PP_1           = f97
+FR_PP_1_lo        = f98
+FR_ArgPrime       = f99
+FR_inexact        = f100
+
+GR_exp_m2_to_m3= r36
+GR_N_Inc       = r37
+GR_Sin_or_Cos  = r38
+GR_signexp_x   = r40
+GR_exp_x       = r40
+GR_exp_mask    = r41
+GR_exp_2_to_63 = r42
+GR_exp_2_to_m3 = r43
+GR_exp_2_to_24 = r44
+
+GR_sig_inv_pi  = r45
+GR_rshf_2to64  = r46
+GR_exp_2tom64  = r47
+GR_rshf        = r48
+GR_ad_p        = r49
+GR_ad_d        = r50
+GR_ad_pp       = r51
+GR_ad_qq       = r52
+GR_ad_c        = r53
+GR_ad_s        = r54
+GR_ad_ce       = r55
+GR_ad_se       = r56
+GR_ad_m14      = r57
+GR_ad_s1       = r58
+
+// Added for unwind support
+
+GR_SAVE_B0     = r39
+GR_SAVE_GP     = r40
+GR_SAVE_PFS    = r41
+
+
+.section .text
+
+GLOBAL_IEEE754_ENTRY(sinl)
+{ .mlx
+      alloc r32 = ar.pfs,0,27,2,0
+      movl GR_sig_inv_pi = 0xa2f9836e4e44152a // significand of 1/pi
+}
+{ .mlx
+      mov GR_Sin_or_Cos = 0x0
+      movl GR_rshf_2to64 = 0x47e8000000000000 // 1.1000 2^(63+64)
+}
+;;
+
+{ .mfi
+      addl           GR_ad_p   = @ltoff(FSINCOSL_CONSTANTS#), gp
+      fclass.m p6, p0 =  FR_Input_X, 0x1E3 // Test x natval, nan, inf
+      mov GR_exp_2_to_m3 = 0xffff - 3      // Exponent of 2^-3
+}
+{ .mfb
+      nop.m 999
+      fnorm.s1 FR_norm_x = FR_Input_X      // Normalize x
+      br.cond.sptk SINCOSL_CONTINUE
+}
+;;
+
+GLOBAL_IEEE754_END(sinl)
+libm_alias_ldouble_other (__sin, sin)
+
+GLOBAL_IEEE754_ENTRY(cosl)
+{ .mlx
+      alloc r32 = ar.pfs,0,27,2,0
+      movl GR_sig_inv_pi = 0xa2f9836e4e44152a // significand of 1/pi
+}
+{ .mlx
+      mov GR_Sin_or_Cos = 0x1
+      movl GR_rshf_2to64 = 0x47e8000000000000 // 1.1000 2^(63+64)
+}
+;;
+
+{ .mfi
+      addl           GR_ad_p   = @ltoff(FSINCOSL_CONSTANTS#), gp
+      fclass.m p6, p0 =  FR_Input_X, 0x1E3 // Test x natval, nan, inf
+      mov GR_exp_2_to_m3 = 0xffff - 3      // Exponent of 2^-3
+}
+{ .mfi
+      nop.m 999
+      fnorm.s1 FR_norm_x = FR_Input_X      // Normalize x
+      nop.i 999
+}
+;;
+
+SINCOSL_CONTINUE:
+{ .mfi
+      setf.sig FR_inv_pi_2to63 = GR_sig_inv_pi // Form 1/pi * 2^63
+      nop.f 999
+      mov GR_exp_2tom64 = 0xffff - 64      // Scaling constant to compute N
+}
+{ .mlx
+      setf.d FR_rshf_2to64 = GR_rshf_2to64    // Form const 1.1000 * 2^(63+64)
+      movl GR_rshf = 0x43e8000000000000       // Form const 1.1000 * 2^63
+}
+;;
+
+{ .mfi
+      ld8 GR_ad_p = [GR_ad_p]              // Point to Inv_pi_by_2
+      fclass.m p7, p0 = FR_Input_X, 0x0b   // Test x denormal
+      nop.i 999
+}
+;;
+
+{ .mfi
+      getf.exp GR_signexp_x = FR_Input_X   // Get sign and exponent of x
+      fclass.m p10, p0 = FR_Input_X, 0x007 // Test x zero
+      nop.i 999
+}
+{ .mib
+      mov GR_exp_mask = 0x1ffff            // Exponent mask
+      nop.i 999
+(p6)  br.cond.spnt SINCOSL_SPECIAL         // Branch if x natval, nan, inf
+}
+;;
+
+{ .mfi
+      setf.exp FR_2tom64 = GR_exp_2tom64   // Form 2^-64 for scaling N_float
+      nop.f 0
+      add GR_ad_d = 0x70, GR_ad_p          // Point to constant table d
+}
+{ .mib
+      setf.d FR_rshf = GR_rshf         // Form right shift const 1.1000 * 2^63
+      mov  GR_exp_m2_to_m3 = 0x2fffc       // Form -(2^-3)
+(p7)  br.cond.spnt SINCOSL_DENORMAL        // Branch if x denormal
+}
+;;
+
+SINCOSL_COMMON:
+{ .mfi
+      and GR_exp_x = GR_exp_mask, GR_signexp_x // Get exponent of x
+      fclass.nm p8, p0 = FR_Input_X, 0x1FF // Test x unsupported type
+      mov GR_exp_2_to_63 = 0xffff + 63     // Exponent of 2^63
+}
+{ .mib
+      add GR_ad_pp = 0x40, GR_ad_d         // Point to constant table pp
+      mov GR_exp_2_to_24 = 0xffff + 24     // Exponent of 2^24
+(p10) br.cond.spnt SINCOSL_ZERO            // Branch if x zero
+}
+;;
+
+{ .mfi
+      ldfe FR_Inv_pi_by_2 = [GR_ad_p], 16  // Load 2/pi
+      fcmp.eq.s0 p15, p0 = FR_Input_X, f0  // Dummy to set denormal
+      add GR_ad_qq = 0xa0, GR_ad_pp        // Point to constant table qq
+}
+{ .mfi
+      ldfe FR_Pi_by_4 = [GR_ad_d], 16      // Load pi/4 for range test
+      nop.f 999
+      cmp.ge p10,p0 = GR_exp_x, GR_exp_2_to_63   // Is |x| >= 2^63
+}
+;;
+
+{ .mfi
+      ldfe FR_P_0 = [GR_ad_p], 16          // Load P_0 for pi/4 <= |x| < 2^63
+      fmerge.s FR_abs_x = f1, FR_norm_x    // |x|
+      add GR_ad_c = 0x90, GR_ad_qq         // Point to constant table c
+}
+{ .mfi
+      ldfe FR_Inv_P_0 = [GR_ad_d], 16      // Load 1/P_0 for pi/4 <= |x| < 2^63
+      nop.f 999
+      cmp.ge p7,p0 = GR_exp_x, GR_exp_2_to_24   // Is |x| >= 2^24
+}
+;;
+
+{ .mfi
+      ldfe FR_P_1 = [GR_ad_p], 16          // Load P_1 for pi/4 <= |x| < 2^63
+      nop.f 999
+      add GR_ad_s = 0x50, GR_ad_c          // Point to constant table s
+}
+{ .mfi
+      ldfe FR_PP_8 = [GR_ad_pp], 16        // Load PP_8 for 2^-3 < |r| < pi/4
+      nop.f 999
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe FR_P_2 = [GR_ad_p], 16          // Load P_2 for pi/4 <= |x| < 2^63
+      nop.f 999
+      add GR_ad_ce = 0x40, GR_ad_c         // Point to end of constant table c
+}
+{ .mfi
+      ldfe FR_QQ_8 = [GR_ad_qq], 16        // Load QQ_8 for 2^-3 < |r| < pi/4
+      nop.f 999
+      nop.i 999
+}
+;;
+
+{ .mfi
+      ldfe FR_QQ_7 = [GR_ad_qq], 16        // Load QQ_7 for 2^-3 < |r| < pi/4
+      fma.s1        FR_N_float_signif = FR_Input_X, FR_inv_pi_2to63, FR_rshf_2to64
+      add GR_ad_se = 0x40, GR_ad_s         // Point to end of constant table s
+}
+{ .mib
+      ldfe FR_PP_7 = [GR_ad_pp], 16        // Load PP_7 for 2^-3 < |r| < pi/4
+      mov GR_ad_s1 = GR_ad_s               // Save pointer to S_1
+(p10) br.cond.spnt SINCOSL_ARG_TOO_LARGE   // Branch if |x| >= 2^63
+                                           // Use Payne-Hanek Reduction
+}
+;;
+
+{ .mfi
+      ldfe FR_P_3 = [GR_ad_p], 16          // Load P_3 for pi/4 <= |x| < 2^63
+      fmerge.se FR_r = FR_norm_x, FR_norm_x // r = x, in case |x| < pi/4
+      add GR_ad_m14 = 0x50, GR_ad_s        // Point to constant table m14
+}
+{ .mfb
+      ldfps FR_Two_to_M3, FR_Neg_Two_to_M3 = [GR_ad_d], 8
+      fma.s1 FR_rsq = FR_norm_x, FR_norm_x, f0 // rsq = x*x, in case |x| < pi/4
+(p7)  br.cond.spnt SINCOSL_LARGER_ARG      // Branch if 2^24 <= |x| < 2^63
+                                           // Use pre-reduction
+}
+;;
+
+{ .mmf
+      ldfe FR_PP_6 = [GR_ad_pp], 16       // Load PP_6 for normal path
+      ldfe FR_QQ_6 = [GR_ad_qq], 16       // Load QQ_6 for normal path
+      fmerge.se FR_c = f0, f0             // c = 0 in case |x| < pi/4
+}
+;;
+
+{ .mmf
+      ldfe FR_PP_5 = [GR_ad_pp], 16       // Load PP_5 for normal path
+      ldfe FR_QQ_5 = [GR_ad_qq], 16       // Load QQ_5 for normal path
+      nop.f 999
+}
+;;
+
+// Here if 0 < |x| < 2^24
+{ .mfi
+      ldfe FR_S_5 = [GR_ad_se], -16       // Load S_5 if i_1=0
+      fcmp.lt.s1  p6, p7 = FR_abs_x, FR_Pi_by_4  // Test |x| < pi/4
+      nop.i 999
+}
+{ .mfi
+      ldfe FR_C_5 = [GR_ad_ce], -16       // Load C_5 if i_1=1
+      fms.s1 FR_N_float = FR_N_float_signif, FR_2tom64, FR_rshf
+      nop.i 999
+}
+;;
+
+{ .mmi
+      ldfe FR_S_4 = [GR_ad_se], -16       // Load S_4 if i_1=0
+      ldfe FR_C_4 = [GR_ad_ce], -16       // Load C_4 if i_1=1
+      nop.i 999
+}
+;;
+
+//
+//     N  = Arg * 2/pi
+//     Check if Arg < pi/4
+//
+//
+//     Case 2: Convert integer N_fix back to normalized floating-point value.
+//     Case 1: p8 is only affected  when p6 is set
+//
+//
+//     Grab the integer part of N and call it N_fix
+//
+{ .mfi
+(p7)  ldfps FR_Two_to_M33, FR_Neg_Two_to_M33 = [GR_ad_d], 8
+(p6)  fma.s1 FR_r_cubed = FR_r, FR_rsq, f0        // r^3 if |x| < pi/4
+(p6)  mov GR_N_Inc = GR_Sin_or_Cos                // N_Inc if |x| < pi/4
+}
+;;
+
+//     If |x| < pi/4, r = x and c = 0
+//     lf |x| < pi/4, is x < 2**(-3).
+//     r = Arg
+//     c = 0
+{ .mmi
+(p7)  getf.sig        GR_N_Inc = FR_N_float_signif
+(p6)  cmp.lt.unc p8,p0 = GR_exp_x, GR_exp_2_to_m3   // Is |x| < 2^-3
+(p6)  tbit.z p9,p10 = GR_N_Inc, 0         // p9  if i_1=0, N mod 4 = 0,1
+                                          // p10 if i_1=1, N mod 4 = 2,3
+}
+;;
+
+//
+//     lf |x| < pi/4, is -2**(-3)< x < 2**(-3) - set p8.
+//     If |x| >= pi/4,
+//     Create the right N for |x| < pi/4 and otherwise
+//     Case 2: Place integer part of N in GP register
+//
+
+
+{ .mbb
+      nop.m 999
+(p8)  br.cond.spnt SINCOSL_SMALL_R_0    // Branch if 0 < |x| < 2^-3
+(p6)  br.cond.spnt SINCOSL_NORMAL_R_0   // Branch if 2^-3 <= |x| < pi/4
+}
+;;
+
+// Here if pi/4 <= |x| < 2^24
+{ .mfi
+      ldfs FR_Neg_Two_to_M67 = [GR_ad_d], 8     // Load -2^-67
+      fnma.s1 FR_s = FR_N_float, FR_P_1, FR_Input_X // s = -N * P_1  + Arg
+      add GR_N_Inc = GR_N_Inc, GR_Sin_or_Cos    // Adjust N_Inc for sin/cos
+}
+{ .mfi
+      nop.m 999
+      fma.s1 FR_w = FR_N_float, FR_P_2, f0      // w = N * P_2
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fms.s1 FR_r = FR_s, f1, FR_w        // r = s - w, assume |s| >= 2^-33
+      tbit.z p9,p10 = GR_N_Inc, 0         // p9  if i_1=0, N mod 4 = 0,1
+                                          // p10 if i_1=1, N mod 4 = 2,3
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fcmp.lt.s1 p7, p6 = FR_s, FR_Two_to_M33
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p7)  fcmp.gt.s1 p7, p6 = FR_s, FR_Neg_Two_to_M33 // p6 if |s| >= 2^-33, else p7
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+      fms.s1 FR_c = FR_s, f1, FR_r             // c = s - r, for |s| >= 2^-33
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+      fma.s1 FR_rsq = FR_r, FR_r, f0           // rsq = r * r, for |s| >= 2^-33
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p7)  fma.s1 FR_w = FR_N_float, FR_P_3, f0
+      nop.i 999
+}
+;;
+
+{ .mmf
+(p9)  ldfe FR_C_1 = [GR_ad_pp], 16     // Load C_1 if i_1=0
+(p10) ldfe FR_S_1 = [GR_ad_qq], 16     // Load S_1 if i_1=1
+      frcpa.s1 FR_r_hi, p15 = f1, FR_r  // r_hi = frcpa(r)
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p6)  fcmp.lt.unc.s1 p8, p13 = FR_r, FR_Two_to_M3 // If big s, test r with 2^-3
+      nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p7)  fma.s1 FR_U_1 = FR_N_float, FR_P_2, FR_w
+      nop.i 999
+}
+;;
+
+//
+//     For big s: r = s - w: No further reduction is necessary
+//     For small s: w = N * P_3 (change sign) More reduction
+//
+{ .mfi
+        nop.m 999
+(p8)   fcmp.gt.s1 p8, p13 = FR_r, FR_Neg_Two_to_M3 // If big s, p8 if |r| < 2^-3
+        nop.i 999 ;;
+}
+
+{ .mfi
+      nop.m 999
+(p9)  fma.s1 FR_poly = FR_rsq, FR_PP_8, FR_PP_7 // poly = rsq*PP_8+PP_7 if i_1=0
+      nop.i 999
+}
+{ .mfi
+      nop.m 999
+(p10) fma.s1 FR_poly = FR_rsq, FR_QQ_8, FR_QQ_7 // poly = rsq*QQ_8+QQ_7 if i_1=1
+      nop.i 999
+}
+;;
+
+{ .mfi
+        nop.m 999
+(p7)   fms.s1 FR_r = FR_s, f1, FR_U_1
+        nop.i 999
+}
+;;
+
+{ .mfi
+      nop.m 999
+(p6)  fma.s1 FR_r_cubed = FR_r, FR_rsq, f0  // rcubed = r * rsq
+      nop.i 999
+}
+;;
+
+{ .mfi
+//
+//     For big s: Is |r| < 2**(-3)?
+//     For big s: c = S - r
+//     For small s: U_1 = N * P_2 + w
+//
+//     If p8 is set, prepare to branch to Small_R.
+//     If p9 is set, prepare to branch to Normal_R.
+//     For big s,  r is complete here.
+//
+//
+//     For big s: c = c + w (w has not been negated.)
+//     For small s: r = S - U_1
+//
+      nop.m 999
+(p6)  fms.s1 FR_c = FR_c, f1, FR_w
+      nop.i 999
+}
+{ .mbb
+      nop.m 999
+(p8)  br.cond.spnt    SINCOSL_SMALL_R_1  // Branch if |s|>=2^-33, |r| < 2^-3,
+                                         // and pi/4 <= |x| < 2^24
+(p13) br.cond.sptk    SINCOSL_NORMAL_R_1 // Branch if |s|>=2^-33, |r| >= 2^-3,
+                                         // and pi/4 <= |x| < 2^24
+}
+;;
+
+SINCOSL_S_TINY:
+//
+// Here if |s| < 2^-33, and pi/4 <= |x| < 2^24
+//
+{ .mfi
+       fms.s1 FR_U_2 = FR_N_float, FR_P_2, FR_U_1
+//
+//     c = S - U_1
+//     r = S_1 * r
+//
+//
+}
+;;
+
+{ .mmi
+        nop.m 999
+//
+//     Get [i_0,i_1] - two lsb of N_fix_gr.
+//     Do dummy fmpy so inexact is always set.
+//
+      tbit.z p9,p10 = GR_N_Inc, 0      // p9  if i_1=0, N mod 4 = 0,1
+                                       // p10 if i_1=1, N mod 4 = 2,3
+}
+;;
+
+//
+//     For small s: U_2 = N * P_2 - U_1
+//     S_1 stored constant - grab the one stored with the
+//     coefficients.
+//
+{ .mfi
+       ldfe FR_S_1 = [GR_ad_s1], 16
+//
+//     Check if i_1 and i_0  != 0
+//
+(p10)  fma.s1        FR_poly = f0, f1, FR_Neg_Two_to_M67
+      tbit.z p11,p12 = GR_N_Inc, 1     // p11 if i_0=0, N mod 4 = 0,2
+                                       // p12 if i_0=1, N mod 4 = 1,3
+}
+;;
+
+{ .mfi
+        nop.m 999
+       fms.s1        FR_s = FR_s, f1, FR_r
+        nop.i 999
+}
+{ .mfi
+        nop.m 999
+//
+//     S = S - r
+//     U_2 = U_2 + w
+//     load S_1
+//
+       fma.s1        FR_rsq = FR_r, FR_r, f0
+        nop.i 999 ;;
+}
+{ .mfi
+        nop.m 999
+       fma.s1        FR_U_2 = FR_U_2, f1, FR_w
+        nop.i 999
+}
+{ .mfi
+        nop.m 999
+       fmerge.se FR_tmp_result = FR_r, FR_r
+        nop.i 999 ;;
+}
+{ .mfi
+        nop.m 999
+(p10)  fma.s1 FR_tmp_result = f0, f1, f1
+        nop.i 999 ;;
+}
+{ .mfi
+        nop.m 999
+//
+//     FR_rsq = r * r
+//     Save r as the result.
+//
+       fms.s1        FR_c = FR_s, f1, FR_U_1
+        nop.i 999 ;;
+}
+{ .mfi
+        nop.m 999
+//
+//     if ( i_1 ==0) poly = c + S_1*r*r*r
+//     else Result = 1
+//
+(p12)  fnma.s1 FR_tmp_result = FR_tmp_result, f1, f0
+        nop.i 999
+}
+{ .mfi
+        nop.m 999
+       fma.s1        FR_r = FR_S_1, FR_r, f0
+        nop.i 999 ;;
+}
+{ .mfi
+        nop.m 999
+       fma.s0        FR_S_1 = FR_S_1, FR_S_1, f0
+        nop.i 999 ;;
+}
+{ .mfi
+        nop.m 999
+//
+//     If i_1 != 0, poly = 2**(-67)
+//
+       fms.s1 FR_c = FR_c, f1, FR_U_2
+        nop.i 999 ;;
+}
+{ .mfi
+        nop.m 999
+//
+//     c = c - U_2
+//
+(p9)   fma.s1 FR_poly = FR_r, FR_rsq, FR_c
+        nop.i 999 ;;
+}
+{ .mfi
+        nop.m 999
+//
+//     i_0 != 0, so Result = -Result
+//
+(p11)  fma.s0 FR_Result = FR_tmp_result, f1, FR_poly
+        nop.i 999 ;;
+}
+{ .mfb
+        nop.m 999
+(p12)  fms.s0 FR_Result = FR_tmp_result, f1, FR_poly
+//
+//     if (i_0 == 0),  Result = Result + poly
+//     else            Result = Result - poly
+//
+        br.ret.sptk   b0         // Exit if |s| < 2^-33, and pi/4 <= |x| < 2^24
